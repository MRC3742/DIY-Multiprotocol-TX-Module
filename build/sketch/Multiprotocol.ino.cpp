#include <Arduino.h>
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
/*********************************************************
					Multiprotocol Tx code
               by Midelic and Pascal Langer(hpnuts)
	http://www.rcgroups.com/forums/showthread.php?t=2165676
    https://github.com/pascallanger/DIY-Multiprotocol-TX-Module/edit/master/README.md

	Thanks to PhracturedBlue, Hexfet, Goebish, Victzh and all protocol developers
				Ported  from deviation firmware 

 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <avr/pgmspace.h>

//#define DEBUG_PIN		// Use pin TX for AVR and SPI_CS for STM32 => DEBUG_PIN_on, DEBUG_PIN_off, DEBUG_PIN_toggle
//#define DEBUG_SERIAL	// Only for STM32_BOARD, compiled with Upload method "Serial"->usart1, "STM32duino bootloader"->USB serial

#ifdef __arm__			// Let's automatically select the board if arm is selected
	#define STM32_BOARD
#endif
#if defined (ARDUINO_AVR_XMEGA32D4) || defined (ARDUINO_MULTI_ORANGERX)
	#include "MultiOrange.h"
#endif

#include "Multiprotocol.h"

//Multiprotocol module configuration file
#include "_Config.h"

//Personal config file
#if defined(USE_MY_CONFIG)
#include "_MyConfig.h"
#endif

#include "Pins.h"
#include "TX_Def.h"
#include "Validate.h"

#ifndef STM32_BOARD
	#include <avr/eeprom.h>
#else
	#include <libmaple/usart.h>
	#include <libmaple/timer.h>
	//#include <libmaple/spi.h>
	#include <SPI.h>
	#include <EEPROM.h>	
	HardwareTimer HWTimer2(2);
	#ifdef ENABLE_SERIAL
		HardwareTimer HWTimer3(3);
		void ISR_COMPB();
	#endif

	void PPM_decode();
	extern "C"
	{
		void __irq_usart2(void);
		void __irq_usart3(void);
	}
	#ifdef SEND_CPPM
		HardwareTimer HWTimer1(1) ;
	#endif				 
#endif

//Global constants/variables
uint32_t MProtocol_id;//tx id,
uint32_t MProtocol_id_master;
uint32_t blink=0,last_signal=0;
//
uint16_t counter;
uint8_t  channel;
#if defined(ESKY150V2_CC2500_INO)
	uint8_t  packet[150];
#else
	uint8_t  packet[50];
#endif

#define NUM_CHN 16
// Servo data
uint16_t Channel_data[NUM_CHN];
uint8_t  Channel_AUX;
#ifdef FAILSAFE_ENABLE
	uint16_t Failsafe_data[NUM_CHN];
#endif

// Protocol variables
uint8_t  cyrfmfg_id[6];//for dsm2 and devo
uint8_t  rx_tx_addr[5];
uint8_t  rx_id[5];
uint8_t  phase;
uint16_t bind_counter;
uint8_t  bind_phase;
uint8_t  binding_idx;
uint16_t packet_period;
uint8_t  packet_count;
uint8_t  packet_sent;
uint8_t  packet_length;
#if defined(HOTT_CC2500_INO) || defined(ESKY150V2_CC2500_INO) || defined(MLINK_CYRF6936_INO)
	uint8_t  hopping_frequency[78];
#else
	uint8_t  hopping_frequency[50];
#endif
uint8_t  *hopping_frequency_ptr;
uint8_t  hopping_frequency_no=0;
uint8_t  rf_ch_num;
uint8_t  throttle, rudder, elevator, aileron;
uint8_t  flags;
uint16_t crc;
uint16_t crc16_polynomial;
uint8_t  crc8;
uint8_t  crc8_polynomial;
uint16_t seed;
uint16_t failsafe_count;
uint16_t state;
uint8_t  len;
uint8_t  armed, arm_flags, arm_channel_previous;
uint8_t  num_ch;
uint32_t pps_timer;
uint16_t pps_counter;

#ifdef CC2500_INSTALLED
	#ifdef SCANNER_CC2500_INO
		uint8_t calData[255];
	#elif defined(HOTT_CC2500_INO) || defined(ESKY150V2_CC2500_INO)
		uint8_t calData[75];
	#else
		uint8_t calData[50];
	#endif
#endif

#ifdef CHECK_FOR_BOOTLOADER
	uint8_t BootTimer ;
	uint8_t BootState ;
	uint8_t NotBootChecking ;
	uint8_t BootCount ;

	#define BOOT_WAIT_30_IDLE	0
	#define BOOT_WAIT_30_DATA	1
	#define BOOT_WAIT_20		2
	#define BOOT_READY			3
#endif

//Channel mapping for protocols
uint8_t CH_AETR[]={AILERON, ELEVATOR, THROTTLE, RUDDER, CH5, CH6, CH7, CH8, CH9, CH10, CH11, CH12, CH13, CH14, CH15, CH16};
uint8_t CH_TAER[]={THROTTLE, AILERON, ELEVATOR, RUDDER, CH5, CH6, CH7, CH8, CH9, CH10, CH11, CH12, CH13, CH14, CH15, CH16};
//uint8_t CH_RETA[]={RUDDER, ELEVATOR, THROTTLE, AILERON, CH5, CH6, CH7, CH8, CH9, CH10, CH11, CH12, CH13, CH14, CH15, CH16};
uint8_t CH_EATR[]={ELEVATOR, AILERON, THROTTLE, RUDDER, CH5, CH6, CH7, CH8, CH9, CH10, CH11, CH12, CH13, CH14, CH15, CH16};

// Mode_select variables
uint8_t mode_select;
uint8_t protocol_flags=0,protocol_flags2=0,protocol_flags3=0;
uint8_t option_override;

#ifdef ENABLE_PPM
// PPM variable
volatile uint16_t PPM_data[NUM_CHN];
volatile uint8_t  PPM_chan_max=0;
uint32_t chan_order=0;
#endif

#if not defined (ORANGE_TX) && not defined (STM32_BOARD)
//Random variable
volatile uint32_t gWDT_entropy=0;
#endif

//Serial protocol
uint8_t sub_protocol;
uint8_t protocol;
uint8_t option;
uint8_t cur_protocol[3];
uint8_t prev_option;
uint8_t prev_power=0xFD; // unused power value
uint8_t RX_num;

//Serial RX variables
#define BAUD 100000
#define RXBUFFER_SIZE 36	// 26+1+9
volatile uint8_t rx_buff[RXBUFFER_SIZE];
volatile uint8_t rx_ok_buff[RXBUFFER_SIZE];
volatile bool discard_frame = false;
volatile uint8_t rx_idx=0, rx_len=0;

// Callback
uint16_function_t remote_callback = 0;

// Telemetry
#define TELEMETRY_BUFFER_SIZE 32
uint8_t packet_in[TELEMETRY_BUFFER_SIZE];//telemetry receiving packets
#if defined(TELEMETRY)
	#ifdef MULTI_SYNC
		uint16_t last_serial_input=0;
		uint16_t inputRefreshRate=0;
	#endif
	#ifdef INVERT_TELEMETRY
		#if not defined(ORANGE_TX) && not defined(STM32_BOARD)
			// enable bit bash for serial
			#define	BASH_SERIAL 1
		#endif
		#define	INVERT_SERIAL 1
	#endif
	uint8_t telemetry_in_buffer[TELEMETRY_BUFFER_SIZE];//telemetry receiving packets
	#ifdef BASH_SERIAL
	// For bit-bashed serial output
		#define TXBUFFER_SIZE 192
		volatile struct t_serial_bash
		{
			uint8_t head ;
			uint8_t tail ;
			uint8_t data[TXBUFFER_SIZE] ;
			uint8_t busy ;
			uint8_t speed ;
		} SerialControl ;
	#else
		#define TXBUFFER_SIZE 96
		volatile uint8_t tx_buff[TXBUFFER_SIZE];
		volatile uint8_t tx_head=0;
		volatile uint8_t tx_tail=0;
	#endif // BASH_SERIAL
	uint8_t v_lipo1;
	uint8_t v_lipo2;
	uint8_t RX_RSSI;
	uint8_t TX_RSSI;
	uint8_t RX_LQI;
	uint8_t TX_LQI;
	uint8_t telemetry_link=0; 
	uint8_t telemetry_counter=0;
	uint8_t telemetry_lost;
	#ifdef SPORT_SEND
		#define MAX_SPORT_BUFFER 64
		uint8_t	SportData[MAX_SPORT_BUFFER];
		uint8_t	SportHead=0, SportTail=0;
	#endif

	// Functions definition when required
	#ifdef HUB_TELEMETRY
		static void __attribute__((unused)) frsky_send_user_frame(uint8_t, uint8_t, uint8_t);
	#endif

	//RX protocols
	#if defined(AFHDS2A_RX_A7105_INO) || defined(FRSKY_RX_CC2500_INO) || defined(BAYANG_RX_NRF24L01_INO) || defined(DSM_RX_CYRF6936_INO)
		bool rx_data_started;
		bool rx_data_received;
		bool rx_disable_lna;
		uint16_t rx_rc_chan[16];
	#endif
	
	#ifdef HOTT_FW_TELEMETRY
		uint8_t HoTT_SerialRX_val=0;
		bool HoTT_SerialRX=false;
	#endif
	#ifdef DSM_FWD_PGM
		uint8_t DSM_SerialRX_val[7];
		bool DSM_SerialRX=false;
	#endif
	#ifdef MULTI_CONFIG_INO
		uint8_t CONFIG_SerialRX_val[7];
		bool CONFIG_SerialRX=false;
	#endif
#endif // TELEMETRY

uint8_t multi_protocols_index=0xFF;

// Init
#line 273 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void setup();
#line 683 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void loop();
#line 756 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void End_Bind();
#line 768 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void Update_Telem();
#line 779 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
bool Update_All();
#line 894 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void PPM_failsafe();
#line 920 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
static void update_channels_aux(void);
#line 944 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
static void update_led_status(void);
#line 990 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
uint8_t bank_switch(void);
#line 1071 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void tx_pause();
#line 1089 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void tx_resume();
#line 1114 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void rf_switch(uint8_t comp);
#line 1132 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
static void protocol_init();
#line 1280 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void update_serial_data();
#line 1605 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void modules_reset();
#line 1629 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void Mprotocol_serial_init( uint8_t boot );
#line 1706 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void usart2_begin(uint32_t baud,uint32_t config );
#line 1714 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void usart3_begin(uint32_t baud,uint32_t config );
#line 1723 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void init_HWTimer();
#line 1749 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void pollBoot();
#line 1823 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void PPM_Telemetry_serial_init();
#line 1841 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
static void set_rx_tx_addr(uint32_t id);
#line 1850 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
static uint32_t random_id(uint16_t address, uint8_t create_new);
#line 2164 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void setupTrainerPulses();
#line 2193 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void init_trainer_ppm();
#line 2223 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void release_trainer_ppm();
#line 2233 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void tim1_up();
#line 2251 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void tim1_cc();
#line 2267 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void Send_CCPM_USART1();
#line 21 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_WriteData(uint8_t len, uint8_t channel);
#line 42 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_ReadData(uint8_t len);
#line 53 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_WriteReg(uint8_t address, uint8_t data);
#line 61 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
uint8_t A7105_ReadReg(uint8_t address);
#line 72 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_SetTxRxMode(uint8_t mode);
#line 97 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
uint8_t A7105_Reset();
#line 109 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_WriteID(uint32_t ida);
#line 148 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_SetPower();
#line 166 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_Strobe(uint8_t address);
#line 174 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_AdjustLOBaseFreq(uint8_t cmd);
#line 360 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
void A7105_Init(void);
#line 65 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_Rx_a7105.ino"
void AFHDS2A_RX_init();
#line 91 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_Rx_a7105.ino"
uint16_t AFHDS2A_RX_callback();
#line 42 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
static void AFHDS2A_calc_channels();
#line 83 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
static void AFHDS2A_update_telemetry();
#line 146 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
static void AFHDS2A_build_bind_packet();
#line 180 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
static void AFHDS2A_build_packet(uint8_t type);
#line 295 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
uint16_t AFHDS2A_callback();
#line 476 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
void AFHDS2A_init();
#line 36 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ASSAN_nrf24l01.ino"
void ASSAN_RF_init();
#line 46 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ASSAN_nrf24l01.ino"
void ASSAN_send_packet();
#line 63 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ASSAN_nrf24l01.ino"
uint16_t ASSAN_callback();
#line 167 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ASSAN_nrf24l01.ino"
void ASSAN_init();
#line 20 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Arduino.ino"
int16_t map16b( int16_t x, int16_t in_min, int16_t in_max, int16_t out_min, int16_t out_max);
#line 201 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Ares_cc2500.ino"
uint16_t ARES_callback();
#line 255 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Ares_cc2500.ino"
void ARES_init();
#line 253 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/BUGSMINI_nrf24l01.ino"
uint16_t BUGSMINI_callback();
#line 341 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/BUGSMINI_nrf24l01.ino"
void BUGSMINI_init();
#line 88 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_Rx_nrf24l01.ino"
void BAYANG_RX_init();
#line 112 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_Rx_nrf24l01.ino"
uint16_t BAYANG_RX_callback();
#line 264 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_nrf24l01.ino"
uint16_t BAYANG_callback();
#line 338 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_nrf24l01.ino"
void BAYANG_init(void);
#line 318 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bugs_a7105.ino"
uint16_t BUGS_callback(void);
#line 440 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bugs_a7105.ino"
void BUGS_init(void);
#line 25 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_WriteReg(uint8_t address, uint8_t data);
#line 35 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
static void CC2500_ReadRegisterMulti(uint8_t address, uint8_t data[], uint8_t length);
#line 45 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
static uint8_t CC2500_ReadReg(uint8_t address);
#line 56 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_ReadData(uint8_t *dpbuffer, uint8_t len);
#line 62 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_Strobe(uint8_t state);
#line 69 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
static void CC2500_WriteRegisterMulti(uint8_t address, const uint8_t data[], uint8_t length);
#line 78 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_WriteData(uint8_t *dpbuffer, uint8_t len);
#line 85 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_SetTxRxMode(uint8_t mode);
#line 119 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
uint8_t CC2500_Reset();
#line 144 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"
void CC2500_SetPower();
#line 87 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static uint8_t crtp_create_header(uint8_t port, uint8_t channel);
#line 185 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void send_packet();
#line 200 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static uint8_t packet_ack();
#line 221 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void set_rate_channel(uint8_t rate, uint8_t channel);
#line 227 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void send_search_packet();
#line 262 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void frac2float(int32_t n, float* res);
#line 280 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void send_crtp_rpyt_packet();
#line 414 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void send_cmd_packet();
#line 435 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static uint8_t crtp_log_setup_state_machine();
#line 647 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static void CFLIE_RF_init();
#line 739 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static uint16_t CFLIE_callback();
#line 789 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
static uint8_t CFLIE_initialize_rx_tx_addr();
#line 834 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
void CFLIE_init(void);
#line 125 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CG023_nrf24l01.ino"
uint16_t CG023_callback();
#line 148 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CG023_nrf24l01.ino"
void CG023_init(void);
#line 173 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CX10_nrf24l01.ino"
uint16_t CX10_callback();
#line 244 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CX10_nrf24l01.ino"
void CX10_init(void);
#line 18 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_WriteRegister(uint8_t address, uint8_t data);
#line 26 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
static void CYRF_WriteRegisterMulti(uint8_t address, const uint8_t data[], uint8_t length);
#line 37 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
static void CYRF_ReadRegisterMulti(uint8_t address, uint8_t data[], uint8_t length);
#line 48 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
uint8_t CYRF_ReadRegister(uint8_t address);
#line 59 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
uint8_t CYRF_Reset();
#line 79 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_GetMfgData(uint8_t data[]);
#line 108 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_SetTxRxMode(uint8_t mode);
#line 136 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_ConfigRFChannel(uint8_t ch);
#line 149 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_SetPower(uint8_t val);
#line 182 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_ConfigCRCSeed(uint16_t crc_seed);
#line 191 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_ConfigSOPCode(const uint8_t *sopcodes);
#line 198 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_ConfigDataCode(const uint8_t *datacodes);
#line 205 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_WritePreamble(uint32_t preamble);
#line 222 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_ReadDataPacketLen(uint8_t dpbuffer[], uint8_t length);
#line 227 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
static void CYRF_WriteDataPacketLen(const uint8_t dpbuffer[], uint8_t len);
#line 235 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_WriteDataPacket(const uint8_t dpbuffer[]);
#line 252 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
void CYRF_FindBestChannels(uint8_t *channels, uint8_t len, uint8_t minspace, uint8_t min, uint8_t max, uint8_t forced);
#line 20 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
void reverse_channel(uint8_t num);
#line 28 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint16_t convert_channel_ppm(uint8_t num);
#line 35 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint16_t convert_channel_10b(uint8_t num, bool failsafe);
#line 51 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint8_t convert_channel_8b(uint8_t num);
#line 61 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint8_t convert_channel_8b_limit_deadband(uint8_t num,uint8_t min,uint8_t mid, uint8_t max, uint8_t deadband);
#line 92 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
int16_t convert_channel_16b_limit(uint8_t num,int16_t min,int16_t max);
#line 100 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
int16_t convert_channel_16b_nolimit(uint8_t num, int16_t min, int16_t max, bool failsafe);
#line 114 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint8_t convert_channel_s8b(uint8_t num);
#line 122 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint16_t limit_channel_100(uint8_t num);
#line 132 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
void convert_channel_HK310(uint8_t num, uint8_t *low, uint8_t *high);
#line 141 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
void convert_failsafe_HK310(uint8_t num, uint8_t *low, uint8_t *high);
#line 150 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
uint16_t convert_channel_frsky(uint8_t num);
#line 258 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Corona_cc2500.ino"
uint16_t CORONA_callback();
#line 279 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Corona_cc2500.ino"
void CORONA_init();
#line 96 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DM002_nrf24l01.ino"
uint16_t DM002_callback();
#line 134 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DM002_nrf24l01.ino"
void DM002_init(void);
#line 55 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_Rx_cyrf6936.ino"
uint16_t convert_channel_DSM_nolimit(int32_t val);
#line 212 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_Rx_cyrf6936.ino"
uint16_t DSM_RX_callback();
#line 488 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_Rx_cyrf6936.ino"
void DSM_RX_init();
#line 276 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_cyrf6936.ino"
uint16_t DSM_callback();
#line 574 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_cyrf6936.ino"
void DSM_init();
#line 429 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Devo_cyrf6936.ino"
uint16_t DEVO_callback();
#line 539 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Devo_cyrf6936.ino"
void DEVO_init();
#line 53 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E010R5_cyrf6936.ino"
uint16_t E010R5_callback();
#line 89 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E010R5_cyrf6936.ino"
void E010R5_init();
#line 121 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016HV2_cc2500.ino"
uint16_t E016HV2_callback();
#line 127 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016HV2_cc2500.ino"
void E016HV2_init();
#line 112 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016H_nrf24l01.ino"
uint16_t E016H_callback();
#line 145 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016H_nrf24l01.ino"
void E016H_init();
#line 176 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E01X_cyrf6936.ino"
uint16_t E01X_callback();
#line 205 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E01X_cyrf6936.ino"
void E01X_init();
#line 101 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E129_cyrf6936.ino"
uint16_t E129_callback();
#line 141 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E129_cyrf6936.ino"
void E129_init();
#line 129 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150_nrf24l01.ino"
uint8_t ESKY150_convert_2bit_channel(uint8_t num);
#line 142 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150_nrf24l01.ino"
uint16_t ESKY150_callback();
#line 165 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150_nrf24l01.ino"
void ESKY150_init(void);
#line 80 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150v2_cc2500.ino"
uint16_t ESKY150V2_callback();
#line 107 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150v2_cc2500.ino"
void ESKY150V2_init();
#line 153 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky_nrf24l01.ino"
uint16_t ESKY_callback();
#line 182 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky_nrf24l01.ino"
void ESKY_init(void);
#line 161 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FQ777_nrf24l01.ino"
uint16_t FQ777_callback();
#line 179 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FQ777_nrf24l01.ino"
void FQ777_init(void);
#line 251 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FX_nrf24l01.ino"
uint16_t FX_callback();
#line 324 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FX_nrf24l01.ino"
void FX_init();
#line 113 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FY326_nrf24l01.ino"
uint16_t FY326_callback();
#line 203 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FY326_nrf24l01.ino"
void FY326_init(void);
#line 160 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FlySky_a7105.ino"
uint16_t FLYSKY_callback();
#line 189 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FlySky_a7105.ino"
void FLYSKY_init();
#line 125 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyDVX_common.ino"
void Frsky_init_hop(void);
#line 146 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyDVX_common.ino"
void FrSkyX2_init_hop(void);
#line 179 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyDVX_common.ino"
void Frsky_init_clone(void);
#line 368 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyDVX_common.ino"
void FRSKY_init_cc2500(const uint8_t *ptr);
#line 97 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyD_cc2500.ino"
void FRSKYD_init(void);
#line 128 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyD_cc2500.ino"
uint16_t FRSKYD_callback(void);
#line 140 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyL_cc2500.ino"
uint16_t FRSKYL_callback();
#line 215 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyL_cc2500.ino"
void FRSKYL_init();
#line 116 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyV_cc2500.ino"
uint16_t FRSKYV_callback(void);
#line 151 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyV_cc2500.ino"
void FRSKYV_init(void);
#line 118 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyX_cc2500.ino"
uint16_t FRSKYX_callback();
#line 247 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyX_cc2500.ino"
void FRSKYX_init();
#line 359 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSky_Rx_cc2500.ino"
void FRSKY_RX_init();
#line 392 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSky_Rx_cc2500.ino"
uint16_t FRSKY_RX_callback();
#line 209 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Futaba_cc2500.ino"
uint16_t SFHSS_callback();
#line 303 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Futaba_cc2500.ino"
void SFHSS_init();
#line 206 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GD00X_ccnrf.ino"
uint16_t GD00X_callback();
#line 218 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GD00X_ccnrf.ino"
void GD00X_init();
#line 93 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GW008_nrf24l01.ino"
uint16_t GW008_callback();
#line 133 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GW008_nrf24l01.ino"
void GW008_init();
#line 101 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H36_nrf24l01.ino"
uint16_t H36_callback();
#line 123 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H36_nrf24l01.ino"
void H36_init();
#line 164 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H8_3D_nrf24l01.ino"
uint16_t H8_3D_callback();
#line 223 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H8_3D_nrf24l01.ino"
void H8_3D_init(void);
#line 291 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/HOTT_cc2500.ino"
uint16_t HOTT_callback();
#line 526 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/HOTT_cc2500.ino"
void HOTT_init();
#line 44 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Height_a7105.ino"
uint16_t HEIGHT_callback();
#line 81 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Height_a7105.ino"
void HEIGHT_init();
#line 94 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hisky_nrf24l01.ino"
uint16_t HISKY_callback();
#line 225 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hisky_nrf24l01.ino"
void HISKY_init();
#line 223 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hitec_cc2500.ino"
uint16_t HITEC_callback();
#line 393 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hitec_cc2500.ino"
void HITEC_init();
#line 292 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hontai_nrf24l01.ino"
uint16_t HONTAI_callback();
#line 310 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hontai_nrf24l01.ino"
void HONTAI_init();
#line 288 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hubsan_a7105.ino"
uint16_t HUBSAN_callback();
#line 449 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hubsan_a7105.ino"
void HUBSAN_init();
#line 130 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/J6Pro_cyrf6936.ino"
uint16_t J6PRO_callback();
#line 230 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/J6Pro_cyrf6936.ino"
void J6PRO_init();
#line 138 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/JJRC345_nrf24l01.ino"
uint16_t JJRC345_callback();
#line 175 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/JJRC345_nrf24l01.ino"
void JJRC345_init(void);
#line 147 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KF606_ccnrf.ino"
uint16_t KF606_callback();
#line 162 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KF606_ccnrf.ino"
void KF606_init();
#line 254 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KN_nrf24l01.ino"
void KN_init();
#line 274 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KN_nrf24l01.ino"
uint16_t KN_callback();
#line 110 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho2_nrf24l01.ino"
uint16_t KYOSHO2_callback();
#line 128 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho2_nrf24l01.ino"
void KYOSHO2_init();
#line 141 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho_a7105.ino"
uint16_t KYOSHO_callback();
#line 178 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho_a7105.ino"
void KYOSHO_init();
#line 163 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/LOLI_nrf24l01.ino"
uint16_t LOLI_callback();
#line 281 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/LOLI_nrf24l01.ino"
void LOLI_init();
#line 311 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MJXQ_ccnrf.ino"
uint16_t MJXQ_callback();
#line 337 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MJXQ_ccnrf.ino"
void MJXQ_init(void);
#line 342 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MLINK_cyrf6936.ino"
uint16_t MLINK_callback();
#line 535 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MLINK_cyrf6936.ino"
void MLINK_init();
#line 455 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MT99xx_ccnrf.ino"
uint16_t MT99XX_callback();
#line 525 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MT99xx_ccnrf.ino"
void MT99XX_init(void);
#line 22 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Config.ino"
void CONFIG_write_GID(uint32_t id);
#line 29 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Config.ino"
void CONFIG_write_CID(uint8_t *data);
#line 35 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Config.ino"
uint16_t CONFIG_callback();
#line 188 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Config.ino"
void CONFIG_init();
#line 561 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Protos.ino"
uint16_t PROTOLIST_callback();
#line 129 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NCC1701_nrf24l01.ino"
uint16_t NCC_callback();
#line 241 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NCC1701_nrf24l01.ino"
void NCC_init(void);
#line 27 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_Initialize();
#line 46 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_WriteReg(uint8_t reg, uint8_t data);
#line 54 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_WriteRegisterMulti(uint8_t reg, uint8_t * data, uint8_t length);
#line 64 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_WritePayload(uint8_t * data, uint8_t length);
#line 73 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
uint8_t NRF24L01_ReadReg(uint8_t reg);
#line 92 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
static void NRF24L01_ReadPayload(uint8_t * data, uint8_t length);
#line 101 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
static void NRF24L01_Strobe(uint8_t state);
#line 108 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_FlushTx();
#line 113 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_FlushRx();
#line 123 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
static uint8_t NRF24L01_GetDynamicPayloadSize();
#line 140 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_SetBitrate(uint8_t bitrate);
#line 173 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_SetPower();
#line 194 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_SetTxRxMode(enum TXRX_State mode);
#line 225 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void NRF24L01_Reset();
#line 235 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
uint8_t NRF24L01_packet_ack();
#line 266 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_Config(uint8_t preamble_len, uint8_t trailer_len, uint8_t flags, uint8_t crc_init);
#line 283 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_SetChannel(uint8_t channel);
#line 288 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_SetTxRxMode(enum TXRX_State mode);
#line 314 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_BuildOverhead();
#line 336 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_SetAddress(uint8_t *address,uint8_t addr_size);
#line 356 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
uint8_t LT8900_ReadPayload(uint8_t* msg, uint8_t len);
#line 400 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
void LT8900_WritePayload(uint8_t* msg, uint8_t len);
#line 152 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/OMP_ccnrf.ino"
uint16_t OMP_callback();
#line 265 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/OMP_ccnrf.ino"
void OMP_init();
#line 93 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/POTENSIC_nrf24l01.ino"
uint16_t POTENSIC_callback();
#line 108 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/POTENSIC_nrf24l01.ino"
void POTENSIC_init(void);
#line 166 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
uint16_t PELIKAN_callback();
#line 216 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
static uint8_t pelikan_firstCh(uint8_t u, uint8_t l);
#line 235 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
static uint8_t pelikan_firstCh_scx(uint8_t i, uint8_t j);
#line 311 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
static uint8_t pelikan_adjust_value(uint8_t value, uint8_t addition, uint8_t limit);
#line 339 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
static uint8_t pelikan_add(uint8_t pfrq,uint8_t a, uint8_t limit);
#line 504 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
void PELIKAN_init();
#line 203 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Propel_nrf24l01.ino"
uint16_t PROPEL_callback();
#line 283 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Propel_nrf24l01.ino"
void PROPEL_init();
#line 335 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q303_ccnrf.ino"
uint16_t Q303_callback();
#line 354 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q303_ccnrf.ino"
void Q303_init();
#line 33 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q90C_ccnrf.ino"
int16_t Q90C_channel(uint8_t num, int16_t in_min,int16_t in_max, int16_t out_min,int16_t out_max);
#line 147 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q90C_ccnrf.ino"
uint16_t Q90C_callback();
#line 162 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q90C_ccnrf.ino"
void Q90C_init();
#line 116 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/REALACC_nrf24l01.ino"
uint16_t REALACC_callback();
#line 137 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/REALACC_nrf24l01.ino"
void REALACC_init();
#line 339 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/RadioLink_cc2500.ino"
uint16_t RLINK_callback();
#line 429 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/RadioLink_cc2500.ino"
void RLINK_init();
#line 207 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SGF22_nrf24l01.ino"
uint16_t SGF22_callback();
#line 294 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SGF22_nrf24l01.ino"
void SGF22_init();
#line 351 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SLT_ccnrf.ino"
uint16_t SLT_callback();
#line 449 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SLT_ccnrf.ino"
void SLT_init();
#line 26 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void initSPI2();
#line 39 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void SPI_Write(uint8_t command);
#line 49 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
uint8_t SPI_Read(void);
#line 55 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
uint8_t SPI_SDI_Read();
#line 77 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void SPI_ENABLE();
#line 82 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void SPI_DISABLE();
#line 87 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void SPI_SET_BIDIRECTIONAL();
#line 93 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
void SPI_SET_UNIDIRECTIONAL();
#line 96 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scanner_cc2500.ino"
uint16_t SCANNER_callback();
#line 134 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scanner_cc2500.ino"
void SCANNER_init(void);
#line 95 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scorpio_cyrf6936.ino"
uint16_t SCORPIO_callback();
#line 109 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scorpio_cyrf6936.ino"
void SCORPIO_init();
#line 123 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Skyartec_cc2500.ino"
uint16_t SKYARTEC_callback();
#line 157 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Skyartec_cc2500.ino"
void SKYARTEC_init();
#line 318 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Symax_nrf24l01.ino"
uint16_t SYMAX_callback();
#line 355 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Symax_nrf24l01.ino"
void SYMAX_init();
#line 74 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
static void multi_send_header(uint8_t type, uint8_t len);
#line 124 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
static void multi_send_status();
#line 229 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void CONFIG_frame();
#line 238 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void MLINK_frame();
#line 249 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void DSM_frame();
#line 268 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void spectrum_scanner_frame();
#line 278 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void receiver_channels_frame();
#line 292 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void AFHDSA_short_frame();
#line 301 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void HITEC_short_frame();
#line 310 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void HOTT_short_frame();
#line 318 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
static void multi_send_frskyhub();
#line 327 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void frskySendStuffed();
#line 342 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
bool frsky_process_telemetry(uint8_t *buffer,uint8_t len);
#line 501 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void init_frskyd_link_telemetry();
#line 517 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void frsky_link_frame();
#line 547 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void frsky_user_frame();
#line 701 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void sportSend(uint8_t *p);
#line 744 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void sportIdle();
#line 751 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void sportSendFrame();
#line 814 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void proces_sport_data(uint8_t data);
#line 865 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void TelemetryUpdate();
#line 1038 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void Serial_write(uint8_t data);
#line 1049 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void initTXSerial( uint8_t speed);
#line 1127 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
void __irq_usart3();
#line 221 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V2X2_nrf24l01.ino"
uint16_t V2X2_callback();
#line 248 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V2X2_nrf24l01.ino"
void V2X2_init();
#line 193 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V761_nrf24l01.ino"
uint16_t V761_callback();
#line 322 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V761_nrf24l01.ino"
void V761_init(void);
#line 144 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V911S_ccnrf.ino"
uint16_t V911S_callback();
#line 165 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V911S_ccnrf.ino"
void V911S_init(void);
#line 209 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY2_a7105.ino"
uint16_t WFLY2_callback();
#line 313 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY2_a7105.ino"
void WFLY2_init();
#line 160 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY_cyrf6936.ino"
uint16_t WFLY_callback();
#line 254 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY_cyrf6936.ino"
void WFLY_init();
#line 434 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WK2x01_cyrf6936.ino"
uint16_t WK_callback();
#line 468 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WK2x01_cyrf6936.ino"
void WK_init();
#line 188 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XERALL_nrf24l01.ino"
uint16_t XERALL_callback();
#line 268 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XERALL_nrf24l01.ino"
void XERALL_init(void);
#line 164 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK2_ccnrf.ino"
uint16_t XK2_callback();
#line 277 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK2_ccnrf.ino"
void XK2_init();
#line 204 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK_ccnrf.ino"
uint16_t XK_callback();
#line 219 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK_ccnrf.ino"
void XK_init();
#line 149 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/YD717_nrf24l01.ino"
uint16_t YD717_callback();
#line 165 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/YD717_nrf24l01.ino"
void YD717_init();
#line 160 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Yuxiang_nrf24l01.ino"
uint16_t YUXIANG_callback();
#line 240 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Yuxiang_nrf24l01.ino"
void YUXIANG_init(void);
#line 71 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ZSX_nrf24l01.ino"
uint16_t ZSX_callback();
#line 87 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ZSX_nrf24l01.ino"
void ZSX_init();
#line 273 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multiprotocol.ino"
void setup()
{
	// Setup diagnostic uart before anything else
	#ifdef DEBUG_SERIAL
		Serial.begin(115200,SERIAL_8N1);

		// Wait up to 30s for a serial connection; double-blink the LED while we wait
		unsigned long currMillis = millis();
		unsigned long initMillis = currMillis;
		pinMode(LED_pin,OUTPUT);
		LED_off;
		while (!Serial && (currMillis - initMillis) <= 30000) {
			LED_on;
			delay(100);
			LED_off;
			delay(100);
			LED_on;
			delay(100);
			LED_off;
			delay(500);
			currMillis = millis();
		}

		delay(250);  // Brief delay for FTDI debugging
		debugln("Multiprotocol version: %d.%d.%d.%d", VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_PATCH_LEVEL);
	#endif

	// General pinout
	#ifdef ORANGE_TX
		//XMEGA
		PORTD.OUTSET = 0x17 ;
		PORTD.DIRSET = 0xB2 ;
		PORTD.DIRCLR = 0x4D ;
		PORTD.PIN0CTRL = 0x18 ;
		PORTD.PIN2CTRL = 0x18 ;
		PORTE.DIRSET = 0x01 ;
		PORTE.DIRCLR = 0x02 ;
		// Timer1 config
		// TCC1 16-bit timer, clocked at 0.5uS
		EVSYS.CH3MUX = 0x80 + 0x04 ;				// Prescaler of 16
		TCC1.CTRLB = 0; TCC1.CTRLC = 0; TCC1.CTRLD = 0; TCC1.CTRLE = 0;
		TCC1.INTCTRLA = 0; TIMSK1 = 0;
		TCC1.PER = 0xFFFF ;
		TCNT1 = 0 ;
		TCC1.CTRLA = 0x0B ;							// Event3 (prescale of 16)
	#elif defined STM32_BOARD
		//STM32
		afio_cfg_debug_ports(AFIO_DEBUG_NONE);
		pinMode(LED_pin,OUTPUT);
		pinMode(LED2_pin,OUTPUT);
		pinMode(A7105_CSN_pin,OUTPUT);
		pinMode(CC25_CSN_pin,OUTPUT);
		pinMode(NRF_CSN_pin,OUTPUT);
		pinMode(CYRF_CSN_pin,OUTPUT);
		pinMode(SPI_CSN_pin,OUTPUT);
		pinMode(CYRF_RST_pin,OUTPUT);
		pinMode(PE1_pin,OUTPUT);
		pinMode(PE2_pin,OUTPUT);
		pinMode(TX_INV_pin,OUTPUT);
		pinMode(RX_INV_pin,OUTPUT);
		#if defined TELEMETRY
			#if defined INVERT_SERIAL
				TX_INV_on;							// activate inverter for both serial TX and RX signals
				RX_INV_on;
			#else
				TX_INV_off;
				RX_INV_off;
			#endif	
		#endif
		pinMode(BIND_pin,INPUT_PULLUP);
		pinMode(PPM_pin,INPUT);
		pinMode(S1_pin,INPUT_PULLUP);				// dial switch
		pinMode(S2_pin,INPUT_PULLUP);
		pinMode(S3_pin,INPUT_PULLUP);
		pinMode(S4_pin,INPUT_PULLUP);
		
		#ifdef MULTI_5IN1_INTERNAL
			//pinMode(SX1276_RST_pin,OUTPUT);		// already done by LED2_pin
			pinMode(SX1276_TXEN_pin,OUTPUT);		// PB0
			pinMode(SX1276_DIO0_pin,INPUT_PULLUP);
		#else
			//Random pin
			pinMode(RND_pin, INPUT_ANALOG);			// set up PB0 pin for analog input
		#endif
	
		#if defined ENABLE_DIRECT_INPUTS
			#if defined (DI1_PIN)
				pinMode(DI1_PIN,INPUT_PULLUP);
			#endif
			#if defined (DI2_PIN)
				pinMode(DI2_PIN,INPUT_PULLUP);
			#endif
			#if defined (DI3_PIN)
				pinMode(DI3_PIN,INPUT_PULLUP);
			#endif
			#if defined (DI4_PIN)
				pinMode(DI4_PIN,INPUT_PULLUP);
			#endif
		#endif

		#ifdef SEND_CPPM
			pinMode(PA9,INPUT);						// make sure the USART1.TX pin is released for heartbeat use
		#endif

		//Timers
		init_HWTimer();								//0.5us

		//Read module flash size
		#ifndef DISABLE_FLASH_SIZE_CHECK
			unsigned short *flashSize = (unsigned short *) (0x1FFFF7E0);// Address register 
			debugln("Module Flash size: %dKB",(int)(*flashSize & 0xffff));
			if((int)(*flashSize & 0xffff) < MCU_EXPECTED_FLASH_SIZE)  // Not supported by this project
				while (true) { //SOS
					for(uint8_t i=0; i<3;i++)
					{
						LED_on;
						delay(100);
						LED_off;
						delay(100);
					}
					for(uint8_t i=0; i<3;i++)
					{
						LED_on;
						delay(500);
						LED_off;
						delay(100);
					}
					for(uint8_t i=0; i<3;i++)
					{
						LED_on;
						delay(100);
						LED_off;
						delay(100);
					}
					LED_off;
					delay(1000);
				}
		#endif

		// Initialize the EEPROM
		uint16_t eepromStatus = EEPROM.init();
		debugln("EEPROM initialized: %d",eepromStatus);

		// If there was no valid EEPROM page the EEPROM is corrupt or uninitialized and should be formatted
		if( eepromStatus == EEPROM_NO_VALID_PAGE )
		{
			EEPROM.format();
			debugln("No valid EEPROM page, EEPROM formatted");
		}
	#else
		//ATMEGA328p
		// all inputs
		DDRB=0x00;DDRC=0x00;DDRD=0x00;
		// outputs
		SDI_output;
		SCLK_output;
		#ifdef A7105_CSN_pin
			A7105_CSN_output;
		#endif
		#ifdef CC25_CSN_pin
			CC25_CSN_output;
		#endif
		#ifdef CYRF_CSN_pin
			CYRF_RST_output;
			CYRF_CSN_output;
		#endif
		#ifdef NRF_CSN_pin
			NRF_CSN_output;
		#endif
		PE1_output;
		PE2_output;
		SERIAL_TX_output;

		// pullups
		PROTO_DIAL1_port |= _BV(PROTO_DIAL1_pin);
		PROTO_DIAL2_port |= _BV(PROTO_DIAL2_pin);
		PROTO_DIAL3_port |= _BV(PROTO_DIAL3_pin);
		PROTO_DIAL4_port |= _BV(PROTO_DIAL4_pin);
		BIND_port |= _BV(BIND_pin);

		// Timer1 config
		TCCR1A = 0;
		TCCR1B = (1 << CS11);	//prescaler8, set timer1 to increment every 0.5us(16Mhz) and start timer

		// Random
		random_init();
	#endif

	LED2_on;
	
	// Set Chip selects
	#ifdef A7105_CSN_pin
		A7105_CSN_on;
	#endif
	#ifdef CC25_CSN_pin
		CC25_CSN_on;
	#endif
	#ifdef CYRF_CSN_pin
		CYRF_CSN_on;
	#endif
	#ifdef NRF_CSN_pin
		NRF_CSN_on;
	#endif
	#ifdef SPI_CSN_pin
		SPI_CSN_on;
	#endif

	//	Set SPI lines
	#ifdef	STM32_BOARD
		initSPI2();
	#else
		SDI_on;
		SCLK_off;
	#endif

	//Wait for every component to start
	delayMilliseconds(100);
	
	// Read status of bind button
	if( IS_BIND_BUTTON_on )
	{
		BIND_BUTTON_FLAG_on;	// If bind button pressed save the status
		BIND_IN_PROGRESS;		// Request bind
	}
	else
		BIND_DONE;

	// Read status of mode select binary switch
	// after this mode_select will be one of {0000, 0001, ..., 1111}
	#ifndef ENABLE_PPM
		mode_select = MODE_SERIAL ;	// force serial mode
	#elif defined STM32_BOARD
		mode_select= 0x0F -(uint8_t)(((GPIOA->regs->IDR)>>4)&0x0F);
	#else
		mode_select =
			((PROTO_DIAL1_ipr & _BV(PROTO_DIAL1_pin)) ? 0 : 1) + 
			((PROTO_DIAL2_ipr & _BV(PROTO_DIAL2_pin)) ? 0 : 2) +
			((PROTO_DIAL3_ipr & _BV(PROTO_DIAL3_pin)) ? 0 : 4) +
			((PROTO_DIAL4_ipr & _BV(PROTO_DIAL4_pin)) ? 0 : 8);
	#endif
	//mode_select=1;
    debugln("Protocol selection switch reads as %d", mode_select);

	#ifdef ENABLE_PPM
		uint8_t bank=bank_switch();
	#endif

	// Set default channels' value
	for(uint8_t i=0;i<NUM_CHN;i++)
		Channel_data[i]=1024;
	Channel_data[THROTTLE]=0;	//0=-125%, 204=-100%

	#ifdef ENABLE_PPM
		// Set default PPMs' value
		for(uint8_t i=0;i<NUM_CHN;i++)
			PPM_data[i]=PPM_MAX_100+PPM_MIN_100;
		PPM_data[THROTTLE]=PPM_MIN_100*2;
	#endif

	// Update LED
	LED_off;
	LED_output;

	//Init RF modules
	modules_reset();

#ifndef ORANGE_TX
	#ifdef STM32_BOARD
		uint32_t seed=0;
		for(uint8_t i=0;i<4;i++)
		#ifdef RND_pin
			seed=(seed<<8) | (analogRead(RND_pin)& 0xFF);
		#else
		//TODO find something to randomize...
			seed=(seed<<8);
		#endif
		randomSeed(seed);
	#else
		//Init the seed with a random value created from watchdog timer for all protocols requiring random values
		randomSeed(random_value());
	#endif
#endif

	// Read or create protocol id
	MProtocol_id_master=random_id(EEPROM_ID_OFFSET,false);

	debugln("Module Id: %lx", MProtocol_id_master);

#ifdef ENABLE_PPM
	//Protocol and interrupts initialization
	if(mode_select != MODE_SERIAL)
	{ // PPM
		#ifndef MY_PPM_PROT
			const PPM_Parameters *PPM_prot_line=&PPM_prot[bank*14+mode_select-1];
		#else
			const PPM_Parameters *PPM_prot_line=&My_PPM_prot[bank*14+mode_select-1];
		#endif
		
		protocol		=	PPM_prot_line->protocol;
		cur_protocol[1] =	protocol;
		sub_protocol   	=	PPM_prot_line->sub_proto;
		RX_num			=	PPM_prot_line->rx_num;
		chan_order		=	PPM_prot_line->chan_order;

		//Forced frequency tuning values for CC2500 protocols
		#if defined(FORCE_FRSKYD_TUNING) && defined(FRSKYD_CC2500_INO)
			if(protocol==PROTO_FRSKYD) 
				option			=	FORCE_FRSKYD_TUNING;		// Use config-defined tuning value for FrSkyD
			else
		#endif
		#if defined(FORCE_FRSKYL_TUNING) && defined(FRSKYL_CC2500_INO)
			if(protocol==PROTO_FRSKYL) 
				option			=	FORCE_FRSKYL_TUNING;		// Use config-defined tuning value for FrSkyL
			else
		#endif
		#if defined(FORCE_FRSKYV_TUNING) && defined(FRSKYV_CC2500_INO)
			if(protocol==PROTO_FRSKYV)
				option			=	FORCE_FRSKYV_TUNING;		// Use config-defined tuning value for FrSkyV
			else
		#endif
		#if defined(FORCE_FRSKYX_TUNING) && defined(FRSKYX_CC2500_INO)
			if(protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2)
				option			=	FORCE_FRSKYX_TUNING;		// Use config-defined tuning value for FrSkyX
			else
		#endif 
		#if defined(FORCE_FUTABA_TUNING) && defined(FUTABA_CC2500_INO)
			if (protocol==PROTO_FUTABA)
				option			=	FORCE_FUTABA_TUNING;			// Use config-defined tuning value for SFHSS
			else
		#endif
		#if defined(FORCE_CORONA_TUNING) && defined(CORONA_CC2500_INO)
			if (protocol==PROTO_CORONA)
				option			=	FORCE_CORONA_TUNING;		// Use config-defined tuning value for CORONA
			else
		#endif
		#if defined(FORCE_SKYARTEC_TUNING) && defined(SKYARTEC_CC2500_INO)
			if (protocol==PROTO_SKYARTEC)
				option			=	FORCE_SKYARTEC_TUNING;		// Use config-defined tuning value for SKYARTEC
			else
		#endif
		#if defined(FORCE_REDPINE_TUNING) && defined(REDPINE_CC2500_INO)
			if (protocol==PROTO_REDPINE)
				option			=	FORCE_REDPINE_TUNING;		// Use config-defined tuning value for REDPINE
			else
		#endif
		#if defined(FORCE_RADIOLINK_TUNING) && defined(RADIOLINK_CC2500_INO)
			if (protocol==PROTO_RADIOLINK)
				option			=	FORCE_RADIOLINK_TUNING;		// Use config-defined tuning value for RADIOLINK
			else
		#endif
		#if defined(FORCE_HITEC_TUNING) && defined(HITEC_CC2500_INO)
			if (protocol==PROTO_HITEC)
				option			=	FORCE_HITEC_TUNING;		// Use config-defined tuning value for HITEC
			else
		#endif
		#if defined(FORCE_HOTT_TUNING) && defined(HOTT_CC2500_INO)
			if (protocol==PROTO_HOTT)
				option			=	FORCE_HOTT_TUNING;			// Use config-defined tuning value for HOTT
			else
		#endif
				option			=	(uint8_t)PPM_prot_line->option;	// Use radio-defined option value

		if(PPM_prot_line->power)		POWER_FLAG_on;
		if(PPM_prot_line->autobind)
		{
			AUTOBIND_FLAG_on;
			BIND_IN_PROGRESS;	// Force a bind at protocol startup
		}

		protocol_init();

		#ifndef STM32_BOARD
			//Configure PPM interrupt
			#if PPM_pin == 2
				EICRA |= _BV(ISC01);	// The rising edge of INT0 pin D2 generates an interrupt request
				EIMSK |= _BV(INT0);		// INT0 interrupt enable
			#elif PPM_pin == 3
				EICRA |= _BV(ISC11);	// The rising edge of INT1 pin D3 generates an interrupt request
				EIMSK |= _BV(INT1);		// INT1 interrupt enable
			#else
				#error PPM pin can only be 2 or 3
			#endif
		#else
			attachInterrupt(PPM_pin,PPM_decode,FALLING);
		#endif

		#if defined(TELEMETRY)
			PPM_Telemetry_serial_init();// Configure serial for telemetry
		#endif
	}
	else
#endif //ENABLE_PPM
	{ // Serial
		#ifdef ENABLE_SERIAL
			for(uint8_t i=0;i<3;i++)
				cur_protocol[i]=0;
			protocol=0;
			#ifdef CHECK_FOR_BOOTLOADER
				Mprotocol_serial_init(1); 	// Configure serial and enable RX interrupt
			#else
				Mprotocol_serial_init(); 	// Configure serial and enable RX interrupt
			#endif
		#endif //ENABLE_SERIAL
	}
	debugln("Init complete");
	LED2_on;
}

// Main
// Protocol scheduler
void loop()
{ 
	uint16_t next_callback, diff;
	uint8_t count=0;

	while(1)
	{
		while(remote_callback==0 || IS_WAIT_BIND_on || IS_INPUT_SIGNAL_off)
			if(!Update_All())
			{
				cli();								// Disable global int due to RW of 16 bits registers
				OCR1A=TCNT1;						// Callback should already have been called... Use "now" as new sync point.
				sei();								// Enable global int
			}
		TX_MAIN_PAUSE_on;
		tx_pause();
		next_callback=remote_callback()<<1;
		TX_MAIN_PAUSE_off;
		tx_resume();
		cli();										// Disable global int due to RW of 16 bits registers
		OCR1A+=next_callback;						// Calc when next_callback should happen
		#ifndef STM32_BOARD			
			TIFR1=OCF1A_bm;							// Clear compare A=callback flag
		#else
			TIMER2_BASE->SR = 0x1E5F & ~TIMER_SR_CC1IF;	// Clear Timer2/Comp1 interrupt flag
		#endif		
		diff=OCR1A-TCNT1;							// Calc the time difference
		sei();										// Enable global int
		if((diff&0x8000) && !(next_callback&0x8000))
		{ // Negative result=callback should already have been called... 
			debugln("Short CB:%d",next_callback);
		}
		else
		{
			if(IS_RX_FLAG_on || IS_PPM_FLAG_on)
			{ // Serial or PPM is waiting...
				if(++count>10)
				{ //The protocol does not leave enough time for an update so forcing it
					count=0;
					debugln("Force update");
					Update_All();
				}
			}
			#ifndef STM32_BOARD
				while((TIFR1 & OCF1A_bm) == 0)
			#else
				while((TIMER2_BASE->SR & TIMER_SR_CC1IF )==0)
			#endif
			{
				if(diff>900*2)
				{	//If at least 1ms is available update values 
					if((diff&0x8000) && !(next_callback&0x8000))
					{//Should never get here...
						debugln("!!!BUG!!!");
						break;
					}
					count=0;
					Update_All();
					#ifdef DEBUG_SERIAL
						if(TIMER2_BASE->SR & TIMER_SR_CC1IF )
							debugln("Long update");
					#endif
					if(remote_callback==0)
						break;
					cli();							// Disable global int due to RW of 16 bits registers
					diff=OCR1A-TCNT1;				// Calc the time difference
					sei();							// Enable global int
				}
			}
		}			
	}
}

void End_Bind()
{
	//Request protocol to terminate bind
	if(protocol==PROTO_FRSKYD || protocol==PROTO_FRSKYL || protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2 || protocol==PROTO_FRSKYV || protocol==PROTO_FRSKY_R9
	|| protocol==PROTO_DSM_RX || protocol==PROTO_AFHDS2A_RX || protocol==PROTO_FRSKY_RX || protocol==PROTO_BAYANG_RX
	|| protocol==PROTO_AFHDS2A || protocol==PROTO_BUGS || protocol==PROTO_BUGSMINI || protocol==PROTO_HOTT || protocol==PROTO_ASSAN)
		BIND_DONE;
	else
		if(bind_counter>2)
			bind_counter=2;
}

void Update_Telem()
{
	#if defined(TELEMETRY)
		#ifndef MULTI_TELEMETRY
			if((protocol == PROTO_BAYANG_RX) || (protocol == PROTO_AFHDS2A_RX) || (protocol == PROTO_FRSKY_RX) || (protocol == PROTO_SCANNER) || (protocol==PROTO_FRSKYD) || (protocol==PROTO_BAYANG) || (protocol==PROTO_NCC1701) || (protocol==PROTO_BUGS) || (protocol==PROTO_BUGSMINI) || (protocol==PROTO_HUBSAN) || (protocol==PROTO_AFHDS2A) || (protocol==PROTO_FRSKYX) || (protocol==PROTO_FRSKYX2) || (protocol==PROTO_DSM) || (protocol==PROTO_CABELL) || (protocol==PROTO_HITEC) || (protocol==PROTO_HOTT) || (protocol==PROTO_PROPEL) || (protocol==PROTO_OMP) || (protocol==PROTO_DEVO) || (protocol==PROTO_DSM_RX) || (protocol==PROTO_FRSKY_R9) || (protocol==PROTO_RLINK) || (protocol==PROTO_WFLY2) || (protocol==PROTO_LOLI) || (protocol==PROTO_MLINK) || (protocol==PROTO_MT99XX))
		#endif
				if(IS_DISABLE_TELEM_off)
					TelemetryUpdate();
	#endif
}

bool Update_All()
{
	#ifdef ENABLE_SERIAL
		#ifdef CHECK_FOR_BOOTLOADER
			if ( (mode_select==MODE_SERIAL) && (NotBootChecking == 0) )
				pollBoot() ;
			else
		#endif
		if(mode_select==MODE_SERIAL && IS_RX_FLAG_on)		// Serial mode and something has been received
		{
			update_serial_data();							// Update protocol and data
			update_channels_aux();
			INPUT_SIGNAL_on;								//valid signal received
			last_signal=millis();
		}
	#endif //ENABLE_SERIAL
	#ifdef ENABLE_PPM
		if(mode_select!=MODE_SERIAL && IS_PPM_FLAG_on)		// PPM mode and a full frame has been received
		{
			uint32_t chan_or=chan_order;
			uint8_t ch;		
			uint8_t channelsCount = PPM_chan_max;
			
			#ifdef ENABLE_DIRECT_INPUTS				
				#ifdef DI_CH1_read
					PPM_data[channelsCount] = DI_CH1_read;
					channelsCount++;
				#endif
				#ifdef DI_CH2_read
					PPM_data[channelsCount] = DI_CH2_read;
					channelsCount++;
				#endif
				#ifdef DI_CH3_read
					PPM_data[channelsCount] = DI_CH3_read;
					channelsCount++;
				#endif
				#ifdef DI_CH4_read
					PPM_data[channelsCount] = DI_CH4_read;
					channelsCount++;
				#endif 
			#endif
			
			for(uint8_t i=0;i<channelsCount;i++)
			{ // update servo data without interrupts to prevent bad read
				uint16_t val;
				cli();										// disable global int
				val = PPM_data[i];
				sei();										// enable global int
				val=map16b(val,PPM_MIN_100*2,PPM_MAX_100*2,CHANNEL_MIN_100,CHANNEL_MAX_100);
				if(val&0x8000) 					val=CHANNEL_MIN_125;
				else if(val>CHANNEL_MAX_125)	val=CHANNEL_MAX_125;
				if(chan_or)
				{
					ch=chan_or>>28;
					if(ch)
						Channel_data[ch-1]=val;
					else
						Channel_data[i]=val;
					chan_or<<=4;
				}
				else
					Channel_data[i]=val;
			}
			PPM_FLAG_off;									// wait for next frame before update
			#ifdef FAILSAFE_ENABLE
				PPM_failsafe();
			#endif
			update_channels_aux();
			INPUT_SIGNAL_on;								// valid signal received
			last_signal=millis();
		}
	#endif //ENABLE_PPM
	update_led_status();
	
	#ifdef SEND_CPPM
		if ( telemetry_link & 0x80 )
		{ // Protocol requests telemetry to be disabled
			if( protocol == PROTO_FRSKY_RX || protocol == PROTO_AFHDS2A_RX || protocol == PROTO_BAYANG_RX || protocol == PROTO_DSM_RX )
			{ // RX protocol
				if(RX_LQI == 0)
					telemetry_link = 0x00;					// restore normal telemetry on connection loss
				else if(telemetry_link & 1)
				{ // New data available
					Send_CCPM_USART1();
					telemetry_link &= 0xFE;					// update done
				}
			}
		}
		else
	#endif

	Update_Telem();

	#ifdef ENABLE_BIND_CH
		if(IS_AUTOBIND_FLAG_on && IS_BIND_CH_PREV_off && Channel_data[BIND_CH-1]>CHANNEL_MAX_COMMAND)
		{ // Autobind is on and BIND_CH went up
			CHANGE_PROTOCOL_FLAG_on;						// reload protocol
			BIND_IN_PROGRESS;								// enable bind
			BIND_CH_PREV_on;
		}
		if(IS_AUTOBIND_FLAG_on && IS_BIND_CH_PREV_on && Channel_data[BIND_CH-1]<CHANNEL_MIN_COMMAND)
		{ // Autobind is on and BIND_CH went down
			BIND_CH_PREV_off;
			End_Bind();
		}
	#endif //ENABLE_BIND_CH
	if(IS_CHANGE_PROTOCOL_FLAG_on)
	{ // Protocol needs to be changed or relaunched for bind
		protocol_init();									// init new protocol
		return true;
	}
	return false;
}

#if defined(FAILSAFE_ENABLE) && defined(ENABLE_PPM)
void PPM_failsafe()
{
	static uint8_t counter=0;
	
	if(IS_BIND_IN_PROGRESS || IS_FAILSAFE_VALUES_on) 	// bind is not finished yet or Failsafe already being sent
		return;
	BIND_SET_INPUT;
	BIND_SET_PULLUP;
	if(IS_BIND_BUTTON_on)
	{// bind button pressed
		counter++;
		if(counter>227)
		{ //after 5s with PPM frames @22ms
			counter=0;
			for(uint8_t i=0;i<NUM_CHN;i++)
				Failsafe_data[i]=Channel_data[i];
			FAILSAFE_VALUES_on;
		}
	}
	else
		counter=0;
	BIND_SET_OUTPUT;
}
#endif

// Update channels direction and Channel_AUX flags based on servo AUX positions
static void update_channels_aux(void)
{
	//Reverse channels direction
	#ifdef REVERSE_AILERON
		reverse_channel(AILERON);
	#endif
	#ifdef REVERSE_ELEVATOR
		reverse_channel(ELEVATOR);
	#endif
	#ifdef REVERSE_THROTTLE
		reverse_channel(THROTTLE);
	#endif
	#ifdef REVERSE_RUDDER
		reverse_channel(RUDDER);
	#endif
		
	//Calc AUX flags
	Channel_AUX=0;
	for(uint8_t i=0;i<8;i++)
		if(Channel_data[CH5+i]>CHANNEL_SWITCH)
			Channel_AUX|=1<<i;
}

// Update led status based on binding and serial
static void update_led_status(void)
{
	if(IS_INPUT_SIGNAL_on)
		if(millis()-last_signal>70)
		{
			INPUT_SIGNAL_off;							//no valid signal (PPM or Serial) received for 70ms
			debugln("No input signal");
		}
	if(blink<millis())
	{
		if(IS_INPUT_SIGNAL_off)
		{
			if(mode_select==MODE_SERIAL)
				blink+=BLINK_SERIAL_TIME;				//blink slowly if no valid serial input
			else
				blink+=BLINK_PPM_TIME;					//blink more slowly if no valid PPM input
		}
		else
			if(remote_callback == 0)
			{ // Invalid protocol
				if(IS_LED_on)							//flash to indicate invalid protocol
					blink+=BLINK_BAD_PROTO_TIME_LOW;
				else
					blink+=BLINK_BAD_PROTO_TIME_HIGH;
			}
			else
			{
				if(IS_WAIT_BIND_on)
				{
					if(IS_LED_on)							//flash to indicate WAIT_BIND
						blink+=BLINK_WAIT_BIND_TIME_LOW;
					else
						blink+=BLINK_WAIT_BIND_TIME_HIGH;
				}
				else
				{
					if(IS_BIND_DONE)
						LED_off;							//bind completed force led on
					blink+=BLINK_BIND_TIME;					//blink fastly during binding
				}
			}
		LED_toggle;
	}
}

#ifdef ENABLE_PPM
uint8_t bank_switch(void)
{
	uint8_t bank=eeprom_read_byte((EE_ADDR)EEPROM_BANK_OFFSET);
	if(bank>=NBR_BANKS)
	{ // Wrong number of bank
		eeprom_write_byte((EE_ADDR)EEPROM_BANK_OFFSET,0x00);	// set bank to 0
		bank=0;
	}
	debugln("Using bank %d", bank);

	phase=3;
	uint32_t check=millis();
	blink=millis();
	while(mode_select==15)
	{ //loop here if the dial is on position 15 for user to select the bank
		if(blink<millis())
		{
			switch(phase & 0x03)
			{ // Flash bank number of times
				case 0:
					LED_on;
					blink+=BLINK_BANK_TIME_HIGH;
					phase++;
					break;
				case 1:
					LED_off;
					blink+=BLINK_BANK_TIME_LOW;
					phase++;
					break;
				case 2:
					if( (phase>>2) >= bank)
					{
						phase=0;
						blink+=BLINK_BANK_REPEAT;
					}
					else
						phase+=2;
					break;
				case 3:
					LED_output;
					LED_off;
					blink+=BLINK_BANK_TIME_LOW;
					phase=0;
					break;
			}
		}
		if(check<millis())
		{
			//Test bind button: for AVR it's shared with the LED so some extra work is needed to check it...
			#ifndef STM32_BOARD
				bool led=IS_LED_on;
				BIND_SET_INPUT;
				BIND_SET_PULLUP;
			#endif
			bool test_bind=IS_BIND_BUTTON_on;
			#ifndef STM32_BOARD
				if(led)
					LED_on;
				else
					LED_off;
				LED_output;
			#endif
			if( test_bind )
			{	// Increase bank
				LED_on;
				bank++;
				if(bank>=NBR_BANKS)
					bank=0;
				eeprom_write_byte((EE_ADDR)EEPROM_BANK_OFFSET,bank);
				debugln("Using bank %d", bank);
				phase=3;
				blink+=BLINK_BANK_REPEAT;
				check+=2*BLINK_BANK_REPEAT;
			}
			check+=1;
		}
	}
	return bank;
}
#endif

inline void tx_pause()
{
	#ifdef TELEMETRY
	// Pause telemetry by disabling transmitter interrupt
		#ifdef ORANGE_TX
			USARTC0.CTRLA &= ~0x03 ;
		#else
			#ifndef BASH_SERIAL
				#ifdef STM32_BOARD
					USART3_BASE->CR1 &= ~ USART_CR1_TXEIE;
				#else
					UCSR0B &= ~_BV(UDRIE0);
				#endif
			#endif
		#endif
	#endif
}

inline void tx_resume()
{
	#ifdef TELEMETRY
	// Resume telemetry by enabling transmitter interrupt
		if(IS_TX_PAUSE_off)
		{
			#ifdef ORANGE_TX
				cli() ;
				USARTC0.CTRLA = (USARTC0.CTRLA & 0xFC) | 0x01 ;
				sei() ;
			#else
				#ifndef BASH_SERIAL
					#ifdef STM32_BOARD
						USART3_BASE->CR1 |= USART_CR1_TXEIE;
					#else
						UCSR0B |= _BV(UDRIE0);			
					#endif
				#else
					resumeBashSerial();
				#endif
			#endif
		}
	#endif
}

void rf_switch(uint8_t comp)
{
	PE1_off;
	PE2_off;
	switch(comp)
	{
		case SW_CC2500:
			PE2_on;
			break;
		case SW_CYRF:
			PE2_on;
		case SW_NRF:
			PE1_on;
			break;
	}
}

// Protocol start
static void protocol_init()
{
	if(IS_WAIT_BIND_off)
	{
		remote_callback = 0;			// No protocol
		LED_off;						// Led off during protocol init
		crc16_polynomial = 0x1021;		// Default CRC crc16_polynomial
		crc8_polynomial  = 0x31;		// Default CRC crc8_polynomial
		prev_option = option;

		multi_protocols_index = 0xFF;
		// reset telemetry
		#ifdef TELEMETRY
			#ifdef MULTI_SYNC
				inputRefreshRate = 0;	// Don't do it unless the protocol asks for it
			#endif
			tx_pause();
			init_frskyd_link_telemetry();
			pps_timer=millis();
			pps_counter=0;
			#ifdef BASH_SERIAL
				TIMSK0 = 0 ;			// Stop all timer 0 interrupts
				#ifdef INVERT_SERIAL
					SERIAL_TX_off;
				#else
					SERIAL_TX_on;
				#endif
				SerialControl.tail=0;
				SerialControl.head=0;
				SerialControl.busy=0;
			#else
				tx_tail=0;
				tx_head=0;
			#endif
			TX_RX_PAUSE_off;
			TX_MAIN_PAUSE_off;
			tx_resume();
			#if defined(AFHDS2A_RX_A7105_INO) || defined(FRSKY_RX_CC2500_INO) || defined(BAYANG_RX_NRF24L01_INO) || defined(DSM_RX_CYRF6936_INO)
				for(uint8_t ch=0; ch<16; ch++)
					rx_rc_chan[ch] = 1024;
			#endif
		#endif
		binding_idx=0;
		
		//Stop CPPM if it was previously running
		#ifdef SEND_CPPM
			release_trainer_ppm();
		#endif
		
		//Set global ID and rx_tx_addr
		MProtocol_id = RX_num + MProtocol_id_master;
		set_rx_tx_addr(MProtocol_id);
		
		#ifdef FAILSAFE_ENABLE
			FAILSAFE_VALUES_off;
		#endif
		DATA_BUFFER_LOW_off;

		SUB_PROTO_INVALID;
		option_override = 0xFF;
		
		blink=millis();

		debugln("Protocol selected: %d, sub proto %d, rxnum %d, option %d", protocol, sub_protocol, RX_num, option);
		if(protocol)
		{
			//Reset all modules
			modules_reset();				

			uint8_t index=0;
			//#if defined(FRSKYX_CC2500_INO) && defined(MULTI_EU)
			//	if( ! ( (protocol == PROTO_FRSKYX || protocol == PROTO_FRSKYX2) && sub_protocol < 2 ) )
			//#endif
			while(multi_protocols[index].protocol != 0xFF)
			{
				if(multi_protocols[index].protocol==protocol)
				{
					//Save index
					multi_protocols_index = index;
					//Check sub protocol validity
					if( ((sub_protocol&0x07) == 0) || (sub_protocol&0x07) < multi_protocols[index].nbrSubProto )
						SUB_PROTO_VALID;
					if(IS_SUB_PROTO_VALID)
					{//Start the protocol
						//Set the RF switch
						rf_switch(multi_protocols[index].rfSwitch);
						//Init protocol
						multi_protocols[index].Init();		// Init could invalidate the sub proto in case it is not suuported
						if(IS_SUB_PROTO_VALID)
							remote_callback = multi_protocols[index].CallBack;	//Save call back function address
					}
					#ifdef DEBUG_SERIAL
						debug("Proto=%s", multi_protocols[index].ProtoString);
						debug(", nbr_sub=%d, Sub=", multi_protocols[index].nbrSubProto);
						if(IS_SUB_PROTO_VALID)
						{
							uint8_t len=multi_protocols[index].SubProtoString[0];
							uint8_t offset=len*(sub_protocol&0x07)+1;
							for(uint8_t j=0;j<len;j++)
								debug("%c",multi_protocols[index].SubProtoString[j+offset]);
						}
						debug(", Opt=%d",multi_protocols[index].optionType);
						debug(", FS=%d",multi_protocols[index].failSafe);
						debug(", CHMap=%d",multi_protocols[index].chMap);
						debugln(", rfSw=%d",multi_protocols[index].rfSwitch);
					#endif
					break;
				}
				index++;
			}
			//Send a telemetry status right now
			SEND_MULTI_STATUS_on;
			Update_Telem();
		}
		#ifdef MULTI_TELEMETRY
			else
			{//protocol=PROTO_PROTOLIST=0
				remote_callback = PROTOLIST_callback;
				prev_option = option + 1;
			}
		#endif
	}

	#if defined(WAIT_FOR_BIND) && defined(ENABLE_BIND_CH)
		if( IS_AUTOBIND_FLAG_on && IS_BIND_CH_PREV_off && (cur_protocol[1]&0x80)==0 && mode_select == MODE_SERIAL)
		{ // Autobind is active but no bind requested by either BIND_CH or BIND. But do not wait if in PPM mode...
			WAIT_BIND_on;
			return;
		}
	#endif
	WAIT_BIND_off;
	CHANGE_PROTOCOL_FLAG_off;

	if(protocol)
	{
		//Wait 5ms after protocol init
		cli();										// disable global int
		OCR1A = TCNT1 + 5000*2;						// set compare A for callback
		#ifndef STM32_BOARD
			TIFR1 = OCF1A_bm ;						// clear compare A flag
		#else
			TIMER2_BASE->SR = 0x1E5F & ~TIMER_SR_CC1IF;	// Clear Timer2/Comp1 interrupt flag
		#endif	
		sei();										// enable global int
		BIND_BUTTON_FLAG_off;						// do not bind/reset id anymore even if protocol change
	}
}

void update_serial_data()
{
	static bool prev_ch_mapping=false;
	#if defined(TELEMETRY) && defined(INVERT_TELEMETRY_TX)
		#ifdef INVERT_TELEMETRY
			static bool prev_inv_telem=true;
		#else
			static bool prev_inv_telem=false;
		#endif
	#endif

	RX_DONOTUPDATE_on;
	RX_FLAG_off;								//data is being processed

	#ifdef SAMSON	// Extremely dangerous, do not enable this unless you know what you are doing...
		if( rx_ok_buff[0]==0x55 && (rx_ok_buff[1]&0x1F)==PROTO_FRSKYD && rx_ok_buff[2]==0x7F && rx_ok_buff[24]==217 && rx_ok_buff[25]==202 )
		{//proto==FRSKYD+sub==7+rx_num==7+CH15==73%+CH16==73%
			rx_ok_buff[1]=(rx_ok_buff[1]&0xE0) | PROTO_FLYSKY;			// change the protocol to Flysky
			memcpy((void*)(rx_ok_buff+4),(void*)(rx_ok_buff+4+11),11);	// reassign channels 9-16 to 1-8
		}
	#endif
	#ifdef BONI	// Extremely dangerous, do not enable this!!! This is really for a special case...
		if(CH14_SW)
			rx_ok_buff[2]=(rx_ok_buff[2]&0xF0)|((rx_ok_buff[2]+1)&0x0F);
	#endif

	if(rx_ok_buff[1]&0x20)						//check range
		RANGE_FLAG_on;
	else
		RANGE_FLAG_off;
	if(rx_ok_buff[1]&0x40)						//check autobind
		AUTOBIND_FLAG_on;
	else
		AUTOBIND_FLAG_off;
	if(rx_ok_buff[2]&0x80)						//if rx_ok_buff[2] ==1,power is low ,0-power high
		POWER_FLAG_off;							//power low
	else
		POWER_FLAG_on;							//power high

	//Forced frequency tuning values for CC2500 protocols
	#if defined(FORCE_FRSKYD_TUNING) && defined(FRSKYD_CC2500_INO)
		if(protocol==PROTO_FRSKYD)
			option=FORCE_FRSKYD_TUNING;			// Use config-defined tuning value for FrSkyD
		else
	#endif
	#if defined(FORCE_FRSKYL_TUNING) && defined(FRSKYL_CC2500_INO)
		if(protocol==PROTO_FRSKYL)
			option=FORCE_FRSKYL_TUNING;			// Use config-defined tuning value for FrSkyL
		else
	#endif
	#if defined(FORCE_FRSKYV_TUNING) && defined(FRSKYV_CC2500_INO)
		if(protocol==PROTO_FRSKYV)
			option=FORCE_FRSKYV_TUNING;			// Use config-defined tuning value for FrSkyV
		else
	#endif
	#if defined(FORCE_FRSKYX_TUNING) && defined(FRSKYX_CC2500_INO)
		if(protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2)
			option=FORCE_FRSKYX_TUNING;			// Use config-defined tuning value for FrSkyX
		else
	#endif 
	#if defined(FORCE_FUTABA_TUNING) && defined(FUTABA_CC2500_INO)
		if (protocol==PROTO_FUTABA)
			option=FORCE_FUTABA_TUNING;			// Use config-defined tuning value for SFHSS
		else
	#endif
	#if defined(FORCE_CORONA_TUNING) && defined(CORONA_CC2500_INO)
		if (protocol==PROTO_CORONA)
			option=FORCE_CORONA_TUNING;			// Use config-defined tuning value for CORONA
		else
	#endif
	#if defined(FORCE_SKYARTEC_TUNING) && defined(SKYARTEC_CC2500_INO)
		if (protocol==PROTO_SKYARTEC)
			option=FORCE_SKYARTEC_TUNING;			// Use config-defined tuning value for SKYARTEC
		else
	#endif
	#if defined(FORCE_REDPINE_TUNING) && defined(REDPINE_CC2500_INO)
		if (protocol==PROTO_REDPINE)
			option=FORCE_REDPINE_TUNING;		// Use config-defined tuning value for REDPINE
		else
	#endif
	#if defined(FORCE_RADIOLINK_TUNING) && defined(RADIOLINK_CC2500_INO)
		if (protocol==PROTO_RADIOLINK)
			option			=	FORCE_RADIOLINK_TUNING;		// Use config-defined tuning value for RADIOLINK
		else
	#endif
	#if defined(FORCE_HITEC_TUNING) && defined(HITEC_CC2500_INO)
		if (protocol==PROTO_HITEC)
			option=FORCE_HITEC_TUNING;			// Use config-defined tuning value for HITEC
		else
	#endif
	#if defined(FORCE_HOTT_TUNING) && defined(HOTT_CC2500_INO)
		if (protocol==PROTO_HOTT)
			option=FORCE_HOTT_TUNING;			// Use config-defined tuning value for HOTT
		else
	#endif
			option=rx_ok_buff[3];				// Use radio-defined option value

	#ifdef FAILSAFE_ENABLE
		bool failsafe=false;
		if(rx_ok_buff[0]&0x02)
		{ // Packet contains failsafe instead of channels
			failsafe=true;
			rx_ok_buff[0]&=0xFD;				// Remove the failsafe flag
			FAILSAFE_VALUES_on;					// Failsafe data has been received
			debugln("Failsafe received");
		}
	#endif

	DISABLE_CH_MAP_off;
	DISABLE_TELEM_off;
	if(rx_len>26)
	{//Additional flag received at the end
		rx_ok_buff[0]=(rx_ok_buff[26]&0xF0) | (rx_ok_buff[0]&0x0F);	// Additional protocol numbers and RX_Num available -> store them in rx_ok_buff[0]
		if(rx_ok_buff[26]&0x02)
			DISABLE_TELEM_on;
		if(rx_ok_buff[26]&0x01)
			DISABLE_CH_MAP_on;
		#if defined(TELEMETRY) && defined(INVERT_TELEMETRY_TX)
			if(((rx_ok_buff[26]&0x08)!=0) ^ prev_inv_telem)
			{ //value changed
				if(rx_ok_buff[26]&0x08)
				{								// Invert telemetry
					debugln("Invert telem %d,%d",rx_ok_buff[26]&0x01,prev_inv_telem);
					#if defined (ORANGE_TX)
						PORTC.PIN3CTRL |= 0x40 ;
					#elif defined (STM32_BOARD)
						TX_INV_on;
						RX_INV_on;
					#endif
				}
				else
				{								// Normal telemetry
					debugln("Normal telem %d,%d",rx_ok_buff[26]&0x01,prev_inv_telem);
					#if defined (ORANGE_TX)
						PORTC.PIN3CTRL &= 0xBF ;
					#elif defined (STM32_BOARD)
						TX_INV_off;
						RX_INV_off;
					#endif
				}
				prev_inv_telem=rx_ok_buff[26]&0x08;
			}
		#endif
	}

	if( (rx_ok_buff[0] != cur_protocol[0]) || ((rx_ok_buff[1]&0x5F) != (cur_protocol[1]&0x5F)) || ( (rx_ok_buff[2]&0x7F) != (cur_protocol[2]&0x7F) ) )
	{ // New model has been selected
		CHANGE_PROTOCOL_FLAG_on;				//change protocol
		WAIT_BIND_off;
		if((rx_ok_buff[1]&0x80)!=0 || IS_AUTOBIND_FLAG_on)
			BIND_IN_PROGRESS;					//launch bind right away if in autobind mode or bind is set
		else
			BIND_DONE;
		protocol=rx_ok_buff[1]&0x1F;			//protocol no (0-31)
		if(!(rx_ok_buff[0]&1))
			protocol+=32;						//protocol no (0-63)
		if(rx_len>26)
			protocol|=rx_ok_buff[26]&0xC0;		//protocol no (0-255)
		sub_protocol=(rx_ok_buff[2]>>4)& 0x07;	//subprotocol no (0-7) bits 4-6
		RX_num=rx_ok_buff[2]& 0x0F;				//rx_num no (0-15)
		if(rx_len>26)
			RX_num|=rx_ok_buff[26]&0x30;		//rx_num no (0-63)
	}
	else
		if( ((rx_ok_buff[1]&0x80)!=0) && ((cur_protocol[1]&0x80)==0) )		// Bind flag has been set
		{ // Restart protocol with bind
			CHANGE_PROTOCOL_FLAG_on;
			BIND_IN_PROGRESS;
		}
		else
			if( ((rx_ok_buff[1]&0x80)==0) && ((cur_protocol[1]&0x80)!=0) )	// Bind flag has been reset
			{ // Request protocol to end bind
				End_Bind();
			}
			
	//store current protocol values
	for(uint8_t i=0;i<3;i++)
		cur_protocol[i] =  rx_ok_buff[i];

	//disable channel mapping
	if(multi_protocols[multi_protocols_index].chMap == 0)
		DISABLE_CH_MAP_off;						//not a protocol supporting ch map to be disabled

	if(prev_ch_mapping!=IS_DISABLE_CH_MAP_on)
	{
		prev_ch_mapping=IS_DISABLE_CH_MAP_on;
		if(IS_DISABLE_CH_MAP_on)
		{
			for(uint8_t i=0;i<4;i++)
				CH_AETR[i]=CH_TAER[i]=CH_EATR[i]=i;
			debugln("DISABLE_CH_MAP_on");
		}
		else
		{
			CH_AETR[0]=AILERON;CH_AETR[1]=ELEVATOR;CH_AETR[2]=THROTTLE;CH_AETR[3]=RUDDER;
			CH_TAER[0]=THROTTLE;CH_TAER[1]=AILERON;CH_TAER[2]=ELEVATOR;CH_TAER[3]=RUDDER;
			CH_EATR[0]=ELEVATOR;CH_EATR[1]=AILERON;CH_EATR[2]=THROTTLE;CH_EATR[3]=RUDDER;
			debugln("DISABLE_CH_MAP_off");
		}
	}
	
	// decode channel/failsafe values
	volatile uint8_t *p=rx_ok_buff+3;
	uint8_t dec=-3;
	for(uint8_t i=0;i<NUM_CHN;i++)
	{
		dec+=3;
		if(dec>=8)
		{
			dec-=8;
			p++;
		}
		p++;
		uint16_t temp=((*((uint32_t *)p))>>dec)&0x7FF;
		#ifdef FAILSAFE_ENABLE
			if(failsafe)
				Failsafe_data[i]=temp;			//value range 0..2047, 0=no pulse, 2047=hold
			else
		#endif
				Channel_data[i]=temp;			//value range 0..2047, 0=-125%, 2047=+125%
	}

	#ifdef HOTT_FW_TELEMETRY
		HoTT_SerialRX=false;
	#endif
	if(rx_len>27)
	{ // Data available for the current protocol
		#if defined(FRSKYX_CC2500_INO) || defined(FRSKYR9_SX1276_INO)
			if((protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2 || protocol==PROTO_FRSKY_R9) && rx_len==28)
			{//Protocol waiting for 1 byte during bind
				binding_idx=rx_ok_buff[27];
			}
		#endif
		#ifdef SPORT_SEND
			if((protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2 || protocol==PROTO_FRSKY_R9) && rx_len==27+8)
			{//Protocol waiting for 8 bytes
				#define BYTE_STUFF	0x7D
				#define STUFF_MASK	0x20
				//debug("SPort_in: ");
				boolean sport_valid=false;
				for(uint8_t i=28;i<28+7;i++)
					if(rx_ok_buff[i]!=0) sport_valid=true;	//Check that the payload is not full of 0
				if((rx_ok_buff[27]&0x1F) > 0x1B)				//Check 1st byte validity
					sport_valid=false;
				if(sport_valid)
				{
					SportData[SportTail]=0x7E;
					SportTail = (SportTail+1) & (MAX_SPORT_BUFFER-1);
					SportData[SportTail]=rx_ok_buff[27]&0x1F;
					SportTail = (SportTail+1) & (MAX_SPORT_BUFFER-1);
					for(uint8_t i=28;i<28+7;i++)
					{
						if( (rx_ok_buff[i]==BYTE_STUFF) || (rx_ok_buff[i]==0x7E) )
						{//stuff
							SportData[SportTail]=BYTE_STUFF;
							SportTail = (SportTail+1) & (MAX_SPORT_BUFFER-1);
							SportData[SportTail]=rx_ok_buff[i]^STUFF_MASK;
						}
						else
							SportData[SportTail]=rx_ok_buff[i];
						//debug("%02X ",SportData[SportTail]);
						SportTail = (SportTail+1) & (MAX_SPORT_BUFFER-1);
					}
					uint8_t used = SportTail;
					if ( SportHead > SportTail )
						used += MAX_SPORT_BUFFER - SportHead ;
					else
						used -= SportHead ;
					if ( used >= MAX_SPORT_BUFFER-(MAX_SPORT_BUFFER>>2) )
					{
						DATA_BUFFER_LOW_on;
						//Send Multi Status ASAP to inform the TX
						SEND_MULTI_STATUS_on;
						Update_Telem();
						debugln("Low buf=%d,h=%d,t=%d",used,SportHead,SportTail);
					}
				}
			}
		#endif //SPORT_SEND
		#ifdef HOTT_FW_TELEMETRY
			if(protocol==PROTO_HOTT && rx_len==27+1)
			{//Protocol waiting for 1 byte
				HoTT_SerialRX_val=rx_ok_buff[27];
				HoTT_SerialRX=true;
			}
		#endif
		#ifdef DSM_FWD_PGM
			if(protocol==PROTO_DSM && rx_len==27+7)
			{//Protocol waiting for 7 bytes
				memcpy(DSM_SerialRX_val, (const void *)&rx_ok_buff[27],7);
				DSM_SerialRX=true;
			}
		#endif
		#ifdef MULTI_CONFIG_INO
			if(protocol==PROTO_CONFIG && rx_len==27+7)
			{//Protocol waiting for 7 bytes
				memcpy(CONFIG_SerialRX_val, (const void *)&rx_ok_buff[27],7);
				CONFIG_SerialRX=true;
			}
		#endif
	}

	RX_DONOTUPDATE_off;
	#ifdef ORANGE_TX
		cli();
	#else
		UCSR0B &= ~_BV(RXCIE0);					// RX interrupt disable
	#endif
	if(IS_RX_MISSED_BUFF_on)					// If the buffer is still valid
	{	
		if(rx_idx>=26 && rx_idx<RXBUFFER_SIZE)
		{
			rx_len=rx_idx;
			memcpy((void*)rx_ok_buff,(const void*)rx_buff,rx_len);// Duplicate the buffer
			RX_FLAG_on;							// Data to be processed next time...
		}
		RX_MISSED_BUFF_off;
	}
	#ifdef ORANGE_TX
		sei();
	#else
		UCSR0B |= _BV(RXCIE0) ;					// RX interrupt enable
	#endif
}

void modules_reset()
{
	#ifdef	CC2500_INSTALLED
		CC2500_Reset();
	#endif
	#ifdef	A7105_INSTALLED
		A7105_Reset();
	#endif
	#ifdef	CYRF6936_INSTALLED
		CYRF_Reset();
	#endif
	#ifdef	NRF24L01_INSTALLED
		NRF24L01_Reset();
	#endif
	#ifdef	SX1276_INSTALLED
		SX1276_Reset();
	#endif

	//Wait for every component to reset
	delayMilliseconds(100);
	prev_power=0xFD;		// unused power value
}

#ifdef CHECK_FOR_BOOTLOADER
	void Mprotocol_serial_init( uint8_t boot )
#else
	void Mprotocol_serial_init()
#endif
{
	#ifdef ORANGE_TX
		PORTC.OUTSET = 0x08 ;
		PORTC.DIRSET = 0x08 ;

		USARTC0.BAUDCTRLA = 19 ;
		USARTC0.BAUDCTRLB = 0 ;
		
		USARTC0.CTRLB = 0x18 ;
		USARTC0.CTRLA = (USARTC0.CTRLA & 0xCC) | 0x11 ;
		USARTC0.CTRLC = 0x2B ;
		UDR0 ;
		#ifdef INVERT_SERIAL
			PORTC.PIN3CTRL |= 0x40 ;
		#endif
		#ifdef CHECK_FOR_BOOTLOADER
			if ( boot )
			{
				USARTC0.BAUDCTRLB = 0 ;
				USARTC0.BAUDCTRLA = 33 ;		// 57600
				USARTC0.CTRLA = (USARTC0.CTRLA & 0xC0) ;
				USARTC0.CTRLC = 0x03 ;			// 8 bit, no parity, 1 stop
				USARTC0.CTRLB = 0x18 ;			// Enable Tx and Rx
				PORTC.PIN3CTRL &= ~0x40 ;
			}
		#endif // CHECK_FOR_BOOTLOADER
	#elif defined STM32_BOARD
		#ifdef CHECK_FOR_BOOTLOADER
			if ( boot )
			{
				usart2_begin(57600,SERIAL_8N1);
				USART2_BASE->CR1 &= ~USART_CR1_RXNEIE ;
				(void)UDR0 ;
			}
			else
		#endif // CHECK_FOR_BOOTLOADER
		{
			usart2_begin(100000,SERIAL_8E2);
			USART2_BASE->CR1 |= USART_CR1_PCE_BIT;
		}
		USART2_BASE->CR1 &= ~ USART_CR1_TE;		//disable transmit
		usart3_begin(100000,SERIAL_8E2);
	#else
		//ATMEGA328p
		#include <util/setbaud.h>	
		UBRR0H = UBRRH_VALUE;
		UBRR0L = UBRRL_VALUE;
		UCSR0A = 0 ;	// Clear X2 bit
		//Set frame format to 8 data bits, even parity, 2 stop bits
		UCSR0C = _BV(UPM01)|_BV(USBS0)|_BV(UCSZ01)|_BV(UCSZ00);
		while ( UCSR0A & (1 << RXC0) )	//flush receive buffer
			UDR0;
		//enable reception and RC complete interrupt
		UCSR0B = _BV(RXEN0)|_BV(RXCIE0);//rx enable and interrupt
		#ifndef DEBUG_PIN
			#if defined(TELEMETRY)
				initTXSerial( SPEED_100K ) ;
			#endif //TELEMETRY
		#endif //DEBUG_PIN
		#ifdef CHECK_FOR_BOOTLOADER
			if ( boot )
			{
				UBRR0H = 0;
				UBRR0L = 33;			// 57600
				UCSR0C &= ~_BV(UPM01);	// No parity
				UCSR0B &= ~_BV(RXCIE0);	// No rx interrupt
				UCSR0A |= _BV(U2X0);	// Double speed mode USART0
			}
		#endif // CHECK_FOR_BOOTLOADER
	#endif //ORANGE_TX
}

#ifdef STM32_BOARD
	void usart2_begin(uint32_t baud,uint32_t config )
	{
		usart_init(USART2); 
		usart_config_gpios_async(USART2,GPIOA,PIN_MAP[PA3].gpio_bit,GPIOA,PIN_MAP[PA2].gpio_bit,config);
		LED2_output;
		usart_set_baud_rate(USART2, STM32_PCLK1, baud);
		usart_enable(USART2);
	}
	void usart3_begin(uint32_t baud,uint32_t config )
	{
		usart_init(USART3);
		usart_config_gpios_async(USART3,GPIOB,PIN_MAP[PB11].gpio_bit,GPIOB,PIN_MAP[PB10].gpio_bit,config);
		usart_set_baud_rate(USART3, STM32_PCLK1, baud);
		USART3_BASE->CR3 &= ~USART_CR3_EIE & ~USART_CR3_CTSIE;	// Disable receive
		USART3_BASE->CR1 &= ~USART_CR1_RE & ~USART_CR1_RXNEIE & ~USART_CR1_PEIE & ~USART_CR1_IDLEIE ; // Disable RX and interrupts
    	USART3_BASE->CR1 |= (USART_CR1_TE | USART_CR1_UE);		// Enable USART3 and TX
	}
	void init_HWTimer()
	{	
		HWTimer2.pause();										// Pause the timer2 while we're configuring it
		TIMER2_BASE->PSC = 35;									// 36-1;for 72 MHZ /0.5sec/(35+1)
		TIMER2_BASE->ARR = 0xFFFF;								// Count until 0xFFFF
		HWTimer2.setMode(TIMER_CH1, TIMER_OUTPUT_COMPARE);		// Main scheduler
		TIMER2_BASE->SR = 0x1E5F & ~TIMER_SR_CC2IF;				// Clear Timer2/Comp2 interrupt flag
		TIMER2_BASE->DIER &= ~TIMER_DIER_CC2IE;					// Disable Timer2/Comp2 interrupt
		HWTimer2.refresh();										// Refresh the timer's count, prescale, and overflow
		HWTimer2.resume();

		#ifdef ENABLE_SERIAL
			HWTimer3.pause();									// Pause the timer3 while we're configuring it
			TIMER3_BASE->PSC = 35;								// 36-1;for 72 MHZ /0.5sec/(35+1)
			TIMER3_BASE->ARR = 0xFFFF;							// Count until 0xFFFF
			HWTimer3.setMode(TIMER_CH2, TIMER_OUTPUT_COMPARE);	// Serial check
			TIMER3_BASE->SR = 0x1E5F & ~TIMER_SR_CC2IF;			// Clear Timer3/Comp2 interrupt flag
			HWTimer3.attachInterrupt(TIMER_CH2,ISR_COMPB);		// Assign function to Timer3/Comp2 interrupt
			TIMER3_BASE->DIER &= ~TIMER_DIER_CC2IE;				// Disable Timer3/Comp2 interrupt
			HWTimer3.refresh();									// Refresh the timer's count, prescale, and overflow
			HWTimer3.resume();
		#endif
	}
#endif

#ifdef CHECK_FOR_BOOTLOADER
void pollBoot()
{
	uint8_t rxchar ;
	uint8_t lState = BootState ;
	uint8_t millisTime = millis();				// Call this once only

	#ifdef ORANGE_TX
	if ( USARTC0.STATUS & USART_RXCIF_bm )
	#elif defined STM32_BOARD
	if ( USART2_BASE->SR & USART_SR_RXNE )
	#else
	if ( UCSR0A & ( 1 << RXC0 ) )
	#endif
	{
		rxchar = UDR0 ;
		BootCount += 1 ;
		if ( ( lState == BOOT_WAIT_30_IDLE ) || ( lState == BOOT_WAIT_30_DATA ) )
		{
			if ( lState == BOOT_WAIT_30_IDLE )	// Waiting for 0x30
				BootTimer = millisTime ;		// Start timeout
			if ( rxchar == 0x30 )
				lState = BOOT_WAIT_20 ;
			else
				lState = BOOT_WAIT_30_DATA ;
		}
		else
			if ( lState == BOOT_WAIT_20 && rxchar == 0x20 )	// Waiting for 0x20
				lState = BOOT_READY ;
	}
	else // No byte received
	{
		if ( lState != BOOT_WAIT_30_IDLE )		// Something received
		{
			uint8_t time = millisTime - BootTimer ;
			if ( time > 5 )
			{
				#ifdef	STM32_BOARD
				if ( BootCount > 4 )
				#else
				if ( BootCount > 2 )
				#endif
				{ // Run normally
					NotBootChecking = 0xFF ;
					Mprotocol_serial_init( 0 ) ;
				}
				else if ( lState == BOOT_READY )
				{
					#ifdef	STM32_BOARD
						nvic_sys_reset();
						while(1);						/* wait until reset */
					#else
						cli();							// Disable global int due to RW of 16 bits registers
						void (*p)();
						#ifndef ORANGE_TX
							p = (void (*)())0x3F00 ;	// Word address (0x7E00 byte)
						#else
							p = (void (*)())0x4000 ;	// Word address (0x8000 byte)
						#endif
						(*p)() ;						// go to boot
					#endif
				}
				else
				{
					lState = BOOT_WAIT_30_IDLE ;
					BootCount = 0 ;
				}
			}
		}
	}
	BootState = lState ;
}
#endif //CHECK_FOR_BOOTLOADER

#if defined(TELEMETRY)
void PPM_Telemetry_serial_init()
{
	if( (protocol==PROTO_FRSKYD) || (protocol==PROTO_HUBSAN) || (protocol==PROTO_AFHDS2A) || (protocol==PROTO_BAYANG)|| (protocol==PROTO_NCC1701) || (protocol==PROTO_CABELL)  || (protocol==PROTO_HITEC) || (protocol==PROTO_BUGS) || (protocol==PROTO_BUGSMINI) || (protocol==PROTO_PROPEL) || (protocol==PROTO_OMP) || (protocol==PROTO_RLINK) || (protocol==PROTO_WFLY2) || (protocol==PROTO_LOLI) || (protocol==PROTO_MT99XX)
	#ifdef TELEMETRY_FRSKYX_TO_FRSKYD
		 || (protocol==PROTO_FRSKYX) || (protocol==PROTO_FRSKYX2)
	#endif
	 )
		initTXSerial( SPEED_9600 ) ;
	#ifndef TELEMETRY_FRSKYX_TO_FRSKYD
		if(protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2)
			initTXSerial( SPEED_57600 ) ;
	#endif
	if(protocol==PROTO_DSM)
		initTXSerial( SPEED_125K ) ;
}
#endif

// Convert 32b id to rx_tx_addr
static void set_rx_tx_addr(uint32_t id)
{ // Used by almost all protocols
	rx_tx_addr[0] = (id >> 24) & 0xFF;
	rx_tx_addr[1] = (id >> 16) & 0xFF;
	rx_tx_addr[2] = (id >>  8) & 0xFF;
	rx_tx_addr[3] = (id >>  0) & 0xFF;
	rx_tx_addr[4] = (rx_tx_addr[2]&0xF0)|(rx_tx_addr[3]&0x0F);
}

static uint32_t random_id(uint16_t address, uint8_t create_new)
{
	#ifndef FORCE_GLOBAL_ID
		uint32_t id=0;

		if(eeprom_read_byte((EE_ADDR)(address+10))==0xf0 && !create_new)
		{  // TXID exists in EEPROM
			for(uint8_t i=4;i>0;i--)
			{
				id<<=8;
				id|=eeprom_read_byte((EE_ADDR)address+i-1);
			}
			if(id!=0x2AD141A7)	//ID with seed=0
			{
				//debugln("Read ID from EEPROM");
				return id;
			}
		}
		// Generate a random ID
		#if defined STM32_BOARD
			#define STM32_UUID ((uint32_t *)0x1FFFF7E8)
			if (!create_new)
			{
				id = STM32_UUID[0] ^ STM32_UUID[1] ^ STM32_UUID[2];
				debugln("Generated ID from STM32 UUID");
			}
			else
		#endif
				id = random(0xfefefefe) + ((uint32_t)random(0xfefefefe) << 16);

		for(uint8_t i=0;i<4;i++)
			eeprom_write_byte((EE_ADDR)address+i,id >> (i*8));
		eeprom_write_byte((EE_ADDR)(address+10),0xf0);//write bind flag in eeprom.
		return id;
	#else
		(void)address;
		(void)create_new;
		return FORCE_GLOBAL_ID;
	#endif
}

// Generate frequency hopping sequence in the range [02..77]
static void __attribute__((unused)) calc_fh_channels(uint8_t num_ch)
{
	uint8_t idx = 0;
	uint32_t rnd = MProtocol_id;
	uint8_t max=(num_ch/3)+2;
	
	while (idx < num_ch)
	{
		uint8_t i;
		uint8_t count_2_26 = 0, count_27_50 = 0, count_51_74 = 0;

		rnd = rnd * 0x0019660D + 0x3C6EF35F; // Randomization
		// Use least-significant byte. 73 is prime, so channels 76..77 are unused
		uint8_t next_ch = ((rnd >> 8) % 73) + 2;
		// Keep a distance of 5 between consecutive channels
		if (idx !=0)
		{
			if(hopping_frequency[idx-1]>next_ch)
			{
				if(hopping_frequency[idx-1]-next_ch<5)
					continue;
			}
			else
				if(next_ch-hopping_frequency[idx-1]<5)
					continue;
		}
		// Check that it's not duplicated and spread uniformly
		for (i = 0; i < idx; i++) {
			if(hopping_frequency[i] == next_ch)
				break;
			if(hopping_frequency[i] <= 26)
				count_2_26++;
			else if (hopping_frequency[i] <= 50)
				count_27_50++;
			else
				count_51_74++;
		}
		if (i != idx)
			continue;
		if ( (next_ch <= 26 && count_2_26 < max) || (next_ch >= 27 && next_ch <= 50 && count_27_50 < max) || (next_ch >= 51 && count_51_74 < max) )
			hopping_frequency[idx++] = next_ch;//find hopping frequency
	}
}

static uint8_t __attribute__((unused)) bit_reverse(uint8_t b_in)
{
    uint8_t b_out = 0;
    for (uint8_t i = 0; i < 8; ++i)
	{
        b_out = (b_out << 1) | (b_in & 1);
        b_in >>= 1;
    }
    return b_out;
}

static void __attribute__((unused)) crc16_update(uint8_t a, uint8_t bits)
{
	crc ^= a << 8;
    while(bits--)
        if (crc & 0x8000)
            crc = (crc << 1) ^ crc16_polynomial;
		else
            crc = crc << 1;
}

static void __attribute__((unused)) crc8_update(uint8_t byte)
{
	crc8 = crc8 ^ byte;
	for ( uint8_t j = 0; j < 8; j++ )
		if ( crc8 & 0x80 )
			crc8 = (crc8<<1) ^ crc8_polynomial;
		else
			crc8 <<= 1;
}

/**************************/
/**************************/
/**  Interrupt routines  **/
/**************************/
/**************************/

//PPM
#ifdef ENABLE_PPM
	#ifdef ORANGE_TX
		#if PPM_pin == 2
			ISR(PORTD_INT0_vect)
		#else
			ISR(PORTD_INT1_vect)
		#endif
	#elif defined STM32_BOARD
		void PPM_decode()
	#else
		#if PPM_pin == 2
			ISR(INT0_vect, ISR_NOBLOCK)
		#else
			ISR(INT1_vect, ISR_NOBLOCK)
		#endif
	#endif
	{	// Interrupt on PPM pin
		static int8_t chan=0,bad_frame=1;
		static uint16_t Prev_TCNT1=0;
		uint16_t Cur_TCNT1;

		Cur_TCNT1 = TCNT1 - Prev_TCNT1 ;	// Capture current Timer1 value
		if(Cur_TCNT1<1600)
			bad_frame=1;					// bad frame
		else
			if(Cur_TCNT1>4400)
			{  //start of frame
				if(chan>=MIN_PPM_CHANNELS)
				{
					PPM_FLAG_on;			// good frame received if at least 4 channels have been seen
					if(chan>PPM_chan_max) PPM_chan_max=chan;	// Saving the number of channels received
				}
				chan=0;						// reset channel counter
				bad_frame=0;
			}
			else
				if(bad_frame==0)			// need to wait for start of frame
				{  //servo values between 800us and 2200us will end up here
					PPM_data[chan]=Cur_TCNT1;
					if(chan++>=MAX_PPM_CHANNELS)
						bad_frame=1;		// don't accept any new channels
				}
		Prev_TCNT1+=Cur_TCNT1;
	}
#endif //ENABLE_PPM

//Serial RX
#ifdef ENABLE_SERIAL
	#ifdef ORANGE_TX
		ISR(USARTC0_RXC_vect)
	#elif defined STM32_BOARD
		void __irq_usart2()			
	#else
		ISR(USART_RX_vect)
	#endif
	{	// RX interrupt
		#ifdef ORANGE_TX
			if((USARTC0.STATUS & 0x1C)==0)							// Check frame error, data overrun and parity error
		#elif defined STM32_BOARD
			if((USART2_BASE->SR & USART_SR_RXNE) && (USART2_BASE->SR &0x0F)==0)					
		#else
			UCSR0B &= ~_BV(RXCIE0) ;								// RX interrupt disable
			sei() ;
			if((UCSR0A&0x1C)==0)									// Check frame error, data overrun and parity error
		#endif
		{ // received byte is ok to process
			if(rx_idx==0||discard_frame==true)
			{	// Let's try to sync at this point
				RX_MISSED_BUFF_off;									// If rx_buff was good it's not anymore...
				rx_idx=0;discard_frame=false;
				rx_buff[0]=UDR0;
				#ifdef FAILSAFE_ENABLE
					if((rx_buff[0]&0xFC)==0x54)						// If 1st byte is 0x54, 0x55, 0x56 or 0x57 it looks ok
				#else
					if((rx_buff[0]&0xFE)==0x54)						// If 1st byte is 0x54 or 0x55 it looks ok
				#endif
				{
					#if defined STM32_BOARD
						TIMER3_BASE->CCR2=TIMER3_BASE->CNT + 500;	// Next byte should show up within 250us (1 byte = 120us)
						TIMER3_BASE->SR = 0x1E5F & ~TIMER_SR_CC2IF;	// Clear Timer3/Comp2 interrupt flag
						TIMER3_BASE->DIER |= TIMER_DIER_CC2IE;		// Enable Timer3/Comp2 interrupt
					#else
						TX_RX_PAUSE_on;
						tx_pause();
						cli();										// Disable global int due to RW of 16 bits registers
						OCR1B = TCNT1 + 500;						// Next byte should show up within 250us (1 byte = 120us)
						sei();										// Enable global int
						TIFR1 = OCF1B_bm ;							// clear OCR1B match flag
						SET_TIMSK1_OCIE1B ;							// enable interrupt on compare B match
					#endif
					rx_idx++;
				}
			}
			else
			{
				if(rx_idx>=RXBUFFER_SIZE)
				{
					discard_frame=true; 								// Too many bytes being received...
					debugln("RX frame too long");
				}
				else
				{
					rx_buff[rx_idx++]=UDR0;							// Store received byte
					#if defined STM32_BOARD
						TIMER3_BASE->CCR2=TIMER3_BASE->CNT + 500;	// Next byte should show up within 250us (1 byte = 120us)
					#else
						cli();										// Disable global int due to RW of 16 bits registers
						OCR1B = TCNT1 + 500;						// Next byte should show up within 250us (1 byte = 120us)
						sei();										// Enable global int
					#endif
				}
			}
		}
		else
		{
			rx_idx=UDR0;											// Dummy read
			rx_idx=0;
			discard_frame=true;										// Error encountered discard full frame...
			debugln("Bad frame RX");
		}
		if(discard_frame==true)
		{
			#ifdef STM32_BOARD
				TIMER3_BASE->DIER &= ~TIMER_DIER_CC2IE;				// Disable Timer3/Comp2 interrupt
			#else							
				CLR_TIMSK1_OCIE1B;									// Disable interrupt on compare B match
				TX_RX_PAUSE_off;
				tx_resume();
			#endif
		}
		#if not defined (ORANGE_TX) && not defined (STM32_BOARD)
			cli() ;
			UCSR0B |= _BV(RXCIE0) ;									// RX interrupt enable
		#endif
	}

	//Serial timer
	#ifdef ORANGE_TX
		ISR(TCC1_CCB_vect)
	#elif defined STM32_BOARD
		void ISR_COMPB()
	#else
		ISR(TIMER1_COMPB_vect)
	#endif
	{	// Timer1 compare B interrupt
		if(rx_idx>=26 && rx_idx<=RXBUFFER_SIZE)
		{
			// A full frame has been received
			if(!IS_RX_DONOTUPDATE_on)
			{ //Good frame received and main is not working on the buffer
				rx_len=rx_idx;
				memcpy((void*)rx_ok_buff,(const void*)rx_buff,rx_idx);	// Duplicate the buffer
				RX_FLAG_on;											// Flag for main to process data
			}
			else
				RX_MISSED_BUFF_on;									// Notify that rx_buff is good
			#ifdef MULTI_SYNC
				cli();
				last_serial_input=TCNT1;
				sei();
			#endif
		}
		#ifdef DEBUG_SERIAL
			else
				debugln("RX frame size incorrect");
		#endif
		discard_frame=true;
		#ifdef STM32_BOARD
			TIMER3_BASE->DIER &= ~TIMER_DIER_CC2IE;					// Disable Timer3/Comp2 interrupt
		#else
			CLR_TIMSK1_OCIE1B;										// Disable interrupt on compare B match
			TX_RX_PAUSE_off;
			tx_resume();
		#endif
	}
#endif //ENABLE_SERIAL

/**************************/
/**************************/
/**    CPPM  routines    **/
/**************************/
/**************************/
#ifdef SEND_CPPM
	#define PPM_CENTER 1500*2
	uint32_t TrainerTimer ;
	bool CppmInitialised = false;
	uint16_t *TrainerPulsePtr ;
	uint16_t TrainerPpmStream[10] ;
	int16_t CppmChannels[8] ;

	void setupTrainerPulses()
	{
		uint32_t i ;
		uint32_t total ;
		uint32_t pulse ;
		uint16_t *ptr ;
		uint32_t p = 8 ;
		int16_t PPM_range = 512*2 ;										//range of 0.7..1.7msec

		ptr = TrainerPpmStream ;

		total = 22500u*2;												//Minimum Framelen=22.5 ms

		if ( (millis() - TrainerTimer) < 400 )
		{
			for ( i = 0 ; i < p ; i += 1 )
			{
				pulse = max( (int)min(CppmChannels[i],PPM_range),-PPM_range) + PPM_CENTER ;

				total -= pulse ;
				*ptr++ = pulse ;
			}
		}
		*ptr++ = total ;
		*ptr = 0 ;
		TIMER1_BASE->CCR1 = total - 1500 ;								// Update time
		TIMER1_BASE->CCR2 = 300*2 ;
	}

	void init_trainer_ppm()
	{
		// Timer 1, channel 2 on PA9
		RCC_BASE->APB2ENR |= RCC_APB2ENR_TIM1EN ;						// Enable clock
		setupTrainerPulses() ;
		RCC_BASE->APB2ENR |= RCC_APB2ENR_IOPAEN ;						// Enable portA clock
		RCC_BASE->APB2ENR &= ~RCC_APB2ENR_USART1EN ;					// Disable USART1

		GPIOA_BASE->CRH &= ~0x00F0 ;
		GPIOA_BASE->CRH |= 0x00A0 ;										// AF PP OP2MHz

		HWTimer1.pause() ;												// Pause the timer1 while we're configuring it
		TIMER1_BASE->ARR = *TrainerPulsePtr++ ;
		TIMER1_BASE->PSC = 72000000  / 2000000 - 1 ;					// 0.5uS
		TIMER1_BASE->CCR2 = 600 ;										// 300 uS pulse
		TIMER1_BASE->CCR1 = 5000 ;										// 2500 uS pulse
		TIMER1_BASE->CCMR1 = 0x6000 ;									// PWM mode 1 (header file has incorrect bits)
		TIMER1_BASE->EGR = 1 ;
		TIMER1_BASE->CCER = TIMER_CCER_CC2E ;
		TIMER1_BASE->DIER |= TIMER_DIER_UIE ;
		TIMER1_BASE->CR1 = TIMER_CR1_CEN ;
		nvic_irq_set_priority(NVIC_TIMER1_CC, 4 ) ;
		nvic_irq_set_priority(NVIC_TIMER1_UP, 4 ) ;
		HWTimer1.attachInterrupt(TIMER_UPDATE_INTERRUPT,tim1_up);		// Assign function to Timer1/Comp2 interrupt
		HWTimer1.attachInterrupt(TIMER_CH1,tim1_cc);					// Assign function to Timer1/Comp2 interrupt

		CppmInitialised = true ;
		HWTimer1.resume() ;
	}

	void release_trainer_ppm()
	{
		if ( CppmInitialised )
		{
			TIMER1_BASE->CR1 = 0 ;
			pinMode(PA9,INPUT) ;
			CppmInitialised = false ;
		}
	}

	void tim1_up()
	{
		#define TIMER1_SR_MASK	0x1FFF
		// PPM out update interrupt
		if ( (TIMER1_BASE->DIER & TIMER_DIER_UIE) && ( TIMER1_BASE->SR & TIMER_SR_UIF ) )
		{
			GPIOA_BASE->BRR = 0x0200 ;
			TIMER1_BASE->SR = TIMER1_SR_MASK & ~TIMER_SR_UIF ; 			// Clear flag
			TIMER1_BASE->ARR = *TrainerPulsePtr++ ;
			if ( *TrainerPulsePtr == 0 )
			{
				TIMER1_BASE->SR = 0x1FFF & ~TIMER_SR_CC1IF ;			// Clear this flag
				TIMER1_BASE->DIER |= TIMER_DIER_CC1IE ;					// Enable this interrupt
				TIMER1_BASE->DIER &= ~TIMER_DIER_UIE ;					// Stop this interrupt
			}
		}
	}

	void tim1_cc()
	{
		if ( ( TIMER1_BASE->DIER & TIMER_DIER_CC1IE ) && ( TIMER1_BASE->SR & TIMER_SR_CC1IF ) )
		{
			// compare interrupt
			TIMER1_BASE->DIER &= ~TIMER_DIER_CC1IE ;					// Stop this interrupt
			TIMER1_BASE->SR = 0x1FFF & ~TIMER_SR_CC1IF ;				// Clear flag

			setupTrainerPulses() ;

			TrainerPulsePtr = TrainerPpmStream ;
			TIMER1_BASE->SR = 0x1FFF & ~TIMER_SR_UIF ;					// Clear this flag
			TIMER1_BASE->DIER |= TIMER_DIER_UIE ;						// Enable this interrupt
		}
	}

	void Send_CCPM_USART1()
	{
		if ( CppmInitialised == false )
			init_trainer_ppm() ;
		TrainerTimer = millis() ;
		len = packet_in[3] ;
		uint32_t bitsavailable = 0 ;
		uint32_t bits = 0 ; ;
		uint32_t i ;
		int16_t value ;
		uint8_t *packet ;
		packet = &packet_in[4] ;
		i = packet_in[2] ;	// Start channel
		// Load changed channels
		while ( len )
		{
			while ( bitsavailable < 11 )
			{
				bits |= *packet++ << bitsavailable ;
				bitsavailable += 8 ;
			}
			value = bits & 0x07FF ;
			value -= 0x0400 ;
			bitsavailable -= 11 ;
			bits >>= 11 ;
			if ( i < 8 )
				CppmChannels[i] = value * 5 / 4 ;
			i++ ;
			len-- ;
		}
	}
#endif	

/**************************/
/**************************/
/**    Arduino random    **/
/**************************/
/**************************/
#if not defined (ORANGE_TX) && not defined (STM32_BOARD)
	static void random_init(void)
	{
		cli();					// Temporarily turn off interrupts, until WDT configured
		MCUSR = 0;				// Use the MCU status register to reset flags for WDR, BOR, EXTR, and POWR
		WDTCSR |= _BV(WDCE);	// WDT control register, This sets the Watchdog Change Enable (WDCE) flag, which is  needed to set the prescaler
		WDTCSR = _BV(WDIE);		// Watchdog interrupt enable (WDIE)
		sei();					// Turn interupts on
	}

	static uint32_t random_value(void)
	{
		while (!gWDT_entropy);
		return gWDT_entropy;
	}

	// Random interrupt service routine called every time the WDT interrupt is triggered.
	// It is only enabled at startup to generate a seed.
	ISR(WDT_vect)
	{
		static uint8_t gWDT_buffer_position=0;
		#define gWDT_buffer_SIZE 32
		static uint8_t gWDT_buffer[gWDT_buffer_SIZE];
		gWDT_buffer[gWDT_buffer_position] = TCNT1L; // Record the Timer 1 low byte (only one needed) 
		gWDT_buffer_position++;                     // every time the WDT interrupt is triggered
		if (gWDT_buffer_position >= gWDT_buffer_SIZE)
		{
			// The following code is an implementation of Jenkin's one at a time hash
			for(uint8_t gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter)
			{
				gWDT_entropy += gWDT_buffer[gWDT_loop_counter];
				gWDT_entropy += (gWDT_entropy << 10);
				gWDT_entropy ^= (gWDT_entropy >> 6);
			}
			gWDT_entropy += (gWDT_entropy << 3);
			gWDT_entropy ^= (gWDT_entropy >> 11);
			gWDT_entropy += (gWDT_entropy << 15);
			WDTCSR = 0;	// Disable Watchdog interrupt
		}
	}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/A7105_SPI.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
/********************/
/** A7105 routines **/
/********************/
#ifdef A7105_INSTALLED
#include "iface_a7105.h"

void A7105_WriteData(uint8_t len, uint8_t channel)
{
	uint8_t i;
	A7105_CSN_off;
	SPI_Write(A7105_RST_WRPTR);
	SPI_Write(A7105_05_FIFO_DATA);
	for (i = 0; i < len; i++)
		SPI_Write(packet[i]);
	A7105_CSN_on;
	if(protocol!=PROTO_WFLY2)
	{
		if(!(protocol==PROTO_FLYSKY || (protocol==PROTO_KYOSHO && sub_protocol==KYOSHO_HYPE)))
		{
			A7105_Strobe(A7105_STANDBY);	//Force standby mode, ie cancel any TX or RX...
			A7105_SetTxRxMode(TX_EN);		//Switch to PA
		}
		A7105_WriteReg(A7105_0F_PLL_I, channel);
		A7105_Strobe(A7105_TX);
	}
}

void A7105_ReadData(uint8_t len)
{
	uint8_t i;
	A7105_Strobe(A7105_RST_RDPTR);
	A7105_CSN_off;
	SPI_Write(0x40 | A7105_05_FIFO_DATA);	//bit 6 =1 for reading
	for (i=0;i<len;i++)
		packet[i]=SPI_SDI_Read();
	A7105_CSN_on;
}

void A7105_WriteReg(uint8_t address, uint8_t data) {
	A7105_CSN_off;
	SPI_Write(address); 
	NOP();
	SPI_Write(data);  
	A7105_CSN_on;
} 

uint8_t A7105_ReadReg(uint8_t address)
{ 
	uint8_t result;
	A7105_CSN_off;
	SPI_Write(address |=0x40);				//bit 6 =1 for reading
	result = SPI_SDI_Read();  
	A7105_CSN_on;
	return(result); 
} 

//------------------------
void A7105_SetTxRxMode(uint8_t mode)
{
	if(mode == TX_EN)
	{
		A7105_WriteReg(A7105_0B_GPIO1_PIN1, 0x33);
		A7105_WriteReg(A7105_0C_GPIO2_PIN_II, 0x31);
	}
	else
		if (mode == RX_EN)
		{
			A7105_WriteReg(A7105_0B_GPIO1_PIN1, 0x31);
			A7105_WriteReg(A7105_0C_GPIO2_PIN_II, 0x33);
		}
		else
		{
			//The A7105 seems to some with a cross-wired power-amp (A7700)
			//On the XL7105-D03, TX_EN -> RXSW and RX_EN -> TXSW
			//This means that sleep mode is wired as RX_EN = 1 and TX_EN = 1
			//If there are other amps in use, we'll need to fix this
			A7105_WriteReg(A7105_0B_GPIO1_PIN1, 0x33);
			A7105_WriteReg(A7105_0C_GPIO2_PIN_II, 0x33);
		}
}

//------------------------
uint8_t A7105_Reset()
{
	uint8_t result;
	
	A7105_WriteReg(A7105_00_MODE, 0x00);
	delayMilliseconds(1);
	A7105_SetTxRxMode(TXRX_OFF);			//Set both GPIO as output and low
	result=A7105_ReadReg(A7105_10_PLL_II) == 0x9E;	//check if is reset.
	A7105_Strobe(A7105_STANDBY);
	return result;
}

void A7105_WriteID(uint32_t ida)
{
	A7105_CSN_off;
	SPI_Write(A7105_06_ID_DATA);			//ex id=0x5475c52a ;txid3txid2txid1txid0
	SPI_Write((ida>>24)&0xff);				//54 
	SPI_Write((ida>>16)&0xff);				//75
	SPI_Write((ida>>8)&0xff);				//c5
	SPI_Write((ida>>0)&0xff);				//2a
	A7105_CSN_on;
}

/*
static void A7105_SetPower_Value(int power)
{
	//Power amp is ~+16dBm so:
	//TXPOWER_100uW  = -23dBm == PAC=0 TBG=0
	//TXPOWER_300uW  = -20dBm == PAC=0 TBG=1
	//TXPOWER_1mW    = -16dBm == PAC=0 TBG=2
	//TXPOWER_3mW    = -11dBm == PAC=0 TBG=4
	//TXPOWER_10mW   = -6dBm  == PAC=1 TBG=5
	//TXPOWER_30mW   = 0dBm   == PAC=2 TBG=7
	//TXPOWER_100mW  = 1dBm   == PAC=3 TBG=7
	//TXPOWER_150mW  = 1dBm   == PAC=3 TBG=7
	uint8_t pac, tbg;
	switch(power) {
		case 0: pac = 0; tbg = 0; break;
		case 1: pac = 0; tbg = 1; break;
		case 2: pac = 0; tbg = 2; break;
		case 3: pac = 0; tbg = 4; break;
		case 4: pac = 1; tbg = 5; break;
		case 5: pac = 2; tbg = 7; break;
		case 6: pac = 3; tbg = 7; break;
		case 7: pac = 3; tbg = 7; break;
		default: pac = 0; tbg = 0; break;
	};
	A7105_WriteReg(0x28, (pac << 3) | tbg);
}
*/

void A7105_SetPower()
{
	uint8_t power=A7105_BIND_POWER;
	if(IS_BIND_DONE)
		#ifdef A7105_ENABLE_LOW_POWER
			power=IS_POWER_FLAG_on?A7105_HIGH_POWER:A7105_LOW_POWER;
		#else
			power=A7105_HIGH_POWER;
		#endif
	if(IS_RANGE_FLAG_on)
		power=A7105_RANGE_POWER;
	if(prev_power != power)
	{
		A7105_WriteReg(A7105_28_TX_TEST, power);
		prev_power=power;
	}
}

void A7105_Strobe(uint8_t address) {
	A7105_CSN_off;
	SPI_Write(address);
	A7105_CSN_on;
}

// Fine tune A7105 LO base frequency
// this is required for some A7105 modules and/or RXs with inaccurate crystal oscillator
void A7105_AdjustLOBaseFreq(uint8_t cmd)
{
	static int16_t old_offset=2048;
	int16_t offset=1024;
	if(cmd==0)
	{	// Called at init of the A7105
		old_offset=2048;
		switch(protocol)
		{
			case PROTO_HUBSAN:
				#ifdef FORCE_HUBSAN_TUNING
					offset=(int16_t)FORCE_HUBSAN_TUNING;
				#endif
				break;
			case PROTO_BUGS:
				#ifdef FORCE_BUGS_TUNING
					offset=(int16_t)FORCE_BUGS_TUNING;
				#endif
				break;
			case PROTO_FLYSKY:
				#ifdef FORCE_FLYSKY_TUNING
					offset=(int16_t)FORCE_FLYSKY_TUNING;
				#endif
				break;
			case PROTO_HEIGHT:
				#ifdef FORCE_HEIGHT_TUNING
					offset=(int16_t)FORCE_HEIGHT_TUNING;
				#endif
				break;
			case PROTO_PELIKAN:
				#ifdef FORCE_PELIKAN_TUNING
					offset=(int16_t)FORCE_PELIKAN_TUNING;
				#endif
				break;
			case PROTO_KYOSHO:
				#ifdef FORCE_KYOSHO_TUNING
					offset=(int16_t)FORCE_KYOSHO_TUNING;
				#endif
				break;
			case PROTO_JOYSWAY:
				#ifdef FORCE_JOYSWAY_TUNING
					offset=(int16_t)FORCE_JOYSWAY_TUNING;
				#endif
				break;
			case PROTO_WFLY2:
				#ifdef FORCE_WFLY2_TUNING
					offset=(int16_t)FORCE_WFLY2_TUNING;
				#endif
				break;
			case PROTO_AFHDS2A:
			case PROTO_AFHDS2A_RX:
				#ifdef FORCE_AFHDS2A_TUNING
					offset=(int16_t)FORCE_AFHDS2A_TUNING;
				#endif
				break;
		}
	}
	if(offset==1024)	// Use channel 15 as an input
		offset=convert_channel_16b_nolimit(CH15,-300,300,false);

	if(old_offset==offset)	// offset is the same as before...
			return;
	old_offset=offset;

	// LO base frequency = 32e6*(bip+(bfp/(2^16)))
	uint8_t bip;	// LO base frequency integer part
	uint16_t bfp;	// LO base frequency fractional part
	offset++;		// as per datasheet, not sure why recommended, but that's a +1kHz drift only ...
	offset<<=1;
	if(offset < 0)
	{
		bip = 0x4a;	// 2368 MHz
		bfp = 0xffff + offset;
	}
	else
	{
		bip = 0x4b;	// 2400 MHz (default)
		bfp = offset;
	}
	A7105_WriteReg( A7105_11_PLL_III, bip);
	A7105_WriteReg( A7105_12_PLL_IV, (bfp >> 8) & 0xff);
	A7105_WriteReg( A7105_13_PLL_V, bfp & 0xff);
	//debugln("Channel: %d, offset: %d, bip: %2x, bfp: %4x", Channel_data[14], offset, bip, bfp);
}

static void __attribute__((unused)) A7105_SetVCOBand(uint8_t vb1, uint8_t vb2)
{	// Set calibration band value to best match
	uint8_t diff1, diff2;

	if (vb1 >= 4)
		diff1 = vb1 - 4;
	else
		diff1 = 4 - vb1;

	if (vb2 >= 4)
		diff2 = vb2 - 4;
	else
		diff2 = 4 - vb2;

	if (diff1 == diff2 || diff1 > diff2)
		A7105_WriteReg(A7105_25_VCO_SBCAL_I, vb1 | 0x08);
	else
		A7105_WriteReg(A7105_25_VCO_SBCAL_I, vb2 | 0x08);
}

#if defined(AFHDS2A_A7105_INO) || defined(AFHDS2A_RX_A7105_INO)
const uint8_t PROGMEM AFHDS2A_A7105_regs[] = {
	0xFF, 0x42 | (1<<5), 0x00, 0x25, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3c, 0x05, 0x00, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x4f, 0x62, 0x80, 0xFF, 0xFF, 0x2a, 0x32, 0xc3, 0x1f,				// 10 - 1f
	0x1e, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x3b, 0x00, 0x17, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,				// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef BUGS_A7105_INO
const uint8_t PROGMEM BUGS_A7105_regs[] = {
	0xFF, 0x42, 0x00, 0x15, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x05, 0x01, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x40, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0xc3, 0x0f,	// 10 - 1f
	0x16, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x3b, 0x00, 0x0b, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef FLYSKY_A7105_INO
const uint8_t PROGMEM FLYSKY_A7105_regs[] = {
	0xff, 0x42, 0x00, 0x14, 0x00, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x05, 0x00, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x00, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0xc3, 0x0f,	// 10 - 1f
	0x13, 0xc3, 0x00, 0xff, 0x00, 0x00, 0x3b, 0x00, 0x17, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef HEIGHT_A7105_INO
const uint8_t PROGMEM HEIGHT_A7105_regs[] = {
	0xff, 0x42, 0x00, 0x07, 0x00, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x05, 0x01, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x00, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0xc3, 0x1f,	// 10 - 1f
	0x12, 0x00, 0x00, 0xff, 0x00, 0x00, 0x3a, 0x00, 0x3f, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef HUBSAN_A7105_INO
const uint8_t PROGMEM HUBSAN_A7105_regs[] = {
	0xFF, 0x63, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF ,0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x04, 0xFF,	// 00 - 0f
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2B, 0xFF, 0xFF, 0x62, 0x80, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0x07,	// 10 - 1f
	0x17, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	// 20 - 2f
	0xFF, 0xFF // 30 - 31
};
#endif
#ifdef PELIKAN_A7105_INO
const uint8_t PROGMEM PELIKAN_A7105_regs[] = {
	0xff, 0x42, 0x00, 0x0F, 0x00, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x05, 0x01, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x00, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0xc3, 0x07,	// 10 - 1f
	0x16, 0x00, 0x00, 0xff, 0x00, 0x00, 0x3b, 0x00, 0x1f, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef KYOSHO_A7105_INO
const uint8_t PROGMEM KYOSHO_A7105_regs[] = {
	0xff, 0x42, 0xff, 0x25, 0x00, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x05, 0x00, 0x50,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x40, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0x03, 0x1f,	// 10 - 1f
	0x1e, 0x00, 0x00, 0xff, 0x00, 0x00, 0x23, 0x70, 0x1F, 0x47, 0x80, 0x57, 0x01, 0x45, 0x19, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
const uint8_t PROGMEM KYOSHO_HYPE_A7105_regs[] = {
	0xff, 0x42, 0x00, 0x10, 0xC0, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x01, 0x09, 0x05, 0x01, 0x04,	// 00 - 0f
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x00, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x96, 0xc2, 0x1f,	// 10 - 1f
	0x12, 0x00, 0x00, 0xff, 0x00, 0x00, 0x3a, 0x00, 0x17, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef WFLY2_A7105_INO //A7106 values
const uint8_t PROGMEM WFLY2_A7105_regs[] = {
	0xff, 0x62, 0xff, 0x1F, 0x40, 0xff, 0xff ,0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x05, 0x00, 0x64,	// 00 - 0f Changes: 0B:19->33, 0C:01,33
	0x9e, 0x4b, 0x00, 0x02, 0x16, 0x2b, 0x12, 0x40, 0x62, 0x80, 0x80, 0x00, 0x0a, 0x32, 0x03, 0x0f,	// 10 - 1f 1C:4A->0A
	0x12, 0x00, 0x00, 0xff, 0x00, 0x00, 0x23, 0x70, 0x15, 0x47, 0x80, 0x03, 0x01, 0x45, 0x18, 0x00,	// 20 - 2f 2B:77->03, 2E:19->18
	0x01, 0x0f // 30 - 31
};
#endif
#ifdef JOYSWAY_A7105_INO
const uint8_t PROGMEM JOYSWAY_A7105_regs[] = {
	0xff, 0x62, 0xff, 0x0F, 0x00, 0xff, 0xff ,0x00, 0x00, 0x05, 0x00, 0x01, 0x00, 0xF5, 0x00, 0x15,	// 00 - 0f
	0x9E, 0x4B, 0x00, 0x03, 0x56, 0x2B, 0x12, 0x4A, 0x02, 0x80, 0x80, 0x00, 0x0E, 0x91, 0x03, 0x0F,	// 10 - 1f
	0x16, 0x2A, 0x00, 0xff, 0xff, 0xff, 0x3A, 0x06, 0x1F, 0x47, 0x80, 0x01, 0x05, 0x45, 0x18, 0x00,	// 20 - 2f
	0x01, 0x0f // 30 - 31
};
#endif

#define ID_NORMAL 0x55201041
#define ID_PLUS   0xAA201041
void A7105_Init(void)
{
	uint8_t *A7105_Regs=0;
    uint8_t vco_calibration0, vco_calibration1;
	
	#ifdef JOYSWAY_A7105_INO
		if(protocol==PROTO_JOYSWAY)
		{
			A7105_Regs=(uint8_t*)JOYSWAY_A7105_regs;
		}
		else
	#endif
	#ifdef WFLY2_A7105_INO
		if(protocol==PROTO_WFLY2)
		{
			A7105_Regs=(uint8_t*)WFLY2_A7105_regs;
		}
		else
	#endif
	#ifdef HEIGHT_A7105_INO
		if(protocol==PROTO_HEIGHT)
		{
			A7105_Regs=(uint8_t*)HEIGHT_A7105_regs;
			A7105_WriteID(0x25A53C45);
		}
		else
	#endif
	#ifdef PELIKAN_A7105_INO
		if(protocol==PROTO_PELIKAN)
		{
			A7105_Regs=(uint8_t*)PELIKAN_A7105_regs;
			A7105_WriteID(0x06230623);
		}
		else
	#endif
	#ifdef BUGS_A7105_INO
		if(protocol==PROTO_BUGS)
			A7105_Regs=(uint8_t*)BUGS_A7105_regs;
		else
	#endif
	#ifdef HUBSAN_A7105_INO
		if(protocol==PROTO_HUBSAN)
		{
			A7105_WriteID(ID_NORMAL);
			A7105_Regs=(uint8_t*)HUBSAN_A7105_regs;
		}
		else
	#endif
		{
			A7105_WriteID(0x5475c52A);//0x2Ac57554
			#ifdef FLYSKY_A7105_INO
				if(protocol==PROTO_FLYSKY)
					A7105_Regs=(uint8_t*)FLYSKY_A7105_regs;
			#endif
			#if defined(AFHDS2A_A7105_INO) || defined(AFHDS2A_RX_A7105_INO)
				if(protocol==PROTO_AFHDS2A || protocol==PROTO_AFHDS2A_RX)
					A7105_Regs=(uint8_t*)AFHDS2A_A7105_regs;
			#endif
			#ifdef KYOSHO_A7105_INO
				if(protocol==PROTO_KYOSHO)
				{
					if(sub_protocol==KYOSHO_HYPE)
						A7105_Regs=(uint8_t*)KYOSHO_HYPE_A7105_regs;
					else //FHSS && SYNCRO
						A7105_Regs=(uint8_t*)KYOSHO_A7105_regs;
				}
			#endif
		}

	for (uint8_t i = 0; i < 0x32; i++)
	{
		uint8_t val=pgm_read_byte_near(&A7105_Regs[i]);
		#ifdef FLYSKY_A7105_INO
			if(protocol==PROTO_FLYSKY && sub_protocol==CX20)
			{
				if(i==0x0E) val=0x01;
				if(i==0x1F) val=0x1F;
				if(i==0x20) val=0x1E;
			}
		#endif
		#ifdef HEIGHT_A7105_INO
			if(protocol==PROTO_HEIGHT && sub_protocol==HEIGHT_8CH)
				if(i==0x03) val=0x0A;
		#endif
		if( val != 0xff)
			A7105_WriteReg(i, val);
	}
	A7105_Strobe(A7105_STANDBY);

	if(protocol==PROTO_KYOSHO && sub_protocol!=KYOSHO_HYPE)
	{//strange calibration...
		//IF Filter Bank Calibration
		A7105_WriteReg(A7105_02_CALC,0x0F);
		while(A7105_ReadReg(A7105_02_CALC));			// Wait for calibration to end
	//	A7105_ReadReg(A7105_22_IF_CALIB_I);
	//	A7105_ReadReg(A7105_24_VCO_CURCAL);
	//	A7105_ReadReg(25_VCO_SBCAL_I);
	//	A7105_ReadReg(1A_RX_GAIN_II);
	//	A7105_ReadReg(1B_RX_GAIN_III);
	}
	else
	{
		//IF Filter Bank Calibration
		A7105_WriteReg(A7105_02_CALC,1);
		while(A7105_ReadReg(A7105_02_CALC));			// Wait for calibration to end
	//	A7105_ReadReg(A7105_22_IF_CALIB_I);
	//	A7105_ReadReg(A7105_24_VCO_CURCAL);

		if(protocol!=PROTO_HUBSAN)
		{
			//VCO Current Calibration
			A7105_WriteReg(A7105_24_VCO_CURCAL,0x13);	//Recommended calibration from A7105 Datasheet
			//VCO Bank Calibration
			A7105_WriteReg(A7105_26_VCO_SBCAL_II,0x3b);	//Recommended calibration from A7105 Datasheet
		}

		//VCO Bank Calibrate channel 0
		A7105_WriteReg(A7105_0F_CHANNEL, 0);
		A7105_WriteReg(A7105_02_CALC,2);
		while(A7105_ReadReg(A7105_02_CALC));			// Wait for calibration to end
		vco_calibration0 = A7105_ReadReg(A7105_25_VCO_SBCAL_I);
		
		//VCO Bank Calibrate channel A0
		A7105_WriteReg(A7105_0F_CHANNEL, 0xa0);
		A7105_WriteReg(A7105_02_CALC, 2);
		while(A7105_ReadReg(A7105_02_CALC));			// Wait for calibration to end
		vco_calibration1 = A7105_ReadReg(A7105_25_VCO_SBCAL_I);

		if(protocol==PROTO_BUGS || protocol==PROTO_WFLY2)
			A7105_SetVCOBand(vco_calibration0 & 0x07, vco_calibration1 & 0x07);	// Set calibration band value to best match
		else
			if(protocol!=PROTO_HUBSAN)
			{
				switch(protocol)
				{
					case PROTO_FLYSKY:
						vco_calibration1=0x08;
						break;
					case PROTO_HEIGHT:
						vco_calibration1=0x02;
						break;
					case PROTO_PELIKAN:
						if(sub_protocol == PELIKAN_SCX24)
						{
							vco_calibration1=0x0A;
							break;
						}
					case PROTO_KYOSHO: //sub_protocol Hype
						vco_calibration1=0x0C;
						break;
					case PROTO_JOYSWAY:
						vco_calibration1=0x09;
						break;
					default:
						vco_calibration1=0x0A;
						break;
				}
				A7105_WriteReg(A7105_25_VCO_SBCAL_I,vco_calibration1);	//Reset VCO Band calibration
			}
	}
	A7105_SetTxRxMode(TX_EN);
	A7105_SetPower();

	#ifdef USE_A7105_CH15_TUNING
		A7105_AdjustLOBaseFreq(0);
	#endif
	
	A7105_Strobe(A7105_STANDBY);
}
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_Rx_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(AFHDS2A_RX_A7105_INO)

#include "iface_a7105.h" 

#define AFHDS2A_RX_TXPACKET_SIZE	38
#define AFHDS2A_RX_RXPACKET_SIZE	37
#define AFHDS2A_RX_NUMFREQ			16

enum {
	AFHDS2A_RX_BIND1,
	AFHDS2A_RX_BIND2,
	AFHDS2A_RX_BIND3,
	AFHDS2A_RX_DATA
};

static void __attribute__((unused)) AFHDS2A_RX_build_telemetry_packet()
{
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	uint8_t idx = 0;

	packet_in[idx++] = RX_LQI; // 0 - 130
	packet_in[idx++] = RX_RSSI;
	packet_in[idx++] = 0; // start channel
	packet_in[idx++] = 14; // number of channels in packet
	// pack channels
	for (uint8_t i = 0; i < 14; i++) {
		uint32_t val = packet[9+i*2] | (((packet[10+i*2])&0x0F) << 8);
		if (val < 860)
			val = 860;
		// convert ppm (860-2140) to Multi (0-2047)
		val = min(((val-860)<<3)/5, 2047);

		bits |= val << bitsavailable;
		bitsavailable += 11;
		while (bitsavailable >= 8) {
			packet_in[idx++] = bits & 0xff;
			bits >>= 8;
			bitsavailable -= 8;
		}
	}
}

static uint8_t __attribute__((unused)) AFHDS2A_RX_data_ready()
{
	// check if FECF+CRCF Ok
	return !(A7105_ReadReg(A7105_00_MODE) & (1 << 5 | 1 << 6 | 1 << 0));
}

void AFHDS2A_RX_init()
{
	uint8_t i;
	A7105_Init();
	hopping_frequency_no = 0;
	packet_count = 0;
	rx_data_started = false;
	rx_disable_lna = IS_POWER_FLAG_on;
	A7105_SetTxRxMode(rx_disable_lna ? TXRX_OFF : RX_EN);
	A7105_Strobe(A7105_RX);

	if (IS_BIND_IN_PROGRESS) {
		phase = AFHDS2A_RX_BIND1;
	}
	else {
		uint16_t temp = AFHDS2A_RX_EEPROM_OFFSET;
		for (i = 0; i < 4; i++)
			rx_id[i] = eeprom_read_byte((EE_ADDR)temp++);
		for (i = 0; i < AFHDS2A_RX_NUMFREQ; i++)
			hopping_frequency[i] = eeprom_read_byte((EE_ADDR)temp++);
		phase = AFHDS2A_RX_DATA;
	}
}

#define AFHDS2A_RX_WAIT_WRITE 0x80

uint16_t AFHDS2A_RX_callback()
{
	static int8_t read_retry;
	int16_t temp;
	uint8_t i;

#ifndef FORCE_AFHDS2A_TUNING
	A7105_AdjustLOBaseFreq(1);
#endif
	if (rx_disable_lna != IS_POWER_FLAG_on) {
		rx_disable_lna = IS_POWER_FLAG_on;
		A7105_SetTxRxMode(rx_disable_lna ? TXRX_OFF : RX_EN);
	}

	switch(phase) {
	case AFHDS2A_RX_BIND1:
		if(IS_BIND_DONE)
		{
			AFHDS2A_RX_init();	// Abort bind
			break;
		}
		debugln("bind p=%d", phase+1);
		if (AFHDS2A_RX_data_ready()) {
			A7105_ReadData(AFHDS2A_RX_TXPACKET_SIZE);
			if ((packet[0] == 0xbb && packet[9] == 0x01) ||	(packet[0] == 0xbc && packet[9] <= 0x02)) {
				memcpy(rx_id, &packet[1], 4); // TX id actually
				memcpy(hopping_frequency, &packet[11], AFHDS2A_RX_NUMFREQ);
				phase = AFHDS2A_RX_BIND2;
				debugln("phase bind2");
			}
		}
		A7105_WriteReg(A7105_0F_PLL_I, (packet_count++ & 1) ? 0x0D : 0x8C); // bind channels
		A7105_Strobe(A7105_RX);
		return 10000;

	case AFHDS2A_RX_BIND2:
		if(IS_BIND_DONE)
		{
			AFHDS2A_RX_init();	// Abort bind
			break;
		}
		// got 2nd bind packet from tx ?
		if (AFHDS2A_RX_data_ready()) {
			A7105_ReadData(AFHDS2A_RX_TXPACKET_SIZE);
			if ((packet[0] == 0xBC && packet[9] == 0x02 && packet[10] == 0x00) &&
				(memcmp(rx_id, &packet[1], 4) == 0) &&
				(memcmp(rx_tx_addr, &packet[5], 4) == 0)) {
				// save tx info to eeprom
				temp = AFHDS2A_RX_EEPROM_OFFSET;
				for (i = 0; i < 4; i++)
					eeprom_write_byte((EE_ADDR)temp++, rx_id[i]);
				for (i = 0; i < AFHDS2A_RX_NUMFREQ; i++)
					eeprom_write_byte((EE_ADDR)temp++, hopping_frequency[i]);
				phase = AFHDS2A_RX_BIND3;
				debugln("phase bind3");
				packet_count = 0;
			}
		}

	case AFHDS2A_RX_BIND3:
		debugln("bind p=%d", phase+1);
		// transmit response packet
		packet[0] = 0xBC;
		memcpy(&packet[1], rx_id, 4);
		memcpy(&packet[5], rx_tx_addr, 4);
		//packet[9] = 0x01;
		packet[10] = 0x00;
		memset(&packet[11], 0xFF, 26);
		A7105_SetTxRxMode(TX_EN);
		rx_disable_lna = !IS_POWER_FLAG_on;
		A7105_WriteData(AFHDS2A_RX_RXPACKET_SIZE, packet_count++ & 1 ? 0x0D : 0x8C);
		if(phase == AFHDS2A_RX_BIND3 && packet_count > 20)
		{
			debugln("done");
			BIND_DONE;
			AFHDS2A_RX_init();	// Restart protocol
			break;
		}
		phase |= AFHDS2A_RX_WAIT_WRITE;
		return 1700;
	
	case AFHDS2A_RX_BIND2 | AFHDS2A_RX_WAIT_WRITE:
		//Wait for TX completion
		pps_timer = micros();
		while ((uint32_t)(micros() - pps_timer) < 700) // Wait max 700s, using serial+telemetry exit in about 120s
			if (!(A7105_ReadReg(A7105_00_MODE) & 0x01))
				break;
		A7105_Strobe(A7105_RX);
	case AFHDS2A_RX_BIND3 | AFHDS2A_RX_WAIT_WRITE:
		phase &= ~AFHDS2A_RX_WAIT_WRITE;
		return 10000;
	
	case AFHDS2A_RX_DATA:
		if (AFHDS2A_RX_data_ready()) {
			A7105_ReadData(AFHDS2A_RX_TXPACKET_SIZE);
			if (memcmp(&packet[1], rx_id, 4) == 0 && memcmp(&packet[5], rx_tx_addr, 4) == 0)
			{
				#if 0
					//if(packet[0] == 0xAA)
					{
						for(uint8_t i=0;i<AFHDS2A_RX_TXPACKET_SIZE;i++)
							debug(" %02X",packet[i]);
						debugln("");
					}
				#endif
				if (packet[0] == 0x58 && packet[37] == 0x00 && (telemetry_link&0x7F) == 0)
				{ // standard packet, send channels to TX
					int rssi = min(A7105_ReadReg(A7105_1D_RSSI_THOLD),160);
					RX_RSSI = map16b(rssi, 160, 8, 0, 128);
					AFHDS2A_RX_build_telemetry_packet();
					telemetry_link = 1;
					#ifdef SEND_CPPM
						if(sub_protocol>0)
							telemetry_link |= 0x80;	// Disable telemetry output
					#endif
				}
				rx_data_started = true;
				read_retry = 10; // hop to next channel
				pps_counter++;
			}
		}
		
		// packets per second
		if (millis() - pps_timer >= 1000) {
			pps_timer = millis();
			debugln("%d pps", pps_counter);
			RX_LQI = pps_counter / 2;
			pps_counter = 0;
		}

		// frequency hopping
		if (read_retry++ >= 10) {
			hopping_frequency_no++;
			if(hopping_frequency_no >= AFHDS2A_RX_NUMFREQ)
				hopping_frequency_no = 0;
			A7105_WriteReg(A7105_0F_PLL_I, hopping_frequency[hopping_frequency_no]);
			A7105_Strobe(A7105_RX);
			if (rx_data_started)
				read_retry = 0;
			else
				read_retry = -127; // retry longer until first packet is catched
		}
		return 385;
	}
	return 3850; // never reached
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/AFHDS2A_a7105.ino"
 /*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/flysky_a7105.c dated 2015-09-28

#ifdef AFHDS2A_A7105_INO

#define AFHDS2A_TXPACKET_SIZE	38
#define AFHDS2A_RXPACKET_SIZE	37
#define AFHDS2A_NUMFREQ			16

#if not defined TELEMETRY
	uint8_t RX_LQI=0;
#endif

enum{
	AFHDS2A_PACKET_STICKS,
	AFHDS2A_PACKET_SETTINGS,
	AFHDS2A_PACKET_FAILSAFE,
};

enum{
	AFHDS2A_BIND1,
	AFHDS2A_BIND2,
	AFHDS2A_BIND3,
	AFHDS2A_BIND4,
	AFHDS2A_DATA_INIT,
	AFHDS2A_DATA,
};

static void AFHDS2A_calc_channels()
{
	uint8_t idx = 0;
	uint32_t rnd = MProtocol_id;
	while (idx < AFHDS2A_NUMFREQ)
	{
		uint8_t i;
		uint8_t band_no = ((((idx<<1) | ((idx>>1) & 0b01)) + rx_tx_addr[3]) & 0b11);
		rnd = rnd * 0x0019660D + 0x3C6EF35F; // Randomization

		uint8_t next_ch = band_no*41 + 1 + ((rnd >> idx) % 41); // Channel range: 1..164

		for (i = 0; i < idx; i++)
		{
			// Keep the distance 5 between the channels 
			uint8_t distance;
			if (next_ch > hopping_frequency[i])
				distance = next_ch - hopping_frequency[i];
			else
				distance = hopping_frequency[i] - next_ch;

			if (distance < 5) break;
		}

		if (i != idx) continue;

		hopping_frequency[idx++] = next_ch;
	}
}

// telemetry sensors ID
enum{
	AFHDS2A_SENSOR_RX_VOLTAGE   = 0x00,
	AFHDS2A_SENSOR_RX_ERR_RATE  = 0xfe,
	AFHDS2A_SENSOR_RX_RSSI      = 0xfc,
	AFHDS2A_SENSOR_RX_NOISE     = 0xfb,
	AFHDS2A_SENSOR_RX_SNR       = 0xfa,
	AFHDS2A_SENSOR_A3_VOLTAGE   = 0x03,
};

#if defined(AFHDS2A_FW_TELEMETRY) || defined(AFHDS2A_HUB_TELEMETRY)
static void AFHDS2A_update_telemetry()
{
	// Read TX RSSI
	int16_t temp=256-(A7105_ReadReg(A7105_1D_RSSI_THOLD)*8)/5;		// value from A7105 is between 8 for maximum signal strength to 160 or less
	if(temp<0) temp=0;
	else if(temp>255) temp=255;
	TX_RSSI=temp;
	// AA | TXID | rx_id | sensor id | sensor # | value 16 bit big endian | sensor id ......
	// AC | TXID | rx_id | sensor id | sensor # | length | bytes | sensor id ......
	#ifdef AFHDS2A_FW_TELEMETRY
		if (option & 0x80)
		{// forward 0xAA and 0xAC telemetry to TX, skip rx and tx id to save space
			packet_in[0]= TX_RSSI;
			#if 0
				debug("T(%02X)=",packet[0]);
				for(uint8_t i=9;i < AFHDS2A_RXPACKET_SIZE; i++)
					debug(" %02X",packet[i]);
				debugln("");
			#endif
			for(uint8_t i=9;i < AFHDS2A_RXPACKET_SIZE; i++)
				packet_in[i-8]=packet[i];
			packet_in[29]=packet[0];	// 0xAA Normal telemetry, 0xAC Extended telemetry
			telemetry_link=2;
			return;
		}
	#endif
	#ifdef AFHDS2A_HUB_TELEMETRY
		if(packet[0]==0xAA)
		{ // 0xAA Normal telemetry, 0xAC Extended telemetry not decoded here
			for(uint8_t sensor=0; sensor<7; sensor++)
			{
				// Send FrSkyD telemetry to TX
				uint8_t index = 9+(4*sensor);
				switch(packet[index])
				{
					case AFHDS2A_SENSOR_RX_VOLTAGE:
						//v_lipo1 = packet[index+3]<<8 | packet[index+2];
						v_lipo1 = packet[index+2];
						telemetry_link=1;
						break;
					case AFHDS2A_SENSOR_A3_VOLTAGE:
						v_lipo2 = (packet[index+3]<<5) | (packet[index+2]>>3);	// allows to read voltage up to 4S
						telemetry_link=1;
						break;
					case AFHDS2A_SENSOR_RX_ERR_RATE:
						if(packet[index+2]<=100)
							RX_LQI=packet[index+2];
						break;
					case AFHDS2A_SENSOR_RX_RSSI:
						RX_RSSI = -packet[index+2];
						break;
					case 0xff: // end of data
						return;
					/*default:
						// unknown sensor ID
						break;*/
				}
			}
		}
	#endif
}
#endif

static void AFHDS2A_build_bind_packet()
{
	uint8_t ch;
	memcpy( &packet[1], rx_tx_addr, 4);
	memset( &packet[5], 0xff, 4);
	packet[10]= 0x00;
	for(ch=0; ch<AFHDS2A_NUMFREQ; ch++)
		packet[11+ch] = hopping_frequency[ch];
	memset( &packet[27], 0xff, 10);
	packet[37] = 0x00;
	switch(phase)
	{
		case AFHDS2A_BIND1:
			packet[0] = 0xbb;
			packet[9] = 0x01;
			break;
		case AFHDS2A_BIND2:
		case AFHDS2A_BIND3:
		case AFHDS2A_BIND4:
			packet[0] = 0xbc;
			if(phase == AFHDS2A_BIND4)
			{
				memcpy( &packet[5], &rx_id, 4);
				memset( &packet[11], 0xff, 16);
			}
			packet[9] = phase-1;
			if(packet[9] > 0x02)
				packet[9] = 0x02;
			packet[27]= 0x01;
			packet[28]= 0x80;
			break;
	}
}

static void AFHDS2A_build_packet(uint8_t type)
{
	uint16_t val;
	memcpy( &packet[1], rx_tx_addr, 4);
	memcpy( &packet[5], rx_id, 4);
	switch(type)
	{
		case AFHDS2A_PACKET_STICKS:		
			packet[0] = 0x58;
			//16 channels + RX_LQI on channel 17
			for(uint8_t ch=0; ch<17; ch++)
			{
				val = convert_channel_ppm(sub_protocol<AFHDS2A_GYRO_OFF?CH_AETR[ch]:ch);	// No remapping for BS receivers
				if(ch<14)
				{
					packet[9 +  ch*2] = val;
					packet[10 + ch*2] = (val>>8)&0x0F;
				}
				else
				{
					if(ch == 16)	//CH17=RX_LQI
						val = 2000 - 10*RX_LQI;
					packet[10 + (ch-14)*6] |= (val)<<4;
					packet[12 + (ch-14)*6] |= (val)&0xF0;
					packet[14 + (ch-14)*6] |= (val>>4)&0xF0;
				}
			}
			{
				uint8_t next_hop = (hopping_frequency_no+1)&0x0F;
				packet[34] |= next_hop<<4;
				packet[36] |= next_hop?0x80:0x90;
			}
			break;
		case AFHDS2A_PACKET_FAILSAFE:
			packet[0] = 0x56;
			for(uint8_t ch=0; ch<16; ch++)
			{ // Failsafe values
				#ifdef FAILSAFE_ENABLE
					val = Failsafe_data[protocol==PROTO_AFHDS2A?CH_AETR[ch]:ch];	// No remapping for BS receivers
					if(val!=FAILSAFE_CHANNEL_HOLD && val!=FAILSAFE_CHANNEL_NOPULSES)
						val = (((val<<2)+val)>>3)+860;
					else
				#endif
						val = 0x0FFF;
				if(ch<14)
				{
					packet[9 +  ch*2] = val;
					packet[10 + ch*2] = (val>>8)&0x0F;
				}
				else
				{
					packet[10 + (ch-14)*6] |= (val)<<4;
					packet[12 + (ch-14)*6] |= (val)&0xF0;
					packet[14 + (ch-14)*6] |= (val>>4)&0xF0;
				}
			}
			break;
		case AFHDS2A_PACKET_SETTINGS:
			packet[0] = 0xaa;
			packet[9] = 0xfd;
			packet[10]= 0xff;
			val=5*(option & 0x7f)+50;	// option value should be between 0 and 70 which gives a value between 50 and 400Hz
			if(val<50 || val>400) val=50;	// default is 50Hz
			packet[11]= val;
			packet[12]= val >> 8;
			memset(&packet[15],0xFF,22);
#ifndef MULTI_AIR
			if(sub_protocol < AFHDS2A_GYRO_OFF)
			{
#endif
				packet[13] = sub_protocol & 0x01;	// 1 -> PPM output enabled
				packet[14] = 0x00;		// ?
				packet[18] = 0x05;		// ?
				packet[19] = 0xdc;		// ?
				packet[20] = 0x05;		// ?
				if(sub_protocol&2)
					packet[21] = 0xdd;	// SBUS output enabled
				else
					packet[21] = 0xde;	// IBUS
#ifndef MULTI_AIR
			}
			else
			{//BS receivers
				if(sub_protocol == AFHDS2A_GYRO_OFF)
				{
					memset(&packet[15],0x00,4);
					packet[22] = 0xFC;	// ?
				}
				else
				{//AFHDS2A_GYRO_ON & AFHDS2A_GYRO_ON_REV
					packet[15] = convert_channel_16b_limit(CH13,0,100);	// ST Gain
					packet[16] = convert_channel_16b_limit(CH14,0,100);	// TH Gain
					packet[17] = convert_channel_16b_limit(CH15,0,100);	// Priority
					if(sub_protocol == AFHDS2A_GYRO_ON_REV)
						packet[17] |= 0x80;								// Reverse
					packet[18] = CH16_SW?(0x32|0x80):0x32;				// Calib|50?
					packet[19] = 0x64;									// 100?
					packet[20] = 0x64;									// 100?
					packet[22] = 0xFE;									// ?
				}
			}
#endif
			break;
	}
	packet[37] = 0x00;
}

#define AFHDS2A_WAIT_WRITE 0x80

#ifdef STM32_BOARD
	#define AFHDS2A_WRITE_TIME 1550
#else
	#define AFHDS2A_WRITE_TIME 1700
#endif

uint16_t AFHDS2A_callback()
{
	static uint8_t packet_type;
	static uint16_t packet_counter;
	uint8_t data_rx=0;
	uint16_t start;
	#ifndef MULTI_AIR
		static uint16_t Prev_Channel[4] = { 0,0,0,0 };
	#endif
	#ifndef FORCE_AFHDS2A_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	switch(phase)
	{
		case AFHDS2A_BIND1:
		case AFHDS2A_BIND2:
		case AFHDS2A_BIND3:
			AFHDS2A_build_bind_packet();
			data_rx=A7105_ReadReg(A7105_00_MODE);			// Check if something has been received...
			A7105_WriteData(AFHDS2A_TXPACKET_SIZE, packet_count%2 ? 0x0d : 0x8c);
			if(!(A7105_ReadReg(A7105_00_MODE) & (1<<5)) && !(data_rx & 1))	// removed FECF check due to issues with fs-x6b ->  & (1<<5 | 1<<6)
			{ // RX+CRCF Ok
				A7105_ReadData(AFHDS2A_RXPACKET_SIZE);
				#if 0
					debug("RX");
					for(uint8_t i=0; i<AFHDS2A_RXPACKET_SIZE ; i++)
						debug(" %02X", packet[i]);
					debugln("");
				#endif
				if(packet[0] == 0xbc && packet[9] == 0x01)
				{
					uint16_t addr;
					if(RX_num<16)
						addr=AFHDS2A_EEPROM_OFFSET+RX_num*4;
					else
						addr=AFHDS2A_EEPROM_OFFSET2+(RX_num-16)*4;
					for(uint8_t i=0; i<4; i++)
					{
						rx_id[i] = packet[5+i];
						eeprom_write_byte((EE_ADDR)(addr+i),rx_id[i]);
					}
					phase = AFHDS2A_BIND4;
					packet_count++;
					break;
				}
			}
			packet_count++;
			if(IS_BIND_DONE)
			{ // exit bind if asked to do so from the GUI
				phase = AFHDS2A_BIND4;
				break;
			}
			phase |= AFHDS2A_WAIT_WRITE;
			return AFHDS2A_WRITE_TIME;
		case AFHDS2A_BIND1|AFHDS2A_WAIT_WRITE:
		case AFHDS2A_BIND2|AFHDS2A_WAIT_WRITE:
		case AFHDS2A_BIND3|AFHDS2A_WAIT_WRITE:
			//Wait for TX completion
			start=micros();
			while ((uint16_t)((uint16_t)micros()-start) < 700)			// Wait max 700s, using serial+telemetry exit in about 120s
				if(!(A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			A7105_SetPower();
			A7105_SetTxRxMode((packet_count & 0x40) ? TXRX_OFF : RX_EN);	// Turn LNA off time to time since we are in near range and we want to prevent swamping
			A7105_Strobe(A7105_RX);
			phase &= ~AFHDS2A_WAIT_WRITE;
			phase++;
			if(phase > AFHDS2A_BIND3)
				phase = AFHDS2A_BIND1;
			return 3850-AFHDS2A_WRITE_TIME;
		case AFHDS2A_BIND4:
			AFHDS2A_build_bind_packet();
			A7105_WriteData(AFHDS2A_TXPACKET_SIZE, packet_count%2 ? 0x0d : 0x8c);
			packet_count++;
			bind_phase++;
			if(bind_phase>=4)
			{ 
				hopping_frequency_no=1;
				phase = AFHDS2A_DATA_INIT;
				BIND_DONE;
			}
			break;
		case AFHDS2A_DATA_INIT:
			packet_counter=0;
			packet_type = AFHDS2A_PACKET_STICKS;
			phase = AFHDS2A_DATA;
		case AFHDS2A_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(3850);
			#endif
			AFHDS2A_build_packet(packet_type);
			data_rx=A7105_ReadReg(A7105_00_MODE);			// Check if something has been received...
			A7105_WriteData(AFHDS2A_TXPACKET_SIZE, hopping_frequency[hopping_frequency_no++]);
			hopping_frequency_no &= 0x0F;					// AFHDS2A_NUMFREQ
			#if 0
				for(uint8_t i=0; i<AFHDS2A_TXPACKET_SIZE; i++)
					debug(" %02X",packet[i]);
				debugln("");
			#endif
			#ifndef MULTI_AIR
				if(sub_protocol > AFHDS2A_GYRO_OFF)
				{//Gyro is on
					//Check if gyro settings have changed
					uint16_t val;
					for(uint8_t i=0;i<4;i++)
					{
						val = Channel_data[CH13+i] - Prev_Channel[i];
						if(val&0x8000) val ^= 0xFFFF;
						if(val > 10)
						{//This setting has significantly changed
							Prev_Channel[i] = Channel_data[CH13+i];
							packet_sent = 5;
						}
					}
				}
				if(packet_sent && (packet_counter%5)==0)
				{//Inform the RX of the change
					packet_type = AFHDS2A_PACKET_SETTINGS;
					packet_sent--;
				}
				else
			#endif
			if(!(packet_counter % 1313))
			{//Send settings every 5s
				packet_type = AFHDS2A_PACKET_SETTINGS;
			}
			else
			{
				#ifdef FAILSAFE_ENABLE
					if(!(packet_counter % 1569) && IS_FAILSAFE_VALUES_on)
					{
						packet_type = AFHDS2A_PACKET_FAILSAFE;
						FAILSAFE_VALUES_off;
					}
					else
				#endif
						packet_type = AFHDS2A_PACKET_STICKS;	// todo : check for settings changes
			}
			if(!(A7105_ReadReg(A7105_00_MODE) & (1<<5)) && !(data_rx & 1))	// removed FECF check due to issues with fs-x6b ->  & (1<<5 | 1<<6)
			{ // RX+CRCF Ok
				A7105_ReadData(AFHDS2A_RXPACKET_SIZE);
				if(packet[0] == 0xAA && packet[9] == 0xFC)
					packet_type=AFHDS2A_PACKET_SETTINGS;		// RX is asking for settings
				else
					if((packet[0] == 0xAA && packet[9]!=0xFD) || packet[0] == 0xAC)
					{// Normal telemetry packet, ignore packets which contain the RX configuration: AA FD FF 32 00 01 00 FF FF FF 05 DC 05 DE FA FF FF FF FF FF FF FF FF FF FF FF FF FF FF
						if(!memcmp(&packet[1], rx_tx_addr, 4))
						{ // TX address validated
							for(uint8_t sensor=0; sensor<7; sensor++)
							{//read LQI value for RX output
								uint8_t index = 9+(4*sensor);
								if(packet[index]==AFHDS2A_SENSOR_RX_ERR_RATE && packet[index+2]<=100)
								{
									RX_LQI=packet[index+2];
									break;
								}
							}
							#if defined(AFHDS2A_FW_TELEMETRY) || defined(AFHDS2A_HUB_TELEMETRY)
								AFHDS2A_update_telemetry();
							#endif
						}
					}
			}
			packet_counter++;
			phase |= AFHDS2A_WAIT_WRITE;
			return AFHDS2A_WRITE_TIME;
		case AFHDS2A_DATA|AFHDS2A_WAIT_WRITE:
			//Wait for TX completion
			start=micros();
			while ((uint16_t)((uint16_t)micros()-start) < 700)			// Wait max 700s, using serial+telemetry exit in about 120s
				if(!(A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			A7105_SetPower();
			A7105_SetTxRxMode(RX_EN);
			A7105_Strobe(A7105_RX);
			phase &= ~AFHDS2A_WAIT_WRITE;
			return 3850-AFHDS2A_WRITE_TIME;
	}
	return 3850;
}

void AFHDS2A_init()
{
	A7105_Init();

	AFHDS2A_calc_channels();
	packet_count = 0;
	bind_phase = 0;
	if(IS_BIND_IN_PROGRESS)
		phase = AFHDS2A_BIND1;
	else
	{
		phase = AFHDS2A_DATA_INIT;
		//Read RX ID from EEPROM based on RX_num, RX_num must be uniq for each RX
		uint16_t addr;
		if(RX_num<16)
			addr=AFHDS2A_EEPROM_OFFSET+RX_num*4;
		else
			addr=AFHDS2A_EEPROM_OFFSET2+(RX_num-16)*4;
		for(uint8_t i=0;i<4;i++)
			rx_id[i]=eeprom_read_byte((EE_ADDR)(addr+i));
	}
	hopping_frequency_no = 0;
	packet_sent = 0;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ASSAN_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(ASSAN_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define ASSAN_PACKET_SIZE		20
#define ASSAN_RF_BIND_CHANNEL	0x03
#define ASSAN_ADDRESS_LENGTH	4

enum {
    ASSAN_BIND0=0,
    ASSAN_BIND1,
    ASSAN_BIND2,
    ASSAN_DATA0,
    ASSAN_DATA1,
    ASSAN_DATA2,
    ASSAN_DATA3,
    ASSAN_DATA4,
    ASSAN_DATA5
};

void ASSAN_RF_init()
{
    NRF24L01_Initialize();
	//Specifics to ASSAN
    NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x02);			// 4 bytes rx/tx address
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t *)"\x80\x80\x80\xB8", ASSAN_ADDRESS_LENGTH);	// Bind address
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t *)"\x80\x80\x80\xB8", ASSAN_ADDRESS_LENGTH);	// Bind address
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, ASSAN_PACKET_SIZE);
}

void ASSAN_send_packet()
{
	for(uint8_t i=0;i<8;i++)
	{
		uint16_t val=Channel_data[i];
		val=((val<<2)+val)+(860<<3);					// PPM value <<3
		
		packet[2*i]=val>>8;
		packet[2*i+1]=val;
	}
	for(uint8_t i=0;i<ASSAN_ADDRESS_LENGTH;i++)
		packet[16+i]=packet[23-i];
 	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);		// Clear data ready, data sent, and retransmit
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, ASSAN_PACKET_SIZE);
}

uint16_t ASSAN_callback()
{
	switch (phase)
	{
	// Bind
		case ASSAN_BIND0:
			//Config RX @1M
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, ASSAN_RF_BIND_CHANNEL);
			NRF24L01_SetBitrate(NRF24L01_BR_1M);					// 1Mbps
			NRF24L01_SetTxRxMode(RX_EN);
			phase++;
		case ASSAN_BIND1:
			//Wait for receiver to send the frames
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ //Something has been received
				NRF24L01_ReadPayload(packet, ASSAN_PACKET_SIZE);
				if(packet[19]==0x13)
				{ //Last frame received
					phase++;
					//Switch to TX
					NRF24L01_SetTxRxMode(TXRX_OFF);
					NRF24L01_SetTxRxMode(TX_EN);
					//Prepare bind packet
					memset(packet,0x05,ASSAN_PACKET_SIZE-5);
					packet[15]=0x99;
					for(uint8_t i=0;i<ASSAN_ADDRESS_LENGTH;i++)
						packet[16+i]=packet[23-i];
					packet_count=0;
					delayMilliseconds(260);
					return 10000;	// Wait 270ms in total...
				}
			}
			return 1000;
		case ASSAN_BIND2:
			// Send 20 packets
			packet_count++;
			if(packet_count==20)
				packet[15]=0x13;	// different value for last packet
			NRF24L01_WritePayload(packet, ASSAN_PACKET_SIZE);
			if(packet_count==20)
			{
				phase++;
				delayMilliseconds(2165);
			}
			return 22520;
	// Normal operation
		case ASSAN_DATA0:
			// Bind Done
			BIND_DONE;
			NRF24L01_SetBitrate(NRF24L01_BR_250K);					// 250Kbps
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_SetTxRxMode(TX_EN);
		case ASSAN_DATA1:
		case ASSAN_DATA4:
			// Change ID and RF channel
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,packet+20+4*hopping_frequency_no, ASSAN_ADDRESS_LENGTH);
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);
			hopping_frequency_no^=0x01;
			NRF24L01_SetPower();
			phase=ASSAN_DATA2;
			return 2000;
		case ASSAN_DATA2:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(12000);
			#endif
		case ASSAN_DATA3:
			ASSAN_send_packet();
			phase++;	// DATA 3 or 4
			return 5000;
	}
	return 0;
}

static void __attribute__((unused)) ASSAN_initialize_txid()
{
/*	//Renaud TXID with Freq=36 and alternate Freq 67 or 68 or 69 or 70 or 71 or 73 or 74 or 75 or 78 and may be more...
	packet[23]=0x22;
	packet[22]=0x37;
	packet[21]=0xFA;
	packet[20]=0x53; */
	// Using packet[20..23] to store the ID1 and packet[24..27] to store the ID2
	uint8_t freq=0,freq2;
	for(uint8_t i=0;i<ASSAN_ADDRESS_LENGTH;i++)
	{
		uint8_t temp=rx_tx_addr[i];
		packet[i+20]=temp;
		packet[i+24]=temp+1;
		freq+=temp;
	}	

	// Main frequency
	freq=((freq%25)+2)<<1;
	if(freq&0x02)	freq|=0x01;
	hopping_frequency[0]=freq;
	// Alternate frequency has some random
	do
	{
		freq2=random(0xfefefefe)%9;
		freq2+=freq*2-5;
	}
	while( (freq2>118) || (freq2<freq+1) || (freq2==2*freq) );
	hopping_frequency[1]=freq2;
}

void ASSAN_init()
{
	ASSAN_initialize_txid();
	ASSAN_RF_init();
	hopping_frequency_no = 0;

	if(IS_BIND_IN_PROGRESS)
		phase=ASSAN_BIND0;
	else 
		phase=ASSAN_DATA0;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Arduino.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
/************************************/
/************************************/
/**  Arduino replacement routines  **/
/************************************/
// replacement map()
int16_t map16b( int16_t x, int16_t in_min, int16_t in_max, int16_t out_min, int16_t out_max)
{
//  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	long y ;
	x -= in_min ;
	y = out_max - out_min ;
	y *= x ;
	x = y / (in_max - in_min) ;
	return x  + out_min ;
}

#ifndef STM32_BOARD
int16_t map( int16_t x, int16_t in_min, int16_t in_max, int16_t out_min, int16_t out_max)
{
//  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	long y ;
	x -= in_min ;
	y = out_max - out_min ;
	y *= x ;
	x = y / (in_max - in_min) ;
	return x  + out_min ;
}

// replacement millis() and micros()
// These work polled, no interrupts
// micros() MUST be called at least once every 32 milliseconds
uint16_t MillisPrecount ;
uint16_t lastTimerValue ;
uint32_t TotalMicros ;
uint32_t TotalMillis ;
uint8_t Correction ;

uint32_t micros()
{
   uint16_t elapsed ;
   uint8_t millisToAdd ;
   uint8_t oldSREG = SREG ;
   cli() ;
   uint16_t time = TCNT1 ;   // Read timer 1
   SREG = oldSREG ;

   elapsed = time - lastTimerValue ;
   elapsed += Correction ;
   Correction = elapsed & 0x01 ;
   elapsed >>= 1 ;
   
   uint32_t ltime = TotalMicros ;
   ltime += elapsed ;
   cli() ;
   TotalMicros = ltime ;   // Done this way for RPM to work correctly
   lastTimerValue = time ;
   SREG = oldSREG ;   // Still valid from above
   
   elapsed += MillisPrecount;
   millisToAdd = 0 ;
   
   if ( elapsed  > 15999 )
   {
      millisToAdd = 16 ;
      elapsed -= 16000 ;
   }
   if ( elapsed  > 7999 )
   {
      millisToAdd += 8 ;
      elapsed -= 8000 ;
   }
   if ( elapsed  > 3999 )
   {
      millisToAdd += 4 ;      
      elapsed -= 4000 ;
   }
   if ( elapsed  > 1999 )
   {
      millisToAdd += 2 ;
      elapsed -= 2000 ;
   }
   if ( elapsed  > 999 )
   {
      millisToAdd += 1 ;
      elapsed -= 1000 ;
   }
   TotalMillis += millisToAdd ;
   MillisPrecount = elapsed ;
   return TotalMicros ;
}

uint32_t millis()
{
   micros() ;
   return TotalMillis ;
}

void delayMilliseconds(unsigned long ms)
{
   uint16_t start = (uint16_t)micros();
   uint16_t lms = ms ;

   while (lms > 0) {
      if ((uint16_t)((uint16_t)micros() - start) >= 1000) {
         lms--;
         start += 1000;
      }
   }
}

/* Important notes:
	- Max value is 16000s
	- delay is not accurate due to interrupts happening */
void delayMicroseconds(unsigned int us)
{
   if (--us == 0)
      return;
   us <<= 2;	// * 4
   us -= 2;		// - 2
#ifdef ORANGE_TX
	 __asm__ __volatile__ (
      "1: sbiw %0,1" "\n\t" // 2 cycles
			"nop \n"
			"nop \n"
			"nop \n"
			"nop \n"
      "brne 1b" : "=w" (us) : "0" (us) // 2 cycles
   );
#else   
	 __asm__ __volatile__ (
      "1: sbiw %0,1" "\n\t" // 2 cycles
      "brne 1b" : "=w" (us) : "0" (us) // 2 cycles
   );
#endif
}

#ifndef ORANGE_TX
	void init()
	{
	   // this needs to be called before setup() or some functions won't work there
	   sei();
	}
#endif //ORANGE_TX

#endif //STM32_BOARD
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Ares_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with ARES 6HPA transmitter

#if defined(ARES_CC2500_INO)

#include "iface_cc2500.h"

//#define ARES_FORCE_ID

#define ARES_COARSE			0

#define ARES_PACKET_LEN		17
#define ARES_NUM_FREQUENCE	60
#define ARES_BIND_COUNT		150		// ~1sec on fixed channel

enum {
	ARES_START = 0x00,
	ARES_CALIB = 0x01,
	ARES_PREP  = 0x02,
	ARES_DATA  = 0x03,
};

// CC2500 register init values captured from the ARES 6HPA transmitter
const PROGMEM uint8_t ARES_init_values[] = {
  /* 00 */ 0x06, 0x2E, 0x2E, 0x07, 0x5A, 0x60, 0x30, 0x04,
  /* 08 */ 0x05, 0x00, 0x00, 0x06, 0x00, 0x5C, 0xB1, 0x3B + ARES_COARSE,
  /* 10 */ 0x6A, 0xF8, 0x03, 0x23, 0x7A, 0x44, 0x07, 0x30,
  /* 18 */ 0x18, 0x16, 0x6C, 0x43, 0x40, 0x91, 0x87, 0x6B,
  /* 20 */ 0xF8, 0x56, 0x10, 0xA9, 0x0A, 0x00, 0x11
};

// The 60 RF channel values used for hopping
static const PROGMEM uint8_t ARES_channels[] = {
	0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1D,
	0x20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C,
	0x40, 0x44, 0x48, 0x4C, 0x50, 0x54, 0x58, 0x5C,
	0x60, 0x64, 0x68, 0x6C, 0x6F, 0x74, 0x78, 0x7C,
	0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9B,
	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
	0xC0, 0xC3, 0xC6, 0xCC, 0xD0, 0xD4, 0xD8, 0xDC,
	0xE0, 0xE4, 0xE8, 0xEC
};

static void __attribute__((unused)) ARES_CC2500_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i < 39; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&ARES_init_values[i]));

	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	prev_option = option;

	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}

// Generate hopping table: random permutation of ARES_channels[]
static void __attribute__((unused)) ARES_RF_channels()
{
	// Start with channels in order
	for (uint8_t i = 0; i < ARES_NUM_FREQUENCE; i++)
		hopping_frequency[i] = pgm_read_byte_near(&ARES_channels[i]);

	// Fisher-Yates shuffle using TX ID as seed
	uint32_t rnd = MProtocol_id;
	for (uint8_t i = ARES_NUM_FREQUENCE - 1; i > 0; i--)
	{
		rnd = rnd * 0x0019660D + 0x3C6EF35F;
		uint8_t j = (rnd >> 8) % (i + 1);
		uint8_t tmp = hopping_frequency[i];
		hopping_frequency[i] = hopping_frequency[j];
		hopping_frequency[j] = tmp;
	}
}

static void __attribute__((unused)) ARES_tune_chan()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[hopping_frequency_no]);
	CC2500_Strobe(CC2500_SFTX);
	CC2500_Strobe(CC2500_SCAL);
}

static void __attribute__((unused)) ARES_change_chan_fast()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[hopping_frequency_no]);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[hopping_frequency_no]);
}

static void __attribute__((unused)) ARES_build_packet()
{
	// Length byte: 16 data bytes follow
	packet[0] = 0x10;

	// TX ID
	packet[1] = rx_tx_addr[1];
	packet[2] = rx_tx_addr[2];
	packet[3] = rx_tx_addr[3];

	// 6 channels encoded as interleaved 12-bit values in bytes 4-12
	// Encoding: Ch_N = (byte_H << 4) | (byte_shared >> 4 or & 0x0F)
	// Byte layout:
	//   byte4  = Ch1[11:4]
	//   byte5  = Ch1[3:0] << 4 | Ch2[3:0]
	//   byte6  = Ch2[11:4]
	//   byte7  = Ch3[11:4]
	//   byte8  = Ch3[3:0] << 4 | Ch4[3:0]
	//   byte9  = Ch4[11:4]
	//   byte10 = Ch5[11:4]
	//   byte11 = Ch5[3:0] << 4 | Ch6[3:0]
	//   byte12 = Ch6[11:4]
	// Captured values: center ~2560 (0xA00), range ~1820-3300
	uint16_t ch[6];
	for (uint8_t i = 0; i < 6; i++)
		ch[i] = convert_channel_16b_nolimit(i, 1820, 3300, false);

	packet[4]  = ch[0] >> 4;
	packet[5]  = ((ch[0] & 0x0F) << 4) | (ch[1] & 0x0F);
	packet[6]  = ch[1] >> 4;
	packet[7]  = ch[2] >> 4;
	packet[8]  = ((ch[2] & 0x0F) << 4) | (ch[3] & 0x0F);
	packet[9]  = ch[3] >> 4;
	packet[10] = ch[4] >> 4;
	packet[11] = ((ch[4] & 0x0F) << 4) | (ch[5] & 0x0F);
	packet[12] = ch[5] >> 4;

	// Bytes 13-15: hop counter with rotating frame indicator in bit 7
	// The hop counter cycles through 0-59 using: (start + 23*n) mod 59, with 59 inserted where 0 would first occur
	// rf_ch_num is used as the hop counter index (0-59)
	uint8_t hop_code;
	uint8_t n = rf_ch_num;
	uint8_t offset = rx_tx_addr[1] % 59;
	if (n > 0)
	{
		// Check if the raw formula for position (n-1) gives 0
		uint8_t prev_val = (uint8_t)((offset + (uint16_t)23 * (n - 1)) % 59);
		if (prev_val == 0 && n > 1)
			hop_code = (uint8_t)((offset + (uint16_t)23 * (n - 2)) % 59);	// Shifted due to 59 insertion
		else if (n <= ((59 - offset) * 41 % 59 + 1))  // Before the insertion point
			hop_code = (uint8_t)((offset + (uint16_t)23 * n) % 59);
		else
			hop_code = (uint8_t)((offset + (uint16_t)23 * (n - 1)) % 59);
	}
	else
		hop_code = offset;

	// Simplified approach: just use (offset + 23*n) % 59 for values 0-58, insert 59 at the wrap point
	hop_code = (uint8_t)((offset + (uint16_t)23 * (rf_ch_num % 59)) % 59);
	if (rf_ch_num == 59)
		hop_code = 59;

	// Frame indicator: each data frame is sent 3 times
	// bind_phase tracks position 0/1/2 within the group of 3
	packet[13] = hop_code;
	packet[14] = hop_code;
	packet[15] = hop_code;

	// Set the rotating frame bit (bit 7) on one of bytes 13-15
	switch (bind_phase)
	{
		case 0:
			packet[13] |= 0x80;
			break;
		case 1:
			packet[14] |= 0x80;
			break;
		case 2:
			packet[15] |= 0x80;
			break;
	}

	// Byte 16: session/protocol value derived from TX ID
	packet[16] = rx_tx_addr[2] ^ rx_tx_addr[3];
}

static void __attribute__((unused)) ARES_send_packet()
{
	ARES_change_chan_fast();
	CC2500_SetPower();
	CC2500_WriteData(packet, ARES_PACKET_LEN);
}

#define ARES_PACKET_PERIOD	6670	// 6.67ms between packets
#define ARES_PREP_TIMING	2000

uint16_t ARES_callback()
{
	switch(phase)
	{
		case ARES_START:
			ARES_CC2500_init();
			hopping_frequency_no = 0;
			rf_ch_num = 0;
			bind_phase = 0;
			ARES_tune_chan();
			phase = ARES_CALIB;
			return ARES_PREP_TIMING;
		case ARES_CALIB:
			calData[hopping_frequency_no] = CC2500_ReadReg(CC2500_25_FSCAL1);
			hopping_frequency_no++;
			if (hopping_frequency_no < ARES_NUM_FREQUENCE)
				ARES_tune_chan();
			else
			{
				hopping_frequency_no = 0;
				phase = ARES_PREP;
			}
			return ARES_PREP_TIMING;
		case ARES_PREP:
			if (prev_option != option)
			{
				phase = ARES_START;
				return ARES_PREP_TIMING;
			}
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(ARES_PACKET_PERIOD);
			#endif
			ARES_build_packet();
			phase = ARES_DATA;
			// Fall through
		case ARES_DATA:
			ARES_send_packet();
			hopping_frequency_no++;
			if (hopping_frequency_no >= ARES_NUM_FREQUENCE)
				hopping_frequency_no = 0;
			bind_phase++;
			if (bind_phase >= 3)
			{
				bind_phase = 0;
				rf_ch_num++;
				if (rf_ch_num >= ARES_NUM_FREQUENCE)
					rf_ch_num = 0;
			}
			phase = ARES_PREP;
			return ARES_PACKET_PERIOD;
	}
	return 0;
}

void ARES_init()
{
	ARES_RF_channels();
	#ifdef ARES_FORCE_ID
		rx_tx_addr[1] = 0xDC;
		rx_tx_addr[2] = 0xCC;
		rx_tx_addr[3] = 0x00;
		// Hopping table from capture
		memcpy((void *)hopping_frequency,
			(void *)"\x00\xB0\x6F\x1D\xB4\x74\x20\xB8\xD8\x24\xBC\xDC\x28\x48\xE0\x2C\x4C\xE4\x90\x50\xE8\x94\x54\xEC\x00\x98\x58\x04\x9B\x5C\x08\xA0\xC0\x0C\xA4\xC3\x10\x30\xC6\x14\x34\xCC\x78\x38\xD0\x7C\x3C\xD4\x80\x40\x60\x84\x44\x64\x88\xA8\x68\x8C\xAC\x6C",
			ARES_NUM_FREQUENCE);
	#endif
	phase = ARES_START;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/BUGSMINI_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with MJX Bugs 3 Mini and Bugs 3H

#if defined(BUGSMINI_NRF24L01_INO)

#include "iface_xn297.h"

#define BUGSMINI_INITIAL_WAIT    500
#define BUGSMINI_PACKET_INTERVAL 6840
#define BUGSMINI_WRITE_WAIT      2000
#define BUGSMINI_TX_PAYLOAD_SIZE 24
#define BUGSMINI_RX_PAYLOAD_SIZE 16
#define BUGSMINI_NUM_RF_CHANNELS 15
#define BUGSMINI_ADDRESS_SIZE    5

static uint8_t BUGSMINI_txid[3];
static uint8_t BUGSMINI_txhash;

enum {
    BUGSMINI_BIND1,
    BUGSMINI_BIND2,
    BUGSMINI_DATA1,
    BUGSMINI_DATA2
};

#define BUGSMINI_CH_SW_ARM		CH5_SW
#define BUGSMINI_CH_SW_ANGLE	CH6_SW
#define BUGSMINI_CH_SW_FLIP		CH7_SW
#define BUGSMINI_CH_SW_PICTURE	CH8_SW
#define BUGSMINI_CH_SW_VIDEO	CH9_SW
#define BUGSMINI_CH_SW_LED		CH10_SW
#define BUGSMINI_CH_SW_ALTHOLD	CH11_SW

// flags packet[12]
#define BUGSMINI_FLAG_FLIP    0x08    // automatic flip
#define BUGSMINI_FLAG_MODE    0x04    // low/high speed select (set is high speed)
#define BUGSMINI_FLAG_VIDEO   0x02    // toggle video
#define BUGSMINI_FLAG_PICTURE 0x01    // toggle picture

// flags packet[13]
#define BUGSMINI_FLAG_LED     0x80    // enable LEDs
#define BUGSMINI_FLAG_ARM     0x40    // arm (toggle to turn on motors)
#define BUGSMINI_FLAG_DISARM  0x20    // disarm (toggle to turn off motors)
#define BUGSMINI_FLAG_ANGLE   0x02    // angle/acro mode (set is angle mode)
#define BUGSMINI_FLAG_ALTHOLD 0x04    // angle/altitude hold mode (set is altitude mode)

static void __attribute__((unused)) BUGSMINI_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	//XN297_HoppingCalib(BUGSMINI_NUM_RF_CHANNELS*2);
}

static void __attribute__((unused)) BUGSMINI_check_arming()
{
	uint8_t arm_channel = BUGSMINI_CH_SW_ARM;

	if (arm_channel != arm_channel_previous)
	{
		arm_channel_previous = arm_channel;
		if (arm_channel)
		{
			armed = 1;
			arm_flags ^= BUGSMINI_FLAG_ARM;
		}
		else
		{
			armed = 0;
			arm_flags ^= BUGSMINI_FLAG_DISARM;
		}
	}
}

static void __attribute__((unused)) BUGSMINI_send_packet()
{
	BUGSMINI_check_arming();  // sets globals arm_flags and armed

	uint16_t aileron  = convert_channel_16b_limit(AILERON,500,0);
	uint16_t elevator = convert_channel_16b_limit(ELEVATOR,0,500);
	uint16_t throttle = armed ? convert_channel_16b_limit(THROTTLE,0,500) : 0;
	uint16_t rudder   = convert_channel_16b_limit(RUDDER,500,0);

	packet[1] = BUGSMINI_txid[0];
	packet[2] = BUGSMINI_txid[1];
	packet[3] = BUGSMINI_txid[2];
	if(IS_BIND_IN_PROGRESS)
	{
		packet[4] = 0x00;
		packet[5] = 0x7d;
		packet[6] = 0x7d;
		packet[7] = 0x7d;
		packet[8] = 0x20;
		packet[9] = 0x20;
		packet[10]= 0x20;
		packet[11]= 0x40;
		packet[12]^= 0x40;	 // alternating freq hopping flag
		packet[13]= 0x60;
		packet[14]= 0x00;
		packet[15]= 0x00;
	}
	else
	{
		packet[4] = throttle >> 1;
		packet[5] = rudder >> 1;
		packet[6] = elevator >> 1;
		packet[7] = aileron >> 1;
		packet[8] = (((aileron / 5) >> 1) + 7)   // dynamic trim 0x07 - 0x39
					| (aileron << 7);
		packet[9] = (((elevator / 5) >> 1) + 7)  // dynamic trim 0x07 - 0x39
					| (elevator << 7);
		packet[10]= (((rudder / 5) >> 1) + 7)    // dynamic trim 0x07 - 0x39
					| (rudder << 7);
		packet[11]= 0x40 | (throttle << 7);
		packet[12]= 0x80 | ((packet[12] ^ 0x40) & 0x40)
			| BUGSMINI_FLAG_MODE
			| GET_FLAG(BUGSMINI_CH_SW_PICTURE, BUGSMINI_FLAG_PICTURE)
			| GET_FLAG(BUGSMINI_CH_SW_VIDEO, BUGSMINI_FLAG_VIDEO);
		if(armed)
			packet[12] |= GET_FLAG(BUGSMINI_CH_SW_FLIP, BUGSMINI_FLAG_FLIP);
		packet[13] = arm_flags
			| GET_FLAG(BUGSMINI_CH_SW_LED, BUGSMINI_FLAG_LED)
			| GET_FLAG(BUGSMINI_CH_SW_ALTHOLD, BUGSMINI_FLAG_ALTHOLD)
			| GET_FLAG(BUGSMINI_CH_SW_ANGLE, BUGSMINI_FLAG_ANGLE);
			// BUGS3H althold -> BUGSMINI_FLAG_ALTHOLD|BUGSMINI_FLAG_ANGLE , angle -> 0
		packet[14] = 0;
		packet[15] = 0; // a lot of 0x53 and some 0x52 on bugs 3H
	}
	uint8_t checksum = 0x6d;
	for(uint8_t i=1; i < BUGSMINI_TX_PAYLOAD_SIZE; i++)
	checksum ^= packet[i];
	packet[0] = checksum;

	if(!(packet[12]&0x40))
	{
		hopping_frequency_no++;
		if(hopping_frequency_no >= BUGSMINI_NUM_RF_CHANNELS)
			hopping_frequency_no = 0;
		XN297_Hopping(IS_BIND_IN_PROGRESS ? hopping_frequency_no+BUGSMINI_NUM_RF_CHANNELS : hopping_frequency_no);
	}

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TXRX_OFF);
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, BUGSMINI_TX_PAYLOAD_SIZE);
}

// compute final address for the rxid received during bind
// thanks to Pascal for the function!
const uint8_t PROGMEM BUGSMINI_end []= {
	0x2d,0x9e ,0x95,0xa4 ,0x9c,0x5c ,0xb4,0xa6 ,0xa9,0xce ,0x56,0x2b ,0x3e,0x73 ,0xb8,0x95 ,0x6a,0x82,
	0x94,0x37 ,0x3d,0x5a ,0x4b,0xb2 ,0x69,0x49 ,0xc2,0x24 ,0x6b,0x3d ,0x23,0xc6 ,0x9e,0xa3 ,0xa4,0x98,
	0x5c,0x9e ,0xa6,0x52 ,0xce,0x76 ,0x2b,0x4b ,0x73,0x3a };
static void __attribute__((unused)) BUGSMINI_make_address()
{
    uint8_t start, length, index;

	//read rxid
	uint8_t base_adr=BUGSMINI_EEPROM_OFFSET+(RX_num&0x0F)*2;
    uint8_t rxid_high = eeprom_read_byte((EE_ADDR)(base_adr+0));
    uint8_t rxid_low  = eeprom_read_byte((EE_ADDR)(base_adr+1));
    
    if(rxid_high==0x00 || rxid_high==0xFF)
        rx_tx_addr[0]=0x52;
    else
        rx_tx_addr[0]=rxid_high;
    
    rx_tx_addr[1]=BUGSMINI_txhash;
    
    if(rxid_low==0x00 || rxid_low==0xFF)
        rx_tx_addr[2]=0x66;
    else
        rx_tx_addr[2]=rxid_low;
    
    for(uint8_t end_idx=0;end_idx<23;end_idx++)
    {
        //calculate sequence start
        if(end_idx<=7)
            start=end_idx;
        else
            start=(end_idx-7)*16+7;
        //calculate sequence length
        if(end_idx>6)
        {
            if(end_idx>15)
                length=(23-end_idx)<<1;
            else
                length=16;
        }
        else
            length=(end_idx+1)<<1;
        //calculate first index
        index=start-rxid_high;
        //scan for a possible match using the current end
        for(uint8_t i=0;i<length;i++)
        {
            if(index==rxid_low)
            { //match found
                rx_tx_addr[3]=pgm_read_byte_near( &BUGSMINI_end[end_idx<<1] );
                rx_tx_addr[4]=pgm_read_byte_near( &BUGSMINI_end[(end_idx<<1)+1] );
                return;
            }
            index+=i&1?7:8;	//increment index
        }
    }
    // Something wrong happened if we arrive here....
}

#if defined(BUGS_HUB_TELEMETRY)
static void __attribute__((unused)) BUGSMINI_update_telemetry()
{
	uint8_t checksum = 0x6d;
	for(uint8_t i=1; i<12; i++)
		checksum += packet_in[i];
	if(packet_in[0] == checksum)
	{
		RX_RSSI = packet_in[3];
		if(sub_protocol==BUGS3H)
		{
			if(packet_in[11] & 0x40)
				v_lipo1 = 0x40; // Warning
			else if(packet_in[11] & 0x80)
				v_lipo1 = 0x20; // Critical
			else
				v_lipo1 = 0x80; // Ok
		}
		else
		{
			if(packet_in[11] & 0x80)
				v_lipo1 = 0x80; // Ok
			else if(packet_in[11] & 0x40)
				v_lipo1 = 0x40; // Warning
			else
				v_lipo1 = 0x20; // Critical
		}
		telemetry_link=1;
	}
}
#endif

uint16_t BUGSMINI_callback()
{
	uint8_t base_adr;
	switch(phase)
	{
		case BUGSMINI_BIND1:
			if( XN297_IsRX() )
			{ // RX fifo data ready
				XN297_ReadPayload(packet, BUGSMINI_RX_PAYLOAD_SIZE);	// Not checking the CRC??
				base_adr=BUGSMINI_EEPROM_OFFSET+(RX_num&0x0F)*2;
				eeprom_write_byte((EE_ADDR)(base_adr+0),packet[1]);		// Save rxid in EEPROM
				eeprom_write_byte((EE_ADDR)(base_adr+1),packet[2]);		// Save rxid in EEPROM
				BUGSMINI_make_address();
				XN297_SetTXAddr(rx_tx_addr, 5);
				XN297_SetRXAddr(rx_tx_addr, BUGSMINI_RX_PAYLOAD_SIZE);
				phase = BUGSMINI_DATA1;
				BIND_DONE;
				break;
			}
			BUGSMINI_send_packet();
			phase = BUGSMINI_BIND2;
			return BUGSMINI_WRITE_WAIT;
		case BUGSMINI_BIND2:
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = BUGSMINI_BIND1;
			return BUGSMINI_PACKET_INTERVAL - BUGSMINI_WRITE_WAIT;
		case BUGSMINI_DATA1:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(BUGSMINI_PACKET_INTERVAL);
			#endif
			#if defined(BUGS_HUB_TELEMETRY)
				if( XN297_IsRX() )
				{
					XN297_ReadPayload(packet_in, BUGSMINI_RX_PAYLOAD_SIZE);	// Not checking the CRC??
					BUGSMINI_update_telemetry();
				}
			#endif
			BUGSMINI_send_packet();
	#if not defined(BUGS_HUB_TELEMETRY)
			break;
	#else
			phase = BUGSMINI_DATA2;
			return BUGSMINI_WRITE_WAIT;
		case BUGSMINI_DATA2:
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = BUGSMINI_DATA1;
			return BUGSMINI_PACKET_INTERVAL - BUGSMINI_WRITE_WAIT;
	#endif
	}
	return BUGSMINI_PACKET_INTERVAL;
}

#define BUGSMINI_NUM_TX_RF_MAPS 4
// haven't figured out BUGSMINI_txid<-->rf channel mapping yet
const uint8_t PROGMEM BUGSMINI_RF_chans[BUGSMINI_NUM_TX_RF_MAPS][BUGSMINI_NUM_RF_CHANNELS] = {
	{0x22,0x2f,0x3a,0x14,0x20,0x2d,0x38,0x18,0x26,0x32,0x11,0x1d,0x29,0x35,0x17},
	{0x3d,0x34,0x2b,0x22,0x19,0x40,0x37,0x2e,0x25,0x1c,0x3a,0x31,0x28,0x1f,0x16},
	{0x12,0x20,0x2f,0x1a,0x28,0x38,0x14,0x23,0x32,0x1c,0x2c,0x3b,0x17,0x26,0x34},
	{0x13,0x25,0x37,0x1F,0x31,0x17,0x28,0x3A,0x1C,0x2E,0x22,0x33,0x19,0x2B,0x3D} };
const uint8_t PROGMEM BUGSMINI_bind_chans[BUGSMINI_NUM_RF_CHANNELS] = {
	0x1A,0x23,0x2C,0x35,0x3E,0x17,0x20,0x29,0x32,0x3B,0x14,0x1D,0x26,0x2F,0x38}; // bugs 3 mini bind channels
const uint8_t PROGMEM BUGSMINI_tx_id[BUGSMINI_NUM_TX_RF_MAPS][3] = {
	{0xA8,0xE6,0x32},
	{0xdd,0xab,0xfd},
	{0x90,0x9e,0x4a},
	{0x20,0x28,0xBA} };
const uint8_t PROGMEM BUGSMINI_tx_hash[BUGSMINI_NUM_TX_RF_MAPS] = { // 2nd byte of final address
	0x6c,0x9e,0x3d,0xb3};
	
static void __attribute__((unused)) BUGSMINI_initialize_txid()
{
	// load hopping_frequency with tx channels in low part and bind channels in high part
	for(uint8_t i=0; i<BUGSMINI_NUM_RF_CHANNELS;i++)
	{
		hopping_frequency[i]=pgm_read_byte_near( &BUGSMINI_RF_chans[rx_tx_addr[3]%BUGSMINI_NUM_TX_RF_MAPS][i] );
		hopping_frequency[i+BUGSMINI_NUM_RF_CHANNELS]=pgm_read_byte_near( &BUGSMINI_bind_chans[i] );
	}
	// load txid
	for(uint8_t i=0; i<sizeof(BUGSMINI_txid);i++)
		BUGSMINI_txid[i]=pgm_read_byte_near( &BUGSMINI_tx_id[rx_tx_addr[3]%BUGSMINI_NUM_TX_RF_MAPS][i] );
	//load tx_hash
	BUGSMINI_txhash = pgm_read_byte_near( &BUGSMINI_tx_hash[rx_tx_addr[3]%BUGSMINI_NUM_TX_RF_MAPS] );
}

void BUGSMINI_init()
{
	BUGSMINI_initialize_txid();
	BUGSMINI_RF_init();
	memset(packet, (uint8_t)0, BUGSMINI_TX_PAYLOAD_SIZE);
	if(IS_BIND_IN_PROGRESS)
	{
		XN297_SetTXAddr((const uint8_t*)"mjxRC", 5);
		XN297_SetRXAddr((const uint8_t*)"mjxRC", BUGSMINI_RX_PAYLOAD_SIZE);
		phase = BUGSMINI_BIND1;
	}
	else
	{
		BUGSMINI_make_address();
		XN297_SetTXAddr(rx_tx_addr, 5);
		XN297_SetRXAddr(rx_tx_addr, BUGSMINI_RX_PAYLOAD_SIZE);
		phase = BUGSMINI_DATA1;
	}
	armed = 0;
	arm_flags = BUGSMINI_FLAG_DISARM;    // initial value from captures
	arm_channel_previous = BUGSMINI_CH_SW_ARM;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/BUMBLEB_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(BUMBLEB_CCNRF_INO)

#include "iface_xn297.h"

#define FORCE_BUMBLEB_ORIGINAL_ID
#define BUMBLEB_TELEM_DEBUG

#define BUMBLEB_PACKET_PERIOD	10200
#define BUMBLEB_RF_BIND_CHANNEL	42
#define BUMBLEB_RF_NUM_CHANNELS	2
#define BUMBLEB_PAYLOAD_SIZE	7

static void __attribute__((unused)) BUMBLEB_send_packet()
{
	packet[6] = 0x00;
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = rx_tx_addr[0];
		packet[1] = rx_tx_addr[1];
		packet[2] = 0x54;			 //???
		packet[3] = 0x58;			 //???
		hopping_frequency_no ^= 0x01;
		packet[4] = hopping_frequency[hopping_frequency_no];
	}
	else
	{
		//hopping frequency
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no ^= 0x01;
		packet[0] = 0x20
					|GET_FLAG(CH6_SW,0x80);				// High rate
		packet[1] = convert_channel_8b_limit_deadband(AILERON,0xBF,0xA0,0x81,40);	// Aileron: Max values:BD..A0..82
		if(packet[1] < 0xA0)
			packet[1] = 0x20 - packet[1];				// Reverse low part of aileron
		packet[2] = convert_channel_8b(CH5)>>2;			// 01..20..3F
		if(CH7_SW)										// Drive trim from aileron
		{
			uint8_t ch=convert_channel_8b(AILERON);
			if(ch > 0x5A && ch < 0x80-0x07)
				packet[2] = ch - 0x5A;
			else if(ch < 0x5A)
			{
				if(ch < 0x5A-0x20)
					packet[2] = 0;
				else
					packet[2] = ch - (0x5A-0x20);
			}
			else if(packet[1] == 0x89)
				packet[2] = 0x20;
			else if(ch > 0xA5)
			{
				if(ch > 0xA9+0x1F)
					packet[2] = 0x3F;
				else
					packet[2] = ch - 0x89;
			}
			else if(ch > 0xA5-0x1F)
				packet[2] = ch - (0xA5-0x1F-0x20);
		}
		else
			packet[2] = convert_channel_8b(CH5)>>2;		// 01..20..3F
		packet[3] = convert_channel_8b(THROTTLE)>>2;	// 00..3F
		packet[4] = hopping_frequency[hopping_frequency_no];
	}

	packet[5] = packet[0];
	for(uint8_t i=1;i<BUMBLEB_PAYLOAD_SIZE-2;i++)
		packet[5] += packet[i];

	#if 0
		debug("P:");
		for(uint8_t i=0;i<BUMBLEB_PAYLOAD_SIZE;i++)
			debug(" %02X", packet[i]);
		debugln("");
	#endif

	XN297_SetPower();									// Set tx_power
	XN297_SetFreqOffset();								// Set frequency offset
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, BUMBLEB_PAYLOAD_SIZE);
}

static void __attribute__((unused)) BUMBLEB_RF_init()
{
	//Config CC2500
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	XN297_SetTXAddr((uint8_t*)"\x55\x55\x55\x55\x55", 5);
	XN297_HoppingCalib(BUMBLEB_RF_NUM_CHANNELS);		// Calibrate all channels
	XN297_RFChannel(BUMBLEB_RF_BIND_CHANNEL);			// Set bind channel
	XN297_SetRXAddr(rx_tx_addr, BUMBLEB_PAYLOAD_SIZE);
}

static void __attribute__((unused)) BUMBLEB_initialize_txid()
{
	calc_fh_channels(BUMBLEB_RF_NUM_CHANNELS);
	rx_tx_addr[0] = rx_tx_addr[2];
	rx_tx_addr[1] = rx_tx_addr[3];
	#ifdef FORCE_BUMBLEB_ORIGINAL_ID
		rx_tx_addr[0] = 0x33;
		rx_tx_addr[1] = 0x65;
		hopping_frequency[0] = 2;
		hopping_frequency[1] = 40;
	#endif
	rx_tx_addr[2] = rx_tx_addr[3] = rx_tx_addr[4] = 0x55;
}

enum {
	BUMBLEB_BIND		= 0x00,
	BUMBLEB_BINDRX		= 0x01,
	BUMBLEB_DATA		= 0x02,
};

#define BUMBLEB_WRITE_TIME 850

uint16_t BUMBLEB_callback()
{
	bool rx;
	switch(phase)
	{
		case BUMBLEB_BIND:
			rx = XN297_IsRX();				// Needed for the NRF24L01 since otherwise the bit gets cleared

			BUMBLEB_send_packet();

			if( rx )
			{ // a packet has been received
				#ifdef BUMBLEB_TELEM_DEBUG
					debug("RX :");
				#endif
				if(XN297_ReadPayload(packet_in, BUMBLEB_PAYLOAD_SIZE))
				{ // packet with good CRC
					#ifdef BUMBLEB_TELEM_DEBUG
						debug("OK :");
						for(uint8_t i=0;i<BUMBLEB_PAYLOAD_SIZE;i++)
							debug(" %02X",packet_in[i]);
					#endif
					// packet_in = 4F 71 55 52 58 61 AA
					rx_tx_addr[2] = packet_in[0];
					rx_tx_addr[3] = packet_in[1];
					//rx_tx_addr[4] = packet_in[2];	// to test with other planes...
					XN297_SetTXAddr(rx_tx_addr, 5);
					BIND_DONE;
					phase = BUMBLEB_DATA;
					break;
				}
			}
			phase++;
			return BUMBLEB_WRITE_TIME;
		case BUMBLEB_BINDRX:
			{
				uint16_t start=(uint16_t)micros();
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
				{
					if(XN297_IsPacketSent())
						break;
				}
			}
			XN297_SetTxRxMode(RX_EN);
			phase = BUMBLEB_BIND;
			return BUMBLEB_PACKET_PERIOD-BUMBLEB_WRITE_TIME;
		case BUMBLEB_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(BUMBLEB_PACKET_PERIOD);
			#endif
			BUMBLEB_send_packet();
			break;
	}
	return BUMBLEB_PACKET_PERIOD;
}

void BUMBLEB_init()
{
	BUMBLEB_initialize_txid();
	BUMBLEB_RF_init();
	hopping_frequency_no = 0;
	
	BIND_IN_PROGRESS;	// autobind protocol
	phase = BUMBLEB_BIND;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_Rx_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(BAYANG_RX_NRF24L01_INO)

#include "iface_xn297.h"

#define BAYANG_RX_PACKET_SIZE		15
#define BAYANG_RX_RF_NUM_CHANNELS	4
#define BAYANG_RX_RF_BIND_CHANNEL	0
#define BAYANG_RX_ADDRESS_LENGTH	5

enum {
	BAYANG_RX_BIND = 0,
	BAYANG_RX_DATA
};

static void __attribute__((unused)) Bayang_Rx_RF_init()
{
	const uint8_t bind_address[BAYANG_RX_ADDRESS_LENGTH] = { 0,0,0,0,0 };
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr(bind_address, BAYANG_RX_ADDRESS_LENGTH);
	XN297_SetRXAddr(bind_address, BAYANG_RX_PACKET_SIZE);
	XN297_RFChannel(BAYANG_RX_RF_BIND_CHANNEL);
	XN297_SetTxRxMode(TXRX_OFF);
	XN297_SetTxRxMode(RX_EN);
}

static uint8_t __attribute__((unused)) Bayang_Rx_check_validity() {
	uint8_t sum = packet[0];
	for (uint8_t i = 1; i < BAYANG_RX_PACKET_SIZE - 1; i++)
		sum += packet[i];
	return sum == packet[14];
}

static void __attribute__((unused)) Bayang_Rx_build_telemetry_packet()
{
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	uint8_t idx = 0;

	packet_in[idx++] = RX_LQI;
	packet_in[idx++] = RX_LQI>>1;	// no RSSI: 125..0
	packet_in[idx++] = 0;			// start channel
	packet_in[idx++] = 10;			// number of channels in packet

	// convert & pack channels
	for (uint8_t i = 0; i < packet_in[3]; i++) {
		uint32_t val = CHANNEL_MIN_100;
		if (i < 4) {
			// AETR
			//val = (((packet[4 + i * 2] & ~0x7C) << 8) | packet[5 + i * 2]) << 1;
			val=packet[4 + i * 2]&0x03;
			val=(val<<8)+packet[5 + i * 2];
			val=((val+128)<<3)/5;
		} else if (i == 4 || i == 5) {
			val=packet[i==4?1:13];
			val=((val+32)<<5)/5;						// extra analog channel
		} else if (((i == 6) && (packet[2] & 0x08)) ||	// flip
				 ((i == 7) && (packet[2] & 0x01)) ||	// rth
				 ((i == 8) && (packet[2] & 0x20)) ||	// picture
				 ((i == 9) && (packet[2] & 0x10))) {	// video
			// set channel to 100% if feature is enabled
			val = CHANNEL_MAX_100;
		}
		bits |= val << bitsavailable;
		bitsavailable += 11;
		while (bitsavailable >= 8) {
			packet_in[idx++] = bits & 0xff;
			bits >>= 8;
			bitsavailable -= 8;
		}
	}
}

void BAYANG_RX_init()
{
	uint8_t i;
	Bayang_Rx_RF_init();
	hopping_frequency_no = 0;
	rx_data_started = false;
	rx_data_received = false;
	
	if (IS_BIND_IN_PROGRESS) {
		phase = BAYANG_RX_BIND;
	}
	else {
		uint16_t temp = BAYANG_RX_EEPROM_OFFSET;
		for (i = 0; i < 5; i++)
			rx_tx_addr[i] = eeprom_read_byte((EE_ADDR)temp++);
		for (i = 0; i < BAYANG_RX_RF_NUM_CHANNELS; i++)
			hopping_frequency[i] = eeprom_read_byte((EE_ADDR)temp++);
		//XN297_HoppingCalib(BAYANG_RX_RF_NUM_CHANNELS);
		XN297_SetTXAddr(rx_tx_addr, BAYANG_RX_ADDRESS_LENGTH);
		XN297_SetRXAddr(rx_tx_addr, BAYANG_RX_PACKET_SIZE);
		phase = BAYANG_RX_DATA;
	}
}

uint16_t BAYANG_RX_callback()
{
	uint8_t i;
	static int8_t read_retry;

	switch (phase)
	{
		case BAYANG_RX_BIND:
			if(IS_BIND_DONE)
			{
				BAYANG_RX_init();	// Abort bind
				break;
			}
			if ( XN297_IsRX() )
			{
				debugln("RX");
				// data received from TX
				if (XN297_ReadPayload(packet, BAYANG_RX_PACKET_SIZE) && ( packet[0] == 0xA4 || packet[0] == 0xA2 ) && Bayang_Rx_check_validity())
				{
					// store tx info into eeprom
					uint16_t temp = BAYANG_RX_EEPROM_OFFSET;
					for (i = 0; i < 5; i++) {
						rx_tx_addr[i] = packet[i + 1];
						eeprom_write_byte((EE_ADDR)temp++, rx_tx_addr[i]);
					}
					for (i = 0; i < 4; i++) {
						hopping_frequency[i] = packet[i + 6];
						eeprom_write_byte((EE_ADDR)temp++, hopping_frequency[i]);
					}
					//XN297_HoppingCalib(BAYANG_RX_RF_NUM_CHANNELS);
					XN297_SetTXAddr(rx_tx_addr, BAYANG_RX_ADDRESS_LENGTH);
					XN297_SetRXAddr(rx_tx_addr, BAYANG_RX_PACKET_SIZE);
					BIND_DONE;
					phase = BAYANG_RX_DATA;
				}
				XN297_SetTxRxMode(RX_EN);
			}
			break;
		case BAYANG_RX_DATA:
			if ( XN297_IsRX() ) {
				if (XN297_ReadPayload(packet, BAYANG_RX_PACKET_SIZE) && packet[0] == 0xA5 && Bayang_Rx_check_validity()) {
					if ((telemetry_link & 0x7F) == 0) {
						Bayang_Rx_build_telemetry_packet();
						telemetry_link = 1;
						#ifdef SEND_CPPM
							if(sub_protocol>0)
								telemetry_link |= 0x80;	// Disable telemetry output
						#endif
					}
					rx_data_started = true;
					rx_data_received = true;
					read_retry = 8;
					pps_counter++;
				}
			}
			// packets per second
			if (millis() - pps_timer >= 1000) {
				pps_timer = millis();
				debugln("%d pps", pps_counter);
				RX_LQI = pps_counter >> 1;
				pps_counter = 0;
			}
			// frequency hopping
			if (read_retry++ >= 8) {
				hopping_frequency_no++;
				if (hopping_frequency_no >= BAYANG_RX_RF_NUM_CHANNELS)
					hopping_frequency_no = 0;
				XN297_Hopping(hopping_frequency_no);
				XN297_SetTxRxMode(RX_EN);
				if (rx_data_started)
				{
					if(rx_data_received)
					{ // In sync
						rx_data_received = false;
						read_retry = 5;
						return 1500;
					}
					else
					{ // packet lost
						read_retry = 0;
						if(RX_LQI==0)	// communication lost
							rx_data_started=false;
					}
				}
				else
					read_retry = -16; // retry longer until first packet is caught
			}
			return 250;
	}
	return 1000;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bayang_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with EAchine H8 mini, H10, BayangToys X6/X7/X9, JJRC JJ850 ...
// Last sync with hexfet new_protocols/bayang_nrf24l01.c dated 2015-12-22

#if defined(BAYANG_NRF24L01_INO)

#include "iface_xn297.h"

#define BAYANG_BIND_COUNT		1000
#define BAYANG_PACKET_PERIOD	2000
#define BAYANG_PACKET_TELEM_PERIOD	5000
#define BAYANG_INITIAL_WAIT		500
#define BAYANG_PACKET_SIZE		15
#define BAYANG_RF_NUM_CHANNELS	4
#define BAYANG_RF_BIND_CHANNEL	0
#define BAYANG_RF_BIND_CHANNEL_X16_AH 10
#define BAYANG_ADDRESS_LENGTH	5

enum BAYANG_FLAGS {
	// flags going to packet[2]
	BAYANG_FLAG_RTH			= 0x01,
	BAYANG_FLAG_HEADLESS	= 0x02, 
	BAYANG_FLAG_FLIP		= 0x08,
	BAYANG_FLAG_VIDEO		= 0x10, 
	BAYANG_FLAG_PICTURE		= 0x20, 
	// flags going to packet[3]
	BAYANG_FLAG_INVERTED	= 0x80,			// inverted flight on Floureon H101
	BAYANG_FLAG_TAKE_OFF	= 0x20,			// take off / landing on X16 AH
	BAYANG_FLAG_EMG_STOP	= 0x04|0x08,	// 0x08 for VISUO XS809H-W-HD-G
};

enum BAYANG_OPTION_FLAGS {
	BAYANG_OPTION_FLAG_TELEMETRY	= 0x01,
	BAYANG_OPTION_FLAG_ANALOGAUX	= 0x02,
};

static void __attribute__((unused)) BAYANG_send_packet()
{
	uint8_t i;
	if (IS_BIND_IN_PROGRESS)
	{
	#ifdef BAYANG_HUB_TELEMETRY
		if(option & BAYANG_OPTION_FLAG_TELEMETRY)
			if(option & BAYANG_OPTION_FLAG_ANALOGAUX)
				packet[0]= 0xA1;	// telemetry and analog aux are enabled
			else
				packet[0]= 0xA3;	// telemetry is enabled
		else if(option & BAYANG_OPTION_FLAG_ANALOGAUX)
				packet[0]= 0xA2;	// analog aux is enabled
			else
	#else
		if(option & BAYANG_OPTION_FLAG_ANALOGAUX)
			packet[0]= 0xA2;		// analog aux is enabled
		else
	#endif
			packet[0]= 0xA4;
		if(sub_protocol==QX100)
			packet[0] = 0x53;

		for(i=0;i<5;i++)
			packet[i+1]=rx_tx_addr[i];
		for(i=0;i<4;i++)
			packet[i+6]=hopping_frequency[i];
		switch (sub_protocol)
		{
			case QX100:
			case X16_AH:
				packet[10] = 0x00;
				packet[11] = 0x00;
				break;
			case IRDRONE:
				packet[10] = 0x30;
				packet[11] = 0x01;
				break;
			case DHD_D4:
				packet[10] = 0xC8;
				packet[11] = 0x99;
				break;
			default:
				packet[10] = rx_tx_addr[0];	// txid[0]
				packet[11] = rx_tx_addr[1];	// txid[1]
				break;
		}
	}
	else
	{
		XN297_Hopping(hopping_frequency_no++);
		hopping_frequency_no%=BAYANG_RF_NUM_CHANNELS;
		uint16_t val;
		uint8_t dyntrim = 1;
		switch (sub_protocol)
		{
			case X16_AH:
			case IRDRONE:
				packet[0] = 0xA6;
				break;
			default:
				packet[0] = 0xA5;
				break;
		}
		if (option & BAYANG_OPTION_FLAG_ANALOGAUX)
		{
			// Analog aux channel 1 (channel 14)
			packet[1] = convert_channel_8b(CH14);
		}
		else
			packet[1] = 0xFA;		// normal mode is 0xF7, expert 0xFa , D4 normal is 0xF4

		//Flags packet[2]
		packet[2] = 0x00;
		if(CH5_SW)
			packet[2] = BAYANG_FLAG_FLIP;
		if(CH6_SW)
			packet[2] |= BAYANG_FLAG_RTH;
		if(CH7_SW)
			packet[2] |= BAYANG_FLAG_PICTURE;
		if(CH8_SW)
			packet[2] |= BAYANG_FLAG_VIDEO;
		if(CH9_SW)
		{
			packet[2] |= BAYANG_FLAG_HEADLESS;
			dyntrim = 0;
		}
		//Flags packet[3]
		packet[3] = 0x00;
		if(CH10_SW)
			packet[3] = BAYANG_FLAG_INVERTED;
		if(CH11_SW)
			dyntrim = 0;
		if(CH12_SW)
		  packet[3] |= BAYANG_FLAG_TAKE_OFF;
		if(CH13_SW)
			packet[3] |= BAYANG_FLAG_EMG_STOP;
		//Aileron
		val = convert_channel_10b(AILERON, false);
		packet[4] = (val>>8) + (dyntrim ? ((val>>2) & 0xFC) : 0x7C);
		packet[5] = val & 0xFF;
		//Elevator
		val = convert_channel_10b(ELEVATOR, false);
		packet[6] = (val>>8) + (dyntrim ? ((val>>2) & 0xFC) : 0x7C);
		packet[7] = val & 0xFF;
		//Throttle
		val = convert_channel_10b(THROTTLE, false);
		packet[8] = (val>>8) + 0x7C;
		packet[9] = val & 0xFF;
		//Rudder
		val = convert_channel_10b(RUDDER, false);
		packet[10] = (val>>8) + (dyntrim ? ((val>>2) & 0xFC) : 0x7C);
		packet[11] = val & 0xFF;
	}
	switch (sub_protocol)
	{
		case H8S3D:
			packet[12] = rx_tx_addr[2];	// txid[2]
			packet[13] = 0x34;
			break;
		case QX100:
		case X16_AH:
			packet[12] = 0;
			packet[13] = 0;
			break;
		case IRDRONE:
			packet[12] = 0xE0;
			packet[13] = 0x2E;
			break;
		case DHD_D4:
			packet[12] = 0x37;	//0x17 during bind
			packet[13] = 0xED;
			break;
		default:
			packet[12] = rx_tx_addr[2];	// txid[2]
			if (option & BAYANG_OPTION_FLAG_ANALOGAUX)
			{	// Analog aux channel 2 (channel 15)
				packet[13] = convert_channel_8b(CH15);
			}
			else
				packet[13] = 0x0A;
			break;
	}
	packet[14] = 0;
	for (uint8_t i=0; i < BAYANG_PACKET_SIZE-1; i++)
		packet[14] += packet[i];

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, BAYANG_PACKET_SIZE);
}

#ifdef BAYANG_HUB_TELEMETRY
static void __attribute__((unused)) BAYANG_check_rx(void)
{
	if( XN297_IsRX() )
	{ // data received from model
		XN297_ReadPayload(packet, BAYANG_PACKET_SIZE);	// Strange can't test the CRC since it seems to be disabled on telemetry packets...
		uint8_t check = packet[0];
		for (uint8_t i=1; i < BAYANG_PACKET_SIZE-1; i++)
			check += packet[i];
		// decode data , check sum is ok as well, since there is no crc
		if (packet[0] == 0x85 && packet[14] == check && telemetry_link == 0)
		{
			// uncompensated battery volts*100/2
			v_lipo1 = (packet[3]<<7) + (packet[4]>>1);
			// compensated battery volts*100/2
			v_lipo2 = (packet[5]<<7) + (packet[6]>>1);
			// reception in packets / sec
			RX_LQI = packet[7];
			RX_RSSI = RX_LQI;
			//Flags
			//uint8_t flags = packet[3] >> 3;
			// battery low: flags & 1
			telemetry_link=1;
			#if defined HUB_TELEMETRY
				// Multiplexed P, I, D values in packet[8] and packet[9].
				// The two most significant bits specify which term is sent.
				// Remaining 14 bits represent the value: 0 .. 16383
				frsky_send_user_frame(0x24+(packet[8]>>6), packet[9], packet[8] & 0x3F );	//0x24 = ACCEL_X_ID, so ACCEL_X_ID=P, ACCEL_Y_ID=I, ACCEL_Z_ID=D
			#endif
			telemetry_counter++;
			if(telemetry_lost)
				telemetry_link=0;	// Don't send anything yet
		}
	}
	XN297_SetTxRxMode(TXRX_OFF);
}
#endif

static void __attribute__((unused)) BAYANG_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t *)"\x00\x00\x00\x00\x00", BAYANG_ADDRESS_LENGTH);
	//XN297_HoppingCalib(BAYANG_RF_NUM_CHANNELS);
	
	//Set bind channel
	uint8_t ch = BAYANG_RF_BIND_CHANNEL;
	if(sub_protocol == X16_AH || sub_protocol == IRDRONE)
		ch = BAYANG_RF_BIND_CHANNEL_X16_AH;
	XN297_RFChannel(ch);
}

enum {
	BAYANG_BIND=0,
	BAYANG_WRITE,
	BAYANG_CHECK,
	BAYANG_READ,
};

#define BAYANG_CHECK_DELAY		1000		// Time after write phase to check write complete
#define BAYANG_READ_DELAY		600			// Time before read phase

uint16_t BAYANG_callback()
{
	#ifdef BAYANG_HUB_TELEMETRY
		uint16_t start;
	#endif
	switch(phase)
	{
		case BAYANG_BIND:
			if (--bind_counter == 0)
			{
				XN297_SetTXAddr(rx_tx_addr, BAYANG_ADDRESS_LENGTH);
				#ifdef BAYANG_HUB_TELEMETRY
					XN297_SetRXAddr(rx_tx_addr, BAYANG_PACKET_SIZE);
				#endif
				BIND_DONE;
				phase++;	//WRITE
			}
			else
				BAYANG_send_packet();
			break;
		case BAYANG_WRITE:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync((option & BAYANG_OPTION_FLAG_TELEMETRY)?BAYANG_PACKET_TELEM_PERIOD:BAYANG_PACKET_PERIOD);
			#endif
			BAYANG_send_packet();
			#ifdef BAYANG_HUB_TELEMETRY
				if (option & BAYANG_OPTION_FLAG_TELEMETRY)
				{	// telemetry is enabled
					state++;
					if (state > 200)
					{
						state = 0;
						//telemetry reception packet rate - packets per second
						TX_LQI = telemetry_counter>>1;
						telemetry_counter = 0;
						telemetry_lost=0;
					}
					phase++;	//CHECK
					return BAYANG_CHECK_DELAY;
				}
			#endif
			break;
	#ifdef BAYANG_HUB_TELEMETRY
		case BAYANG_CHECK:
			// switch radio to rx as soon as packet is sent
			start=(uint16_t)micros();
			while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 1000)			// Wait max 1ms
				if(XN297_IsPacketSent())
					break;
			XN297_SetTxRxMode(RX_EN);
			phase++;	// READ
			return BAYANG_PACKET_TELEM_PERIOD - BAYANG_CHECK_DELAY - BAYANG_READ_DELAY;
		case BAYANG_READ:
			BAYANG_check_rx();
			phase=BAYANG_WRITE;
			return BAYANG_READ_DELAY;
	#endif
	}
	return BAYANG_PACKET_PERIOD;
}

static void __attribute__((unused)) BAYANG_initialize_txid()
{
	//Could be using txid[0..2] but using rx_tx_addr everywhere instead...
	if(sub_protocol==DHD_D4)
		hopping_frequency[0]=(rx_tx_addr[2]&0x07)|0x01;
	else
		hopping_frequency[0]=0;
	hopping_frequency[1]=(rx_tx_addr[3]&0x1F)+0x10;
	hopping_frequency[2]=hopping_frequency[1]+0x20;
	hopping_frequency[3]=hopping_frequency[2]+0x20;
	hopping_frequency_no=0;
}

void BAYANG_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
	phase=BAYANG_BIND;
    bind_counter = BAYANG_BIND_COUNT;
	BAYANG_initialize_txid();
	BAYANG_RF_init();
	packet_count=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Binary_Signature.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

/************************/
/** Firmware Signature **/
/************************/

/*
The firmware signature is appended to the compiled binary image in order to provide information
about the options used to compile the firmware file.  This information is then used by Multi-module 
flashing tools to verify that the image is correct / valid.

In order for the build process to determine the options used to build the firmware this file conditionally
declares 'flag' variables for the options we are interested in.

When the pre-compiler parses the source code these variables are either present or not in the parsed cpp file,
typically '$build_dir$/preproc/ctags_target_for_gcc_minus_e.cpp'.

Once the .bin file is created an additional command-line build tool scans the parsed cpp file, detects the
flags, assembles the signature, and finally appends the signature to the end of the binary file.

The signature is 24 bytes long:
multi-x[8-byte hex code]-[8-byte version number]

For example:
multi-x1234abcd-01020199

The 8-byte hex code is a 32-bit bitmask value indicating the configuration options, currently:

Bit(s)  Bitmask    Option                  Comment
1-2     0x3        Module type             Read as a two-bit value indicating a number from 0-3 which maps to a module type (AVR, STM32, OrangeRX)
3-7     0x7C       Channel order           Read as a five-bit value indicating a number from 0-23 which maps to as channel order (AETR, TAER, RETA, etc) (right-shift two bits to read)
8       0x80       Bootloader support      Indicates whether or not the firmware was built with support for the bootloader
9       0x100      CHECK_FOR_BOOTLOADER    Indicates if CHECK_FOR_BOOTLOADER is defined
10      0x200      INVERT_TELEMETRY        Indicates if INVERT_TELEMETRY is defined
11      0x400      MULTI_STATUS            Indicates if MULTI_STATUS is defined
12      0x800      MULTI_TELEMETRY         Indicates if MULTI_TELEMETRY is defined
13      0x1000     DEBUG_SERIAL            Indicates if DEBUG_SERIAL is defined
14-16   0xE000     Module sub-type         Reads as a three-bit value indicating a number from 0-7 which maps to a module sub-type (right-shift 13 bits to read)

The 8-byte version number is the version number zero-padded to a fixed width of two-bytes per segment and no separator.  
E.g. 1.2.3.45 becomes 01020345.

Multi Telemetery Type can be read from bits 11 and 12 using the bitmask 0xC00 and right-shifting ten bits:
Telemetry Type    Decimal Value   Binary Value
Undefined         0               00
erSkyTX           1               01
OpenTX            2               10

Module types are mapped to the following decimal / binary values:
Module Type       Decimal Value   Binary Valsue
AVR (Atmega328p)  0               00
STM32 (F103)      1               01
OrangeRX (Xmega)  2               10

Module sub-type is currently used for STM32F103 only and is mapped as follows:
Module Type       Sub Type        Decimal Value    Binary Value
STM32 (F103)      STM32F103CB     0                000
STM32 (F103)      STM32F103C8     1                001
STM32 (F103)      T18 5in1        2                010

Channel orders are mapped to the following decimal / binary values:
Channel Order	  Decimal Value	  Binary Value
AETR	          0	              00000
AERT	          1	              00001
ARET	          2	              00010
ARTE	          3	              00011
ATRE	          4	              00100
ATER	          5	              00101
EATR	          6	              00110
EART	          7	              00111
ERAT	          8	              01000
ERTA	          9	              01001
ETRA	          10	          01010
ETAR	          11	          01011
TEAR	          12	          01100
TERA	          13	          01101
TREA	          14	          01110
TRAE	          15	          01111
TARE	          16	          10000
TAER	          17	          10001
RETA	          18	          10010
REAT	          19	          10011
RAET	          20	          10100
RATE	          21	          10101
RTAE	          22	          10110
RTEA	          23	          10111
*/
 
// Set the flags for detecting and writing the firmware signature
#if defined (CHECK_FOR_BOOTLOADER)
    bool firmwareFlag_CHECK_FOR_BOOTLOADER = true;
#endif
#if defined (INVERT_TELEMETRY)
    bool firmwareFlag_INVERT_TELEMETRY = true;
#endif
#if defined (MULTI_STATUS)
    bool firmwareFlag_MULTI_STATUS = true;
#endif
#if defined (MULTI_TELEMETRY)
    bool firmwareFlag_MULTI_TELEMETRY = true;
#endif
#if defined (DEBUG_SERIAL)
    bool firmwareFlag_DEBUG_SERIAL = true;
#endif

// STM32 Module sub-type flags
#if defined (MCU_STM32F103CB)
    bool firmwareFlag_MCU_STM32F103CB = true;
#endif
#if defined (MCU_STM32F103C8)
    bool firmwareFlag_MCU_STM32F103C8 = true;
#endif
#if defined (MULTI_5IN1_INTERNAL)
    bool firmwareFlag_MULTI_5IN1_INTERNAL = true;
#endif

// Channel order flags
#if defined (AETR)
    bool firmwareFlag_ChannelOrder_AETR = true;
#endif
#if defined (AERT)
    bool firmwareFlag_ChannelOrder_AERT = true;
#endif
#if defined (ARET)
    bool firmwareFlag_ChannelOrder_ARET = true;
#endif
#if defined (ARTE)
    bool firmwareFlag_ChannelOrder_ARTE = true;
#endif
#if defined (ATRE)
    bool firmwareFlag_ChannelOrder_ATRE = true;
#endif
#if defined (ATER)
    bool firmwareFlag_ChannelOrder_ATER = true;
#endif
#if defined (EATR)
    bool firmwareFlag_ChannelOrder_EATR = true;
#endif
#if defined (EART)
    bool firmwareFlag_ChannelOrder_EART = true;
#endif
#if defined (ERAT)
    bool firmwareFlag_ChannelOrder_ERAT = true;
#endif
#if defined (ERTA)
    bool firmwareFlag_ChannelOrder_ERTA = true;
#endif
#if defined (ETRA)
    bool firmwareFlag_ChannelOrder_ETRA = true;
#endif
#if defined (ETAR)
    bool firmwareFlag_ChannelOrder_ETAR = true;
#endif
#if defined (TEAR)
    bool firmwareFlag_ChannelOrder_TEAR = true;
#endif
#if defined (TERA)
    bool firmwareFlag_ChannelOrder_TERA = true;
#endif
#if defined (TREA)
    bool firmwareFlag_ChannelOrder_TREA = true;
#endif
#if defined (TRAE)
    bool firmwareFlag_ChannelOrder_TRAE = true;
#endif
#if defined (TARE)
    bool firmwareFlag_ChannelOrder_TARE = true;
#endif
#if defined (TAER)
    bool firmwareFlag_ChannelOrder_TAER = true;
#endif
#if defined (RETA)
    bool firmwareFlag_ChannelOrder_RETA = true;
#endif
#if defined (REAT)
    bool firmwareFlag_ChannelOrder_REAT = true;
#endif
#if defined (RAET)
    bool firmwareFlag_ChannelOrder_RAET = true;
#endif
#if defined (RATE)
    bool firmwareFlag_ChannelOrder_RATE = true;
#endif
#if defined (RTAE)
    bool firmwareFlag_ChannelOrder_RTAE = true;
#endif
#if defined (RTEA)
    bool firmwareFlag_ChannelOrder_RTEA = true;
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bluefly_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with BLUEFLY HP100

#if defined(BLUEFLY_CCNRF_INO)

#include "iface_nrf250k.h"

#define BLUEFLY_PACKET_PERIOD		6000
#define BLUEFLY_PACKET_SIZE			12
#define BLUEFLY_RF_BIND_CHANNEL		81
#define BLUEFLY_NUM_RF_CHANNELS		15
#define BLUEFLY_BIND_COUNT			800
#define BLUEFLY_TXID_SIZE			5

static void __attribute__((unused)) BLUEFLY_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		memset(packet, 0x55, BLUEFLY_PACKET_SIZE);
		memcpy(packet, rx_tx_addr, BLUEFLY_TXID_SIZE);
		packet[5] = hopping_frequency[0];
	}
	else
	{
		NRF250K_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		if(hopping_frequency_no >= BLUEFLY_NUM_RF_CHANNELS);
			hopping_frequency_no = 0;

		packet[8] = packet[9] = 0;
		for(uint8_t i=0; i<8 ; i++)
		{
			uint16_t ch = convert_channel_16b_limit(CH_AETR[i], 0, 1000);
			packet[ i] = ch;
			ch &= 0x300;
			ch >>= 2;
			packet[8 + (i>3?0:1)] = (packet[8 + (i>3?0:1)] >> 2) | ch;
		}
		// Checksum
		uint8_t l, h, t;
		l = h = 0xff;
		for (uint8_t i=0; i<10; ++i)
		{
			h ^= packet[i];
			h ^= h >> 4;
			t = h;
			h = l;
			l = t;
			t = (l<<4) | (l>>4);
			h ^= ((t<<2) | (t>>6)) & 0x1f;
			h ^= t & 0xf0;
			l ^= ((t<<1) | (t>>7)) & 0xe0;
		}
		packet[10] = h; 
		packet[11] = l;
	}
	
	NRF250K_WritePayload(packet, BLUEFLY_PACKET_SIZE);
	NRF250K_SetPower();				// Set tx_power
	NRF250K_SetFreqOffset();		// Set frequency offset
}

static void __attribute__((unused)) BLUEFLY_RF_init()
{
	NRF250K_Init();
	NRF250K_SetTXAddr((uint8_t *)"\x32\xAA\x45\x45\x78", BLUEFLY_TXID_SIZE);	// BLUEFLY Bind address
	NRF250K_HoppingCalib(BLUEFLY_NUM_RF_CHANNELS);								// Calibrate all channels
	NRF250K_RFChannel(BLUEFLY_RF_BIND_CHANNEL);									// Set bind channel
}

static void __attribute__((unused)) BLUEFLY_initialize_txid()
{
    uint8_t start = (rx_tx_addr[3] % 47) + 2;
	for(uint8_t i=0;i<BLUEFLY_NUM_RF_CHANNELS;i++)
		hopping_frequency[i] = start + i*2;
	hopping_frequency_no=0;
}

uint16_t BLUEFLY_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(BLUEFLY_PACKET_PERIOD);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			BIND_DONE;
			NRF250K_SetTXAddr(rx_tx_addr, BLUEFLY_TXID_SIZE);
		}
	}
	BLUEFLY_send_packet();
	return	BLUEFLY_PACKET_PERIOD;
}

void BLUEFLY_init(void)
{
	BLUEFLY_initialize_txid();
	BLUEFLY_RF_init();

	bind_counter = IS_BIND_IN_PROGRESS ? BLUEFLY_BIND_COUNT : 1;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Bugs_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
 
#ifdef BUGS_A7105_INO

//////////// rxid -> radioid algorithm //////////////////////////////
// Hex digit 1 is periodic with length 2, and hex digit 2 is periodic
// with length 16. However, storing the byte of those 2 digits
// instead of manipulating bits results simpler code and smaller binary.
const uint8_t PROGMEM BUGS_most_popular_67_cycle[]= {
	0x34, 0xc5, 0x6a, 0xb4, 0x29, 0xd5, 0x2c, 0xd3, 0x91, 0xb3, 0x6c, 0x49,
	0x52, 0x9c, 0x4d, 0x65, 0xc3, 0x4a, 0x5b, 0xd6, 0x92, 0x6d, 0x94, 0xa6,
	0x55, 0xcd, 0x2b, 0x9a, 0x36, 0x95, 0x4b, 0xd4, 0x35, 0x8d, 0x96, 0xb2,
	0xa3 };

static uint8_t __attribute__((unused)) BUGS_most_popular_67(uint8_t i)
{
	uint8_t ii;
	if (i == 0)
		return 0xd2;
	else if (i == 1)
		return 0xda;
	else if (i % 16 < 2)
	{
		ii = 2 * (i / 16) + i % 16 - 2;
		if (ii % 2 == 0)
			ii += 7;
	}
	else
		ii=2 * (i / 16) + (i % 16 - 2) % 7;
	return pgm_read_byte_near( &BUGS_most_popular_67_cycle[ii]);
}

static uint8_t __attribute__((unused)) BUGS_most_popular_45(uint8_t i)
{
	if (i == 0)
		return 0xa3;
	else if (i == 1)
		return 0x86;
	else
	{
		if (i % 8 == 1)
			i -= 8;
		else
			i--;
		return BUGS_most_popular_67(i);
	}
}

static uint8_t __attribute__((unused)) BUGS_most_popular_23(uint8_t i)
{
	if (i == 0)
		return 0xb2;
	else if (i == 1)
		return 0xcb;
	else
	{
		if (i % 8 == 1)
			i -= 8;
		else
			i--;
		return BUGS_most_popular_45(i);
	}
}

const uint8_t PROGMEM BUGS_most_popular_01[] = {
	0x52, 0xac, 0x59, 0xa4, 0x53, 0xab, 0x57, 0xa9,
    0x56, 0xa5, 0x5b, 0xa7, 0x5d, 0xa6, 0x58, 0xad};

static uint32_t __attribute__((unused)) BUGS_most_popular(uint8_t i)
{
	i += !(i <= 127);
	uint8_t mp01=pgm_read_byte_near( &BUGS_most_popular_01[i % 16] );
	return (uint32_t) mp01 << 24 |
		(uint32_t) BUGS_most_popular_23(i) << 16 |
		(uint32_t) BUGS_most_popular_45(i) << 8 |
		BUGS_most_popular_67(i);
}

static uint32_t __attribute__((unused)) BUGS_second_most_popular(uint8_t i)
{
	if (i < 127)
		return BUGS_most_popular(i + 1);
	else if (i > 128)
		return BUGS_most_popular(i - 1);
	else
		return 0x52d6926d;
}

// The 22 irregular values do not match the above periodicities. They might be
// errors from the readout, but let us try them here as long as it is not
// proven.
#define BUGS_NBR_IRREGULAR 22
const uint16_t PROGMEM BUGS_irregular_keys[BUGS_NBR_IRREGULAR] = {
	1131, 1287, 2842, 4668, 5311, 11594, 13122, 13813,
	20655, 22975, 25007, 25068, 28252, 33309, 35364, 35765,
	37731, 40296, 43668, 46540, 49868, 65535 };

const uint32_t PROGMEM BUGS_irregular_values[BUGS_NBR_IRREGULAR] = {
	0x52d6926d, 0xa586da34, 0x5329d52c, 0xa66c4952,
	0x536c4952, 0x524a5bd6, 0x534d65c3, 0xa9d391b3,
	0x5249529c, 0xa555cd2b, 0xac9a3695, 0x58d391b3,
	0xa791b36c, 0x53926d94, 0xa7926d94, 0xa72cd391,
	0xa9b429d5, 0x5629d52c, 0xad2b9a36, 0xa74d65c3,
	0x526d94a6, 0xad96b2a3 };

static uint32_t __attribute__((unused)) BUGS_is_irregular(uint16_t i)
{
	for (uint8_t j = 0; j < BUGS_NBR_IRREGULAR; ++j)
		if (pgm_read_word_near( &BUGS_irregular_keys[j]) == i)
			return pgm_read_dword_near( &BUGS_irregular_values[j]);
	return 0;
}

static uint32_t __attribute__((unused)) BUGS_rxid_to_radioid(uint16_t rxid)
{
	uint8_t block = rxid / 256;
	uint8_t second_seq_size;
	bool use_most_popular;

	if (rxid < 32768)
	{
		second_seq_size = 128 - block;
		use_most_popular = rxid % 256 >= second_seq_size;
	}
	else
	{
		second_seq_size = block - 127;
		use_most_popular = 255 - rxid % 256 >= second_seq_size;
	}
	uint32_t v = BUGS_is_irregular(rxid);
	if (!v)
	{
		if (use_most_popular)
			v = BUGS_most_popular(rxid % 255);
		else
			v = BUGS_second_most_popular(rxid % 255);
	}
	return v;
}
//////////// rxid -> radioid algorithm //////////////////////////////

// For code readability
#define BUGS_CH_SW_ARM		CH5_SW
#define BUGS_CH_SW_ANGLE	CH6_SW
#define BUGS_CH_SW_FLIP		CH7_SW
#define BUGS_CH_SW_PICTURE	CH8_SW
#define BUGS_CH_SW_VIDEO	CH9_SW
#define BUGS_CH_SW_LED		CH10_SW

// flags packet byte 4
#define BUGS_FLAG_FLIP		0x08    // automatic flip
#define BUGS_FLAG_MODE		0x04    // low/high speed select (set is high speed)
#define BUGS_FLAG_VIDEO		0x02    // toggle video
#define BUGS_FLAG_PICTURE	0x01    // toggle picture

// flags packet byte 5
#define BUGS_FLAG_LED		0x80    // enable LEDs
#define BUGS_FLAG_ARM		0x40    // arm (toggle to turn on motors)
#define BUGS_FLAG_DISARM	0x20    // disarm (toggle to turn off motors)
#define BUGS_FLAG_ANGLE		0x04    // angle/acro mode (set is angle mode)

#define BUGS_PACKET_SIZE	22
#define BUGS_NUM_RFCHAN		16

enum {
	BUGS_BIND_1,
	BUGS_BIND_2,
	BUGS_BIND_3,
	BUGS_DATA_1,
	BUGS_DATA_2,
	BUGS_DATA_3,
};

static void __attribute__((unused)) BUGS_check_arming()
{
	uint8_t arm_channel = BUGS_CH_SW_ARM;

	if (arm_channel != arm_channel_previous)
	{
		arm_channel_previous = arm_channel;
		if (arm_channel)
		{
			armed = 1;
			arm_flags ^= BUGS_FLAG_ARM;
		}
		else
		{
			armed = 0;
			arm_flags ^= BUGS_FLAG_DISARM;
		}
	}
}

static void __attribute__((unused)) BUGS_build_packet(uint8_t bind)
{
	uint8_t force_values = bind | !armed;
	uint8_t change_channel = ((packet_count & 0x1) << 6);
	uint16_t aileron  = convert_channel_16b_limit(AILERON,800,0);
	uint16_t elevator = convert_channel_16b_limit(ELEVATOR,800,0);
	uint16_t throttle = convert_channel_16b_limit(THROTTLE,0,800);
	uint16_t rudder   = convert_channel_16b_limit(RUDDER,800,0);

	memset(packet, 0, BUGS_PACKET_SIZE);
	packet[1] = 0x76;		// txid (rx uses to know hopping frequencies)
	packet[2] = 0x71;
	packet[3] = 0x94;

	BUGS_check_arming();	// sets globals arm_flags and armed
	if(bind)
	{
		packet[4] = change_channel | 0x80;
		packet[5] = 0x02 | arm_flags
		| GET_FLAG(BUGS_CH_SW_ANGLE, BUGS_FLAG_ANGLE);
	}
	else
	{
		packet[4] = change_channel | BUGS_FLAG_MODE
		| GET_FLAG(BUGS_CH_SW_FLIP, BUGS_FLAG_FLIP)
		| GET_FLAG(BUGS_CH_SW_PICTURE, BUGS_FLAG_PICTURE)
		| GET_FLAG(BUGS_CH_SW_VIDEO, BUGS_FLAG_VIDEO);
		packet[5] = 0x02 | arm_flags
		| GET_FLAG(BUGS_CH_SW_ANGLE, BUGS_FLAG_ANGLE)
		| GET_FLAG(BUGS_CH_SW_LED, BUGS_FLAG_LED);
	}

	packet[6] = force_values ? 100 : (aileron  >> 2);
	packet[7] = force_values ? 100 : (elevator >> 2);
	packet[8] = force_values ?   0 : (throttle >> 2);
	packet[9] = force_values ? 100 : (rudder   >> 2);
	packet[10] = 100;
	packet[11] = 100;
	packet[12] = 100;
	packet[13] = 100;

	packet[14] = ((aileron  << 6) & 0xc0)
	| ((elevator << 4) & 0x30)
	| ((throttle << 2) & 0x0c)
	| ((rudder       ) & 0x03);

	//    packet[15] = 0;

	// driven trims
	packet[16] = aileron / 8 + 14;
	packet[17] = elevator / 8 + 14;
	packet[18] = 64;
	packet[19] = rudder / 8 + 14;

	//    packet[20] = 0;
	//    packet[21] = 0;

    uint8_t check = 0x6d;
    for (uint8_t i=1; i < BUGS_PACKET_SIZE; i++)
        check ^= packet[i];
	packet[0] = check;
}

const uint8_t PROGMEM BUGS_hop []= {
		0x1d, 0x3b, 0x4d, 0x29, 0x11, 0x2d, 0x0b, 0x3d, 0x59, 0x48, 0x17, 0x41, 0x23, 0x4e, 0x2a, 0x63,	// bind phase ID=0xac59a453
		0x4b, 0x19, 0x35, 0x1e, 0x63, 0x0f, 0x45, 0x21, 0x51, 0x3a, 0x5d, 0x25, 0x0a, 0x44, 0x61, 0x27,	// data phase ID=0xA4C56AB4 for txid 767194 if rx responds C6 BB 57 7F 00 00 00 00 00 00 FF 87 40 00 00 00
	};

static void  __attribute__((unused))BUGS_set_radio_data()
{	// captured radio data for bugs rx/tx version A2
	// it appears that the hopping frequencies are determined by the txid
	// and the data phase radio id is determined by the first 2 bytes of the
	// rx bind packet
	uint8_t offset=0;
	uint32_t radio_id=0xac59a453;	// bind phase ID=0xac59a453

	if(IS_BIND_DONE)
	{
		offset=BUGS_NUM_RFCHAN;
		// Read radio_id from EEPROM
		uint8_t base_adr=BUGS_EEPROM_OFFSET+(RX_num&0x0F)*2;
		uint16_t rxid=0;
		for(uint8_t i=0; i<2; i++)
			rxid|=eeprom_read_byte((EE_ADDR)(base_adr+i))<<(i*8);
		radio_id = BUGS_rxid_to_radioid(rxid);
	}
	A7105_WriteID(radio_id);

	for(uint8_t i=0; i<BUGS_NUM_RFCHAN;i++)
		hopping_frequency[i]=pgm_read_byte_near( &BUGS_hop[i+offset] );
}

static void __attribute__((unused)) BUGS_increment_counts()
{	// this logic works with the use of packet_count in BUGS_build_packet
	// to properly indicate channel changes to rx
	packet_count += 1;
	if ((packet_count & 1) == 0)
	{
		hopping_frequency_no += 1;
		hopping_frequency_no %= BUGS_NUM_RFCHAN;
	}
}

#define BUGS_PACKET_PERIOD   6100
#define BUGS_DELAY_TX        2000
#define BUGS_DELAY_POST_RX   1500
#define BUGS_DELAY_BIND_RST   200

// FIFO config is one less than desired value
#define BUGS_FIFO_SIZE_RX      15
#define BUGS_FIFO_SIZE_TX      21
uint16_t BUGS_callback(void)
{
	uint8_t mode, base_adr;
	uint16_t rxid;
	uint16_t start;

	// keep frequency tuning updated
	#ifndef FORCE_FLYSKY_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif

	switch(phase)
	{
		case BUGS_BIND_1:
			BUGS_build_packet(1);
			A7105_Strobe(A7105_STANDBY);
			A7105_WriteReg(A7105_03_FIFOI, BUGS_FIFO_SIZE_TX);
			A7105_WriteData(BUGS_PACKET_SIZE, hopping_frequency[hopping_frequency_no]);
			phase = BUGS_BIND_2;
			packet_period = BUGS_DELAY_TX;
			break;

		case BUGS_BIND_2:
			//Wait for TX completion
			start=micros();
			while ((uint16_t)((uint16_t)micros()-start) < 500)			// Wait max 500s, using serial+telemetry exit in about 60s
				if(!(A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			A7105_SetTxRxMode(RX_EN);
			A7105_WriteReg(A7105_0F_PLL_I, hopping_frequency[hopping_frequency_no] - 2);
			A7105_WriteReg(A7105_03_FIFOI, BUGS_FIFO_SIZE_RX);
			A7105_Strobe(A7105_RX);

			BUGS_increment_counts();
			phase = BUGS_BIND_3;
			packet_period = BUGS_PACKET_PERIOD-BUGS_DELAY_TX-BUGS_DELAY_POST_RX;
			break;

		case BUGS_BIND_3:
			mode = A7105_ReadReg(A7105_00_MODE);
			A7105_Strobe(A7105_STANDBY);
			A7105_SetTxRxMode(TX_EN);
			if (mode & 0x01)
			{
				phase = BUGS_BIND_1;
				packet_period = BUGS_DELAY_BIND_RST;         // No received data so restart binding procedure.
				break;
			}
			A7105_ReadData(16);
			if ((packet[0] + packet[1] + packet[2] + packet[3]) == 0)
			{
				phase = BUGS_BIND_1;
				packet_period = BUGS_DELAY_BIND_RST;         // No received data so restart binding procedure.
				break;
			}
			A7105_Strobe(A7105_STANDBY);
			BIND_DONE;
			// set radio_id
			rxid = (packet[1] << 8) + packet[2];
			base_adr=BUGS_EEPROM_OFFSET+(RX_num&0x0F)*2;
			for(uint8_t i=0; i<2; i++)
				eeprom_write_byte((EE_ADDR)(base_adr+i),rxid>>(i*8));	// Save rxid in EEPROM
			BUGS_set_radio_data();
			phase = BUGS_DATA_1;
			packet_count = 0;
			hopping_frequency_no = 0;
			packet_period = BUGS_DELAY_POST_RX;
			break;

		case BUGS_DATA_1:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(BUGS_PACKET_PERIOD);
			#endif
			A7105_SetPower();
			BUGS_build_packet(0);
			A7105_WriteReg(A7105_03_FIFOI, BUGS_FIFO_SIZE_TX);
			A7105_WriteData(BUGS_PACKET_SIZE, hopping_frequency[hopping_frequency_no]);
			phase = BUGS_DATA_2;
			packet_period = BUGS_DELAY_TX;
			break;

		case BUGS_DATA_2:
			//Wait for TX completion
			start=micros();
			while ((uint16_t)((uint16_t)micros()-start) < 500)			// Wait max 500s, using serial+telemetry exit in about 60s
				if(!(A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			A7105_SetTxRxMode(RX_EN);
			A7105_WriteReg(A7105_0F_PLL_I, hopping_frequency[hopping_frequency_no] - 2);
			A7105_WriteReg(A7105_03_FIFOI, BUGS_FIFO_SIZE_RX);
			A7105_Strobe(A7105_RX);

			BUGS_increment_counts();
			phase = BUGS_DATA_3;
			packet_period = BUGS_PACKET_PERIOD-BUGS_DELAY_TX-BUGS_DELAY_POST_RX;
			break;

		case BUGS_DATA_3:
			mode = A7105_ReadReg(A7105_00_MODE);
			A7105_Strobe(A7105_STANDBY);
			A7105_SetTxRxMode(TX_EN);
			if (!(mode & 0x01))
			{
				A7105_ReadData(16);
				#if defined(BUGS_HUB_TELEMETRY)
					v_lipo1=packet[10] == 0xff ? 0xff : 0x00;					// Voltage in this case is only an alert on level good or bad.
					RX_RSSI=packet[3];
					// Read TX RSSI
					int16_t temp=256-(A7105_ReadReg(A7105_1D_RSSI_THOLD)*8)/5;	// Value from A7105 is between 8 for maximum signal strength to 160 or less
					if(temp<0) temp=0;
					else if(temp>255) temp=255;
					TX_RSSI=temp;
					telemetry_link=1;
				#endif
			}
			phase = BUGS_DATA_1;
			packet_period = BUGS_DELAY_POST_RX;
			break;
	}
	return packet_period;
}

void BUGS_init(void)
{
	uint16_t rxid=0;
	uint8_t base_adr=BUGS_EEPROM_OFFSET+(RX_num&0x0F)*2;
	for(uint8_t i=0; i<2; i++)
		rxid|=eeprom_read_byte((EE_ADDR)(base_adr+i))<<(i*8);
	if(rxid==0xffff)
		BIND_IN_PROGRESS;

	BUGS_set_radio_data();
	if (IS_BIND_IN_PROGRESS)
		phase = BUGS_BIND_1;
	else
		phase = BUGS_DATA_1;

	A7105_Init();

	hopping_frequency_no = 0;
	packet_count = 0;
	armed = 0;
	arm_flags = BUGS_FLAG_DISARM;		// initial value from captures
	arm_channel_previous = BUGS_CH_SW_ARM;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CABELL_nrf224l01.ino"
/*
 Protocol by Dennis Cabell, 2017
 KE8FZX
  
 To use this software, you must adhere to the license terms described below, and assume all responsibility for the use
 of the software.  The user is responsible for all consequences or damage that may result from using this software.
 The user is responsible for ensuring that the hardware used to run this software complies with local regulations and that 
 any radio signal generated or received from use of this software is legal for that user to generate.  The author(s) of this software 
 assume no liability whatsoever.  The author(s) of this software is not responsible for legal or civil consequences of 
 using this software, including, but not limited to, any damages cause by lost control of a vehicle using this software.  
 If this software is copied or modified, this disclaimer must accompany all copies.
 
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
 
// The Receiver for this protocol is available at: https://github.com/soligen2010/RC_RX_CABELL_V3_FHSS

#if defined(CABELL_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define CABELL_BIND_COUNT		2000		// At least 2000 so that if TX toggles the serial bind flag then bind mode is never exited
#define CABELL_PACKET_PERIOD	3000		// Do not set too low or else next packet may not be finished transmitting before the channel is changed next time around

#define CABELL_NUM_CHANNELS		16			// The maximum number of RC channels that can be sent in one packet
#define CABELL_MIN_CHANNELS		4			// The minimum number of channels that must be included in a packet, the number of channels cannot be reduced any further than this
#define CABELL_PAYLOAD_BYTES	24			// 12 bits per value * 16 channels

#define CABELL_RADIO_CHANNELS			9	// This is 1/5 of the total number of radio channels used for FHSS
#define CABELL_RADIO_MIN_CHANNEL_NUM	3	// Channel 0 is right on the boarder of allowed frequency range, so move up to avoid bleeding over
#define CABELL_TELEMETRY_PACKET_LENGTH	4

#define CABELL_BIND_RADIO_ADDR	0xA4B7C123F7LL

#define CABELL_OPTION_MASK_CHANNEL_REDUCTION		0x0F
#define CABELL_OPTION_MASK_RECIEVER_OUTPUT_MODE		0x30
#define CABELL_OPTION_SHIFT_RECIEVER_OUTPUT_MODE	4
#define CABELL_OPTION_MASK_MAX_POWER_OVERRIDE		0x40

typedef struct
{
   enum RxMode_t : uint8_t
   {   // Note bit 8 is used to indicate if the packet is the first of 2 on the channel.  Mask out this bit before using the enum
         normal                 = 0,
         bind                   = 1,
         setFailSafe            = 2,
         normalWithTelemetry    = 3,
         telemetryResponse      = 4,
         unBind                 = 127
   } RxMode;
   uint8_t reserved = 0;
   uint8_t option;
                          /*   mask 0x0F    : Channel reduction.  The number of channels to not send (subtracted from the 16 max channels) at least 4 are always sent
                           *   mask 0x30>>4 : Receiver output mode
                           *                  0 (00) = Single PPM on individual pins for each channel 
                           *                  1 (01) = SUM PPM on channel 1 pin
                           *                  2 (10) = Future use.  Reserved for SBUS output
                           *                  3 (11) = Unused
                           *   mask 0x40>>6   Contains max power override flag for Multi-protocol TX module. Also sent to RX
                           *   mask 0x80>>7   Unused 
                           */  
   uint8_t modelNum;
   uint8_t checkSum_LSB; 
   uint8_t checkSum_MSB; 
   uint8_t payloadValue [CABELL_PAYLOAD_BYTES] = {0}; //12 bits per channel value, unsigned
} CABELL_RxTxPacket_t;   

//-----------------------------------------------------------------------------------------
static uint8_t __attribute__((unused)) CABELL_getNextChannel (uint8_t seqArray[], uint8_t seqArraySize, uint8_t prevChannel)
{
	/* Possible channels are in 5 bands, each band comprised of seqArraySize channels
	* seqArray contains seqArraySize elements in the relative order in which we should progress through the band 
	* 
	* Each time the channel is changes, bands change in a way so that the next channel will be in a
	* different non-adjacent band. Both the band changes and the index in seqArray is incremented.
	*/
	prevChannel -= CABELL_RADIO_MIN_CHANNEL_NUM;				// Subtract CABELL_RADIO_MIN_CHANNEL_NUM because it was added to the return value
	if(prevChannel>(seqArraySize * 5))
		prevChannel=seqArraySize * 5;							// Constrain the values just in case something bogus was sent in.

	uint8_t currBand = prevChannel / seqArraySize;             
	uint8_t nextBand = (currBand + 3) % 5;

	uint8_t prevChannalSeqArrayValue = prevChannel % seqArraySize;
	uint8_t prevChannalSeqArrayPosition = 0;
	for (int x = 0; x < seqArraySize; x++)
	{	// Find the position of the previous channel in the array
		if (seqArray[x] == prevChannalSeqArrayValue)
			prevChannalSeqArrayPosition = x;
	}
	uint8_t nextChannalSeqArrayPosition = prevChannalSeqArrayPosition + 1;
	if (nextChannalSeqArrayPosition >= seqArraySize)
		nextChannalSeqArrayPosition = 0;

	return (seqArraySize * nextBand) + seqArray[nextChannalSeqArrayPosition] + CABELL_RADIO_MIN_CHANNEL_NUM;	// Add CABELL_RADIO_MIN_CHANNEL_NUM so we dont use channel 0 as it may bleed below 2.400 GHz
}

//-----------------------------------------------------------------------------------------
#if defined CABELL_HUB_TELEMETRY 
static void __attribute__((unused)) CABELL_get_telemetry()
{
	// calculate TX rssi based on past 250 expected telemetry packets.  Cannot use full second count because telemetry_counter is not large enough
	state++;
	if (state > 250)
	{
		TX_RSSI = telemetry_counter;
		telemetry_counter = 0;
		state = 0;
		telemetry_lost=0;
	}

	// Process incoming telemetry packet of it was received
	if (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR)) 
	{ // data received from model
		NRF24L01_ReadPayload(packet, CABELL_TELEMETRY_PACKET_LENGTH);
		if ((packet[0] & 0x7F) == CABELL_RxTxPacket_t::telemetryResponse)	// ignore high order bit in compare because it toggles with each packet
		{
			RX_RSSI = packet[1];	// Packet rate 0 to 255 where 255 is 100% packet rate
			v_lipo1 = packet[2];	// Directly from analog input of receiver, but reduced to 8-bit depth (0 to 255).  Scaling depends on the input to the analog pin of the receiver.
			v_lipo2 = packet[3];	// Directly from analog input of receiver, but reduced to 8-bit depth (0 to 255).  Scaling depends on the input to the analog pin of the receiver.
			telemetry_counter++;      
			if(telemetry_lost==0)
				telemetry_link=1;
		}
	}
	else
	{
		// If no telemetry packet was received then delay by the typical telemetry packet processing time
		// This is done to try to keep the sendPacket process timing more consistent. Since the SPI payload read takes some time
		delayMicroseconds(50);
	}
	NRF24L01_SetTxRxMode(TX_EN);  
	NRF24L01_FlushRx(); 
}
#endif

//-----------------------------------------------------------------------------------------
static void __attribute__((unused)) CABELL_send_packet(uint8_t bindMode)
{  
	#if defined CABELL_HUB_TELEMETRY  
		if (!bindMode && (sub_protocol == CABELL_V3_TELEMETRY))		// check for incoming packet and switch radio back to TX mode if we were listening for telemetry      
			CABELL_get_telemetry();
	#endif

	CABELL_RxTxPacket_t TxPacket;

	uint8_t channelReduction = constrain((option & CABELL_OPTION_MASK_CHANNEL_REDUCTION),0,CABELL_NUM_CHANNELS-CABELL_MIN_CHANNELS);	// Max 12 - cannot reduce below 4 channels
	if (bindMode)
		channelReduction = 0;	// Send full packet to bind as higher channels will contain bind info

	uint8_t packetSize = sizeof(TxPacket) - ((((channelReduction - (channelReduction%2))/ 2)) * 3);		// reduce 3 bytes per 2 channels, but not last channel if it is odd
	uint8_t maxPayloadValueIndex = sizeof(TxPacket.payloadValue) - (sizeof(TxPacket) - packetSize);

	if ((sub_protocol == CABELL_UNBIND) && !bindMode)
	{
		TxPacket.RxMode = CABELL_RxTxPacket_t::unBind;
		TxPacket.option = option;
	}
	else
	{
		if (sub_protocol == CABELL_SET_FAIL_SAFE && !bindMode)
			TxPacket.RxMode = CABELL_RxTxPacket_t::setFailSafe;
		else
		{
			if (bindMode)
				TxPacket.RxMode = CABELL_RxTxPacket_t::bind;        
			else
			{
				switch (sub_protocol)
				{
					case CABELL_V3_TELEMETRY:
						TxPacket.RxMode = CABELL_RxTxPacket_t::normalWithTelemetry;
						break;
					default:
						TxPacket.RxMode = CABELL_RxTxPacket_t::normal;  
						break;
				}      
			}
		}
		TxPacket.option = (bindMode) ? (option & (~CABELL_OPTION_MASK_CHANNEL_REDUCTION)) : option;		//remove channel reduction if in bind mode
	}
 
	rf_ch_num = CABELL_getNextChannel (hopping_frequency,CABELL_RADIO_CHANNELS, rf_ch_num);
	TxPacket.reserved = rf_ch_num & 0x3F;
	TxPacket.modelNum = RX_num;
	uint16_t checkSum = TxPacket.modelNum + TxPacket.option + TxPacket.RxMode  + TxPacket.reserved;		// Start Calculate checksum

	int adjusted_x;
	int payloadIndex = 0;
	uint16_t holdValue;

	for (int x = 0;(x < CABELL_NUM_CHANNELS - channelReduction); x++)
	{
		switch (x)
		{
			case 0	: adjusted_x = ELEVATOR;	break;
			case 1	: adjusted_x = AILERON;		break;
			case 2	: adjusted_x = RUDDER;		break;
			case 3	: adjusted_x = THROTTLE;	break;
			default	: adjusted_x = x;			break;
		}
		holdValue = convert_channel_16b_limit(adjusted_x,1000,2000);				// valid channel values are 1000 to 2000
		if (bindMode)
		{
			switch (adjusted_x)
			{
				case THROTTLE	: holdValue = 1000;					break;      // always set throttle to off when binding for safety
				//tx address sent for bind
				case 11			: holdValue = 1000 + rx_tx_addr[0];	break;
				case 12			: holdValue = 1000 + rx_tx_addr[1];	break;
				case 13			: holdValue = 1000 + rx_tx_addr[2];	break;
				case 14			: holdValue = 1000 + rx_tx_addr[3];	break;
				case 15			: holdValue = 1000 + rx_tx_addr[4];	break;
			}
		}

		// use 12 bits per value
		if (x % 2)
		{ //output channel number is ODD
			holdValue = holdValue<<4;
			payloadIndex--;     
		}
		else
			holdValue &= 0x0FFF;
		TxPacket.payloadValue[payloadIndex] |=  (uint8_t)(holdValue & 0x00FF);
		payloadIndex++;
		TxPacket.payloadValue[payloadIndex] |=  (uint8_t)((holdValue>>8) & 0x00FF);   
		payloadIndex++;
	}

	for(int x = 0; x < maxPayloadValueIndex ; x++)
		checkSum += TxPacket.payloadValue[x];  // Finish Calculate checksum 

	TxPacket.checkSum_MSB = checkSum >> 8;
	TxPacket.checkSum_LSB = checkSum & 0x00FF;

	// Set channel for next transmission
	NRF24L01_WriteReg(NRF24L01_05_RF_CH,rf_ch_num); 

	//NRF24L01_FlushTx();   //just in case things got hung up
	//NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);

	uint8_t* p = reinterpret_cast<uint8_t*>(&TxPacket.RxMode);
	*p &= 0x7F;                  // Make sure 8th bit is clear
	*p |= (packet_count++)<<7;   // This causes the 8th bit of the first byte to toggle with each xmit so consecutive payloads are not identical.
	// This is a work around for a reported bug in clone NRF24L01 chips that mis-took this case for a re-transmit of the same packet.

	NRF24L01_SetPower();
	NRF24L01_WritePayload((uint8_t*)&TxPacket, packetSize);

	#if defined CABELL_HUB_TELEMETRY 
		if (!bindMode && (sub_protocol == CABELL_V3_TELEMETRY))
		{ // switch radio to rx as soon as packet is sent  
			// calculate transmit time based on packet size and data rate of 1MB per sec
			// This is done because polling the status register during xmit caused issues.
			// bits = packst_size * 8  +  73 bits overhead
			// at 250 Kbs per sec, one bit is 4 uS
			// then add 140 uS which is 130 uS to begin the xmit and 10 uS fudge factor
			delayMicroseconds(((((unsigned long)packetSize * 8ul)  +  73ul) * 4ul) + 140ul)   ;
			packet_period = CABELL_PACKET_PERIOD + (constrain(((int16_t)(CABELL_NUM_CHANNELS - channelReduction) - (int16_t)6 ),(int16_t)0 ,(int16_t)10 ) * (int16_t)100);  // increase packet period by 100 us for each channel over 6
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x0F);  // RX mode with 16 bit CRC
		}
		else 
	#endif
			packet_period = CABELL_PACKET_PERIOD;   // Standard packet period when not in telemetry mode.
}

//-----------------------------------------------------------------------------------------
static void __attribute__((unused)) CABELL_getChannelSequence (uint8_t outArray[], uint8_t numChannels, uint64_t permutation)
{
	/* This procedure initializes an array with the sequence progression of channels.
	* This is not the actual channels itself, but the sequence base to be used within bands of
	* channels.
	*
	* There are numChannels! permutations for arranging the channels
	* one of these permutations will be calculated based on the permutation input
	* permutation should be between 1 and numChannels! but the routine will constrain it
	* if these bounds are exceeded.  Typically the radio's unique TX ID should be used.
	*
	* The maximum numChannels is 20.  Anything larger than this will cause the uint64_t
	* variables to overflow, yielding unknown results (possibly infinite loop?).  Therefor
	* this routine constrains the value.
	*/
	uint8_t i;   //iterator counts numChannels
	uint32_t indexOfNextSequenceValue;
	uint32_t numChannelsFactorial=1;
	uint32_t perm32 ;
	uint8_t  sequenceValue;

	numChannels = constrain(numChannels,1,9);

	for (i = 1; i <= numChannels;i++)
	{
		numChannelsFactorial *= i;					//  Calculate n!
		outArray[i-1] = i-1;						//  Initialize array with the sequence
	}

	perm32 = permutation >> 8 ;						// Shift 40 bit input to 32 bit
	perm32 = (perm32 % numChannelsFactorial);		// permutation must be between 1 and n! or this algorithm will infinite loop
	perm32 <<= 8 ;									// Shift back 8 bits
	perm32 += permutation & 0x00FF ;				// Tack on least 8 bits
	perm32 = (perm32 % numChannelsFactorial) + 1;	// permutation must be between 1 and n! or this algorithm will infinite loop

	//Rearrange the array elements based on the permutation selected
	for (i=0, perm32--; i<numChannels; i++ )
	{
		numChannelsFactorial /= numChannels-i;
		indexOfNextSequenceValue = i+(perm32/numChannelsFactorial);
		perm32 %= numChannelsFactorial;

		//Copy the value in the selected array position
		sequenceValue = outArray[indexOfNextSequenceValue];

		//Shift the unused elements in the array to make room to move in the one just selected
		for( ; indexOfNextSequenceValue > i; indexOfNextSequenceValue--)
			outArray[indexOfNextSequenceValue] = outArray[indexOfNextSequenceValue-1];

		// Copy the selected value into it's new array slot
		outArray[i] = sequenceValue;
	}
}

//-----------------------------------------------------------------------------------------
static void __attribute__((unused)) CABELL_setAddress()
{
	uint64_t CABELL_addr;

	//  Serial.print("NORM ID: ");Serial.print((uint32_t)(CABELL_normal_addr>>32)); Serial.print("    ");Serial.println((uint32_t)((CABELL_normal_addr<<32)>>32));

	if (IS_BIND_DONE)
	{
		CABELL_addr = (((uint64_t)rx_tx_addr[0]) << 32) + 
			(((uint64_t)rx_tx_addr[1]) << 24) + 
			(((uint64_t)rx_tx_addr[2]) << 16) + 
			(((uint64_t)rx_tx_addr[3]) << 8) + 
			(((uint64_t)rx_tx_addr[4]));					// Address to use after binding
	}
	else
		CABELL_addr = CABELL_BIND_RADIO_ADDR;				// Static addr for binding

	CABELL_getChannelSequence(hopping_frequency,CABELL_RADIO_CHANNELS,CABELL_addr);		// Get the sequence for hopping through channels
	rf_ch_num = CABELL_RADIO_MIN_CHANNEL_NUM;				// Initialize the channel sequence

	packet_count=0;  

	uint64_t CABELL_Telemetry_addr = ~CABELL_addr;			// Invert bits for reading so that telemetry packets have a different address.

	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, reinterpret_cast<uint8_t*>(&CABELL_Telemetry_addr), 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_0B_RX_ADDR_P1, reinterpret_cast<uint8_t*>(&CABELL_Telemetry_addr), 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    reinterpret_cast<uint8_t*>(&CABELL_addr), 5);
}

//-----------------------------------------------------------------------------------------
static void __attribute__((unused)) CABELL_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_SetBitrate(NRF24L01_BR_250K);				// slower data rate gives better range/reliability
	CABELL_setAddress();
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, 0x20);		// 32 byte packet length
	NRF24L01_WriteReg(NRF24L01_12_RX_PW_P1, 0x20);		// 32 byte packet length
	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3F);			// Enable dynamic payload length on all pipes
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x04);		// Enable dynamic Payload Length

	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}

//-----------------------------------------------------------------------------------------
uint16_t CABELL_callback()
{
	if (IS_BIND_DONE)
	{
		CABELL_send_packet(0);  // packet_period is set/adjusted in CABELL_send_packet
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(packet_period);
		#endif
		return packet_period;
	}
	else if (bind_counter == 0)
	{
		BIND_DONE;
		CABELL_RF_init();   // non-bind address 
	}
	else
	{
		CABELL_send_packet(1);
		bind_counter--;
	}
	return CABELL_PACKET_PERIOD;
}

//-----------------------------------------------------------------------------------------
void CABELL_init(void)
{
	if (IS_BIND_DONE)
		bind_counter = 0;
	else  
		bind_counter = CABELL_BIND_COUNT;
	CABELL_RF_init();

	packet_period = CABELL_PACKET_PERIOD;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CC2500_SPI.ino"

/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
//-------------------------------
//-------------------------------
//CC2500 SPI routines
//-------------------------------
//-------------------------------
#ifdef CC2500_INSTALLED
#include "iface_cc2500.h"

//----------------------------
void CC2500_WriteReg(uint8_t address, uint8_t data)
{
	CC25_CSN_off;
	SPI_Write(address); 
	NOP();
	SPI_Write(data);
	CC25_CSN_on;
} 

//----------------------
static void CC2500_ReadRegisterMulti(uint8_t address, uint8_t data[], uint8_t length)
{
	CC25_CSN_off;
	SPI_Write(CC2500_READ_BURST | address);
	for(uint8_t i = 0; i < length; i++)
		data[i] = SPI_Read();
	CC25_CSN_on;
}

//--------------------------------------------
static uint8_t CC2500_ReadReg(uint8_t address)
{ 
	uint8_t result;
	CC25_CSN_off;
	SPI_Write(CC2500_READ_SINGLE | address);
	result = SPI_Read();  
	CC25_CSN_on;
	return(result); 
} 

//------------------------
void CC2500_ReadData(uint8_t *dpbuffer, uint8_t len)
{
	CC2500_ReadRegisterMulti(CC2500_3F_RXFIFO, dpbuffer, len);
}

//*********************************************
void CC2500_Strobe(uint8_t state)
{
	CC25_CSN_off;
	SPI_Write(state);
	CC25_CSN_on;
}

static void CC2500_WriteRegisterMulti(uint8_t address, const uint8_t data[], uint8_t length)
{
	CC25_CSN_off;
	SPI_Write(CC2500_WRITE_BURST | address);
	for(uint8_t i = 0; i < length; i++)
		SPI_Write(data[i]);
	CC25_CSN_on;
}

void CC2500_WriteData(uint8_t *dpbuffer, uint8_t len)
{
	CC2500_Strobe(CC2500_SFTX);
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, dpbuffer, len);
	CC2500_Strobe(CC2500_STX);
}

void CC2500_SetTxRxMode(uint8_t mode)
{
	if(mode == TX_EN)
	{//from deviation firmware
		CC2500_WriteReg(CC2500_00_IOCFG2, 0x2F);
		CC2500_WriteReg(CC2500_02_IOCFG0, 0x2F | 0x40);
	}
	else
		if (mode == RX_EN)
		{
			CC2500_WriteReg(CC2500_02_IOCFG0, 0x2F);
			CC2500_WriteReg(CC2500_00_IOCFG2, 0x2F | 0x40);
		}
		else
		{
			CC2500_WriteReg(CC2500_02_IOCFG0, 0x2F);
			CC2500_WriteReg(CC2500_00_IOCFG2, 0x2F);
		}
}

//------------------------
/*static void cc2500_resetChip(void)
{
	// Toggle chip select signal
	CC25_CSN_on;
	delayMicroseconds(30);
	CC25_CSN_off;
	delayMicroseconds(30);
	CC25_CSN_on;
	delayMicroseconds(45);
	CC2500_Strobe(CC2500_SRES);
	_delay_ms(100);
}
*/
uint8_t CC2500_Reset()
{
	CC2500_Strobe(CC2500_SRES);
	delayMilliseconds(1);
	CC2500_SetTxRxMode(TXRX_OFF);
	return CC2500_ReadReg(CC2500_0E_FREQ1) == 0xC4;//check if reset
}
/*
static void CC2500_SetPower_Value(uint8_t power)
{
	const unsigned char patable[8]=	{
		0xC5,  // -12dbm
		0x97, // -10dbm
		0x6E, // -8dbm
		0x7F, // -6dbm
		0xA9, // -4dbm
		0xBB, // -2dbm
		0xFE, // 0dbm
		0xFF // 1.5dbm
	};
	if (power > 7)
		power = 7;
	CC2500_WriteReg(CC2500_3E_PATABLE,  patable[power]);
}
*/
void CC2500_SetPower()
{
	uint8_t power=CC2500_BIND_POWER;
	if(IS_BIND_DONE)
		#ifdef CC2500_ENABLE_LOW_POWER
			power=IS_POWER_FLAG_on?CC2500_HIGH_POWER:CC2500_LOW_POWER;
		#else
			power=CC2500_HIGH_POWER;
		#endif
	if(IS_LBT_POWER_on)
	{
		power=CC2500_LBT_POWER;
		LBT_POWER_off;			// Only accept once
	}
	if(IS_RANGE_FLAG_on)
		power=CC2500_RANGE_POWER;
	if(prev_power != power)
	{
		CC2500_WriteReg(CC2500_3E_PATABLE, power);
		prev_power=power;
	}
}

void __attribute__((unused)) CC2500_SetFreqOffset()
{
	if(prev_option != option)
	{
		prev_option = option;
		CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	}
}

void __attribute__((unused)) CC2500_250K_Init()
{
	CC2500_Strobe(CC2500_SIDLE);

	// Address Config = No address check
	// Base Frequency = 2400
	// CRC Autoflush = false
	// CRC Enable = false
	// Channel Spacing = 333.251953
	// Data Format = Normal mode
	// Data Rate = 249.939
	// Deviation = 126.953125
	// Device Address = 0
	// Manchester Enable = false
	// Modulated = true
	// Modulation Format = GFSK
	// Packet Length Mode = Variable packet length mode. Packet length configured by the first byte after sync word
	// RX Filter BW = 203.125000
	// Sync Word Qualifier Mode = No preamble/sync
	// TX Power = 0
	// Whitening = false
	// Fast Frequency Hopping - no PLL auto calibration
/*	//Previous config
	CC2500_WriteReg(CC2500_08_PKTCTRL0,	0x01);   // Packet Automation Control
	CC2500_WriteReg(CC2500_0B_FSCTRL1,	0x0A);   // Frequency Synthesizer Control
	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);  // Frequency offset hack 
	CC2500_WriteReg(CC2500_0D_FREQ2,	0x5C);   // Frequency Control Word, High Byte
	CC2500_WriteReg(CC2500_0E_FREQ1,	0x4E);   // Frequency Control Word, Middle Byte
	CC2500_WriteReg(CC2500_0F_FREQ0,	0xC3);   // Frequency Control Word, Low Byte
	CC2500_WriteReg(CC2500_10_MDMCFG4,	0x8D);   // Modem Configuration
	CC2500_WriteReg(CC2500_11_MDMCFG3,	0x3B);   // Modem Configuration
	CC2500_WriteReg(CC2500_12_MDMCFG2,	0x10);   // Modem Configuration
	CC2500_WriteReg(CC2500_13_MDMCFG1,	0x23);   // Modem Configuration
	CC2500_WriteReg(CC2500_14_MDMCFG0,	0xA4);   // Modem Configuration
	CC2500_WriteReg(CC2500_15_DEVIATN,	0x62);   // Modem Deviation Setting
	CC2500_WriteReg(CC2500_18_MCSM0,	0x08);   // Main Radio Control State Machine Configuration
	CC2500_WriteReg(CC2500_19_FOCCFG,	0x1D);   // Frequency Offset Compensation Configuration
	CC2500_WriteReg(CC2500_1A_BSCFG,	0x1C);   // Bit Synchronization Configuration
	CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0xC7);   // AGC Control
	CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0x00);   // AGC Control
	CC2500_WriteReg(CC2500_1D_AGCCTRL0, 0xB0);   // AGC Control
	CC2500_WriteReg(CC2500_21_FREND1,	0xB6);   // Front End RX Configuration
	CC2500_WriteReg(CC2500_23_FSCAL3,	0xEA);   // Frequency Synthesizer Calibration
	CC2500_WriteReg(CC2500_25_FSCAL1,	0x00);   // Frequency Synthesizer Calibration
	CC2500_WriteReg(CC2500_26_FSCAL0,	0x11);   // Frequency Synthesizer Calibration
*/
	CC2500_WriteReg(CC2500_07_PKTCTRL1, 0x05);   // Packet Automation Control, address check true auto append RSSI & LQI
	CC2500_WriteReg(CC2500_08_PKTCTRL0, 0x00);   // Packet Automation Control, fixed packet len
	CC2500_WriteReg(CC2500_0B_FSCTRL1,  0x0A);   // Frequency Synthesizer Control (IF Frequency)
	CC2500_WriteReg(CC2500_0C_FSCTRL0,  0x00);   // Frequency Synthesizer Control
	CC2500_WriteReg(CC2500_0D_FREQ2,    0x5C);   // Frequency Control Word, High Byte
	CC2500_WriteReg(CC2500_0E_FREQ1,    0x4E);   // Frequency Control Word, Middle Byte
	CC2500_WriteReg(CC2500_0F_FREQ0,    0xC5);   // Frequency Control Word, Low Byte
	CC2500_WriteReg(CC2500_10_MDMCFG4,  0x3D);   // Modem Configuration  Set to 406kHz BW filter
	CC2500_WriteReg(CC2500_11_MDMCFG3,  0x3B);   // Modem Configuration
	CC2500_WriteReg(CC2500_12_MDMCFG2,	0x10);   // Modem Configuration, GFSK, no preambule and no sync word -> TX by default
	CC2500_WriteReg(CC2500_13_MDMCFG1,  0x03);   // Modem Configuration, 2 bytes of preamble
	CC2500_WriteReg(CC2500_14_MDMCFG0,  0xA4);   // Modem Configuration
	CC2500_WriteReg(CC2500_15_DEVIATN,  0x62);   // Modem Deviation Setting
	CC2500_WriteReg(CC2500_18_MCSM0,    0x08);   // Main Radio Control State Machine Configuration
	CC2500_WriteReg(CC2500_19_FOCCFG,   0x1D);   // Frequency Offset Compensation Configuration
	CC2500_WriteReg(CC2500_1A_BSCFG,    0x1C);   // Bit Synchronization Configuration
	CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0xC7);   // AGC Control
	CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0x00);   // AGC Control
	CC2500_WriteReg(CC2500_1D_AGCCTRL0, 0xB0);   // AGC Control
	CC2500_WriteReg(CC2500_21_FREND1,   0xB6);   // Front End RX Configuration
	CC2500_WriteReg(CC2500_23_FSCAL3,   0xEA);   // Frequency Synthesizer Calibration
	CC2500_WriteReg(CC2500_25_FSCAL1,   0x00);   // Frequency Synthesizer Calibration
	CC2500_WriteReg(CC2500_26_FSCAL0,   0x11);   // Frequency Synthesizer Calibration
	
	//Prep RX
	// Set first 3 bytes of rx addr in [0]->SYNC1, [1]->SYNC0 and [2]->ADDR
	// CC2500_WriteReg(CC2500_04_SYNC1,    [0]);   // Sync word, high byte
	// CC2500_WriteReg(CC2500_05_SYNC0,    [1]);   // Sync word, low byte
	// CC2500_WriteReg(CC2500_09_ADDR,     [2]);   // Set addr
	//RX
	// CC2500_WriteReg(CC2500_12_MDMCFG2,  0x12);  // Modem Configuration, GFSK, 16/16 Sync Word TX&RX
	//TX
	// CC2500_WriteReg(CC2500_12_MDMCFG2,	0x10); // Modem Configuration, GFSK, no preambule and no sync word
	// need to set packet length before sending/receiving
	// CC2500_WriteReg(CC2500_06_PKTLEN,   cc2500_packet_len);  // Packet len, fix packet len

	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}
void __attribute__((unused)) CC2500_250K_HoppingCalib(uint8_t num_freq)
{
	for (uint8_t i = 0; i < num_freq; i++)
	{
		CC2500_Strobe(CC2500_SIDLE);
		// spacing is 333.25 kHz, must multiply channel by 3
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[i]*3);
		// calibrate
		CC2500_Strobe(CC2500_SCAL);
		delayMicroseconds(900);
		calData[i]=CC2500_ReadReg(CC2500_25_FSCAL1);
	}
}
void __attribute__((unused)) CC2500_250K_Hopping(uint8_t index)
{
	// spacing is 333.25 kHz, must multiply channel by 3
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[index] * 3);
	// set PLL calibration
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[index]);
}
void __attribute__((unused)) CC2500_250K_RFChannel(uint8_t number)
{
	CC2500_Strobe(CC2500_SIDLE);
	// spacing is 333.25 kHz, must multiply channel by 3
	CC2500_WriteReg(CC2500_0A_CHANNR, number*3);
	// calibrate
	CC2500_Strobe(CC2500_SCAL);
	delayMicroseconds(900);
}
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CFlie_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

// Most of this code was ported from theseankelly's related DeviationTX work.

#if defined(CFLIE_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define CFLIE_BIND_COUNT 60

//=============================================================================
// CRTP (Crazy RealTime Protocol) Implementation
//=============================================================================

// Port IDs
enum {
    CRTP_PORT_CONSOLE = 0x00,
    CRTP_PORT_PARAM = 0x02,
    CRTP_PORT_SETPOINT = 0x03,
    CRTP_PORT_MEM = 0x04,
    CRTP_PORT_LOG = 0x05,
    CRTP_PORT_POSITION = 0x06,
    CRTP_PORT_SETPOINT_GENERIC = 0x07,
    CRTP_PORT_PLATFORM = 0x0D,
    CRTP_PORT_LINK = 0x0F,
};

// Channel definitions for the LOG port
enum {
    CRTP_LOG_CHAN_TOC = 0x00,
    CRTP_LOG_CHAN_SETTINGS = 0x01,
    CRTP_LOG_CHAN_LOGDATA = 0x02,
};

// Command definitions for the LOG port's TOC channel
enum {
    CRTP_LOG_TOC_CMD_ELEMENT = 0x00,
    CRTP_LOG_TOC_CMD_INFO = 0x01,
};

// Command definitions for the LOG port's CMD channel
enum {
    CRTP_LOG_SETTINGS_CMD_CREATE_BLOCK = 0x00,
    CRTP_LOG_SETTINGS_CMD_APPEND_BLOCK = 0x01,
    CRTP_LOG_SETTINGS_CMD_DELETE_BLOCK = 0x02,
    CRTP_LOG_SETTINGS_CMD_START_LOGGING = 0x03,
    CRTP_LOG_SETTINGS_CMD_STOP_LOGGING = 0x04,
    CRTP_LOG_SETTINGS_CMD_RESET_LOGGING = 0x05,
};

// Log variables types
enum {
    LOG_UINT8 = 0x01,
    LOG_UINT16 = 0x02,
    LOG_UINT32 = 0x03,
    LOG_INT8 = 0x04,
    LOG_INT16 = 0x05,
    LOG_INT32 = 0x06,
    LOG_FLOAT = 0x07,
    LOG_FP16 = 0x08,
};

#define CFLIE_TELEM_LOG_BLOCK_ID            0x01
#define CFLIE_TELEM_LOG_BLOCK_PERIOD_10MS   50 // 50*10 = 500ms

// Setpoint type definitions for the generic setpoint channel
enum {
    CRTP_SETPOINT_GENERIC_STOP_TYPE = 0x00,
    CRTP_SETPOINT_GENERIC_VELOCITY_WORLD_TYPE = 0x01,
    CRTP_SETPOINT_GENERIC_Z_DISTANCE_TYPE = 0x02,
    CRTP_SETPOINT_GENERIC_CPPM_EMU_TYPE = 0x03,
};

static inline uint8_t crtp_create_header(uint8_t port, uint8_t channel)
{
    return ((port)&0x0F)<<4 | (channel & 0x03);
}

//=============================================================================
// End CRTP implementation
//=============================================================================

// Address size
#define TX_ADDR_SIZE 5

// Timeout for callback in uSec, 10ms=10000us for Crazyflie
#define CFLIE_PACKET_PERIOD 10000

#define MAX_PACKET_SIZE 32  // CRTP is 32 bytes

// CPPM CRTP supports up to 10 aux channels but deviation only
// supports a total of 12 channels. R,P,Y,T leaves 8 aux channels left
#define MAX_CPPM_AUX_CHANNELS 8

static uint8_t tx_payload_len = 0; // Length of the packet stored in packet
static uint8_t rx_payload_len = 0; // Length of the packet stored in rx_packet
static uint8_t rx_packet[MAX_PACKET_SIZE]; // For reading in ACK payloads

static uint8_t data_rate;

enum {
    CFLIE_INIT_SEARCH = 0,
    CFLIE_INIT_CRTP_LOG,
    CFLIE_INIT_DATA,
    CFLIE_SEARCH,
    CFLIE_DATA
};

static uint8_t crtp_log_setup_state;
enum {
    CFLIE_CRTP_LOG_SETUP_STATE_INIT = 0,
    CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_INFO,
    CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_INFO,
    CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_ITEM,
    CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_ITEM,
    // It might be a good idea to add a state here
    // to send the command to reset the logging engine
    // to avoid log block ID conflicts. However, there
    // is not a conflict with the current defaults in
    // cfclient and I'd rather be able to log from the Tx
    // and cfclient simultaneously
    CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_CREATE_BLOCK,
    CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_CREATE_BLOCK,
    CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_START_BLOCK,
    CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_START_BLOCK,
    CFLIE_CRTP_LOG_SETUP_STATE_COMPLETE,
};

// State variables for the crtp_log_setup_state_machine
static uint8_t toc_size;             // Size of the TOC read from the crazyflie
static uint8_t next_toc_variable;    // State variable keeping track of the next var to read
static uint8_t vbat_var_id;          // ID of the vbatMV variable
static uint8_t extvbat_var_id;       // ID of the extVbatMV variable
static uint8_t rssi_var_id;          // ID of the RSSI variable

// Constants used for finding var IDs from the toc
static const char* pm_group_name = "pm";
static const char* vbat_var_name = "vbatMV";
static const uint8_t vbat_var_type = LOG_UINT16;
static const char* extvbat_var_name = "extVbatMV";
static const uint8_t extvbat_var_type = LOG_UINT16;
static const char* radio_group_name = "radio";
static const char* rssi_var_name = "rssi";
static const uint8_t rssi_var_type = LOG_UINT8;

// Repurposing DSM Telemetry fields
#define TELEM_CFLIE_INTERNAL_VBAT   TELEM_DSM_FLOG_VOLT2    // Onboard voltage
#define TELEM_CFLIE_EXTERNAL_VBAT   TELEM_DSM_FLOG_VOLT1    // Voltage from external pin (BigQuad)
#define TELEM_CFLIE_RSSI            TELEM_DSM_FLOG_FADESA   // Repurpose FADESA for RSSI

enum {
    PROTOOPTS_TELEMETRY = 0,
    PROTOOPTS_CRTP_MODE = 1,
    LAST_PROTO_OPT,
};

#define TELEM_OFF 0
#define TELEM_ON_ACKPKT 1
#define TELEM_ON_CRTPLOG 2

#define CRTP_MODE_RPYT 0
#define CRTP_MODE_CPPM 1

// Bit vector from bit position
#define BV(bit) (1 << bit)

#define PACKET_CHKTIME 500      // time to wait if packet not yet acknowledged or timed out    

// Helper for sending a packet
// Assumes packet data has been put in packet
// and tx_payload_len has been set correctly
static void send_packet()
{
    // clear packet status bits and Tx/Rx FIFOs
    NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));
    NRF24L01_FlushTx();
    NRF24L01_FlushRx();

    // Transmit the payload
    NRF24L01_WritePayload(packet, tx_payload_len);

    // // Check and adjust transmission power.
    NRF24L01_SetPower();
}

static uint16_t dbg_cnt = 0;
static uint8_t packet_ack()
{
	if (++dbg_cnt > 50)
	{
		// debugln("S: %02x\n", NRF24L01_ReadReg(NRF24L01_07_STATUS));
		dbg_cnt = 0;
	}
	switch (NRF24L01_ReadReg(NRF24L01_07_STATUS) & (BV(NRF24L01_07_TX_DS) | BV(NRF24L01_07_MAX_RT)))
	{
		case BV(NRF24L01_07_TX_DS):
			rx_payload_len = NRF24L01_GetDynamicPayloadSize();
			if (rx_payload_len > MAX_PACKET_SIZE)
				rx_payload_len = MAX_PACKET_SIZE;
			NRF24L01_ReadPayload(rx_packet, rx_payload_len);
			return PKT_ACKED;
		case BV(NRF24L01_07_MAX_RT):
			return PKT_TIMEOUT;
	}
	return PKT_PENDING;
}

static void set_rate_channel(uint8_t rate, uint8_t channel)
{
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, channel);		// Defined by model id
	NRF24L01_SetBitrate(rate);							// Defined by model id
}

static void send_search_packet()
{
	uint8_t buf[1];
	buf[0] = 0xff;
	// clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, (BV(NRF24L01_07_TX_DS) | BV(NRF24L01_07_MAX_RT)));
	NRF24L01_FlushTx();

	if (rf_ch_num++ > 125)
	{
		rf_ch_num = 0;
		switch(data_rate)
		{
			case NRF24L01_BR_250K:
				data_rate = NRF24L01_BR_1M;
				break;
			case NRF24L01_BR_1M:
				data_rate = NRF24L01_BR_2M;
				break;
			case NRF24L01_BR_2M:
				data_rate = NRF24L01_BR_250K;
				break;
		}
	}
	set_rate_channel(data_rate, rf_ch_num);

	NRF24L01_WritePayload(buf, sizeof(buf));

}

// Frac 16.16
#define FRAC_MANTISSA 16 // This means, not IEEE 754...
#define FRAC_SCALE (1 << FRAC_MANTISSA)

// Convert fractional 16.16 to float32
static void frac2float(int32_t n, float* res)
{
	if (n == 0)
	{
		*res = 0.0;
		return;
	}
	uint32_t m = n < 0 ? -n : n; // Figure out mantissa?
	int i;
	for (i = (31-FRAC_MANTISSA); (m & 0x80000000) == 0; i--, m <<= 1);
	m <<= 1; // Clear implicit leftmost 1
	m >>= 9;
	uint32_t e = 127 + i;
	if (n < 0) m |= 0x80000000;
	m |= e << 23;
	*((uint32_t *) res) = m;
}

static void send_crtp_rpyt_packet()
{
	int32_t f_roll;
	int32_t f_pitch;
	int32_t f_yaw;
	uint16_t thrust;

	uint16_t val;

	struct CommanderPacketRPYT
	{
		float roll;
		float pitch;
		float yaw;
		uint16_t thrust;
	}__attribute__((packed)) cpkt;

	// Channels in AETR order
	// Roll, aka aileron, float +- 50.0 in degrees
	// float roll  = -(float) Channels[0]*50.0/10000;
	val = convert_channel_16b_limit(AILERON, -10000, 10000);
	// f_roll = -Channels[0] * FRAC_SCALE / (10000 / 50);
	f_roll = val * FRAC_SCALE / (10000 / 50);

	frac2float(f_roll, &cpkt.roll); // TODO: Remove this and use the correct Mode switch below...
	// debugln("Roll: raw, converted:  %d, %d, %d, %0.2f", Channel_data[AILERON], val, f_roll, cpkt.roll);

	// Pitch, aka elevator, float +- 50.0 degrees
	//float pitch = -(float) Channels[1]*50.0/10000;
	val = convert_channel_16b_limit(ELEVATOR, -10000, 10000);
	// f_pitch = -Channels[1] * FRAC_SCALE / (10000 / 50);
	f_pitch = -val * FRAC_SCALE / (10000 / 50);

	frac2float(f_pitch, &cpkt.pitch); // TODO: Remove this and use the correct Mode switch below...
	// debugln("Pitch: raw, converted:  %d, %d, %d, %0.2f", Channel_data[ELEVATOR], val, f_pitch, cpkt.pitch);

	// Thrust, aka throttle 0..65535, working range 5535..65535
	// Android Crazyflie app puts out a throttle range of 0-80%: 0..52000
	thrust = convert_channel_16b_limit(THROTTLE, 0, 32767) * 2;

	// Crazyflie needs zero thrust to unlock
	if (thrust < 900)
		cpkt.thrust = 0;
	else
		cpkt.thrust = thrust;

	// debugln("Thrust: raw, converted:  %d, %u, %u", Channel_data[THROTTLE], thrust, cpkt.thrust);

	// Yaw, aka rudder, float +- 400.0 deg/s
	// float yaw   = -(float) Channels[3]*400.0/10000;
	val = convert_channel_16b_limit(RUDDER, -10000, 10000);
	// f_yaw = - Channels[3] * FRAC_SCALE / (10000 / 400);
	f_yaw = val * FRAC_SCALE / (10000 / 400);
	frac2float(f_yaw, &cpkt.yaw);

	// debugln("Yaw: raw, converted:  %d, %d, %d, %0.2f", Channel_data[RUDDER], val, f_yaw, cpkt.yaw);

	// Switch on/off?
	// TODO: Get X or + mode working again:
	// if (Channels[4] >= 0) {
	//     frac2float(f_roll, &cpkt.roll);
	//     frac2float(f_pitch, &cpkt.pitch);
	// } else {
	//     // Rotate 45 degrees going from X to + mode or opposite.
	//     // 181 / 256 = 0.70703125 ~= sqrt(2) / 2
	//     int32_t f_x_roll = (f_roll + f_pitch) * 181 / 256;
	//     frac2float(f_x_roll, &cpkt.roll);
	//     int32_t f_x_pitch = (f_pitch - f_roll) * 181 / 256;
	//     frac2float(f_x_pitch, &cpkt.pitch);
	// }

	// Construct and send packet
	packet[0] = crtp_create_header(CRTP_PORT_SETPOINT, 0); // Commander packet to channel 0
	memcpy(&packet[1], (char*) &cpkt, sizeof(cpkt));
	tx_payload_len = 1 + sizeof(cpkt);
	send_packet();
}

/*static void send_crtp_cppm_emu_packet()
{
    struct CommanderPacketCppmEmu {
        struct {
            uint8_t numAuxChannels : 4; // Set to 0 through MAX_AUX_RC_CHANNELS
            uint8_t reserved : 4;
        } hdr;
        uint16_t channelRoll;
        uint16_t channelPitch;
        uint16_t channelYaw;
        uint16_t channelThrust;
        uint16_t channelAux[10];
    } __attribute__((packed)) cpkt;

    // To emulate PWM RC signals, rescale channels from (-10000,10000) to (1000,2000)
    // This is done by dividing by 20 to get a total range of 1000 (-500,500)
    // and then adding 1500 to to rebase the offset
#define RESCALE_RC_CHANNEL_TO_PWM(chan) ((chan / 20) + 1500)

    // Make sure the number of aux channels in use is capped to MAX_CPPM_AUX_CHANNELS
    // uint8_t numAuxChannels = Model.num_channels - 4;
    uint8_t numAuxChannels = 2; // TODO: Figure this out correctly
    if(numAuxChannels > MAX_CPPM_AUX_CHANNELS)
    {
        numAuxChannels = MAX_CPPM_AUX_CHANNELS;
    }

    cpkt.hdr.numAuxChannels = numAuxChannels;

    // Remap AETR to AERT (RPYT)
    cpkt.channelRoll = convert_channel_16b_limit(AILERON,1000,2000);
    cpkt.channelPitch = convert_channel_16b_limit(ELEVATOR,1000,2000);
    // Note: T & R Swapped:
    cpkt.channelYaw = convert_channel_16b_limit(RUDDER, 1000, 2000);
    cpkt.channelThrust = convert_channel_16b_limit(THROTTLE, 1000, 2000);

    // Rescale the rest of the aux channels - RC channel 4 and up
    for (uint8_t i = 4; i < 14; i++)
    {
        cpkt.channelAux[i] = convert_channel_16b_limit(i, 1000, 2000);
    }

    // Total size of the commander packet is a 1-byte header, 4 2-byte channels and
    // a variable number of 2-byte auxiliary channels
    uint8_t commanderPacketSize = 1 + 8 + (2*numAuxChannels);

    // Construct and send packet
    packet[0] = crtp_create_header(CRTP_PORT_SETPOINT_GENERIC, 0); // Generic setpoint packet to channel 0
    packet[1] = CRTP_SETPOINT_GENERIC_CPPM_EMU_TYPE;

    // Copy the header (1) plus 4 2-byte channels (8) plus whatever number of 2-byte aux channels are in use
    memcpy(&packet[2], (char*)&cpkt, commanderPacketSize); // Why not use sizeof(cpkt) here??
    tx_payload_len = 2 + commanderPacketSize; // CRTP header, commander type, and packet
    send_packet();
}*/

static void send_cmd_packet()
{
    // TODO: Fix this so we can actually configure the packet type
    // switch(Model.proto_opts[PROTOOPTS_CRTP_MODE])
    // {
    // case CRTP_MODE_CPPM:
    //     send_crtp_cppm_emu_packet();
    //     break;
    // case CRTP_MODE_RPYT:
    //     send_crtp_rpyt_packet();
    //     break;
    // default:
    //     send_crtp_rpyt_packet();
    // }

    // send_crtp_cppm_emu_packet(); // oh maAAAn
    send_crtp_rpyt_packet();
}

// State machine for setting up CRTP logging
// returns 1 when the state machine has completed, 0 otherwise
static uint8_t crtp_log_setup_state_machine()
{
    uint8_t state_machine_completed = 0;
    // A note on the design of this state machine:
    //
    // Responses from the crazyflie come in the form of ACK payloads.
    // There is no retry logic associated with ACK payloads, so it is possible
    // to miss a response from the crazyflie. To avoid this, the request
    // packet must be re-sent until the expected response is received. However,
    // re-sending the same request generates another response in the crazyflie
    // Rx queue, which can produce large backlogs of duplicate responses.
    //
    // To avoid this backlog but still guard against dropped ACK payloads,
    // transmit cmd packets (which don't generate responses themselves)
    // until an empty ACK payload is received (the crazyflie alternates between
    // 0xF3 and 0xF7 for empty ACK payloads) which indicates the Rx queue on the
    // crazyflie has been drained. If the queue has been drained and the
    // desired ACK has still not been received, it was likely dropped and the
    // request should be re-transmit.

    switch (crtp_log_setup_state) {
    case CFLIE_CRTP_LOG_SETUP_STATE_INIT:
        toc_size = 0;
        next_toc_variable = 0;
        vbat_var_id = 0;
        extvbat_var_id = 0;
        crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_INFO;
        // fallthrough
    case CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_INFO:
        crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_INFO;
        packet[0] = crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_TOC);
        packet[1] = CRTP_LOG_TOC_CMD_INFO;
        tx_payload_len = 2;
        send_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_INFO:
        if (packet_ack() == PKT_ACKED) {
            if (rx_payload_len >= 3
                    && rx_packet[0] == crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_TOC)
                    && rx_packet[1] == CRTP_LOG_TOC_CMD_INFO) {
                // Received the ACK payload. Save the toc_size
                // and advance to the next state
                toc_size = rx_packet[2];
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_ITEM;
                return state_machine_completed;
            } else if (rx_packet[0] == 0xF3 || rx_packet[0] == 0xF7) {
                // "empty" ACK packet received - likely missed the ACK
                // payload we are waiting for.
                // return to the send state and retransmit the request
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_INFO;
                return state_machine_completed;
            }
        }

        // Otherwise, send a cmd packet to get the next ACK in the Rx queue
        send_cmd_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_ITEM:
        crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_ITEM;
        packet[0] = crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_TOC);
        packet[1] = CRTP_LOG_TOC_CMD_ELEMENT;
        packet[2] = next_toc_variable;
        tx_payload_len = 3;
        send_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_ACK_CMD_GET_ITEM:
        if (packet_ack() == PKT_ACKED) {
            if (rx_payload_len >= 3
                    && rx_packet[0] == crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_TOC)
                    && rx_packet[1] == CRTP_LOG_TOC_CMD_ELEMENT
                    && rx_packet[2] == next_toc_variable) {
                // For every element in the TOC we must compare its
                // type (rx_packet[3]), group and name (back to back
                // null terminated strings starting with the fifth byte)
                // and see if it matches any of the variables we need
                // for logging
                //
                // Currently enabled for logging:
                //  - vbatMV (LOG_UINT16)
                //  - extVbatMV (LOG_UINT16)
                //  - rssi (LOG_UINT8)
                if(rx_packet[3] == vbat_var_type
                        && (0 == strcmp((char*)&rx_packet[4], pm_group_name))
                        && (0 == strcmp((char*)&rx_packet[4 + strlen(pm_group_name) + 1], vbat_var_name))) {
                    // Found the vbat element - save it for later
                    vbat_var_id = next_toc_variable;
                }

                if(rx_packet[3] == extvbat_var_type
                        && (0 == strcmp((char*)&rx_packet[4], pm_group_name))
                        && (0 == strcmp((char*)&rx_packet[4 + strlen(pm_group_name) + 1], extvbat_var_name))) {
                    // Found the extvbat element - save it for later
                    extvbat_var_id = next_toc_variable;
                }

                if(rx_packet[3] == rssi_var_type
                        && (0 == strcmp((char*)&rx_packet[4], radio_group_name))
                        && (0 == strcmp((char*)&rx_packet[4 + strlen(radio_group_name) + 1], rssi_var_name))) {
                    // Found the rssi element - save it for later
                    rssi_var_id = next_toc_variable;
                }

                // Advance the toc variable counter
                // If there are more variables, read them
                // If not, move on to the next state
                next_toc_variable += 1;
                if(next_toc_variable >= toc_size) {
                    crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_CREATE_BLOCK;
                } else {
                    // There are more TOC elements to get
                    crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_ITEM;
                }
                return state_machine_completed;
            } else if (rx_packet[0] == 0xF3 || rx_packet[0] == 0xF7) {
                // "empty" ACK packet received - likely missed the ACK
                // payload we are waiting for.
                // return to the send state and retransmit the request
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CMD_GET_INFO;
                return state_machine_completed;
            }
        }

        // Otherwise, send a cmd packet to get the next ACK in the Rx queue
        send_cmd_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_CREATE_BLOCK:
        crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_CREATE_BLOCK;
        packet[0] = crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_SETTINGS);
        packet[1] = CRTP_LOG_SETTINGS_CMD_CREATE_BLOCK;
        packet[2] = CFLIE_TELEM_LOG_BLOCK_ID; // Log block ID
        packet[3] = vbat_var_type; // Variable type
        packet[4] = vbat_var_id; // ID of the VBAT variable
        packet[5] = extvbat_var_type; // Variable type
        packet[6] = extvbat_var_id; // ID of the ExtVBat variable
        packet[7] = rssi_var_type; // Variable type
        packet[8] = rssi_var_id; // ID of the RSSI variable
        tx_payload_len = 9;
        send_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_CREATE_BLOCK:
        if (packet_ack() == PKT_ACKED) {
            if (rx_payload_len >= 2
                    && rx_packet[0] == crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_SETTINGS)
                    && rx_packet[1] == CRTP_LOG_SETTINGS_CMD_CREATE_BLOCK) {
                // Received the ACK payload. Advance to the next state
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_START_BLOCK;
                return state_machine_completed;
            } else if (rx_packet[0] == 0xF3 || rx_packet[0] == 0xF7) {
                // "empty" ACK packet received - likely missed the ACK
                // payload we are waiting for.
                // return to the send state and retransmit the request
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_CREATE_BLOCK;
                return state_machine_completed;
            }
        }

        // Otherwise, send a cmd packet to get the next ACK in the Rx queue
        send_cmd_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_START_BLOCK:
        crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_START_BLOCK;
        packet[0] = crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_SETTINGS);
        packet[1] = CRTP_LOG_SETTINGS_CMD_START_LOGGING;
        packet[2] = CFLIE_TELEM_LOG_BLOCK_ID; // Log block ID 1
        packet[3] = CFLIE_TELEM_LOG_BLOCK_PERIOD_10MS; // Log frequency in 10ms units
        tx_payload_len = 4;
        send_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_ACK_CONTROL_START_BLOCK:
        if (packet_ack() == PKT_ACKED) {
            if (rx_payload_len >= 2
                    && rx_packet[0] == crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_SETTINGS)
                    && rx_packet[1] == CRTP_LOG_SETTINGS_CMD_START_LOGGING) {
                // Received the ACK payload. Advance to the next state
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_COMPLETE;
                return state_machine_completed;
            } else if (rx_packet[0] == 0xF3 || rx_packet[0] == 0xF7) {
                // "empty" ACK packet received - likely missed the ACK
                // payload we are waiting for.
                // return to the send state and retransmit the request
                crtp_log_setup_state =
                        CFLIE_CRTP_LOG_SETUP_STATE_SEND_CONTROL_START_BLOCK;
                return state_machine_completed;
            }
        }

        // Otherwise, send a cmd packet to get the next ACK in the Rx queue
        send_cmd_packet();
        break;

    case CFLIE_CRTP_LOG_SETUP_STATE_COMPLETE:
        state_machine_completed = 1;
        return state_machine_completed;
        break;
    }

    return state_machine_completed;
}

static void CFLIE_RF_init()
{
    NRF24L01_Initialize();

    // CRC, radio on
    NRF24L01_WriteReg(NRF24L01_01_EN_AA, 0x01);              // Auto Acknowledgement for data pipe 0
    NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0x13);         // 3 retransmits, 500us delay

    NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch_num);        // Defined in initialize_rx_tx_addr
    NRF24L01_SetBitrate(data_rate);                          // Defined in initialize_rx_tx_addr

    NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, TX_ADDR_SIZE);
    NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, TX_ADDR_SIZE);

    NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x01);       // Enable Dynamic Payload Length on pipe 0
    NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x06);     // Enable Dynamic Payload Length, enable Payload with ACK

	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}

// TODO: Fix telemetry

// Update telemetry using the CRTP logging framework
// static void update_telemetry_crtplog()
// {
//     static uint8_t frameloss = 0;

//     // Read and reset count of dropped packets
//     frameloss += NRF24L01_ReadReg(NRF24L01_08_OBSERVE_TX) >> 4;
//     NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch_num); // reset packet loss counter
//     Telemetry.value[TELEM_DSM_FLOG_FRAMELOSS] = frameloss;
//     TELEMETRY_SetUpdated(TELEM_DSM_FLOG_FRAMELOSS);

//     if (packet_ack() == PKT_ACKED) {
//         // See if the ACK packet is a cflie log packet
//         // A log data packet is a minimum of 5 bytes. Ignore anything less.
//         if (rx_payload_len >= 5) {
//             // Port 5 = log, Channel 2 = data
//             if (rx_packet[0] == crtp_create_header(CRTP_PORT_LOG, CRTP_LOG_CHAN_LOGDATA)) {
//                 // The log block ID
//                 if (rx_packet[1] == CFLIE_TELEM_LOG_BLOCK_ID) {
//                     // Bytes 5 and 6 are the Vbat in mV units
//                     uint16_t vBat;
//                     memcpy(&vBat, &rx_packet[5], sizeof(uint16_t));
//                     Telemetry.value[TELEM_CFLIE_INTERNAL_VBAT] = (int32_t) (vBat / 10); // The log value expects centivolts
//                     TELEMETRY_SetUpdated(TELEM_CFLIE_INTERNAL_VBAT);

//                     // Bytes 7 and 8 are the ExtVbat in mV units
//                     uint16_t extVBat;
//                     memcpy(&extVBat, &rx_packet[7], sizeof(uint16_t));
//                     Telemetry.value[TELEM_CFLIE_EXTERNAL_VBAT] = (int32_t) (extVBat / 10); // The log value expects centivolts
//                     TELEMETRY_SetUpdated(TELEM_CFLIE_EXTERNAL_VBAT);

//                     // Byte 9 is the RSSI
//                     Telemetry.value[TELEM_CFLIE_RSSI] = rx_packet[9];
//                     TELEMETRY_SetUpdated(TELEM_CFLIE_RSSI);
//                 }
//             }
//         }
//     }
// }

// // Update telemetry using the ACK packet payload
// static void update_telemetry_ackpkt()
// {
//     static uint8_t frameloss = 0;

//     // Read and reset count of dropped packets
//     frameloss += NRF24L01_ReadReg(NRF24L01_08_OBSERVE_TX) >> 4;
//     NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch_num); // reset packet loss counter
//     Telemetry.value[TELEM_DSM_FLOG_FRAMELOSS] = frameloss;
//     TELEMETRY_SetUpdated(TELEM_DSM_FLOG_FRAMELOSS);

//     if (packet_ack() == PKT_ACKED) {
//         // Make sure this is an ACK packet (first byte will alternate between 0xF3 and 0xF7
//         if (rx_packet[0] == 0xF3 || rx_packet[0] == 0xF7) {
//             // If ACK packet contains RSSI (proper length and byte 1 is 0x01)
//             if(rx_payload_len >= 3 && rx_packet[1] == 0x01) {
//                 Telemetry.value[TELEM_CFLIE_RSSI] = rx_packet[2];
//                 TELEMETRY_SetUpdated(TELEM_CFLIE_RSSI);
//             }
//             // If ACK packet contains VBAT (proper length and byte 3 is 0x02)
//             if(rx_payload_len >= 8 && rx_packet[3] == 0x02) {
//                 uint32_t vBat = 0;
//                 memcpy(&vBat, &rx_packet[4], sizeof(uint32_t));
//                 Telemetry.value[TELEM_CFLIE_INTERNAL_VBAT] = (int32_t)(vBat / 10); // The log value expects centivolts
//                 TELEMETRY_SetUpdated(TELEM_CFLIE_INTERNAL_VBAT);
//             }
//         }
//     }
// }

static uint16_t CFLIE_callback()
{
    switch (phase) {
    case CFLIE_INIT_SEARCH:
        send_search_packet();
        phase = CFLIE_SEARCH;
        break;
    case CFLIE_INIT_CRTP_LOG:
        if (crtp_log_setup_state_machine()) {
            phase = CFLIE_INIT_DATA;
        }
        break;
    case CFLIE_INIT_DATA:
        send_cmd_packet();
        phase = CFLIE_DATA;
        break;
    case CFLIE_SEARCH:
        switch (packet_ack()) {
        case PKT_PENDING:
            return PACKET_CHKTIME;                 // packet send not yet complete
        case PKT_ACKED:
            phase = CFLIE_DATA;
            // PROTOCOL_SetBindState(0);
            // MUSIC_Play(MUSIC_DONE_BINDING);
            BIND_DONE;
            break;
        case PKT_TIMEOUT:
            send_search_packet();
        }
        break;

    case CFLIE_DATA:
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(CFLIE_PACKET_PERIOD);
		#endif
		// if (Model.proto_opts[PROTOOPTS_TELEMETRY] == TELEM_ON_CRTPLOG) {
        //     update_telemetry_crtplog();
        // } else if (Model.proto_opts[PROTOOPTS_TELEMETRY] == TELEM_ON_ACKPKT) {
        //     update_telemetry_ackpkt();
        // }

        if (packet_ack() == PKT_PENDING)
            return PACKET_CHKTIME;         // packet send not yet complete
        send_cmd_packet();
        break;
    }
    return CFLIE_PACKET_PERIOD;                  // Packet at standard protocol interval
}

// Generate address to use from TX id and manufacturer id (STM32 unique id)
static uint8_t CFLIE_initialize_rx_tx_addr()
{
    rx_tx_addr[0] = 
    rx_tx_addr[1] = 
    rx_tx_addr[2] = 
    rx_tx_addr[3] = 
    rx_tx_addr[4] = 0xE7; // CFlie uses fixed address

    // if (Model.fixed_id) {
    //     rf_ch_num = Model.fixed_id % 100;
    //     switch (Model.fixed_id / 100) {
    //     case 0:
    //         data_rate = NRF24L01_BR_250K;
    //         break;
    //     case 1:
    //         data_rate = NRF24L01_BR_1M;
    //         break;
    //     case 2:
    //         data_rate = NRF24L01_BR_2M;
    //         break;
    //     default:
    //         break;
    //     }

    //     if (Model.proto_opts[PROTOOPTS_TELEMETRY] == TELEM_ON_CRTPLOG) {
    //         return CFLIE_INIT_CRTP_LOG;
    //     } else {
    //         return CFLIE_INIT_DATA;
    //     }
    // } else {
    //     data_rate = NRF24L01_BR_250K;
    //     rf_ch_num = 10;
    //     return CFLIE_INIT_SEARCH;
    // }

    // Default 1
    data_rate = NRF24L01_BR_1M;
    rf_ch_num = 10;

    // Default 2
    // data_rate = NRF24L01_BR_2M;
    // rf_ch_num = 110;
    return CFLIE_INIT_SEARCH;
}

void CFLIE_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol

    phase = CFLIE_initialize_rx_tx_addr();
    crtp_log_setup_state = CFLIE_CRTP_LOG_SETUP_STATE_INIT;
    packet_count=0;

    CFLIE_RF_init();
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CG023_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with EAchine 3D X4, CG023/CG031, Attop YD-822/YD-829/YD-829C and H8_3D/JJRC H20/H22

#if defined(CG023_NRF24L01_INO)

#include "iface_xn297.h"

#define CG023_PACKET_PERIOD		8200 // Timeout for callback in uSec
#define CG023_INITIAL_WAIT		500
#define CG023_PACKET_SIZE		15   // packets have 15-byte payload
#define CG023_RF_BIND_CHANNEL	0x2D
#define CG023_BIND_COUNT		500  // 4 seconds
#define YD829_PACKET_PERIOD		4100 // Timeout for callback in uSec


enum CG023_FLAGS {
    // flags going to packet[13]
    CG023_FLAG_FLIP     = 0x01, 
    CG023_FLAG_EASY     = 0x02, 
    CG023_FLAG_VIDEO    = 0x04, 
    CG023_FLAG_STILL    = 0x08, 
    CG023_FLAG_LED_OFF  = 0x10,
    CG023_FLAG_RATE_LOW = 0x00,
    CG023_FLAG_RATE_MID = 0x20,
    CG023_FLAG_RATE_HIGH= 0x40,
};

enum YD829_FLAGS {
    // flags going to packet[13] (YD-829)
    YD829_FLAG_FLIP     = 0x01,
    YD829_MASK_RATE     = 0x0C,
    YD829_FLAG_RATE_MID = 0x04,
    YD829_FLAG_RATE_HIGH= 0x08,
    YD829_FLAG_HEADLESS = 0x20,
    YD829_FLAG_VIDEO    = 0x40, 
    YD829_FLAG_STILL    = 0x80,
};

static void __attribute__((unused)) CG023_send_packet()
{
	// throttle : 0x00 - 0xFF
	throttle=convert_channel_8b(THROTTLE);
	// rudder
	rudder = convert_channel_16b_limit(RUDDER,0x44,0xBC);	// yaw right : 0x80 (neutral) - 0xBC (right)
	if (rudder<=0x80)
		rudder=0x80-rudder;							// yaw left : 0x00 (neutral) - 0x3C (left)
	// elevator : 0xBB - 0x7F - 0x43
	elevator = convert_channel_16b_limit(ELEVATOR, 0x43, 0xBB); 
	// aileron : 0x43 - 0x7F - 0xBB
	aileron = convert_channel_16b_limit(AILERON, 0x43, 0xBB); 
	
	if (IS_BIND_IN_PROGRESS)
	{
		packet[0]= 0xaa;
		XN297_RFChannel(CG023_RF_BIND_CHANNEL);
	}
	else
	{
		packet[0]= 0x55;
		XN297_RFChannel(hopping_frequency_no);
	}
	// transmitter id
	packet[1] = rx_tx_addr[0]; 
	packet[2] = rx_tx_addr[1];
	// unknown
	packet[3] = 0x00;
	packet[4] = 0x00;
	packet[5] = throttle;
	packet[6] = rudder;
	packet[7] = elevator;
	packet[8] = aileron;
	// throttle trim : 0x30 - 0x20 - 0x10
	packet[9] = 0x20; // neutral
	// neutral trims
	packet[10] = 0x20;
	packet[11] = 0x40;
	packet[12] = 0x40;
	if(sub_protocol==CG023)
	{
		// rate
		packet[13] =				  CG023_FLAG_RATE_HIGH
					| GET_FLAG(CH5_SW,CG023_FLAG_FLIP)
					| GET_FLAG(CH6_SW,CG023_FLAG_LED_OFF)
					| GET_FLAG(CH7_SW,CG023_FLAG_STILL)
					| GET_FLAG(CH8_SW,CG023_FLAG_VIDEO)
					| GET_FLAG(CH9_SW,CG023_FLAG_EASY);
	}
	else
	{// YD829
		// rate
		packet[13] =				  YD829_FLAG_RATE_HIGH
					| GET_FLAG(CH5_SW,YD829_FLAG_FLIP)
					| GET_FLAG(CH7_SW,YD829_FLAG_STILL)
					| GET_FLAG(CH8_SW,YD829_FLAG_VIDEO)
					| GET_FLAG(CH9_SW,YD829_FLAG_HEADLESS);
	}
	packet[14] = 0;
	
	// Send
	XN297_SetTxRxMode(TX_EN);
	XN297_SetPower();
	XN297_WritePayload(packet, CG023_PACKET_SIZE);
}

static void __attribute__((unused)) CG023_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);

	XN297_SetTXAddr((uint8_t *)"\x26\xA8\x67\x35\xCC", 5);
}

uint16_t CG023_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
			BIND_DONE;
	}
	CG023_send_packet();
	return	packet_period;
}

static void __attribute__((unused)) CG023_initialize_txid()
{
	rx_tx_addr[0]= 0x80 | (rx_tx_addr[0] % 0x40);
	if( rx_tx_addr[0] == 0xAA)						// avoid using same freq for bind and data channel
		rx_tx_addr[0] ++;
	hopping_frequency_no = rx_tx_addr[0] - 0x7D;	// rf channel for data packets
}

void CG023_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
    bind_counter = CG023_BIND_COUNT;
	CG023_initialize_txid();
	CG023_RF_init();
	if(sub_protocol==CG023)
		packet_period=CG023_PACKET_PERIOD;
	else // YD829
		packet_period=YD829_PACKET_PERIOD;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CX10_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with Cheerson CX-10 blue & newer red pcb, CX-10A, CX11, CX-10 green pcb, DM007, Floureon FX-10, JXD 509 (Q282), Q222, Q242 and Q282
// Last sync with hexfet new_protocols/cx10_nrf24l01.c dated 2015-11-26

#if defined(CX10_NRF24L01_INO)

#include "iface_xn297.h"

#define CX10_BIND_COUNT		4360	// 6 seconds
#define CX10_PACKET_SIZE	15
#define CX10A_PACKET_SIZE	19		// CX10 blue board packets have 19-byte payload
#define Q2X2_PACKET_SIZE	21
#define CX10_PACKET_PERIOD	1316	// Timeout for callback in uSec
#define CX10A_PACKET_PERIOD	6000

#define CX10_INITIAL_WAIT     500

// flags
#define CX10_FLAG_FLIP       0x10	// goes to rudder channel
#define CX10_FLAG_MODE_MASK  0x03
#define CX10_FLAG_HEADLESS   0x04
// flags2
#define CX10_FLAG_VIDEO      0x02
#define CX10_FLAG_SNAPSHOT   0x04

// frequency channel management
#define CX10_RF_BIND_CHANNEL 0x02
#define CX10_NUM_RF_CHANNELS    4

enum {
    CX10_BIND1 = 0,
    CX10_BIND2,
    CX10_DATA
};

static void __attribute__((unused)) CX10_Write_Packet()
{
	uint8_t offset = 0;
	if(sub_protocol == CX10_BLUE)
		offset = 4;
	packet[0] = IS_BIND_IN_PROGRESS ? 0xAA : 0x55;
	packet[1] = rx_tx_addr[0];
	packet[2] = rx_tx_addr[1];
	packet[3] = rx_tx_addr[2];
	packet[4] = rx_tx_addr[3];
	// packet[5] to [8] (aircraft id) is filled during bind for blue board
	uint16_t aileron= convert_channel_16b_limit(AILERON ,1000,2000);
	uint16_t elevator=convert_channel_16b_limit(ELEVATOR,2000,1000);
	uint16_t throttle=convert_channel_16b_limit(THROTTLE,1000,2000);
	uint16_t rudder=  convert_channel_16b_limit(RUDDER  ,2000,1000);
    // Channel 5 - flip flag
	packet[12+offset] = GET_FLAG(CH5_SW,CX10_FLAG_FLIP); 	// flip flag applied on rudder

	// Channel 6 - rate mode is 2 lsb of packet 13
	if(CH6_SW)												// rate 3 / headless on CX-10A
		flags = 0x02;
	else
		if(Channel_data[CH6] < CHANNEL_MIN_COMMAND)
			flags = 0x00;									// rate 1
		else
			flags = 0x01;									// rate 2
	uint8_t flags2=0;										// packet 14

	uint8_t video_state=packet[14] & 0x21;
	switch(sub_protocol)
	{
		case CX10_BLUE:
			flags |= GET_FLAG(!CH7_SW, 0x10)				// Channel 7 - picture
					|GET_FLAG( CH8_SW, 0x08);				// Channel 8 - video
			break;
		case F_Q282:
		case F_Q242:
		case F_Q222:
			memcpy(&packet[15], "\x10\x10\xaa\xaa\x00\x00", 6);
			//FLIP|LED|PICTURE|VIDEO|HEADLESS|RTH|XCAL|YCAL
			flags2 = GET_FLAG(CH5_SW, 0x80)					// Channel 5 - FLIP
					|GET_FLAG(!CH6_SW, 0x40)				// Channel 6 - LED
					|GET_FLAG(CH9_SW, 0x08)					// Channel 9 - HEADLESS
					|GET_FLAG(CH11_SW, 0x04)				// Channel 11 - XCAL
					|GET_FLAG(CH12_SW, 0x02);				// Channel 12 - YCAL or Start/Stop motors on JXD 509
	
			if(sub_protocol==F_Q242)
			{
				flags=2;
				flags2|= GET_FLAG(CH7_SW,0x01)				// Channel 7 - picture
						|GET_FLAG(CH8_SW,0x10);				// Channel 8 - video
				packet[17]=0x00;
				packet[18]=0x00;
			}
			else
			{ // F_Q282 & F_Q222
				flags=3;									// expert
				if(CH8_SW)									// Channel 8 - F_Q282 video / F_Q222 Module 1
				{
					if (!(video_state & 0x20)) video_state ^= 0x21;
				}
				else
					if (video_state & 0x20) video_state &= 0x01;
				flags2 |= video_state
						|GET_FLAG(CH7_SW,0x10);				// Channel 7 - F_Q282 picture / F_Q222 Module 2
			}
			if(CH10_SW)	flags |=0x80;						// Channel 10 - RTH
			break;
		case DM007:
			aileron = 3000 - aileron;
			//FLIP|MODE|PICTURE|VIDEO|HEADLESS
			flags2=  GET_FLAG(CH7_SW,CX10_FLAG_SNAPSHOT)	// Channel 7 - picture
					|GET_FLAG(CH8_SW,CX10_FLAG_VIDEO);		// Channel 8 - video
			if(CH9_SW)	flags |= CX10_FLAG_HEADLESS;		// Channel 9 - headless
			break;
		case JC3015_2:
			aileron = 3000 - aileron;
			elevator = 3000 - elevator;
			//FLIP|MODE|LED|DFLIP
			if(CH8_SW)	packet[12] &= ~CX10_FLAG_FLIP;
		case JC3015_1:
			//FLIP|MODE|PICTURE|VIDEO
			flags2=	 GET_FLAG(CH7_SW,_BV(3))				// Channel 7
					|GET_FLAG(CH8_SW,_BV(4));				// Channel 8
			break;
		case MK33041:
			elevator = 3000 - elevator;
			//FLIP|MODE|PICTURE|VIDEO|HEADLESS|RTH
			flags|=GET_FLAG(CH7_SW,_BV(7))					// Channel 7 - picture
				  |GET_FLAG(CH10_SW,_BV(2));				// Channel 10 - rth
			flags2=GET_FLAG(CH8_SW,_BV(0))					// Channel 8 - video
				  |GET_FLAG(CH9_SW,_BV(5));					// Channel 9 - headless
			break;
	}
	packet[5+offset] = lowByte(aileron);
	packet[6+offset] = highByte(aileron);
	packet[7+offset] = lowByte(elevator);
	packet[8+offset] = highByte(elevator);
	packet[9+offset] = lowByte(throttle);
	packet[10+offset]= highByte(throttle);
	packet[11+offset]= lowByte(rudder);
	packet[12+offset]|= highByte(rudder);
	packet[13+offset]=flags;
	packet[14+offset]=flags2;
	
	// Send
	if(IS_BIND_DONE)
	{
		XN297_Hopping(hopping_frequency_no++);
		hopping_frequency_no %= CX10_NUM_RF_CHANNELS;
	}
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, packet_length);
}

static void __attribute__((unused)) CX10_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t *)"\xcc\xcc\xcc\xcc\xcc", 5);
	XN297_SetRXAddr((uint8_t *)"\xcc\xcc\xcc\xcc\xcc", packet_length);
	XN297_RFChannel(CX10_RF_BIND_CHANNEL);
}

uint16_t CX10_callback()
{
	switch (phase) {
		case CX10_BIND1:
			if (bind_counter == 0)
			{
				phase = CX10_DATA;
				BIND_DONE;
			}
			else
			{
				CX10_Write_Packet();
				bind_counter--;
			}
			break;
		case CX10_BIND2:
			// switch to TX mode
			if( XN297_IsRX() )
			{ // RX fifo data ready
				debugln("RX");
				if(XN297_ReadPayload(packet, packet_length) && packet[9] == 1)
				{
					BIND_DONE;
					XN297_SetTxRxMode(TXRX_OFF);
					phase = CX10_DATA;
					break;
				}
			}
			else
			{
				XN297_SetTxRxMode(TXRX_OFF);
				CX10_Write_Packet();
				// wait for packet to be sent
				while( !XN297_IsPacketSent());					//delayMicroseconds(400);
			}
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			break;
		case CX10_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(packet_period);
			#endif
			CX10_Write_Packet();
			break;
	}
	return packet_period;
}

static void __attribute__((unused)) CX10_initialize_txid()
{
	rx_tx_addr[1]%= 0x30;
	if(sub_protocol&0x08)	//F_Q2X2 protocols
	{
		uint8_t offset=0;	//F_Q282
		if(sub_protocol==F_Q242)
			offset=2;
		if(sub_protocol==F_Q222)
			offset=3;
		for(uint8_t i=0;i<4;i++)
			hopping_frequency[i]=0x46+2*i+offset;
	}
	else
	{
		hopping_frequency[0] = 0x03 + (rx_tx_addr[0] & 0x0F);
		hopping_frequency[1] = 0x16 + (rx_tx_addr[0] >> 4);
		hopping_frequency[2] = 0x2D + (rx_tx_addr[1] & 0x0F);
		hopping_frequency[3] = 0x40 + (rx_tx_addr[1] >> 4);
	}
}

void CX10_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
	
	if(protocol == PROTO_Q2X2)
		sub_protocol|=0x08;		// Increase the number of sub_protocols for CX-10
	
	if(sub_protocol==CX10_BLUE)
	{
		packet_length = CX10A_PACKET_SIZE;
		packet_period = CX10A_PACKET_PERIOD;

		phase = CX10_BIND2;

		for(uint8_t i=0; i<4; i++)
			packet[5+i] = 0xff; // clear aircraft id
		packet[9] = 0;
	}
	else
	{
		if(sub_protocol&0x08)	//F_Q2X2 protocols
			packet_length = Q2X2_PACKET_SIZE;
		else
		    packet_length = CX10_PACKET_SIZE;
		packet_period = CX10_PACKET_PERIOD;
		phase = CX10_BIND1;
		bind_counter = CX10_BIND_COUNT;
	}
	CX10_initialize_txid();
	CX10_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/CYRF6936_SPI.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifdef CYRF6936_INSTALLED
#include "iface_cyrf6936.h"

void CYRF_WriteRegister(uint8_t address, uint8_t data)
{
	CYRF_CSN_off;
	SPI_Write(0x80 | address);
	SPI_Write(data);
	CYRF_CSN_on;
}

static void CYRF_WriteRegisterMulti(uint8_t address, const uint8_t data[], uint8_t length)
{
	uint8_t i;

	CYRF_CSN_off;
	SPI_Write(0x80 | address);
	for(i = 0; i < length; i++)
		SPI_Write(data[i]);
	CYRF_CSN_on;
}

static void CYRF_ReadRegisterMulti(uint8_t address, uint8_t data[], uint8_t length)
{
	uint8_t i;

	CYRF_CSN_off;
	SPI_Write(address);
	for(i = 0; i < length; i++)
		data[i] = SPI_Read();
	CYRF_CSN_on;
}

uint8_t CYRF_ReadRegister(uint8_t address)
{
	uint8_t data;
	CYRF_CSN_off;
	SPI_Write(address);
	data = SPI_Read();
	CYRF_CSN_on;
	return data;
}
//

uint8_t CYRF_Reset()
{
#ifdef CYRF_RST_HI
	CYRF_RST_HI;										//Hardware reset
	delayMicroseconds(100);
	CYRF_RST_LO;
	delayMicroseconds(100);		  
#endif
	CYRF_WriteRegister(CYRF_1D_MODE_OVERRIDE, 0x01);	//Software reset
	delayMicroseconds(200);
	CYRF_WriteRegister(CYRF_0C_XTAL_CTRL, 0xC0);		//Enable XOUT as GPIO
	CYRF_WriteRegister(CYRF_0D_IO_CFG, 0x04);			//Enable PACTL as GPIO
	CYRF_SetTxRxMode(TXRX_OFF);
	//Verify the CYRF chip is responding
	return (CYRF_ReadRegister(CYRF_10_FRAMING_CFG) == 0xa5);
}

/*
*
*/
void CYRF_GetMfgData(uint8_t data[])
{
#ifndef FORCE_CYRF_ID
	if(eeprom_read_byte((EE_ADDR)EEPROM_CID_INIT_OFFSET)==0xf0)
	{//read Cyrf ID from EEPROM
		for(uint8_t i=0;i<6;i++)
			data[i] = eeprom_read_byte((EE_ADDR)EEPROM_CID_OFFSET+i);
	}
	else
	{//read Cyrf ID and store it EEPROM
		/* Fuses power on */
		CYRF_WriteRegister(CYRF_25_MFG_ID, 0xFF);

		CYRF_ReadRegisterMulti(CYRF_25_MFG_ID, data, 6);
		for(uint8_t i=0;i<6;i++)
			eeprom_write_byte((EE_ADDR)EEPROM_CID_OFFSET+i, data[i]);
		eeprom_write_byte((EE_ADDR)EEPROM_CID_INIT_OFFSET, 0xf0);

		/* Fuses power off */
		CYRF_WriteRegister(CYRF_25_MFG_ID, 0x00);
	}
#else
	memcpy(data,FORCE_CYRF_ID,6);
#endif
}

/*
* 1 - Tx else Rx
*/
void CYRF_SetTxRxMode(uint8_t mode)
{
	if(mode==TXRX_OFF)
	{
		if( protocol!=PROTO_WFLY && protocol!=PROTO_MLINK )
			CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24); // 4=IDLE, 8=TX, C=RX
		CYRF_WriteRegister(CYRF_0E_GPIO_CTRL,0x00); // XOUT=0 PACTL=0
	}
	else
	{
		//Set the post tx/rx state
		if( protocol!=PROTO_WFLY && protocol!=PROTO_MLINK )
			CYRF_WriteRegister(CYRF_0F_XACT_CFG, mode == TX_EN ? 0x28 : 0x2C); // 4=IDLE, 8=TX, C=RX
		if(mode == TX_EN)
#ifdef ORANGE_TX_BLUE
			CYRF_WriteRegister(CYRF_0E_GPIO_CTRL,0x20); // XOUT=1, PACTL=0
		else
			CYRF_WriteRegister(CYRF_0E_GPIO_CTRL,0x80);	// XOUT=0, PACTL=1
#else
			CYRF_WriteRegister(CYRF_0E_GPIO_CTRL,0x80); // XOUT=1, PACTL=0
		else
			CYRF_WriteRegister(CYRF_0E_GPIO_CTRL,0x20);	// XOUT=0, PACTL=1
#endif
	}
}
/*
*
*/
void CYRF_ConfigRFChannel(uint8_t ch)
{
	CYRF_WriteRegister(CYRF_00_CHANNEL,ch);
}

/*
static void CYRF_SetPower_Value(uint8_t power)
{
	uint8_t val = CYRF_ReadRegister(CYRF_03_TX_CFG) & 0xF8;
	CYRF_WriteRegister(CYRF_03_TX_CFG, val | (power & 0x07));
}
*/

void CYRF_SetPower(uint8_t val)
{
	uint8_t power=CYRF_BIND_POWER;
	if(IS_BIND_DONE)
		#ifdef CYRF6936_ENABLE_LOW_POWER
			power=IS_POWER_FLAG_on?CYRF_HIGH_POWER:CYRF_LOW_POWER;
		#else
			power=CYRF_HIGH_POWER;
		#endif
	if(IS_RANGE_FLAG_on)
		power=CYRF_RANGE_POWER;
	power|=val;
	if(prev_power != power)
	{
		CYRF_WriteRegister(CYRF_03_TX_CFG,power);
		prev_power=power;
	}

	#ifdef USE_CYRF6936_CH15_TUNING
		static uint16_t Channel15=1024;
		if(Channel15!=Channel_data[CH15])
		{ // adjust frequency
			Channel15=Channel_data[CH15]+0x155;	// default value is 0x555 = 0x400 + 0x155
			CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB, Channel15&0xFF);
			CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB, Channel15>>8);
			Channel15-=0x155;
		}
	#endif
}

/*
*
*/
void CYRF_ConfigCRCSeed(uint16_t crc_seed)
{
	CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB,crc_seed & 0xff);
	CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB,crc_seed >> 8);
}
/*
* these are the recommended sop codes from Cyrpress
* See "WirelessUSB LP/LPstar and PRoC LP/LPstar Technical Reference Manual"
*/
void CYRF_ConfigSOPCode(const uint8_t *sopcodes)
{
	//NOTE: This can also be implemented as:
	//for(i = 0; i < 8; i++) WriteRegister)0x23, sopcodes[i];
	CYRF_WriteRegisterMulti(CYRF_22_SOP_CODE, sopcodes, 8);
}

void CYRF_ConfigDataCode(const uint8_t *datacodes)
{
	//NOTE: This can also be implemented as:
	//for(i = 0; i < 16; i++) WriteRegister)0x23, datacodes[i];
	CYRF_WriteRegisterMulti(CYRF_23_DATA_CODE, datacodes, 16);
}

void CYRF_WritePreamble(uint32_t preamble)
{
	CYRF_CSN_off;
	SPI_Write(0x80 | 0x24);
	SPI_Write(preamble & 0xff);
	SPI_Write((preamble >> 8) & 0xff);
	SPI_Write((preamble >> 16) & 0xff);
	CYRF_CSN_on;
}
/*
*
*/
/*static void CYRF_ReadDataPacket(uint8_t dpbuffer[])
{
	CYRF_ReadRegisterMulti(CYRF_21_RX_BUFFER, dpbuffer, 0x10);
}
*/
void CYRF_ReadDataPacketLen(uint8_t dpbuffer[], uint8_t length)
{
    CYRF_ReadRegisterMulti(CYRF_21_RX_BUFFER, dpbuffer, length);
}

static void CYRF_WriteDataPacketLen(const uint8_t dpbuffer[], uint8_t len)
{
	CYRF_WriteRegister(CYRF_01_TX_LENGTH, len);
	CYRF_WriteRegister(CYRF_02_TX_CTRL, 0x43);	// 0x40
	CYRF_WriteRegisterMulti(CYRF_20_TX_BUFFER, dpbuffer, len);
	CYRF_WriteRegister(CYRF_02_TX_CTRL, 0x83);	// 0xBF
}

void CYRF_WriteDataPacket(const uint8_t dpbuffer[])
{
	CYRF_WriteDataPacketLen(dpbuffer, 16);
}

/*static uint8_t CYRF_ReadRSSI(uint8_t dodummyread)
{
	uint8_t result;
	if(dodummyread)
		CYRF_ReadRegister(CYRF_13_RSSI);
	result = CYRF_ReadRegister(CYRF_13_RSSI);
	if(result & 0x80)
		result = CYRF_ReadRegister(CYRF_13_RSSI);
	return (result & 0x0F);
}
*/
//NOTE: This routine will reset the CRC Seed
void CYRF_FindBestChannels(uint8_t *channels, uint8_t len, uint8_t minspace, uint8_t min, uint8_t max, uint8_t forced)
{
	#define NUM_FREQ 80
	#define FREQ_OFFSET 4
	uint8_t rssi[NUM_FREQ];

	if (min < FREQ_OFFSET)
		min = FREQ_OFFSET;
	if (max > NUM_FREQ)
		max = NUM_FREQ;

	uint8_t i;
	int8_t j;
	memset(channels, 0, sizeof(uint8_t) * len);
	CYRF_ConfigCRCSeed(0x0000);
	CYRF_SetTxRxMode(RX_EN);
	//Wait for pre-amp to switch from send to receive
	delayMilliseconds(1);
	for(i = 0; i < NUM_FREQ; i++)
	{
		if(((i&1) && forced == FIND_CHANNEL_EVEN) || (!(i&1) && forced == FIND_CHANNEL_ODD))
		{
			rssi[i] = 0xFF;
			continue;
		}
		CYRF_ConfigRFChannel(i);	//protocol==PROTO_LOSI?i|1:i);
		delayMicroseconds(270);					//slow channel require 270usec for synthesizer to settle
        if( !(CYRF_ReadRegister(CYRF_05_RX_CTRL) & 0x80)) {
            CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x80); //Prepare to receive
            delayMicroseconds(15);
            CYRF_ReadRegister(CYRF_13_RSSI);	//dummy read
            delayMicroseconds(15);				//The conversion can occur as often as once every 12us
        }
		rssi[i] = CYRF_ReadRegister(CYRF_13_RSSI)&0x1F;
	}

	for (i = 0; i < len; i++)
	{
		channels[i] = min;
		for (j = min; j < max; j++)
			if (rssi[j] < rssi[channels[i]])
				channels[i] = j;
		for (j = channels[i] - minspace; j < channels[i] + minspace; j++) {
			//Ensure we don't reuse any channels within minspace of the selected channel again
			if (j < 0 || j >= NUM_FREQ)
				continue;
			rssi[j] = 0xff;
		}
	}
	CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Abort RX operation
	CYRF_SetTxRxMode(TX_EN);
	CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Clear abort RX
}

#if defined(DEVO_CYRF6936_INO) || defined(J6PRO_CYRF6936_INO) || defined(TRAXXAS_CYRF6936_INO)
const uint8_t PROGMEM DEVO_j6pro_sopcodes[][8] = {
    /* Note these are in order transmitted (LSB 1st) */
    {0x3C, 0x37, 0xCC, 0x91, 0xE2, 0xF8, 0xCC, 0x91},
    {0x9B, 0xC5, 0xA1, 0x0F, 0xAD, 0x39, 0xA2, 0x0F},
    {0xEF, 0x64, 0xB0, 0x2A, 0xD2, 0x8F, 0xB1, 0x2A},
    {0x66, 0xCD, 0x7C, 0x50, 0xDD, 0x26, 0x7C, 0x50},
    {0x5C, 0xE1, 0xF6, 0x44, 0xAD, 0x16, 0xF6, 0x44},
    {0x5A, 0xCC, 0xAE, 0x46, 0xB6, 0x31, 0xAE, 0x46},
    {0xA1, 0x78, 0xDC, 0x3C, 0x9E, 0x82, 0xDC, 0x3C},
    {0xB9, 0x8E, 0x19, 0x74, 0x6F, 0x65, 0x18, 0x74},
    {0xDF, 0xB1, 0xC0, 0x49, 0x62, 0xDF, 0xC1, 0x49},
    {0x97, 0xE5, 0x14, 0x72, 0x7F, 0x1A, 0x14, 0x72},
#if defined(J6PRO_CYRF6936_INO) || defined(TRAXXAS_CYRF6936_INO)
    {0x82, 0xC7, 0x90, 0x36, 0x21, 0x03, 0xFF, 0x17},
    {0xE2, 0xF8, 0xCC, 0x91, 0x3C, 0x37, 0xCC, 0x91}, //Note: the '03' was '9E' in the Cypress recommended table
    {0xAD, 0x39, 0xA2, 0x0F, 0x9B, 0xC5, 0xA1, 0x0F}, //The following are the same as the 1st 8 above,
    {0xD2, 0x8F, 0xB1, 0x2A, 0xEF, 0x64, 0xB0, 0x2A}, //but with the upper and lower word swapped
    {0xDD, 0x26, 0x7C, 0x50, 0x66, 0xCD, 0x7C, 0x50},
    {0xAD, 0x16, 0xF6, 0x44, 0x5C, 0xE1, 0xF6, 0x44},
    {0xB6, 0x31, 0xAE, 0x46, 0x5A, 0xCC, 0xAE, 0x46},
    {0x9E, 0x82, 0xDC, 0x3C, 0xA1, 0x78, 0xDC, 0x3C},
    {0x6F, 0x65, 0x18, 0x74, 0xB9, 0x8E, 0x19, 0x74},
    {0x62, 0xDF, 0xC1, 0x49, 0xDF, 0xB1, 0xC0, 0x49}, //j6pro bind
#endif
};
#endif

static void __attribute__((unused)) CYRF_PROGMEM_ConfigSOPCode(const uint8_t *data)
{
	uint8_t code[8];
	//debug("SOP:");
	for(uint8_t i=0;i<8;i++)
	{
		code[i]=pgm_read_byte_near(&data[i]);
		//debug(" %02X",code[i]);
	}
	//debugln("");
	CYRF_ConfigSOPCode(code);
}

//CYRF GFSK 1Mb functions
const uint8_t PROGMEM CYRF_GFSK1M_init_vals[][2] = {
	{CYRF_02_TX_CTRL, 0x00},		// transmit err & complete interrupts disabled
	{CYRF_05_RX_CTRL, 0x00},		// receive err & complete interrupts disabled
	{CYRF_28_CLK_EN, 0x02},			// Force Receive Clock Enable, MUST be set
	{CYRF_32_AUTO_CAL_TIME, 0x3c},	// must be set to 3C
	{CYRF_35_AUTOCAL_OFFSET, 0x14},	// must be  set to 14
	{CYRF_06_RX_CFG, 0x48},			// LNA manual control, Rx Fast Turn Mode Enable
	{CYRF_1B_TX_OFFSET_LSB, 0x00},	// Tx frequency offset LSB
	{CYRF_1C_TX_OFFSET_MSB, 0x00},	// Tx frequency offset MSB
	{CYRF_0F_XACT_CFG, 0x24},		// Force End State, transaction end state = idle
	{CYRF_03_TX_CFG, 0x00},			// GFSK mode
	{CYRF_12_DATA64_THOLD, 0x0a},	// 64 Chip Data PN Code Correlator Threshold = 10
	{CYRF_0F_XACT_CFG, 0x04},		// Transaction End State = idle
	{CYRF_39_ANALOG_CTRL, 0x01},	// synth setting time for all channels is the same as for slow channels
	{CYRF_0F_XACT_CFG, 0x24},		//Force IDLE
	{CYRF_29_RX_ABORT, 0x00},		//Clear RX abort
	{CYRF_12_DATA64_THOLD, 0x0a},	//set pn correlation threshold
	{CYRF_10_FRAMING_CFG, 0x4a},	//set sop len and threshold
	{CYRF_29_RX_ABORT, 0x0f},		//Clear RX abort?
	{CYRF_03_TX_CFG, 0x00},			// GFSK mode
	{CYRF_10_FRAMING_CFG, 0x4a},	// 0b11000000 //set sop len and threshold
	{CYRF_1F_TX_OVERRIDE, 0x04},	//disable tx CRC
	{CYRF_1E_RX_OVERRIDE, 0x14},	//disable rx crc
	{CYRF_14_EOP_CTRL, 0x00},		//set EOP sync == 0
};
static void __attribute__((unused)) CYRF_GFSK1M_Init(uint8_t payload_length, uint8_t preamble_len)
{
	for(uint8_t i = 0; i < sizeof(CYRF_GFSK1M_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&CYRF_GFSK1M_init_vals[i][0]), pgm_read_byte_near(&CYRF_GFSK1M_init_vals[i][1]));


	CYRF_WriteRegister(CYRF_01_TX_LENGTH, payload_length);
	
	CYRF_WritePreamble(0xAAAA00 | preamble_len);

	CYRF_SetPower(0x00);
	
	CYRF_SetTxRxMode(TX_EN);
}
static void __attribute__((unused)) CYRF_GFSK1M_SendPayload(uint8_t *buffer, uint8_t len)
{
	uint8_t send=len>16 ? 16 : len;
	CYRF_WriteRegister(CYRF_02_TX_CTRL, 0x40);
	CYRF_WriteRegisterMulti(CYRF_20_TX_BUFFER, buffer, send);			// Fill the buffer with 16 bytes max
	CYRF_WriteRegister(CYRF_02_TX_CTRL, 0x80);							// Start send
	buffer += send;
	len -= send;

	while(len>8)
	{
		while((CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS)&0x10) == 0);	// Wait that half of the buffer is empty
		CYRF_WriteRegisterMulti(CYRF_20_TX_BUFFER, buffer, 8);			// Add 8 bytes to the buffer
		buffer+=8;
		len-=8;
	}

	if(len)
	{
		while((CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS)&0x10) == 0);	// Wait that half of the buffer is empty
		CYRF_WriteRegisterMulti(CYRF_20_TX_BUFFER, buffer, len);		// Add the remaining bytes to the buffer
	}
}
#define CYRF_GFSK1M_SetPower() CYRF_SetPower(0x00)
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Convert.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

/************************/
/**  Convert routines  **/
/************************/
// Reverse a channel and store it
void reverse_channel(uint8_t num)
{
	uint16_t val=2048-Channel_data[num];
	if(val>=2048) val=2047;
	Channel_data[num]=val;
}

// Channel value is converted to ppm 860<->2140 -125%<->+125% and 988<->2012 -100%<->+100%
uint16_t convert_channel_ppm(uint8_t num)
{
	uint16_t val=Channel_data[num];
	return (((val<<2)+val)>>3)+860;				//value range 860<->2140 -125%<->+125%
}

// Channel value 100% is converted to 10bit values 0<->1023
uint16_t convert_channel_10b(uint8_t num, bool failsafe)
{
	uint16_t val;
	#ifdef FAILSAFE_ENABLE
	if(failsafe)
		val=Failsafe_data[num];				// 0<->2047
	else
	#endif
		val=Channel_data[num];
	val=((val<<2)+val)>>3;
	if(val<=128) return 0;
	if(val>=1152) return 1023;
	return val-128;
}

// Channel value 100% is converted to 8bit values 0<->255
uint8_t convert_channel_8b(uint8_t num)
{
	uint16_t val=Channel_data[num];
	val=((val<<2)+val)>>5;
	if(val<=32) return 0;
	if(val>=288) return 255;
	return val-32;
}

// Channel value 100% is converted to 8b with deadband
uint8_t convert_channel_8b_limit_deadband(uint8_t num,uint8_t min,uint8_t mid, uint8_t max, uint8_t deadband)
{
	uint16_t val=limit_channel_100(num);		// 204<->1844
	uint16_t db_low=CHANNEL_MID-deadband, db_high=CHANNEL_MID+deadband; // 1024+-deadband
	int32_t calc;
	uint8_t out;
	if(val>=db_low && val<=db_high)
		return mid;
	else if(val<db_low)
	{
		val-=CHANNEL_MIN_100;
		calc=mid-min;
		calc*=val;
		calc/=(db_low-CHANNEL_MIN_100);
		out=calc;
		out+=min;
	}
	else
	{
		val-=db_high;
		calc=max-mid;
		calc*=val;
		calc/=(CHANNEL_MAX_100-db_high+1);
		out=calc;
		out+=mid;
		if(max>min) out++; else out--;
	}
	return out;
}

// Channel value 100% is converted to value scaled
int16_t convert_channel_16b_limit(uint8_t num,int16_t min,int16_t max)
{
	int32_t val=limit_channel_100(num);			// 204<->1844
	val=(val-CHANNEL_MIN_100)*(max-min)/(CHANNEL_MAX_100-CHANNEL_MIN_100)+min;
	return (uint16_t)val;
}

// Channel value -125%<->125% is scaled to 16bit value with no limit
int16_t convert_channel_16b_nolimit(uint8_t num, int16_t min, int16_t max, bool failsafe)
{
	int32_t val;
	#ifdef FAILSAFE_ENABLE
	if(failsafe)
		val=Failsafe_data[num];				// 0<->2047
	else
	#endif
		val=Channel_data[num];				// 0<->2047
	val=(val-CHANNEL_MIN_100)*(max-min)/(CHANNEL_MAX_100-CHANNEL_MIN_100)+min;
	return (uint16_t)val;
}

// Channel value is converted sign + magnitude 8bit values
uint8_t convert_channel_s8b(uint8_t num)
{
	uint8_t ch;
	ch = convert_channel_8b(num);
	return (ch < 128 ? 127-ch : ch);	
}

// Channel value is limited to 100%
uint16_t limit_channel_100(uint8_t num)
{
	if(Channel_data[num]>=CHANNEL_MAX_100)
		return CHANNEL_MAX_100;
	if (Channel_data[num]<=CHANNEL_MIN_100)
		return CHANNEL_MIN_100;
	return Channel_data[num];
}

// Channel value is converted for HK310
void convert_channel_HK310(uint8_t num, uint8_t *low, uint8_t *high)
{
	uint16_t temp=0xFFFF-(3440+((Channel_data[num]*5)>>1))/3;
	*low=(uint8_t)(temp&0xFF);
	*high=(uint8_t)(temp>>8);
}

#ifdef FAILSAFE_ENABLE
// Failsafe value is converted for HK310
void convert_failsafe_HK310(uint8_t num, uint8_t *low, uint8_t *high)
{
	uint16_t temp=0xFFFF-(3440+((Failsafe_data[num]*5)>>1))/3;
	*low=(uint8_t)(temp&0xFF);
	*high=(uint8_t)(temp>>8);
}
#endif

// Channel value for FrSky (PPM is multiplied by 1.5)
uint16_t convert_channel_frsky(uint8_t num)
{
	uint16_t val=Channel_data[num];
	return ((val*15)>>4)+1290;
}

// 0-2047, 0 = 817, 1024 = 1500, 2047 = 2182
//64=860,1024=1500,1984=2140//Taranis 125%
static uint16_t  __attribute__((unused)) FrSkyX_scaleForPXX( uint8_t i, uint8_t num_chan=8)
{	//mapped 860,2140(125%) range to 64,1984(PXX values);
	uint16_t chan_val=convert_channel_frsky(i)-1226;
	if(i>=num_chan) chan_val|=2048;   // upper channels offset
	return chan_val;
}

#ifdef FAILSAFE_ENABLE
static uint16_t  __attribute__((unused)) FrSkyX_scaleForPXX_FS( uint8_t i, uint8_t num_chan=8)
{	//mapped 1,2046(125%) range to 64,1984(PXX values);
	uint16_t chan_val=((Failsafe_data[i]*15)>>4)+64;
	if(Failsafe_data[i]==FAILSAFE_CHANNEL_NOPULSES)
		chan_val=FAILSAFE_CHANNEL_NOPULSES;
	else if(Failsafe_data[i]==FAILSAFE_CHANNEL_HOLD)
		chan_val=FAILSAFE_CHANNEL_HOLD;
	if(i>=num_chan) chan_val|=2048;   // upper channels offset
	return chan_val;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Corona_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(CORONA_CC2500_INO)

#include "iface_cc2500.h"

//#define CORONA_FORCE_ID

#define CORONA_RF_NUM_CHANNELS	3
#define CORONA_ADDRESS_LENGTH	4
#define CORONA_BIND_CHANNEL_V1	0xD1	// also Flydream V3
#define CORONA_BIND_CHANNEL_V2	0xB8
#define CORONA_COARSE			0x00
#define FDV3_BIND_PERIOD		5000
#define FDV3_CHANNEL_PERIOD		4000

const PROGMEM uint8_t CORONA_init_values[] = {
  /* 00 */ 0x29, 0x2E, 0x06, 0x07, 0xD3, 0x91, 0xFF, 0x04,
  /* 08 */ 0x05, 0x00, CORONA_BIND_CHANNEL_V1, 0x06, 0x00, 0x5C, 0x4E, 0xC4 + CORONA_COARSE,
  /* 10 */ 0x5B, 0xF8, 0x03, 0x23, 0xF8, 0x47, 0x07, 0x30,
  /* 18 */ 0x18, 0x16, 0x6C, 0x43, 0x40, 0x91, 0x87, 0x6B,
  /* 20 */ 0xF8, 0x56, 0x10, 0xA9, 0x0A, 0x00, 0x11, 0x41,
  /* 28 */ 0x00, 0x59, 0x7F, 0x3F, 0x81, 0x35, 0x0B
};

uint8_t fdv3_id_send;

static void __attribute__((unused)) CORONA_rf_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i <= 0x2E; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&CORONA_init_values[i]));
	if(sub_protocol==COR_V2)
	{
		CC2500_WriteReg(CC2500_0A_CHANNR, CORONA_BIND_CHANNEL_V2);
		CC2500_WriteReg(CC2500_0E_FREQ1, 0x80);
		CC2500_WriteReg(CC2500_0F_FREQ0, 0x00 + CORONA_COARSE);
		CC2500_WriteReg(CC2500_15_DEVIATN, 0x50);
		CC2500_WriteReg(CC2500_17_MCSM1, 0x00);
	    CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0x67);
		CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0xFB);
		CC2500_WriteReg(CC2500_1D_AGCCTRL0, 0xDC);
	}
	else if(sub_protocol==FD_V3)
	{
		// Flydream receiver captures have deviation 50, tx captures show 47
		CC2500_WriteReg(CC2500_15_DEVIATN, 0x50);
	}
	
	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);

	//not sure what they are doing to the PATABLE since basically only the first byte is used and it's only 8 bytes long. So I think they end up filling the PATABLE fully with 0xFF
	CC2500_WriteRegisterMulti(CC2500_3E_PATABLE,(const uint8_t *)"\x08\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 13);

	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}

// Generate id and hopping freq
static void __attribute__((unused)) CORONA_TXID_init()
{
	#ifdef CORONA_FORCE_ID
		// Example of ID and channels taken from dumps
		switch(sub_protocol)
		{
			case COR_V1:
				memcpy((void *)rx_tx_addr,(void *)"\x1F\xFE\x6C\x35",CORONA_ADDRESS_LENGTH);
				memcpy((void *)hopping_frequency,(void *)"\x17\x0D\x03\x49",CORONA_RF_NUM_CHANNELS+1);
				break;
			case COR_V2:
				memcpy((void *)rx_tx_addr,(void *)"\xFE\xFE\x02\xFB",CORONA_ADDRESS_LENGTH);
				memcpy((void *)hopping_frequency,(void *)"\x14\x3D\x35",CORONA_RF_NUM_CHANNELS);
			case FD_V3:
				memcpy((void *)rx_tx_addr,(void *)"\x02\xFA\x38\x38",CORONA_ADDRESS_LENGTH);
				memcpy((void *)hopping_frequency,(void *)"\x71\xB9\x30",CORONA_RF_NUM_CHANNELS);
				break;
	}
	#else
		// From dumps channels are anything between 0x00 and 0xC5 on V1.
		// But 0x00 and 0xB8 should be avoided on V2 since they are used for bind.
		// Below code make sure channels are between 0x02 and 0xA0, spaced with
		// a minimum of 2 and not ordered (RX only use the 1st channel unless there is an issue).
		// Extra hopping frequency used for Flydream V3 id packets.
		uint8_t order=rx_tx_addr[3]&0x03;
		for(uint8_t i=0; i<CORONA_RF_NUM_CHANNELS+1; i++)
			hopping_frequency[i^order]=2+rx_tx_addr[3-i]%39+(i<<5)+(i<<3);

		if(sub_protocol!=FD_V3)
		{
			// ID looks random but on the 15 V1 dumps they all show the same odd/even rule
			if(rx_tx_addr[3]&0x01)
			{	// If [3] is odd then [0] is odd and [2] is even 
				rx_tx_addr[0]|=0x01;
				rx_tx_addr[2]&=0xFE;
			}
			else
			{	// If [3] is even then [0] is even and [2] is odd 
				rx_tx_addr[0]&=0xFE;
				rx_tx_addr[2]|=0x01;
			}
			rx_tx_addr[1]=0xFE;			// Always FE in the dumps of V1 and V2
		}
		else
		{
			rx_tx_addr[1]=0xFA;			// Always FA for Flydream V3
			rx_tx_addr[3]=hopping_frequency[CORONA_RF_NUM_CHANNELS];	// channel used for id/freq packets
		}
	#endif
}

static uint16_t __attribute__((unused)) CORONA_build_bind_pkt()
{
	if(sub_protocol==COR_V1)
	{	// V1
		if(bind_counter&1)
		{ // Send TX ID
			packet[0]=0x04;		// 5 bytes to follow
			for(uint8_t i=0; i<CORONA_ADDRESS_LENGTH; i++)
				packet[i+1]=rx_tx_addr[i];
			packet[5]=0xCD;		// Unknown but seems to be always the same value for V1
			return 3689;
		}
		else
		{ // Send hopping freq
			packet[0]=0x03;		// 4 bytes to follow
			for(uint8_t i=0; i<CORONA_RF_NUM_CHANNELS+1; i++)
				packet[i+1]=hopping_frequency[i];
			// Only the first 3 channels of hopping_frequency used for data
			return 3438;
		}
	}
	else
	{	// V2 and FDV3
		packet[0]=0x04;		// 5 bytes to follow
		for(uint8_t i=0; i<CORONA_ADDRESS_LENGTH; i++)
			packet[i+1]=rx_tx_addr[i];
		packet[5]=0x00;		// Unknown but seems to be always the same value for V2 and FDV3
		if(sub_protocol==FD_V3)
			return FDV3_BIND_PERIOD;
		else
			return 26791;
	}
}

// 8 Channels with direct values from PPM
static uint16_t __attribute__((unused)) CORONA_build_packet()
{
	CC2500_SetPower();
	if(state && sub_protocol==COR_V2)
	{	// Send identifier packet for 2.65sec. This is how the RX learns the hopping table after a bind. Why it's not part of the bind like V1 is a mistery...
		// Set channel
		CC2500_WriteReg(CC2500_0A_CHANNR, 0x00);
		state--;
		packet[0]=0x07;		// 8 bytes to follow
		// Send hopping freq
		for(uint8_t i=0; i<CORONA_RF_NUM_CHANNELS; i++)
			packet[i+1]=hopping_frequency[i];
		// Send TX ID
		for(uint8_t i=0; i<CORONA_ADDRESS_LENGTH; i++)
			packet[i+4]=rx_tx_addr[i];
		packet[8]=0;
		return 6647;
	}

	// Flydream every fourth packet is identifier packet and is on channel number
	// that is last byte of rx_tx_addr
	if (fdv3_id_send)
	{
		fdv3_id_send = 0;
		CC2500_WriteReg(CC2500_0A_CHANNR, rx_tx_addr[CORONA_ADDRESS_LENGTH-1]);
		packet[0] = 0x07;   // 8 bytes to follow
		// Send TX ID
		for(uint8_t i = 0; i < CORONA_ADDRESS_LENGTH; i++)
			packet[i+1] = rx_tx_addr[i];
		// Send hopping freq
		for(uint8_t i = 0; i < CORONA_RF_NUM_CHANNELS; i++)
			packet[i+1+CORONA_ADDRESS_LENGTH] = hopping_frequency[i];
		packet[8] = 0;
		return 2*FDV3_CHANNEL_PERIOD;  // extra delay after id packet according to captures
	}

	// Set RF channel
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[hopping_frequency_no]);

	// Build packet
	packet[0] = 0x10;   // 17 bytes to follow

	// Channels
	memset(packet+9, 0x00, 4);
	for (uint8_t i=0; i<8; i++)
	{ // Channel values are packed
		uint16_t val=convert_channel_ppm(i);
		packet[i+1] = val;
		packet[9 + (i>>1)] |= (i&0x01)?(val>>4)&0xF0:(val>>8)&0x0F;
	}

	// TX ID
	for (uint8_t i=0; i < CORONA_ADDRESS_LENGTH; i++)
		packet[i+13] = rx_tx_addr[i];

	packet[17] = 0x00;

	if (sub_protocol!=FD_V3)
	{
		// Packet period is based on hopping
		switch (hopping_frequency_no)
		{
			case 0:
				packet_period = sub_protocol == COR_V1
				? 4991
				: 4248;
				break;
			case 1: 
				packet_period = sub_protocol == COR_V1
				? 4991
				: 4345;
				break;
			case 2: 
				packet_period = sub_protocol == COR_V1
				? 12520
				: 13468;
				if (sub_protocol == COR_V2)
					packet[17] = 0x03;
				break;
		}
	}
	hopping_frequency_no++;

	if (sub_protocol == FD_V3)
	{
		if (hopping_frequency_no == CORONA_RF_NUM_CHANNELS)
		{
			fdv3_id_send = 1;
			packet_period = 6000; // extra delay before id packet according to captures
		}
		else
			packet_period = FDV3_CHANNEL_PERIOD;
	}

	hopping_frequency_no %= CORONA_RF_NUM_CHANNELS;
	return packet_period;
}

uint16_t CORONA_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(22000);
	#endif
	// Tune frequency if it has been changed
	CC2500_SetFreqOffset();

	if(IS_BIND_IN_PROGRESS)
	{
		if (bind_counter-- == 0) BIND_DONE;
		packet_period=CORONA_build_bind_pkt();
	}
	else
		packet_period=CORONA_build_packet();

	// Send packet
	CC2500_WriteData(packet, packet[0]+2);
	return packet_period;
}

void CORONA_init()
{
	switch(sub_protocol)
	{
		case COR_V1:
			bind_counter=1400;		// Stay in bind mode for 5s
			break;
		case COR_V2:
			bind_counter=187;		// Stay in bind mode for 5s
			break;
		case FD_V3:
			bind_counter = 2000;	// Stay in bind mode for 10s
			break;
	}
	state=400;					// Used by V2 to send RF channels + ID for 2.65s at startup
	hopping_frequency_no=0;
	fdv3_id_send = 0;
	CORONA_TXID_init();
	CORONA_rf_init();
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DM002_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with DM002

#if defined(DM002_NRF24L01_INO)

#include "iface_xn297.h"

#define DM002_PACKET_PERIOD		6100 // Timeout for callback in uSec
#define DM002_INITIAL_WAIT		500
#define DM002_PACKET_SIZE		12   // packets have 12-byte payload
#define DM002_RF_BIND_CHANNEL	0x27
#define DM002_BIND_COUNT		655  // 4 seconds

enum DM002_FLAGS {
    // flags going to packet[9]
    DM002_FLAG_FLIP		= 0x01, 
    DM002_FLAG_LED		= 0x02, 
    DM002_FLAG_MEDIUM	= 0x04, 
    DM002_FLAG_HIGH		= 0x08, 
    DM002_FLAG_RTH		= 0x10,
    DM002_FLAG_HEADLESS	= 0x20,
    DM002_FLAG_CAMERA1	= 0x40,
    DM002_FLAG_CAMERA2	= 0x80,
};

static void __attribute__((unused)) DM002_send_packet()
{
	memcpy(packet+5,(uint8_t *)"\x00\x7F\x7F\x7F\x00\x00\x00",7);
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0xAA;
		packet[1] = rx_tx_addr[0]; 
		packet[2] = rx_tx_addr[1];
		packet[3] = rx_tx_addr[2];
		packet[4] = rx_tx_addr[3];
	}
	else
	{
		packet[0]=0x55;
		// Throttle : 0 .. 200
		packet[1]=convert_channel_16b_limit(THROTTLE,0,200);
		// Other channels min 0x57, mid 0x7F, max 0xA7
		packet[2] = convert_channel_16b_limit(RUDDER,0x57,0xA7);
		packet[3] = convert_channel_16b_limit(AILERON, 0x57,0xA7);
		packet[4] = convert_channel_16b_limit(ELEVATOR, 0xA7, 0x57);
		// Features
		packet[9] =   GET_FLAG(CH5_SW,DM002_FLAG_FLIP)
					| GET_FLAG(!CH6_SW,DM002_FLAG_LED)
					| GET_FLAG(CH7_SW,DM002_FLAG_CAMERA1)
					| GET_FLAG(CH8_SW,DM002_FLAG_CAMERA2)
					| GET_FLAG(CH9_SW,DM002_FLAG_HEADLESS)
					| GET_FLAG(CH10_SW,DM002_FLAG_RTH)
					| GET_FLAG(!CH11_SW,DM002_FLAG_HIGH);
		// Packet counter
		if(packet_count&0x03)
		{
			packet_count++;
			hopping_frequency_no++;
			hopping_frequency_no&=4;
		}
		packet_count&=0x0F;
		packet[10] = packet_count;
		packet_count++;
		XN297_Hopping(hopping_frequency_no);
	}
	//CRC
	for(uint8_t i=0;i<DM002_PACKET_SIZE-1;i++)
		packet[11]+=packet[i];
	
	//Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, DM002_PACKET_SIZE);
}

static void __attribute__((unused)) DM002_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t *)"\x26\xA8\x67\x35\xCC", 5);
	XN297_RFChannel(DM002_RF_BIND_CHANNEL);
}

uint16_t DM002_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(DM002_PACKET_PERIOD);
	#endif
	if (bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);
		}
	}
	DM002_send_packet();
	return	DM002_PACKET_PERIOD;
}

static void __attribute__((unused)) DM002_initialize_txid()
{
	// Only 3 IDs/RFs are available, RX_NUM is used to switch between them
	switch(rx_tx_addr[3]%3)
	{
		case 0:
			memcpy(hopping_frequency,(uint8_t *)"\x34\x39\x43\x48",4);
			memcpy(rx_tx_addr,(uint8_t *)"\x47\x93\x00\x00\xD5",5);
			break;
		case 1:
			memcpy(hopping_frequency,(uint8_t *)"\x35\x39\x3B\x3D",4);
			memcpy(rx_tx_addr,(uint8_t *)"\xAC\xA1\x00\x00\xD5",5);
			break;
		case 2:
			memcpy(hopping_frequency,(uint8_t *)"\x32\x37\x41\x46",4);
			memcpy(rx_tx_addr,(uint8_t *)"\x92\x45\x01\x00\xD5",5);
			break;
	}
}

void DM002_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
    bind_counter = DM002_BIND_COUNT;
	DM002_initialize_txid();
	DM002_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM.ino"
#if defined(DSM_CYRF6936_INO) || defined(DSM_RX_CYRF6936_INO)

#include "iface_cyrf6936.h"

uint8_t sop_col;

const uint8_t PROGMEM DSM_pncodes[][8] = {
	/* Note these are in order transmitted (LSB 1st) */
	/* Row 1 */
		/* Col 0 */ {0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3},
		/* Col 1 */ {0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9},
		/* Col 2 */ {0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82},
		/* Col 3 */ {0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB},
		/* Col 4 */ {0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7},
		/* Col 5 */ {0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95},
		/* Col 6 */ {0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4},
		/* Col 7 */ {0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF},
	/* Row 2 */
		/* Col 0 */ {0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97},
		/* Col 1 */ {0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA},
		/* Col 2 */ {0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE},
		/* Col 3 */ {0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD},
		/* Col 4 */ {0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD},
		/* Col 5 */ {0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9},
		/* Col 6 */ {0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3},
		/* Col 7 */ {0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0},
	/* Row 3 */
		/* Col 0 */ {0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E},
		/* Col 1 */ {0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7},
		/* Col 2 */ {0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1},
		/* Col 3 */ {0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4},
		/* Col 4 */ {0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6},
		/* Col 5 */ {0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80},
		/* Col 6 */ {0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88},
		/* Col 7 */ {0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88},
	/* Row 4 */
		/* Col 0 */ {0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93}, // Wrong values used by Orange TX/RX Row 3 Col 8: {0x88, 0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40}
		/* Col 1 */ {0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C},
		/* Col 2 */ {0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA},
		/* Col 3 */ {0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC},
		/* Col 4 */ {0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84},
		/* Col 5 */ {0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7},
		/* Col 6 */ {0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0},
		/* Col 7 */ {0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1},
	/* Row 0 */
		/* Col 0 */ {0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8},
		/* Col 1 */ {0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6},
		/* Col 2 */ {0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9},
		/* Col 3 */ {0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4},
		/* Col 4 */ {0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0},
		/* Col 5 */ {0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8},
		/* Col 6 */ {0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D},
		/* Col 7 */ {0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1},
		/* Col 8 */ {0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86}
};

static void __attribute__((unused)) DSM_read_code(uint8_t *buf, uint8_t row, uint8_t col)
{
	row--;
	if(row>4)
		row = 4;
	for(uint8_t i=0;i<8;i++)
		buf[i]=pgm_read_byte_near( &DSM_pncodes[row*8+col][i] );
}

const uint8_t PROGMEM DSM_init_vals[][2] = {
	{CYRF_02_TX_CTRL, 0x00},				// All TX interrupt disabled
	{CYRF_05_RX_CTRL, 0x00},				// All RX interrupt disabled
	{CYRF_28_CLK_EN, 0x02},					// Force receive clock enable
	{CYRF_32_AUTO_CAL_TIME, 0x3c},			// Default init value
	{CYRF_35_AUTOCAL_OFFSET, 0x14},			// Default init value
	{CYRF_26_XTAL_CFG, 0x08},				// Start delay
	{CYRF_06_RX_CFG, 0x4A},					// LNA enabled, RX override enabled, Fast turn mode enabled, RX is 1MHz below TX
	{CYRF_1B_TX_OFFSET_LSB, 0x55},			// Default init value
	{CYRF_1C_TX_OFFSET_MSB, 0x05},			// Default init value
	{CYRF_39_ANALOG_CTRL, 0x01},			// All slow for synth setting time
	{CYRF_01_TX_LENGTH, 0x10},				// 16 bytes packet
	{CYRF_14_EOP_CTRL, 0x02},				// Set EOP Symbol Count to 2
	{CYRF_12_DATA64_THOLD, 0x0a},			// 64 Chip Data PN corelator threshold, default datasheet value is 0x0E
	//Below is for bind only
	{CYRF_03_TX_CFG, 0x38 | CYRF_BIND_POWER}, //64 chip codes, SDR mode
	{CYRF_10_FRAMING_CFG, 0x4a},			// SOP disabled, no LEN field and SOP correlator of 0x0a but since SOP is disabled...
	{CYRF_1F_TX_OVERRIDE, 0x04},			// Disable TX CRC, no ACK, use TX synthesizer
	{CYRF_1E_RX_OVERRIDE, 0x14},			// Disable RX CRC, Force receive data rate, use RX synthesizer
};

const uint8_t PROGMEM DSM_data_vals[][2] = {
	{CYRF_29_RX_ABORT, 0x20},				// Abort RX operation in case we are coming from bind
	{CYRF_0F_XACT_CFG, 0x24},				// Force Idle
	{CYRF_29_RX_ABORT, 0x00},				// Clear abort RX
	{CYRF_03_TX_CFG, 0x28 | CYRF_HIGH_POWER}, // 64 chip codes, 8DR mode
	{CYRF_10_FRAMING_CFG, 0xea},			// SOP enabled, SOP_CODE_ADR 64 chips, Packet len enabled, SOP correlator 0x0A
	{CYRF_1F_TX_OVERRIDE, 0x00},			// CRC16 enabled, no ACK
	{CYRF_1E_RX_OVERRIDE, 0x00},			// CRC16 enabled, no ACK
};

static void __attribute__((unused)) DSM_cyrf_config()
{
	for(uint8_t i = 0; i < sizeof(DSM_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&DSM_init_vals[i][0]), pgm_read_byte_near(&DSM_init_vals[i][1]));
	CYRF_WritePreamble(0x333304);
}

static void __attribute__((unused)) DSM_cyrf_configdata()
{
	for(uint8_t i = 0; i < sizeof(DSM_data_vals) / 2; i++)
		CYRF_WriteRegister(pgm_read_byte_near(&DSM_data_vals[i][0]), pgm_read_byte_near(&DSM_data_vals[i][1]));
}

static uint8_t __attribute__((unused)) DSM_get_pn_row(uint8_t channel, bool dsmx)
{
	if(protocol == PROTO_DSM && sub_protocol == DSMR)
		return (channel + 2) % 5;
	return (dsmx ? (channel - 2) % 5 : channel % 5);
}

static void __attribute__((unused)) DSM_set_sop_data_crc(bool ch2, bool dsmx)
{
	//The crc for channel '1' is NOT(mfgid[0] << 8 + mfgid[1])
	//The crc for channel '2' is (mfgid[0] << 8 + mfgid[1])
	if(ch2)
		CYRF_ConfigCRCSeed(seed);	//CH2
	else
		CYRF_ConfigCRCSeed(~seed);	//CH1, DSMR only use CH1

	uint8_t pn_row = DSM_get_pn_row(hopping_frequency[hopping_frequency_no], dsmx);
	uint8_t code[16];
	#if 0
		debug_time();
		debug(" crc:%04X,row:%d,col:%d,rf:%02X",(~seed)&0xffff,pn_row,sop_col,hopping_frequency[hopping_frequency_no]);
	#endif
	DSM_read_code(code,pn_row,sop_col);						// pn_row between 0 and 4, sop_col between 0 and 7
	CYRF_ConfigSOPCode(code);
	DSM_read_code(code,pn_row,7 - sop_col);					// 7-sop_col between 0 and 7
	DSM_read_code(code+8,pn_row,7 - sop_col + 1);			// 7-sop_col+1 between 1 and 8
	CYRF_ConfigDataCode(code);

	CYRF_ConfigRFChannel(hopping_frequency[hopping_frequency_no]);
	hopping_frequency_no++;
	if(dsmx)
		hopping_frequency_no %=23;
	else
		hopping_frequency_no %=2;
}

static void __attribute__((unused)) DSM_calc_dsmx_channel()
{
	uint8_t idx = 0;
	uint32_t id = ~(((uint32_t)cyrfmfg_id[0] << 24) | ((uint32_t)cyrfmfg_id[1] << 16) | ((uint32_t)cyrfmfg_id[2] << 8) | (cyrfmfg_id[3] << 0));
	uint32_t id_tmp = id;
	while(idx < 23)
	{
		uint8_t i;
		uint8_t count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;
		id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F;		// Randomization
		uint8_t next_ch = ((id_tmp >> 8) % 0x49) + 3;	// Use least-significant byte and must be larger than 3
		if ( (next_ch ^ cyrfmfg_id[3]) & 0x01 )
			continue;
		for (i = 0; i < idx; i++)
		{
			if(hopping_frequency[i] == next_ch)
				break;
			if(hopping_frequency[i] <= 27)
				count_3_27++;
			else
				if (hopping_frequency[i] <= 51)
					count_28_51++;
				else
					count_52_76++;
		}
		if (i != idx)
			continue;
		if ((next_ch < 28 && count_3_27 < 8)
			||(next_ch >= 28 && next_ch < 52 && count_28_51 < 7)
			||(next_ch >= 52 && count_52_76 < 8))
			hopping_frequency[idx++] = next_ch;
	}
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_Rx_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(DSM_RX_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define DSM_DEBUG_RF
//#define DSM_DEBUG_CH

uint8_t DSM_rx_type;

enum {
	DSM_RX_BIND1 = 0,
	DSM_RX_BIND2,
	DSM_RX_DATA_PREP,
	DSM2_RX_SCAN,
	DSM_RX_DATA_CH1,
	DSM_RX_DATA_CH2,
};

static void __attribute__((unused)) DSM_RX_RF_init()
{
	DSM_cyrf_config();
	rx_disable_lna = IS_POWER_FLAG_on;
	if(IS_BIND_IN_PROGRESS)
	{
		//64 SDR Mode is configured so only the 8 first values are needed but need to write 16 values...
		uint8_t code[16];
		DSM_read_code(code,0,8);
		CYRF_ConfigDataCode(code);
		CYRF_ConfigRFChannel(1);
		CYRF_SetTxRxMode(RX_EN);									// Force end state read
		CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);					// Prepare to receive
	}
	else
	{
		DSM_cyrf_configdata();
		CYRF_WriteRegister(CYRF_06_RX_CFG, rx_disable_lna ? 0x0A:0x4A);	// AGC disabled, LNA disabled/enabled, Attenuator disabled, RX override enabled, Fast turn mode enabled, RX is 1MHz below TX
	}
}

uint16_t convert_channel_DSM_nolimit(int32_t val)
{
	val=(val-0x150)*(CHANNEL_MAX_100-CHANNEL_MIN_100)/(0x6B0-0x150)+CHANNEL_MIN_100;
	if(val<0)
		val=0;
	else
		if(val>2047)
			val=2047;
	return (uint16_t)val;
}

static uint8_t __attribute__((unused)) DSM_RX_check_packet()
{
 	uint8_t rx_status=CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
	if((rx_status & 0x03) == 0x02)  									// RXC=1, RXE=0 then 2nd check is required (debouncing)
		rx_status |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
	if((rx_status & 0x07) == 0x02)
	{ // data received with no errors
		len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
		#ifdef DSM_DEBUG_RF
			debugln("l=%d",len);
		#endif
		if(len>=2 && len<=16)
		{
			// Read packet
			CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);		// Need to set RXOW before data read
			CYRF_ReadDataPacketLen(packet, len);

			// Check packet ID
			if ((DSM_rx_type&0x80) == 0)
			{//DSM2
				packet[0] ^= 0xff;
				packet[1] ^= 0xff;
			}
			#ifdef DSM_DEBUG_CH
				for(uint8_t i=0;i<len;i++)
					debug("%02X ",packet[i]);
				debugln("");
			#endif
			if(packet[0] == cyrfmfg_id[2] && packet[1] == cyrfmfg_id[3])
				return 0x02;										// Packet ok
		}
		return 0x00;												// Wrong size or ID -> nothing received
	}
	return rx_status;												// Return error code
}

static void __attribute__((unused)) DSM_RX_build_telemetry_packet()
{
	uint8_t nbr_bits = 11;
	if((DSM_rx_type&0xF0) == 0x00)
		nbr_bits=10;												// Only DSM_22 is using a resolution of 1024

	// Use packet length to calculate the number of channels
	len -= 2;														// Remove header length
	len >>= 1;														// Channels are on 2 bytes
	if(len==0) return;												// No channels...

	// Extract channels
	uint8_t idx;
	for (uint8_t i = 0; i < len; i++)
	{
		uint16_t value=(packet[i*2+2]<<8) | packet[i*2+3];
		if(value!=0xFFFF)
		{
			idx=(value&0x7FFF)>>nbr_bits;							// retrieve channel index
			#ifdef DSM_DEBUG_CH
				debugln("i=%d,v=%d,u=%X",idx,value&0x7FF,value&0x8000);
			#endif
			if(idx<13)
			{
				if(nbr_bits==10) value <<= 1;						// switch to 11 bits
				value &= 0x7FF;
				rx_rc_chan[CH_TAER[idx]]=convert_channel_DSM_nolimit(value);
			}
		}
	}

	// Buid telemetry packet
	idx=0;
	packet_in[idx++] = RX_LQI;
	packet_in[idx++] = RX_LQI;
	packet_in[idx++] = 0;  											// start channel
	packet_in[idx++] = 12; 											// number of channels in packet

	// Pack channels
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	for (uint8_t i = 0; i < 12; i++)
	{
		bits |= ((uint32_t)rx_rc_chan[i]) << bitsavailable;
		bitsavailable += 11;
		while (bitsavailable >= 8)
		{
			packet_in[idx++] = bits & 0xff;
			bits >>= 8;
			bitsavailable -= 8;
		}
	}
	if(bitsavailable)
		packet_in[idx++] = bits & 0xff;
	// Send telemetry
	telemetry_link = 1;
	#ifdef SEND_CPPM
		if(sub_protocol>0)
			telemetry_link |= 0x80;	// Disable telemetry output
	#endif
}

static bool __attribute__((unused)) DSM_RX_bind_check_validity()
{
	uint16_t sum = 384 - 0x10;//
	for(uint8_t i = 0; i < 8; i++)
		sum += packet_in[i];
	if( packet_in[8] != (sum>>8) || packet_in[9] != (sum&0xFF))		//Checksum
		return false;
	for(uint8_t i = 8; i < 14; i++)
		sum += packet_in[i];
	if( packet_in[14] != (sum>>8) || packet_in[15] != (sum&0xFF))	//Checksum
		return false;
	if(memcmp(packet_in,packet_in+4,4))								//Check ID
		return false;
	return true;
}

static void __attribute__((unused)) DSM_RX_build_bind_packet()
{
	uint16_t sum = 384 - 0x10;//
	packet[0] = 0xff ^ cyrfmfg_id[0];								// ID
	packet[1] = 0xff ^ cyrfmfg_id[1];
	packet[2] = 0xff ^ cyrfmfg_id[2];
	packet[3] = 0xff ^ cyrfmfg_id[3];
	packet[4] = 0x01;												// RX version
	packet[5] = num_ch;												// Number of channels
	packet[6] = DSM_rx_type;										// DSM type, let's just send back whatever the TX gave us...
	packet[7] = 0x00;												// Unknown
	for(uint8_t i = 0; i < 8; i++)
		sum += packet[i];
	packet[8] = sum >> 8;
	packet[9] = sum & 0xff;
}

static void __attribute__((unused)) DSM_abort_channel_rx(uint8_t ch)
{
	CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);						// Abort RX operation
	CYRF_SetTxRxMode(IS_POWER_FLAG_on ? TXRX_OFF:RX_EN);			// Force end state read
	if (rx_disable_lna != IS_POWER_FLAG_on && IS_BIND_DONE)
	{
		rx_disable_lna = IS_POWER_FLAG_on;
		CYRF_WriteRegister(CYRF_06_RX_CFG, rx_disable_lna ? 0x0A:0x4A);	// AGC disabled, LNA disabled/enabled, Attenuator disabled, RX override enabled, Fast turn mode enabled, RX is 1MHz below TX
	}
	if(ch&0x02) DSM_set_sop_data_crc(true ,DSM_rx_type&0x80);		// Set sop data,crc seed and rf channel using CH1, DSM2/X
	if(ch&0x01) DSM_set_sop_data_crc(false,DSM_rx_type&0x80);		// Set sop data,crc seed and rf channel using CH1, DSM2/X
	CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);						// Clear abort RX operation
	CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);						// Prepare to receive
}

uint16_t DSM_RX_callback()
{
	uint8_t rx_status;
	static uint8_t read_retry=0;

	if(sub_protocol == DSM_ERASE)
	{
		if(packet_count)
			packet_count--;
		else
			BIND_DONE;
		return 10000;	//  Nothing to do...
	}

	switch (phase)
	{
		case DSM_RX_BIND1:
			if(IS_BIND_DONE)										// Abort bind
			{
				phase = DSM_RX_DATA_PREP;
				break;
			}
			if(packet_count==0)
				read_retry=0;
			//Check received data
			rx_status = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((rx_status & 0x03) == 0x02)  						// RXC=1, RXE=0 then 2nd check is required (debouncing)
				rx_status |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((rx_status & 0x07) == 0x02)
			{ // data received with no errors
				CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);	// Need to set RXOW before data read
				len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				debugln("RX:%d, CH:%d",len,hopping_frequency_no);
				if(len==16)
				{
					CYRF_ReadDataPacketLen(packet_in, 16);
					if(DSM_RX_bind_check_validity())
					{
						// store tx info into eeprom
						uint16_t temp = DSM_RX_EEPROM_OFFSET;

						debug("ID=");
						for(uint8_t i=0;i<4;i++)
						{
							if (sub_protocol == DSM_CLONE && i == 3)
								cyrfmfg_id[i]=(packet_in[i]^RX_num)^0xFF;
							else
								cyrfmfg_id[i]=packet_in[i]^0xFF;
							eeprom_write_byte((EE_ADDR)temp++, cyrfmfg_id[i]);
							debug(" %02X", cyrfmfg_id[i]);
						}
						// save num_ch
						num_ch=packet_in[11];
						// store DSM_rx_type
						/*packet[12]     1 byte -> max DSM type allowed:
							0x01 => 22ms 1024 DSM2 1 packet => number of channels is <8
							0x02 => 22ms 1024 DSM2 2 packets => either a number of channel >7
							0x12 => 11ms 2048 DSM2 2 packets => can be any number of channels
							0x23 => DX3R DSM2 2 surface packets
							0xA2 => 22ms 2048 DSMX 1 packet => number of channels is <8
							0xB2 => 11ms 2048 DSMX => can be any number of channels
							(0x01 or 0xA2) and num_ch < 7 => 22ms else 11ms
							&0x80 => false=DSM2, true=DSMX
							&0xF0 => false=1024, true=2048 */
						DSM_rx_type=packet_in[12];
						debugln(", num_ch=%d, type=%02X",num_ch, DSM_rx_type);
						eeprom_write_byte((EE_ADDR)temp, DSM_rx_type);
						CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);	// Abort RX operation
						CYRF_SetTxRxMode(TX_EN);					// Force end state TX
						CYRF_ConfigDataCode((const uint8_t *)"\x98\x88\x1B\xE4\x30\x79\x03\x84");
						CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);	// Clear abort RX
						DSM_RX_build_bind_packet();
						bind_counter=500;
						phase++;									// DSM_RX_BIND2;
						return 1000;
					}
				}
				DSM_abort_channel_rx(0);							// Abort RX operation and receive
				if(read_retry==0)
					read_retry=8;
			}
			else
				if(rx_status & 0x02)								// RX error
					DSM_abort_channel_rx(0);						// Abort RX operation and receive
			packet_count++;
			if(packet_count>12)
			{
				packet_count=1;
				if(read_retry)
					read_retry--;
				if(read_retry==0)
				{
					packet_count=0;
					hopping_frequency_no++;							// Change channel
					hopping_frequency_no %= 0x50;
					hopping_frequency_no |= 0x01;					// Odd channels only
					CYRF_ConfigRFChannel(hopping_frequency_no);
					DSM_abort_channel_rx(0);						// Abort RX operation and receive
				}
			}
			return 1000;
		case DSM_RX_BIND2:
			//Transmit settings back
			CYRF_WriteDataPacketLen(packet,10);						// Send packet
			if(bind_counter--==0)
			{
				BIND_DONE;
				phase++;											// DSM_RX_DATA_PREP
				//Copy clone values to EEPROM
				if (sub_protocol == DSM_CLONE)
					{
					uint16_t temp = DSM_CLONE_EEPROM_OFFSET;	
					for(uint8_t i=0; i<4; i++)
						eeprom_write_byte((EE_ADDR)temp++, cyrfmfg_id[i]);
					eeprom_write_byte((EE_ADDR)temp, 0xF0);						
				}
			}
			break;
		case DSM_RX_DATA_PREP:
			hopping_frequency_no = 0;
			read_retry=0;
			rx_data_started = false;
			pps_counter = 0;
			RX_LQI = 100;
			DSM_cyrf_configdata();
			pps_timer=millis();
			sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
			seed = (cyrfmfg_id[0] << 8) + cyrfmfg_id[1];
			if(DSM_rx_type&0x80)
			{ // DSMX
				DSM_calc_dsmx_channel();							// Build hop table
				DSM_abort_channel_rx(1);							// Abort RX operation, set sop&data&seed&rf using CH1, DSM2/X and receive
				phase=DSM_RX_DATA_CH1;
			}
			else
			{ // DSM2
				rf_ch_num=0;
				hopping_frequency_no = 0;
				hopping_frequency[0] = 3;
				hopping_frequency[1] = 0;
				DSM_abort_channel_rx(1);							// Abort RX operation, set sop&data&seed&rf using CH1, DSM2/X and receive
				phase=DSM2_RX_SCAN;
			}
			break;
		case DSM2_RX_SCAN:											// Scan for DSM2 frequencies
			//Received something ?
			rx_status = DSM_RX_check_packet();
			if(rx_status == 0x02)
			{ // data received with no errors
				debugln("CH%d:Found %d",rf_ch_num+1,hopping_frequency[rf_ch_num]);
				read_retry=0;
				if(rf_ch_num)
				{													// Both CH1 and CH2 found
					read_retry=0;
					hopping_frequency_no=0;
					DSM_abort_channel_rx(1);						// Abort RX operation, set sop&data&seed&rf using CH1, DSM2/X and receive
					pps_timer=millis();
					phase++;										// DSM_RX_DATA_CH1
				}
				else
				{
					rf_ch_num++;									// CH1 found, scan for CH2
					hopping_frequency_no = 1;
					if(hopping_frequency[1] < 3)					// If no CH2 keep then restart from current
						hopping_frequency[1]=hopping_frequency[0]+1;
					DSM_abort_channel_rx(2);						// Abort RX operation, set sop&data&seed&rf using CH2, DSM2/X and receive
				}
			}
			else
			{
				read_retry++;
				if(read_retry>50)									// After 50ms
				{ // Try next channel
					debugln("CH%d:Next channel",rf_ch_num+1);
					read_retry=0;
					hopping_frequency_no = rf_ch_num;
					hopping_frequency[rf_ch_num]++;
					if(hopping_frequency[rf_ch_num] > 73) hopping_frequency[rf_ch_num] = 3;
					DSM_abort_channel_rx(rf_ch_num+1);				// Abort RX operation, set sop&data&seed&rf using CH1/2, DSM2/X and receive
				}
				else if(rx_status & 0x02)
				{ // data received with errors
					if((rx_status & 0x01) && rf_ch_num==0)
						hopping_frequency[1] = hopping_frequency[0];// Might be CH2 since it's a CRC error so keep it
					debugln("CH%d:RX error",rf_ch_num+1);
					DSM_abort_channel_rx(0);						// Abort RX operation and receive
				}
			}
			return 1000;
		case DSM_RX_DATA_CH1:
			//Packets per second
			if (millis() - pps_timer >= 1000)
			{//182pps @11ms, 91pps @22ms
				pps_timer = millis();
				if(DSM_rx_type!=0xA2 && DSM_rx_type!=0x01)			// if 11ms
					pps_counter >>=1;								// then /2
				debugln("%d pps", pps_counter);
				RX_LQI = pps_counter;								// max=91pps
				pps_counter = 0;
			}
			//Received something ?
			rx_status = DSM_RX_check_packet();
			if(rx_status == 0x02)
			{ // data received with no errors
				#ifdef DSM_DEBUG_RF
					debugln("CH1:RX");
				#endif
				DSM_RX_build_telemetry_packet();
				rx_data_started = true;
				pps_counter++;
				DSM_abort_channel_rx(2);							// Abort RX operation, set sop&data&seed&rf using CH2, DSM2/X and receive
				phase++;
				return 5000;
			}
			else
			{
				read_retry++;
				if(rx_data_started && read_retry>6)					// After 6*500=3ms
				{ // skip to CH2
					#ifdef DSM_DEBUG_RF
						debugln("CH1:Skip to CH2");
					#endif
					DSM_abort_channel_rx(2);						// Abort RX operation, set sop&data&seed&rf using CH2, DSM2/X and receive
					phase++;
					return 4000;
				}
				if(rx_data_started && RX_LQI==0)
				{  // communication lost
					#ifdef DSM_DEBUG_RF
						debugln("CH1:Restart...");
					#endif
					phase=DSM_RX_DATA_PREP;
					return 1000;
				}
				if(read_retry>250)
				{ // move to next RF channel
					#ifdef DSM_DEBUG_RF
						debugln("CH1:Scan");
					#endif
					DSM_abort_channel_rx(3);						// Abort RX operation, set sop&data&seed&rf using CH2 then CH1, DSM2/X and receive
					read_retry=0;
				}
				else if(rx_status & 0x02)
				{ // data received with errors
					#ifdef DSM_DEBUG_RF
						debugln("CH1:RX error %02X",rx_status);
					#endif
					DSM_abort_channel_rx(0);						// Abort RX operation and receive
				}
			}
			return 500;
		case DSM_RX_DATA_CH2:
			rx_status = DSM_RX_check_packet();
			if(rx_status == 0x02)
			{ // data received with no errors
				#ifdef DSM_DEBUG_RF
					debugln("CH2:RX");
				#endif
				DSM_RX_build_telemetry_packet();
				pps_counter++;
			}
			#ifdef DSM_DEBUG_RF
				else
					debugln("CH2:No RX");
			#endif
			DSM_abort_channel_rx(1);								// Abort RX operation, set sop&data&seed&rf using CH1, DSM2/X and receive
			read_retry=0;
			phase=DSM_RX_DATA_CH1;
			if(DSM_rx_type==0xA2) //|| DSM_rx_type==0x01 -> not needed for DSM2 since we are ok to listen even if there will be nothing
				return 15000;										//22ms
			else
				return 4000;										//11ms
	}
	return 10000;
}

void DSM_RX_init()
{
	DSM_RX_RF_init();
	hopping_frequency_no = 0;
	
	if (IS_BIND_IN_PROGRESS)
	{
		if(sub_protocol == DSM_ERASE)
		{
			// Clear all cloned addresses
			uint16_t addr = DSM_CLONE_EEPROM_OFFSET;
			for(uint8_t i=0; i<6; i++)
				eeprom_write_byte((EE_ADDR)(addr++), 0xFF);
			packet_count = 100;	
		}
		else
		{
			packet_count=0;
			phase = DSM_RX_BIND1;
		}
	}
	else
	{
		uint16_t temp = DSM_RX_EEPROM_OFFSET;
		if (sub_protocol == DSM_CLONE  || sub_protocol == DSM_ERASE )
			temp = DSM_CLONE_EEPROM_OFFSET;
		debug("ID=");
		for(uint8_t i=0;i<4;i++)
		{
			cyrfmfg_id[i]=eeprom_read_byte((EE_ADDR)temp++);
			debug(" %02X", cyrfmfg_id[i]);
		}
		DSM_rx_type=eeprom_read_byte((EE_ADDR)DSM_RX_EEPROM_OFFSET+4);
		debugln(", type=%02X", DSM_rx_type);

		phase = DSM_RX_DATA_PREP;
	}
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/DSM_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(DSM_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define DSM_DEBUG_FWD_PGM
//#define DEBUG_BIND  1

#define CLONE_BIT_MASK			0x20
#define DSM_BIND_CHANNEL		0x0D	//13 This can be any odd channel
#define DSM2_SFC_PERIOD			16500

//During binding we will send BIND_COUNT packets
//One packet each 10msec
//
// Most RXs seems to work properly with a long BIND send count (3s): Spektrum, OrangeRX. 
// Lemon-RX G2s seems to have a timeout waiting for the channel to get quiet after the 
// first good BIND packet.. If using 3s (300), Lemon-RX will not transmit the BIND-Response packet. 

#define DSM_BIND_COUNT			180  // About 1.8s
#define DSM_BIND_COUNT_READ		600  // About 4.2s of waiting for Response

enum {
	DSM_BIND_WRITE=0,
	DSM_BIND_CHECK,
	DSM_BIND_READ,
	DSM_CHANSEL,
	DSM_CH1_WRITE_A,
	DSM_CH1_CHECK_A,
	DSM_CH2_WRITE_A,
	DSM_CH2_CHECK_A,
	DSM_CH2_READ_A,
	DSM_CH1_WRITE_B,
	DSM_CH1_CHECK_B,
	DSM_CH2_WRITE_B,
	DSM_CH2_CHECK_B,
	DSM_CH2_READ_B,
};

//
uint8_t ch_map[14];
const uint8_t PROGMEM DSM_ch_map_progmem[][14] = {
//22+11ms for 3..7 channels
	{1, 0, 2, 0xff, 0xff, 0xff, 0xff, 1,  0,   2, 0xff, 0xff, 0xff,    0xff}, //3ch  - Guess
	{1, 0, 2, 3, 0xff, 0xff, 0xff, 1,    0,    2,    3, 0xff, 0xff,    0xff}, //4ch  - Guess
	{1, 0, 2, 3, 4,    0xff, 0xff, 1,    0,    2,    3,    4, 0xff,    0xff}, //5ch  - Guess
	{1, 5, 2, 3, 0,    4,    0xff, 1,    5,    2,    3,    0,    4,    0xff}, //6ch  - HP6DSM
	{1, 5, 2, 4, 3,    6,    0,    1,    5,    2,    4,    3,    6,    0   }, //7ch  - DX6i
//22ms for 8..12 channels
	{1, 5, 2, 3, 6,    0xff, 0xff, 4,    0,    7,    0xff, 0xff, 0xff, 0xff}, //8ch  - DX8/DX7
	{1, 5, 2, 3, 6,    0xff, 0xff, 4,    0,    7,    8,    0xff, 0xff, 0xff}, //9ch  - Guess
	{1, 5, 2, 3, 6,    0xff, 0xff, 4,    0,    7,    8,    9,    0xff, 0xff}, //10ch - Guess
	{1, 5, 2, 3, 6,    10,   0xff, 4,    0,    7,    8,    9,    0xff, 0xff}, //11ch - Guess
	{1, 5, 2, 4, 6,    10,   0xff, 0,    7,    3,    8,    9   , 11  , 0xff}, //12ch - DX18/DX8G2
//11ms for 8..11 channels
	{1, 5, 2, 3, 6,    7,    0xff, 1,    5,    2,    4,    0,    0xff, 0xff}, //8ch  - DX7
	{1, 5, 2, 3, 6,    7,    0xff, 1,    5,    2,    4,    0,    8,    0xff}, //9ch  - Guess
	{1, 5, 2, 3, 4,    8,    9,    1,    5,    2,    3,    0,    7,    6   }, //10ch - DX18
	{1, 5, 2, 3, 4,    8,    9,    1,   10,    2,    3,    0,    7,    6   }, //11ch - Guess
};

static void __attribute__((unused)) DSM_build_bind_packet()
{
	uint8_t i;
	uint16_t sum = 384 - 0x10;//
	packet[0] = 0xff ^ cyrfmfg_id[0];
	packet[1] = 0xff ^ cyrfmfg_id[1];
	packet[2] = 0xff ^ cyrfmfg_id[2];
	packet[3] = 0xff ^ cyrfmfg_id[3];
	packet[4] = packet[0];
	packet[5] = packet[1];
	packet[6] = packet[2];
	packet[7] = packet[3];
	for(i = 0; i < 8; i++)
		sum += packet[i];
	packet[8] = sum >> 8;
	packet[9] = sum & 0xff;
	packet[10] = 0x01;						// ???
	if(sub_protocol==DSM_AUTO)
		packet[11] = 12;
	else
		packet[11] = num_ch;				// DX5 DSMR sends 0x48...
	//packet[11] = 3;						// DX3R

	if (sub_protocol==DSMR)
		packet[12] = 0xa2;
	else if (sub_protocol==DSM2_SFC)
		packet[12] = 0x23;					// DX3R
	else if (sub_protocol==DSM2_1F)
		packet[12] = num_ch<8?0x01:0x02;	// DSM2/1024 1 or 2 packets depending on the number of channels
	else if(sub_protocol==DSM2_2F)
		packet[12] = 0x12;					// DSM2/2048 2 packets
	else if(sub_protocol==DSMX_1F)
		#if defined DSM_TELEMETRY
			packet[12] = 0xb2;				// DSMX/2048 2 packets
		#else
			packet[12] = num_ch<8? 0xa2 : 0xb2;	// DSMX/2048 1 or 2 packets depending on the number of channels
		#endif
	else									// DSMX_2F && DSM_AUTO
		packet[12] = 0xb2;					// DSMX/2048 2 packets

	packet[13] = 0x00;						//???
	for(i = 8; i < 14; i++)
		sum += packet[i];
	packet[14] = sum >> 8;
	packet[15] = sum & 0xff;
}

static void __attribute__((unused)) DSM_initialize_bind_phase()
{
	CYRF_ConfigRFChannel(DSM_BIND_CHANNEL); //This seems to be random?
	//64 SDR Mode is configured so only the 8 first values are needed but need to write 16 values...
	uint8_t code[16];
	DSM_read_code(code,0,8);
	CYRF_ConfigDataCode(code);
	DSM_build_bind_packet();
}

static void __attribute__((unused)) DSM_update_channels()
{
	prev_option=option;
	num_ch=option & 0x0F;				// Remove flags 0x80=max_throw, 0x40=11ms

	if(num_ch<3 || num_ch>12)
		num_ch=6;						// Default to 6 channels if invalid choice...

	#ifndef MULTI_AIR
		if(sub_protocol==DSMR && num_ch>7)
			num_ch=7;						// Max 7 channels in DSMR

		if(sub_protocol==DSM2_SFC && num_ch>5)
			num_ch=5;						// Max 5 channels in DSM2_SFC
	#endif

	// Create channel map based on number of channels and refresh rate
	uint8_t idx=num_ch-3;
	if((option & 0x40) && num_ch>7 && num_ch<12)
		idx+=5;							// In 11ms mode change index only for channels 8..11
	for(uint8_t i=0;i<14;i++)
		ch_map[i]=pgm_read_byte_near(&DSM_ch_map_progmem[idx][i]);
}

static void __attribute__((unused)) DSM_build_data_packet(uint8_t upper)
{
	uint8_t bits = 11;
	
	// Check if clone flag has changed
	if((prev_option&CLONE_BIT_MASK) != (option&CLONE_BIT_MASK))
	{
		DSM_init();
		prev_option^=CLONE_BIT_MASK;
	}
	if(prev_option!=option)
		DSM_update_channels();

	if (sub_protocol==DSMX_2F || sub_protocol==DSMX_1F)
	{//DSMX
		packet[0] = cyrfmfg_id[2];
		packet[1] = cyrfmfg_id[3];
	}
	else
	{//DSM2 && DSMR
		packet[0] = (0xff ^ cyrfmfg_id[2]);
		packet[1] = (0xff ^ cyrfmfg_id[3]);
		if(sub_protocol==DSM2_1F)
			bits=10;								// Only DSM2_1F is using a resolution of 1024
	}

	#ifndef MULTI_AIR
		if(sub_protocol == DSMR || sub_protocol == DSM2_SFC)
		{ // 12 bits, full range, no reassignment
			for (uint8_t i = 0; i < 7; i++)
			{
				uint16_t value = 0x0000;
				if(i < num_ch)
				{
					value=Channel_data[i]<<1;
					if(sub_protocol == DSM2_SFC)
						value |= i<<12;
				}
				packet[i*2+2] = (value >> 8) & 0xff;
				packet[i*2+3] = (value >> 0) & 0xff;
			}
			return;
		}
	#endif
	
	#ifdef DSM_THROTTLE_KILL_CH
		uint16_t kill_ch=Channel_data[DSM_THROTTLE_KILL_CH-1];
	#endif
	for (uint8_t i = 0; i < 7; i++)
	{	
		uint8_t idx = ch_map[(upper?7:0) + i];		// 1,5,2,3,0,4	   
		uint16_t value = 0xffff;
		if((option&0x40) == 0 && num_ch < 8 && upper)
			idx=0xff;								// in 22ms do not transmit upper channels if <8, is it the right method???
		if (idx != 0xff)
		{
			/* Spektrum own remotes transmit normal values during bind and actually use this (e.g. Nano CP X) to
			   select the transmitter mode (e.g. computer vs non-computer radio), so always send normal output */
			#ifdef DSM_THROTTLE_KILL_CH
				if(idx==CH1 && kill_ch<=604)
				{//Activate throttle kill only if channel is throttle and DSM_THROTTLE_KILL_CH below -50%
					if(kill_ch<CHANNEL_MIN_100)		// restrict val to 0...400
						kill_ch=0;
					else
						kill_ch-=CHANNEL_MIN_100;
					value=(kill_ch*21)/25;			// kill channel -100%->904us ... -50%->1100us *0x150/400
				}
				else
			#endif
				#ifdef DSM_MAX_THROW
					value=Channel_data[CH_TAER[idx]];										// -100%..+100% => 1024..1976us and -125%..+125% => 904..2096us based on Redcon 6 channel DSM2 RX
				#else
					if(option & 0x80)
						value=Channel_data[CH_TAER[idx]];									// -100%..+100% => 1024..1976us and -125%..+125% => 904..2096us based on Redcon 6 channel DSM2 RX
					else
						value=convert_channel_16b_nolimit(CH_TAER[idx],0x156,0x6AA,false);	// -100%..+100% => 1100..1900us and -125%..+125% => 1000..2000us based on a DX8 G2 dump
				#endif
			if(bits==10) value>>=1;
			value |= (upper && i==0 ? 0x8000 : 0) | (idx << bits);
		}	  
		packet[i*2+2] = value >> 8;
		packet[i*2+3] = value;
	}
	#ifdef DSM_FWD_PGM
		if(upper==0 && DSM_SerialRX && (DSM_SerialRX_val[0]&0xF8)==0x70 )
		{ // Send forward programming data if available
			for(uint8_t i=0; i<(DSM_SerialRX_val[0]&0x07);i++)
			{
				packet[i*2+4]=0x70+i;
				packet[i*2+5]=DSM_SerialRX_val[i+1];
			}
			DSM_SerialRX=false;
			#ifdef DSM_DEBUG_FWD_PGM
				debug("FWD=");
				for(uint8_t i=4; i<16;i++)
					debug(" %02X",packet[i]);
				debugln("");
			#endif
		}
	#endif
}

static uint8_t __attribute__((unused)) DSM_Check_RX_packet()
{
	uint8_t result=1;							// assume good packet
	
	uint16_t sum = 384 - 0x10;
	for(uint8_t i = 1; i < 9; i++)
	{
		sum += packet_in[i];
		if(i<5)
			if(packet_in[i] != (0xff ^ cyrfmfg_id[i-1]))
				result=0; 						// bad packet
	}
	if( packet_in[9] != (sum>>8)  && packet_in[10] != (uint8_t)sum )
		result=0;
	return result;
}

uint16_t DSM_callback()
{
	#if defined MULTI_EU
		if(sub_protocol == DSM2_1F || sub_protocol == DSM2_2F || sub_protocol == DSM2_SFC)
		{
			SUB_PROTO_INVALID;
			return 11000;
		}
	#endif
	#if defined MULTI_AIR
		if(sub_protocol == DSMR || sub_protocol == DSM2_SFC)
		{
			SUB_PROTO_INVALID;
			return 11000;
		}
	#endif
	#define DSM_CH1_CH2_DELAY	4010			// Time between write of channel 1 and channel 2
	#ifdef STM32_BOARD
		#define DSM_WRITE_DELAY		1600		// Time after write to verify write complete
		#define DSM_READ_DELAY		300			// Time before write to check read phase, and switch channels.
	#else
		#define DSM_WRITE_DELAY		1950		// Time after write to verify write complete
		#define DSM_READ_DELAY		600			// Time before write to check read phase, and switch channels.
	#endif
	#if defined DSM_TELEMETRY
		uint8_t rx_phase;
		uint8_t length;
	#endif
	uint8_t start;
	//debugln("P=%d",phase);
	switch(phase)
	{
		case DSM_BIND_WRITE:
			if(bind_counter--==0)
			#if defined DSM_TELEMETRY
				phase=DSM_BIND_CHECK;							//Check RX answer
			#else
				phase=DSM_CHANSEL;								//Switch to normal mode
			#endif
			CYRF_WriteDataPacket(packet);
			return 10000;
	#if defined DSM_TELEMETRY
		case DSM_BIND_CHECK:
			#if DEBUG_BIND
				debugln("Bind Check");
			#endif
			//64 SDR Mode is configured so only the 8 first values are needed
			CYRF_ConfigDataCode((const uint8_t *)"\x98\x88\x1B\xE4\x30\x79\x03\x84");
			CYRF_SetTxRxMode(RX_EN);							//Receive mode
			CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x87);			//Prepare to receive
			bind_counter=DSM_BIND_COUNT_READ; //Timeout of 4.2s if no packet received
			phase++;											// change from BIND_CHECK to BIND_READ
			return 2000;
		case DSM_BIND_READ:
			//Read data from RX
			rx_phase = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((rx_phase & 0x03) == 0x02)  						// RXC=1, RXE=0 then 2nd check is required (debouncing)
				rx_phase |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((rx_phase & 0x07) == 0x02)
			{ // data received with no errors
				CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);// Need to set RXOW before data read
				if(CYRF_ReadRegister(CYRF_09_RX_COUNT)==10)		// Len
				{
					CYRF_ReadDataPacketLen(packet_in+1, 10);
					if(DSM_Check_RX_packet())
					{
						#if DEBUG_BIND
  						  debug("Bind");
  						  for(uint8_t i=0;i<10;i++)
  							debug(" %02X",packet_in[i+1]);
  						  debugln("");
						#endif
						packet_in[0]=0x80;
						packet_in[6]&=0x0F;						// It looks like there is a flag 0x40 being added by some receivers
						if(packet_in[6]>12) packet_in[6]=12;
						else if(packet_in[6]<3) packet_in[6]=6;
						telemetry_link=1;						// Send received data on serial
						phase++;
						return 2000;
					}
				}
				CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Abort RX operation
				CYRF_SetTxRxMode(RX_EN);						// Force end state read
				CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Clear abort RX operation
				CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);		// Prepare to receive
			}
			else
				if((rx_phase & 0x02) != 0x02)
				{ // data received with errors
					CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);	// Abort RX operation
					CYRF_SetTxRxMode(RX_EN);					// Force end state read
					CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);	// Clear abort RX operation
					CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);	// Prepare to receive
				}
			if( --bind_counter == 0 )
			{ // Exit if no answer has been received for some time
        #if DEBUG_BIND
          debugln("Bind Read TIMEOUT");
        #endif
				phase++;										// DSM_CHANSEL
				return 7000 ;
			}
			return 7000;
	#endif
		case DSM_CHANSEL:
			BIND_DONE;
			DSM_cyrf_configdata();
			CYRF_SetTxRxMode(TX_EN);
			hopping_frequency_no = 0;
			phase = DSM_CH1_WRITE_A;							// in fact phase++
			#ifndef MULTI_AIR
			if(sub_protocol == DSMR)
				DSM_set_sop_data_crc(false, true);
			else
			#endif
				DSM_set_sop_data_crc(true, sub_protocol==DSMX_2F||sub_protocol==DSMX_1F);	//prep CH1
			return 10000;
		case DSM_CH1_WRITE_A:
			#ifdef MULTI_SYNC
				if(sub_protocol!=DSM2_SFC || option&0x40)		// option&40 in this case is 16.5ms/11ms frame rate for DSM2_SFC
					telemetry_set_input_sync(11000);			// Always request 11ms spacing even if we don't use half of it in 22ms mode
				else
					telemetry_set_input_sync(DSM2_SFC_PERIOD);
			#endif
			#ifndef MULTI_AIR
			if(sub_protocol == DSMR)
				CYRF_SetPower(0x08);							//Keep transmit power in sync
			else
			#endif
				CYRF_SetPower(0x28);							//Keep transmit power in sync
		case DSM_CH1_WRITE_B:
			DSM_build_data_packet(phase == DSM_CH1_WRITE_B);	// build lower or upper channels
		case DSM_CH2_WRITE_A:
		case DSM_CH2_WRITE_B:
			CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS);			// clear IRQ flags
			//debugln_time("");
			#ifndef MULTI_AIR
			if(sub_protocol==DSM2_SFC)
				CYRF_WriteDataPacketLen(packet,2*(num_ch+1));
			else
			#endif
				CYRF_WriteDataPacket(packet);
			#if 0
				for(uint8_t i=0;i<16;i++)
					debug(" %02X", packet[i]);
				debugln("");
			#endif
			phase++;											// change from WRITE to CHECK mode
			return DSM_WRITE_DELAY;
		case DSM_CH1_CHECK_A:
		case DSM_CH1_CHECK_B:
		case DSM_CH2_CHECK_A:
		case DSM_CH2_CHECK_B:
			start=(uint8_t)micros();
			while ((uint8_t)((uint8_t)micros()-(uint8_t)start) < 100)			// Wait max 100s, max I've seen is 50s
				if((CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80) == 0x00)
					break;
			
			if((phase==DSM_CH1_CHECK_A || phase==DSM_CH1_CHECK_B) && sub_protocol!=DSMR)
			{
				#if defined DSM_TELEMETRY
					// reset cyrf6936 if freezed after switching from TX to RX
					if (((CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS) & 0x22) == 0x20) || (CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80))
					{
						CYRF_Reset();
						DSM_cyrf_config();
						DSM_cyrf_configdata();
						CYRF_SetTxRxMode(TX_EN);
					}
				#endif
				DSM_set_sop_data_crc(true, sub_protocol==DSMX_2F||sub_protocol==DSMX_1F);	// prep CH2
				phase++;									// change from CH1_CHECK to CH2_WRITE
				return DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY;
			}
#if defined DSM_TELEMETRY
			phase++;										// change from CH2_CHECK to CH2_READ
			CYRF_SetTxRxMode(RX_EN);						//Receive mode
			CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x87);		//0x80??? //Prepare to receive
			#ifndef MULTI_AIR
				if(sub_protocol==DSMR || sub_protocol == DSM2_SFC)
				{
					phase = DSM_CH2_READ_B;
					if(sub_protocol == DSM2_SFC)
					{
						if(option&0x40)		// option&40 in this case is 16.5ms/11ms frame rate for DSM2_SFC
							return 11000 - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY - DSM_READ_DELAY;
						else
							return DSM2_SFC_PERIOD - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY - DSM_READ_DELAY;
					}
					return 10900 - DSM_WRITE_DELAY - DSM_READ_DELAY;	//Was 11000 but the SR6200A needs 10900 to report telemetry correctly
				}
			#endif
			return 11000 - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY - DSM_READ_DELAY;
		case DSM_CH2_READ_A:
		case DSM_CH2_READ_B:
			//Read telemetry
			rx_phase = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			//debug("ST1:%02X ",rx_phase);
			if((rx_phase & 0x03) == 0x02)  					// RXC=1, RXE=0 then 2nd check is required (debouncing)
				rx_phase |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			//debug("ST2:%02X ",rx_phase);
			if((rx_phase & 0x07) == 0x02)
			{ // good data (complete with no errors)
				CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);	// need to set RXOW before data read
				length=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				//debug("RX(%d)",length);
				if(length>TELEMETRY_BUFFER_SIZE-2)
					length=TELEMETRY_BUFFER_SIZE-2;
				CYRF_ReadDataPacketLen(packet_in+1, length);
				#ifdef DSM_DEBUG_FWD_PGM
					//debug(" %02X", packet_in[1]);
					if(packet_in[1]==9)
					{
						for(uint8_t i=0;i<length;i++)
							debug(" %02X", packet_in[i+1]);
						debugln("");
					}
				#endif
				packet_in[0]=CYRF_ReadRegister(CYRF_13_RSSI)&0x1F;// store RSSI of the received telemetry signal
				//for(uint8_t i=0;i<length+1;i++)
				//	debug(" %02X", packet_in[i]);
				telemetry_link=1;
			}
			//debugln("");
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Abort RX operation
			if (phase == DSM_CH2_READ_A && (sub_protocol==DSM2_1F || sub_protocol==DSMX_1F) && num_ch < 8)	// 22ms mode
			{
				CYRF_SetTxRxMode(RX_EN);					// Force end state read
				CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);	// Clear abort RX operation
				CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x87);	//0x80???	//Prepare to receive
				phase = DSM_CH2_READ_B;
				return 11000;
			}
			if (phase == DSM_CH2_READ_A)
				phase = DSM_CH1_WRITE_B;					//Transmit upper
			else
				phase = DSM_CH1_WRITE_A;					//Transmit lower
			CYRF_SetTxRxMode(TX_EN);						//TX mode
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		//Clear abort RX operation
			DSM_set_sop_data_crc(false, sub_protocol==DSMX_2F||sub_protocol==DSMX_1F||sub_protocol==DSMR);
			return DSM_READ_DELAY;
#else
			// No telemetry
			DSM_set_sop_data_crc(phase==DSM_CH1_CHECK_A||phase==DSM_CH1_CHECK_B, sub_protocol==DSMX_2F||sub_protocol==DSMX_1F);
			if (phase == DSM_CH2_CHECK_A)
			{
				if(num_ch > 7 || sub_protocol==DSM2_2F || sub_protocol==DSMX_2F)
					phase = DSM_CH1_WRITE_B;				//11ms mode or upper to transmit change from CH2_CHECK_A to CH1_WRITE_A
				else										
				{											//Normal mode 22ms
					phase = DSM_CH1_WRITE_A;				// change from CH2_CHECK_A to CH1_WRITE_A (ie no upper)
					#ifndef MULTI_AIR
						if(sub_protocol==DSM2_SFC)
						{
							if(option&0x40)					// option&40 in this case is 16.5ms/11ms frame rate for DSM2_SFC
								return 11000 - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY ;
							else
								return DSM2_SFC_PERIOD - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY ;
						}
					#endif
					return 22000 - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY ;
				}
			}
			else
				phase = DSM_CH1_WRITE_A;					// change from CH2_CHECK_B to CH1_WRITE_A (upper already transmitted so transmit lower)
			return 11000 - DSM_CH1_CH2_DELAY - DSM_WRITE_DELAY;
#endif
	}
	return 0;		
}


#ifndef MULTI_AIR
const uint8_t PROGMEM DSMR_ID_FREQ[][4 + 23] = {
	{ 0x71, 0x74, 0x1c, 0xe4, 0x11, 0x2f, 0x17, 0x3d, 0x23, 0x3b, 0x0f, 0x21, 0x25, 0x49, 0x1d, 0x13, 0x4d, 0x1f, 0x41, 0x4b, 0x47, 0x05, 0x27, 0x15, 0x19, 0x3f, 0x07 },
	{ 0xfe, 0xfe, 0xfe, 0xfe, 0x45, 0x31, 0x33, 0x4b, 0x11, 0x29, 0x49, 0x3f, 0x09, 0x13, 0x47, 0x21, 0x1d, 0x43, 0x1f, 0x05, 0x41, 0x19, 0x1b, 0x2d, 0x15, 0x4d, 0x0f },
	{ 0xfe, 0xff, 0xff, 0xff, 0x2a, 0x06, 0x22, 0x28, 0x16, 0x24, 0x38, 0x0e, 0x32, 0x2e, 0x14, 0x3a, 0x04, 0x44, 0x0c, 0x42, 0x1c, 0x4a, 0x10, 0x36, 0x3c, 0x48, 0x26 },
	{ 0xff, 0xfe, 0xff, 0xff, 0x28, 0x34, 0x48, 0x46, 0x3a, 0x12, 0x18, 0x32, 0x14, 0x42, 0x16, 0x40, 0x22, 0x44, 0x1c, 0x0a, 0x36, 0x20, 0x10, 0x0c, 0x3c, 0x26, 0x2e },
	{ 0xff, 0xff, 0xfe, 0xff, 0x3c, 0x16, 0x04, 0x48, 0x1e, 0x4a, 0x10, 0x18, 0x22, 0x28, 0x38, 0x40, 0x20, 0x06, 0x3e, 0x42, 0x30, 0x1a, 0x2c, 0x1c, 0x46, 0x14, 0x34 },
	{ 0xff, 0xff, 0xff, 0xfe, 0x4d, 0x39, 0x1b, 0x13, 0x45, 0x2f, 0x0d, 0x3d, 0x0b, 0x11, 0x47, 0x2d, 0x19, 0x1d, 0x23, 0x35, 0x33, 0x3b, 0x21, 0x31, 0x17, 0x0f, 0x43 },
	{ 0xff, 0xff, 0xff, 0xff, 0x14, 0x28, 0x2e, 0x32, 0x3e, 0x10, 0x38, 0x0e, 0x12, 0x06, 0x2c, 0x26, 0x30, 0x4c, 0x34, 0x16, 0x04, 0x3a, 0x42, 0x48, 0x36, 0x46, 0x1a },
	{ 0x00, 0xff, 0xff, 0xff, 0x3e, 0x30, 0x42, 0x24, 0x06, 0x0e, 0x14, 0x1c, 0x08, 0x10, 0x20, 0x22, 0x04, 0x32, 0x0c, 0x44, 0x3c, 0x46, 0x4a, 0x26, 0x4c, 0x48, 0x1e },
	{ 0xff, 0x00, 0xff, 0xff, 0x38, 0x0e, 0x22, 0x2a, 0x44, 0x3a, 0x4a, 0x3e, 0x16, 0x20, 0x36, 0x24, 0x46, 0x18, 0x1e, 0x12, 0x1c, 0x30, 0x2c, 0x14, 0x06, 0x0c, 0x40 },
	{ 0x00, 0x00, 0xff, 0xff, 0x06, 0x4c, 0x26, 0x08, 0x46, 0x3e, 0x30, 0x12, 0x38, 0x1c, 0x04, 0x4a, 0x2c, 0x1a, 0x20, 0x3a, 0x18, 0x36, 0x28, 0x2e, 0x22, 0x40, 0x10 },
	{ 0xff, 0xff, 0x00, 0xff, 0x12, 0x06, 0x3c, 0x2a, 0x22, 0x38, 0x48, 0x4c, 0x32, 0x44, 0x26, 0x16, 0x0c, 0x28, 0x2c, 0x36, 0x1c, 0x1a, 0x42, 0x10, 0x08, 0x4a, 0x34 },
	{ 0x00, 0xff, 0x00, 0xff, 0x04, 0x4c, 0x4a, 0x28, 0x2a, 0x24, 0x14, 0x1e, 0x40, 0x48, 0x44, 0x2c, 0x2e, 0x1a, 0x12, 0x46, 0x3a, 0x0e, 0x18, 0x1c, 0x20, 0x10, 0x42 },
	{ 0xff, 0x00, 0x00, 0xff, 0x06, 0x10, 0x14, 0x16, 0x48, 0x18, 0x44, 0x2c, 0x0a, 0x26, 0x24, 0x42, 0x36, 0x30, 0x38, 0x3e, 0x0c, 0x3c, 0x34, 0x46, 0x2a, 0x32, 0x0e },
	{ 0x00, 0x00, 0x00, 0xff, 0x2c, 0x0a, 0x46, 0x28, 0x38, 0x24, 0x14, 0x06, 0x04, 0x10, 0x18, 0x30, 0x12, 0x20, 0x3a, 0x1a, 0x32, 0x3c, 0x3e, 0x4a, 0x1e, 0x44, 0x36 },
	{ 0x00, 0x00, 0x00, 0x00, 0x45, 0x23, 0x07, 0x37, 0x4b, 0x13, 0x3d, 0x31, 0x19, 0x2b, 0x2f, 0x2d, 0x1f, 0x4d, 0x3f, 0x1b, 0x43, 0x27, 0x3b, 0x11, 0x05, 0x0d, 0x17 },
	{ 0xff, 0xff, 0xff, 0x00, 0x0b, 0x4b, 0x1d, 0x39, 0x09, 0x0f, 0x49, 0x25, 0x07, 0x35, 0x3b, 0x05, 0x33, 0x17, 0x2d, 0x11, 0x2b, 0x29, 0x1f, 0x45, 0x1b, 0x41, 0x47 },
	{ 0x00, 0xff, 0xff, 0x00, 0x41, 0x35, 0x11, 0x25, 0x29, 0x27, 0x33, 0x47, 0x4d, 0x31, 0x05, 0x37, 0x15, 0x1f, 0x23, 0x07, 0x1b, 0x0f, 0x3b, 0x49, 0x19, 0x3f, 0x0b },
	{ 0xff, 0x00, 0xff, 0x00, 0x25, 0x47, 0x05, 0x0b, 0x45, 0x1f, 0x2b, 0x27, 0x2d, 0x09, 0x07, 0x43, 0x49, 0x29, 0x4d, 0x39, 0x33, 0x41, 0x17, 0x0f, 0x15, 0x19, 0x3b },
	{ 0x00, 0x00, 0xff, 0x00, 0x3b, 0x05, 0x21, 0x0d, 0x1b, 0x43, 0x17, 0x2d, 0x1d, 0x25, 0x4b, 0x35, 0x4d, 0x3f, 0x07, 0x09, 0x37, 0x41, 0x15, 0x1f, 0x0f, 0x27, 0x29 },
	{ 0xff, 0xff, 0x00, 0x00, 0x2b, 0x35, 0x1b, 0x1d, 0x0f, 0x47, 0x09, 0x0d, 0x45, 0x41, 0x21, 0x11, 0x2f, 0x43, 0x27, 0x33, 0x4b, 0x37, 0x13, 0x19, 0x4d, 0x23, 0x17 },
	{ 0x00, 0xff, 0x00, 0x00, 0x1b, 0x1d, 0x33, 0x13, 0x2b, 0x27, 0x09, 0x41, 0x25, 0x17, 0x19, 0x2d, 0x4b, 0x37, 0x45, 0x11, 0x21, 0x0d, 0x3d, 0x4d, 0x07, 0x39, 0x43 },
	{ 0xff, 0x00, 0x00, 0x00, 0x37, 0x27, 0x43, 0x4b, 0x39, 0x13, 0x07, 0x0d, 0x25, 0x17, 0x29, 0x1b, 0x1d, 0x45, 0x19, 0x2d, 0x0b, 0x3d, 0x15, 0x47, 0x1f, 0x21, 0x4d } };
#endif

void DSM_init()
{ 
	if(sub_protocol == DSMR)
	{
		#ifndef MULTI_AIR
			if(option&CLONE_BIT_MASK)
				SUB_PROTO_INVALID;
			else
			{
				//SUB_PROTO_VALID;
				uint8_t row = rx_tx_addr[3]%22;
				for(uint8_t i=0; i< 4; i++)
					cyrfmfg_id[i] = pgm_read_byte_near(&DSMR_ID_FREQ[row][i]);
				for(uint8_t i=0; i< 23; i++)
					hopping_frequency[i] = pgm_read_byte_near(&DSMR_ID_FREQ[row][i+4]);
			}
		#endif
	}
	else
	{
		if(option&CLONE_BIT_MASK)
		{ 
			if(eeprom_read_byte((EE_ADDR)DSM_CLONE_EEPROM_OFFSET+4)==0xF0)
			{
				//read cloned ID from EEPROM
				uint16_t temp = DSM_CLONE_EEPROM_OFFSET;
				for(uint8_t i=0;i<4;i++)
					cyrfmfg_id[i] = eeprom_read_byte((EE_ADDR)temp++);
					cyrfmfg_id[3]^=RX_num;		//Model match
				#if DEBUG_BIND
					debugln("Using cloned ID");  
					debug("Clone ID=")
					for(uint8_t i=0;i<4;i++)
						debug("%02x ", cyrfmfg_id[i]);
					debugln("");
				#endif
			}
			else
			{
				SUB_PROTO_INVALID;
				#if DEBUG_BIND
				  debugln("No valid cloned ID");
				#endif
			}
		}
		else
		{
			//SUB_PROTO_VALID;
			CYRF_GetMfgData(cyrfmfg_id);
			cyrfmfg_id[3]^=RX_num;			//Model match
		}
	}

	//Calc sop_col
	sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;

	//We cannot manipulate the ID if we are cloning
	if(!(option&CLONE_BIT_MASK))
	{	
		//Fix for OrangeRX using wrong DSM_pncodes by preventing access to "Col 8"
		if(sop_col==0 && sub_protocol != DSMR)
		{
			cyrfmfg_id[rx_tx_addr[0]%3]^=0x01;					//Change a bit so sop_col will be different from 0
			sop_col = (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + 2) & 0x07;
		}
	}

	//Calc CRC seed
	seed = (cyrfmfg_id[0] << 8) + cyrfmfg_id[1];

	//Hopping frequencies
	if (sub_protocol == DSMX_2F || sub_protocol == DSMX_1F)
		DSM_calc_dsmx_channel();
	else if(sub_protocol != DSMR)
	{ 
		uint8_t tmpch[10];
		CYRF_FindBestChannels(tmpch, 10, 5, 3, 75, FIND_CHANNEL_ANY);
		//
		uint8_t idx = random(0xfefefefe) % 10;
		hopping_frequency[0] = tmpch[idx];
		while(1)
		{
			idx = random(0xfefefefe) % 10;
			if (tmpch[idx] != hopping_frequency[0])
				break;
		}
		hopping_frequency[1] = tmpch[idx];
	}

	//
	DSM_cyrf_config();
	CYRF_SetTxRxMode(TX_EN);
	//
	DSM_update_channels();
	//
	if(IS_BIND_IN_PROGRESS)
	{
		DSM_initialize_bind_phase();		
		phase = DSM_BIND_WRITE;
		bind_counter=DSM_BIND_COUNT;
		#if DEBUG_BIND
			debugln("Bind Started: write count=%d",bind_counter);
		#endif
	}
	else
		phase = DSM_CHANSEL;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Devo_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(DEVO_CYRF6936_INO) 
 
#include "iface_cyrf6936.h"

//For Debug
//#define NO_SCRAMBLE

#define DEVO_PKTS_PER_CHANNEL	4
#define DEVO_BIND_COUNT			0x1388

#define DEVO_NUM_WAIT_LOOPS (100 / 5) //each loop is ~5us.  Do not wait more than 100us

enum {
	DEVO_BIND,
	DEVO_BIND_SENDCH,
	DEVO_BOUND,
	DEVO_BOUND_1,
	DEVO_BOUND_2,
	DEVO_BOUND_3,
	DEVO_BOUND_4,
	DEVO_BOUND_5,
	DEVO_BOUND_6,
	DEVO_BOUND_7,
	DEVO_BOUND_8,
	DEVO_BOUND_9,
	DEVO_BOUND_10,
};

static void __attribute__((unused)) DEVO_scramble_pkt()
{
#ifdef NO_SCRAMBLE
	return;
#else
	for(uint8_t i = 0; i < 15; i++)
		packet[i + 1] ^= cyrfmfg_id[i % 4];
#endif
}

static void __attribute__((unused)) DEVO_add_pkt_suffix()
{
    uint8_t bind_state;
	#ifdef ENABLE_PPM
	if(mode_select && (option&0x01)==0 && IS_BIND_DONE) 			//PPM mode and option not already set and bind is finished
	{
		BIND_SET_INPUT;
		BIND_SET_PULLUP;										// set pullup
		if(IS_BIND_BUTTON_on)
		{
			eeprom_write_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num),0x01);	// Set fixed id mode for the current model
			option |= 0x01;
		}
		BIND_SET_OUTPUT;
	}
	#endif //ENABLE_PPM
    if(prev_option!=option && IS_BIND_DONE)
	{
		MProtocol_id = RX_num + MProtocol_id_master;
		bind_counter=DEVO_BIND_COUNT;
	}
	if (option&0x01)
	{
        if (bind_counter > 0)
            bind_state = 0xc0;
        else
            bind_state = 0x80;
    }
	else
        bind_state = 0x00;
	packet[10] = bind_state | (DEVO_PKTS_PER_CHANNEL - packet_count - 1);
	packet[11] = *(hopping_frequency_ptr + 1);
	packet[12] = *(hopping_frequency_ptr + 2);
	packet[13] = MProtocol_id  & 0xff;
	packet[14] = (MProtocol_id >> 8) & 0xff;
	packet[15] = (MProtocol_id >> 16) & 0xff;
}

static void __attribute__((unused)) DEVO_build_beacon_pkt(uint8_t upper)
{
	packet[0] = (num_ch << 4) | 0x07;
	uint8_t max = 8, offset = 0, enable = 0;
	if (upper)
	{
		packet[0] += 1;
		max = 4;
		offset = 8;
	}
	for(uint8_t i = 0; i < max; i++)
	{
		#ifdef FAILSAFE_ENABLE
			uint16_t failsafe=Failsafe_data[CH_EATR[i+offset]];
			if(i + offset < num_ch && failsafe!=FAILSAFE_CHANNEL_HOLD && IS_FAILSAFE_VALUES_on)
			{
				enable |= 0x80 >> i;
				packet[i+1] = ((failsafe*25)>>8)-100;
			}
			else
		#else
			(void)offset;
		#endif
				packet[i+1] = 0;
	}
	packet[9] = enable;
	DEVO_add_pkt_suffix();
}

static void __attribute__((unused)) DEVO_build_bind_pkt()
{
	packet[0] = (num_ch << 4) | 0x0a;
	packet[1] = bind_counter & 0xff;
	packet[2] = (bind_counter >> 8);
	packet[3] = *hopping_frequency_ptr;
	packet[4] = *(hopping_frequency_ptr + 1);
	packet[5] = *(hopping_frequency_ptr + 2);
	packet[6] = cyrfmfg_id[0];
	packet[7] = cyrfmfg_id[1];
	packet[8] = cyrfmfg_id[2];
	packet[9] = cyrfmfg_id[3];
	DEVO_add_pkt_suffix();
	//The fixed-id portion is scrambled in the bind packet
	//I assume it is ignored
	packet[13] ^= cyrfmfg_id[0];
	packet[14] ^= cyrfmfg_id[1];
	packet[15] ^= cyrfmfg_id[2];
}

static void __attribute__((unused)) DEVO_build_data_pkt()
{
	static uint8_t ch_idx=0;

	packet[0] = (num_ch << 4) | (0x0b + ch_idx);
	uint8_t sign = 0x0b;
	for (uint8_t i = 0; i < 4; i++)
	{
		int16_t value=convert_channel_16b_nolimit(CH_EATR[ch_idx * 4 + i],-1600,1600,false);//range -1600..+1600
		if(value < 0)
		{
			value = -value;
			sign |= 1 << (7 - i);
		}
		packet[2 * i + 1] = value & 0xff;
		packet[2 * i + 2] = (value >> 8) & 0xff;
	}
	packet[9] = sign;
	ch_idx++;
	if (ch_idx * 4 >= num_ch)
		ch_idx = 0;
	DEVO_add_pkt_suffix();
}

#if defined DEVO_HUB_TELEMETRY
static uint32_t __attribute__((unused)) DEVO_text_to_int(uint8_t *ptr, uint8_t len)
{
	uint32_t value = 0;
	for(uint8_t i = 0; i < len; i++)
		value = value * 10 + (ptr[i] - '0');
	return value;
}

static void __attribute__((unused)) DEVO_float_to_ints(uint8_t *ptr, uint16_t *value, uint16_t *decimal)
{
	bool seen_decimal = false;
	*value = 0;
	*decimal = 0;
	for(uint8_t i = 0; i < 7; i++)
	{
		if(ptr[i] == '.')
		{
			seen_decimal = true;
			continue;
		}
		if(ptr[i] < '0' || ptr[i] > '9')
		{
			if(*value != 0 || seen_decimal)
				return;
		}
		else
		{
			if(seen_decimal)
				*decimal = *decimal * 10 + (ptr[i] - '0');
			else
				*value = *value * 10 + (ptr[i] - '0');
		}
	}
}

static void __attribute__((unused)) DEVO_parse_telemetry_packet()
{ // Telemetry packets every 2.4ms
	DEVO_scramble_pkt(); //This will unscramble the packet
	
	debugln("RX");
	if ((((uint32_t)packet[15] << 16) | ((uint32_t)packet[14] << 8) | packet[13]) != (MProtocol_id & 0x00ffffff))
		return;	// ID does not match
		
	if((telemetry_link & 3) != 0)
	{
		debugln("S%d",telemetry_link);
		return;	// Previous telemetry not sent yet...
	}

	//Debug telem RX
	//for(uint8_t i=0;i<12;i++)
	//	debug("%02X ",packet[i]);
	//debugln("");
	
	#if defined HUB_TELEMETRY
	//Telemetry https://github.com/DeviationTX/deviation/blob/5efb6a28bea697af9a61b5a0ed2528cc8d203f90/src/protocol/devo_cyrf6936.c#L232
		uint16_t val, dec;
		uint32_t val32;
		switch(packet[0])
		{
			case 0x30:	// Volt and RPM packet
				//RSSI and voltage
				TX_RSSI = CYRF_ReadRegister(CYRF_13_RSSI) & 0x1F;
				TX_RSSI = (TX_RSSI << 1) + TX_RSSI;
				RX_RSSI = TX_RSSI;
				telemetry_link |= 1;
				v_lipo1 = packet[1] << 1;
				v_lipo2 = packet[3] << 1;
				//packet[5] = 127;																					// 12.7V
				if(packet[5] != 0)
				{
					val  = (packet[5]*11)/21;																		// OpenTX strange transformation??
					dec  = val;
					val /= 10;
					dec -= val*10;
					frsky_send_user_frame(0x3A, val, 0x00);															// volt3
					frsky_send_user_frame(0x3B, dec, 0x00);															// volt3
				}
				val = packet[7] * 120;																				// change to RPM
				frsky_send_user_frame(0x03, val, val>>8);															// RPM
				break;
			case 0x31:	// Temperature packet
				//memcpy(&packet[1],"\x29\x2A\x2B\x00\x00\x00\x00\x00\x00\x00\x00\x00",12);							// 21, 22, 23
				for(uint8_t i=0; i<2;i++)
					if(packet[i+1]!=0xff)
					{
						val = packet[i+1];
						val -= 20;
						frsky_send_user_frame(0x02 + i*3, val, val>>8);												// temp 1 & 2
					}
				break;
			// GPS Data
			case 0x32: // Longitude
				//memcpy(&packet[1],"\x30\x33\x30\x32\x30\x2e\x38\x32\x37\x30\x45\xfb",12);							// 03020.8270E in ddmm.mmmm
				//memcpy(&packet[1],"\x31\x31\x37\x31\x31\x2e\x35\x39\x34\x37\x57\xfb",12);							// RX705 sends 11711.5947W which should be 11706.95685W in ddmm.mmmm
				val = DEVO_text_to_int(&packet[1], 3)*100;															// dd00
				val32 = DEVO_text_to_int(&packet[4], 2) * 10000 + DEVO_text_to_int(&packet[7], 4);					// mmmmmm
				if(option&0x02)																						// if RX705 GPS format
					val32 = (val32*3)/5;																			// then * 6/10 correction
				dec = val32/10000;
				val = val + dec;																					// dddmm
				frsky_send_user_frame(0x12  , val, val>>8);
				val = val32 - dec*10000;																			// .mmmm
				frsky_send_user_frame(0x12+8, val, val>>8);
				frsky_send_user_frame(0x1A+8, packet[11], 0x00);													// 'E'/'W'
				break;
			case 0x33: // Latitude
				//memcpy(&packet[1],"\x35\x39\x35\x34\x2e\x37\x37\x37\x36\x4e\x07\x00",12);							// 5954.776N in ddmm.mmmm
				//memcpy(&packet[1],"\x31\x37\x31\x31\x2e\x35\x39\x34\x37\x4e\xfb\x00",12);							// RX705 sends 1711.5947N which should be 1706.95685N in ddmm.mmmm
				val = DEVO_text_to_int(&packet[1], 2)*100;															// dd00
				val32 = DEVO_text_to_int(&packet[3], 2) * 10000 + DEVO_text_to_int(&packet[6], 4);					// mmmmmm
				if(option&0x02)																						// if RX705 GPS format
					val32 = (val32*3)/5;																			// then * 6/10 correction
				dec = val32/10000;
				val = val + dec;																					// dddmm
				frsky_send_user_frame(0x13  , val, val>>8);
				val = val32 - dec*10000;																			// .mmmm
				frsky_send_user_frame(0x13+8, val, val>>8);
				frsky_send_user_frame(0x1B+8, packet[10], 0x00);													// 'N'/'S'
				break;
			case 0x34: // Altitude
				//memcpy(&packet[1],"\x31\x32\x2e\x38\x00\x00\x00\x4d\x4d\x4e\x45\xfb",12);							// 12.8 MMNE
				DEVO_float_to_ints(&packet[1], &val, &dec);
				frsky_send_user_frame(0x10, val, val>>8);
				frsky_send_user_frame(0x21, dec, dec>>8);
				break;
			case 0x35: // Speed
				//memcpy(&packet[1],"\x00\x00\x00\x00\x00\x00\x30\x2e\x30\x30\x00\x00",12);							// 0.0
				DEVO_float_to_ints(&packet[1], &val, &dec);
				frsky_send_user_frame(0x11  , val, val>>8);
				frsky_send_user_frame(0x11+8, dec, dec>>8);
				break;
			case 0x36: // Time
				//memcpy(&packet[1],"\x31\x38\x32\x35\x35\x32\x31\x35\x31\x30\x31\x32",12);							// "182552151012" = 2012-10-15 18:25:52 (UTC)
				if(packet[1]!=0)
				{
					frsky_send_user_frame(0x15, DEVO_text_to_int(&packet[9], 2), DEVO_text_to_int(&packet[7], 2));	// month, day
					val = 2000 + DEVO_text_to_int(&packet[11], 2);													// year
					frsky_send_user_frame(0x16, val, val>>8);
					frsky_send_user_frame(0x17, DEVO_text_to_int(&packet[1], 2), DEVO_text_to_int(&packet[3], 2));	// hour, min
					frsky_send_user_frame(0x18, DEVO_text_to_int(&packet[5], 2), 0x00);								// second
				}
				break;
		}
	#else
		if(packet[0] == 0x30)
		{
			TX_RSSI = CYRF_ReadRegister(CYRF_13_RSSI) & 0x1F;
			TX_RSSI = (TX_RSSI << 1) + TX_RSSI;
			RX_RSSI = TX_RSSI;
			telemetry_link |= 1;
			v_lipo1 = packet[1] << 1;
			v_lipo2 = packet[3] << 1;
		}
	#endif
}
#endif

static void __attribute__((unused)) DEVO_cyrf_set_bound_sop_code()
{
	/* crc == 0 isn't allowed, so use 1 if the math results in 0 */
	uint8_t crc = (cyrfmfg_id[0] + (cyrfmfg_id[1] >> 6) + cyrfmfg_id[2]);
	if(! crc)
		crc = 1;
	uint8_t sopidx = (0xff &((cyrfmfg_id[0] << 2) + cyrfmfg_id[1] + cyrfmfg_id[2])) % 10;
	CYRF_SetTxRxMode(TX_EN);
	CYRF_ConfigCRCSeed((crc << 8) + crc);
	CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[sopidx]);
	CYRF_SetPower(0x08);
}

const uint8_t PROGMEM DEVO_init_vals[][2] = {
	{ CYRF_1D_MODE_OVERRIDE, 0x38 },
	{ CYRF_03_TX_CFG, 0x08 },
	{ CYRF_06_RX_CFG, 0x4A },
	{ CYRF_0B_PWR_CTRL, 0x00 },
	{ CYRF_10_FRAMING_CFG, 0xA4 },
	{ CYRF_11_DATA32_THOLD, 0x05 },
	{ CYRF_12_DATA64_THOLD, 0x0E },
	{ CYRF_1B_TX_OFFSET_LSB, 0x55 },
	{ CYRF_1C_TX_OFFSET_MSB, 0x05 },
	{ CYRF_32_AUTO_CAL_TIME, 0x3C },
	{ CYRF_35_AUTOCAL_OFFSET, 0x14 },
	{ CYRF_39_ANALOG_CTRL, 0x01 },
	{ CYRF_1E_RX_OVERRIDE, 0x10 },
	{ CYRF_1F_TX_OVERRIDE, 0x00 },
	{ CYRF_01_TX_LENGTH, 0x10 },
	{ CYRF_0F_XACT_CFG, 0x10 },
	{ CYRF_27_CLK_OVERRIDE, 0x02 },
	{ CYRF_28_CLK_EN, 0x02 },
	{ CYRF_0F_XACT_CFG, 0x28 }
};

static void __attribute__((unused)) DEVO_cyrf_init()
{
	/* Initialise CYRF chip */
	for(uint8_t i = 0; i < sizeof(DEVO_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte( &DEVO_init_vals[i][0]), pgm_read_byte( &DEVO_init_vals[i][1]) );
}

static void __attribute__((unused)) DEVO_set_radio_channels()
{
	CYRF_FindBestChannels(hopping_frequency, 3, 4, 4, 80, FIND_CHANNEL_ANY);
	hopping_frequency[3] = hopping_frequency[0];
	hopping_frequency[4] = hopping_frequency[1];
}

static void __attribute__((unused)) DEVO_BuildPacket()
{
	static uint8_t failsafe_pkt=0;
	switch(phase)
	{
		case DEVO_BIND:
			if(bind_counter)
				bind_counter--;
			DEVO_build_bind_pkt();
			phase = DEVO_BIND_SENDCH;
			break;
		case DEVO_BIND_SENDCH:
			if(bind_counter)
				bind_counter--;
			DEVO_build_data_pkt();
			DEVO_scramble_pkt();
			if (bind_counter == 0)
			{
				phase = DEVO_BOUND;
				BIND_DONE;
			}
			else
				phase = DEVO_BIND;
			break;
		case DEVO_BOUND:
		case DEVO_BOUND_1:
		case DEVO_BOUND_2:
		case DEVO_BOUND_3:
		case DEVO_BOUND_4:
		case DEVO_BOUND_5:
		case DEVO_BOUND_6:
		case DEVO_BOUND_7:
		case DEVO_BOUND_8:
		case DEVO_BOUND_9:
			DEVO_build_data_pkt();
			DEVO_scramble_pkt();
			phase++;
			if (bind_counter)
			{
				bind_counter--;
				if (bind_counter == 0)
					BIND_DONE;
			}
			break;
		case DEVO_BOUND_10:
			DEVO_build_beacon_pkt(num_ch > 8 ? failsafe_pkt : 0);
			failsafe_pkt = failsafe_pkt ? 0 : 1;
			DEVO_scramble_pkt();
			phase = DEVO_BOUND_1;
			break;
	}
	packet_count++;
	if(packet_count == DEVO_PKTS_PER_CHANNEL)
		packet_count = 0;
}

uint16_t DEVO_callback()
{
	static uint8_t txState=0;
	
#if defined DEVO_HUB_TELEMETRY
	int delay;
	
	if (txState == 0)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(2400);
		#endif
		DEVO_BuildPacket();
		CYRF_WriteDataPacket(packet);
		txState = 1;
		return 900;
	}
	if (txState == 1)
	{
		int i = 0;
		uint8_t reg;
		while (! ((reg = CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS)) & 0x02))
		{
			if (++i >= DEVO_NUM_WAIT_LOOPS)
				break;
		}
		if (((reg & 0x22) == 0x20) || (CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80))
		{
			CYRF_Reset();
			DEVO_cyrf_init();
			DEVO_cyrf_set_bound_sop_code();
			CYRF_ConfigRFChannel(*hopping_frequency_ptr);
			//printf("Rst CYRF\n");
			delay = 1500;
			txState = 15;
		}
		else
		{
			if (phase == DEVO_BOUND)
			{
				/* exit binding state */
				phase = DEVO_BOUND_3;
				DEVO_cyrf_set_bound_sop_code();
			}
			if((packet_count != 0) && (bind_counter == 0))
			{
				CYRF_SetTxRxMode(RX_EN); //Receive mode
				CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x87); //0x80??? //Prepare to receive
				txState = 2;
				return 1300;
			}
		}
		if(packet_count == 0)
		{
			CYRF_SetPower(0x08);		//Keep tx power updated
			hopping_frequency_ptr = hopping_frequency_ptr == &hopping_frequency[2] ? hopping_frequency : hopping_frequency_ptr + 1;
			CYRF_ConfigRFChannel(*hopping_frequency_ptr);
		}
		delay = 1500;
	}
	if(txState == 2)
	{
		uint8_t rx_state = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
		if((rx_state & 0x03) == 0x02)
		{  // RXC=1, RXE=0 then 2nd check is required (debouncing)
			rx_state |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);   
		}
		if((rx_state & 0x07) == 0x02)
		{ // good data (complete with no errors)
			CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);	// need to set RXOW before data read
			CYRF_ReadDataPacketLen(packet, CYRF_ReadRegister(CYRF_09_RX_COUNT));
			DEVO_parse_telemetry_packet();
		}
		CYRF_SetTxRxMode(TX_EN); //Write mode
		delay = 200;
	}
	txState = 0;   
	return delay;
#else
	if (txState == 0)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(2400);
		#endif
		txState = 1;
		DEVO_BuildPacket();
		CYRF_WriteDataPacket(packet);
		return 1200;
	}
	txState = 0;
	uint8_t i = 0;
	while (! (CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS) & 0x02))
		if(++i > DEVO_NUM_WAIT_LOOPS)
			return 1200;
	if (phase == DEVO_BOUND)
	{
		/* exit binding state */
		phase = DEVO_BOUND_3;
		DEVO_cyrf_set_bound_sop_code();
	}   
	if(packet_count == 0)
	{
		CYRF_SetPower(0x08);		//Keep tx power updated
		hopping_frequency_ptr = hopping_frequency_ptr == &hopping_frequency[2] ? hopping_frequency : hopping_frequency_ptr + 1;
		CYRF_ConfigRFChannel(*hopping_frequency_ptr);
	}
	return 1200;
#endif
}

void DEVO_init()
{	
	#ifdef ENABLE_PPM
		if(mode_select) //PPM mode
		{
			if(IS_BIND_BUTTON_FLAG_on)
			{
				option &= 0xFE;
				eeprom_write_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num),option);	// reset to autobind mode for the current model
			}
			else
			{	
				option=eeprom_read_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num));		// load previous mode: autobind or fixed id
				if(option > 3) option = 0;												// if invalid then it should be autobind
			}
		}
	#endif //ENABLE_PPM
	switch(sub_protocol)
	{
		case 1:
			num_ch=10;
			break;
		case 2:
			num_ch=12;
			break;
		case 3:
			num_ch=6;
			break;
		case 4:
			num_ch=7;
			break;
		default:
			num_ch=8;
			break;
	}
	DEVO_cyrf_init();
	CYRF_GetMfgData(cyrfmfg_id);
	CYRF_SetTxRxMode(TX_EN);
	CYRF_ConfigCRCSeed(0x0000);
	CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[0]);
	DEVO_set_radio_channels();

	hopping_frequency_ptr = hopping_frequency;
	CYRF_ConfigRFChannel(*hopping_frequency_ptr);

	packet_count = 0;

	if(option&0x01)
	{
		phase = DEVO_BOUND_1;
		bind_counter = 0;
		DEVO_cyrf_set_bound_sop_code();
	}
	else
	{
		MProtocol_id = ((uint32_t)(hopping_frequency[0] ^ cyrfmfg_id[0] ^ cyrfmfg_id[3]) << 16)
					 | ((uint32_t)(hopping_frequency[1] ^ cyrfmfg_id[1] ^ cyrfmfg_id[4]) << 8)
					 | ((uint32_t)(hopping_frequency[2] ^ cyrfmfg_id[2] ^ cyrfmfg_id[5]) << 0);
		MProtocol_id %= 1000000;
		bind_counter = DEVO_BIND_COUNT;
		phase = DEVO_BIND;
		BIND_IN_PROGRESS;
	}
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E010R5_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(E010R5_CYRF6936_INO)

#include "iface_rf2500.h"

#define E010R5_FORCE_ID

#define E010R5_PAYLOAD_SIZE	14


static void __attribute__((unused)) E010R5_build_data_packet()
{
	packet[ 0] = 0x0D;								// Packet length
	packet[ 1] = convert_channel_8b(THROTTLE);
	packet[ 2] = convert_channel_s8b(RUDDER);
	packet[ 3] = convert_channel_s8b(ELEVATOR);
	packet[ 4] = convert_channel_s8b(AILERON);
	packet[ 5] = 0x20;								// Trim Rudder
	packet[ 6] = 0x20;								// Trim Elevator
	packet[ 7] = 0x20;								// Trim Aileron
	packet[ 8] = 0x01								// Flags: high=0x01, low=0x00
			| GET_FLAG(CH5_SW, 0x04)				//        flip=0x04
			| GET_FLAG(CH6_SW, 0x08)				//        led=0x08
			| GET_FLAG(CH8_SW, 0x10)				//		  headless=0x10
			| GET_FLAG(CH9_SW, 0x20);				//		  one key return=0x20
	packet[ 9] = IS_BIND_IN_PROGRESS ? 0x80 : 0x00	// Flags: bind=0x80
			| GET_FLAG(CH7_SW, 0x20)				//        calib=0x20
			| GET_FLAG(CH10_SW, 0x01);				//		  strange effect=0x01=long press on right button
	packet[10] = rx_tx_addr[0];
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2];
	packet[13] = 0x9D;								// Check
	for(uint8_t i=0;i<13;i++)
		packet[13] += packet[i];

	RF2500_BuildPayload(packet);
}

uint16_t E010R5_callback()
{
	//Bind
	if(bind_counter)
		if(--bind_counter==0)
			BIND_DONE;

	//Send packet
	RF2500_SendPayload();
	
	//Timing and hopping
	packet_count++;
	switch(packet_count)
	{
		case 1:
		case 2:
		case 4:
		case 5:
			return 1183;
		default:
			hopping_frequency_no++;
			hopping_frequency_no &= 3;
			if(IS_BIND_IN_PROGRESS)
				rf_ch_num = 0x30 + (hopping_frequency_no<<3);
			else
				rf_ch_num = hopping_frequency[hopping_frequency_no];
			RF2500_RFChannel(rf_ch_num);
			RF2500_SetPower();
			packet_count = 0;
		case 3:
			E010R5_build_data_packet();
			return 3400;
	}
	return 0;
}

void E010R5_init()
{
	BIND_IN_PROGRESS;									// Autobind protocol
	bind_counter = 2600;

	//RF2500 emu init
	RF2500_Init(E010R5_PAYLOAD_SIZE, false);			// 14 bytes, not scrambled
	RF2500_SetTXAddr((uint8_t*)"\x0E\x54\x96\xEE");		// Same address for bind and normal packets
	
	rx_tx_addr[0]=0x00;
	hopping_frequency[0]=0x35;	//53
	#ifdef E010R5_FORCE_ID
		switch(rx_tx_addr[3]%5)
		{
			case 0:
				//TX1
				//hopping_frequency[0]=0x35;	//53
				hopping_frequency[1]=0x30;		//48
				rx_tx_addr[1]=0x45;
				rx_tx_addr[2]=0x46;
				break;
			case 1:
				//TX2
				//hopping_frequency[0]=0x35;	//53
				hopping_frequency[1]=0x3C;		//60
				rx_tx_addr[1]=0x1B;
				rx_tx_addr[2]=0x9E;
				break;
			case 2:
				//TX4
				hopping_frequency[0]=0x30;		//48
				hopping_frequency[1]=0x38;		//56
				rx_tx_addr[1]=0x2E;
				rx_tx_addr[2]=0xAE;
				break;
			case 3:
				//TX5
				//hopping_frequency[0]=0x35;	//53
				hopping_frequency[1]=0x41;		//65
				rx_tx_addr[0]=0x0D;
				rx_tx_addr[1]=0xB9;
				rx_tx_addr[2]=0xFC;
				break;
			default:
				//TX3
				hopping_frequency[0]=0x30;		//48
				hopping_frequency[1]=0x38;		//56
				rx_tx_addr[1]=0x17;
				rx_tx_addr[2]=0x0D;
				break;
		}
    #endif
	// This is the same as the E010 v1...
	hopping_frequency[2]=hopping_frequency[0]+0x10;
	hopping_frequency[3]=hopping_frequency[1]+0x10;

	E010R5_build_data_packet();
	RF2500_RFChannel(hopping_frequency[0]);
	hopping_frequency_no=0;
	packet_count=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016HV2_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(E016HV2_CC2500_INO)

#include "iface_cc2500.h"

//#define FORCE_E016HV2_ORIGINAL_ID

#define E016HV2_INITIAL_WAIT		500
#define E016HV2_PACKET_PERIOD		10000
#define E016HV2_RF_BIND_CHANNEL	5
#define E016HV2_PAYLOAD_SIZE		11
#define E016HV2_BIND_COUNT		300	//3sec

static void __attribute__((unused)) E016HV2_send_packet()
{
	//payload length (after this byte)
	packet[0 ] = 0x0A;
	
	//bind indicator
	if(IS_BIND_IN_PROGRESS)
	{
		packet[1 ] = 0x02;
		if(bind_counter)
			bind_counter--;
		else
		{
			BIND_DONE;
			CC2500_250K_RFChannel(rf_ch_num);			// Set main channel
		}
	}
	else
		packet[1 ] = 0x20;
	
	//ID
	packet[2 ] = rx_tx_addr[2];
	packet[3 ] = rx_tx_addr[3];

	//channels TREA
	uint8_t channel;
	if(IS_BIND_IN_PROGRESS)
		channel=0x64;								// Throttle must be centered during bind
	else
		channel=convert_channel_8b_limit_deadband(THROTTLE,0x00,0x64,0xC8, 20);
	packet[4 ]  = channel;
	channel=convert_channel_16b_limit(RUDDER,0x00,0xC8);
	packet[5 ]  = channel;
	channel=convert_channel_16b_limit(ELEVATOR,0x00,0xC8);
	packet[6 ]  = channel;
	channel=convert_channel_16b_limit(AILERON,0x00,0xC8);
	packet[7 ]  = channel;

	//flags
	if(CH8_SW && !phase) //toggle calib flag
		flags ^= 0x40;
	phase=CH8_SW;

	packet[8 ] = GET_FLAG(CH7_SW,  0x01)			// 0x01=Flip
			   | GET_FLAG(CH9_SW,  0x02)			// 0x02=Headless
			   | GET_FLAG(CH10_SW, 0x04)			// 0x04=One Key Return
			   | flags;								// 0x40=Calib

	packet[9 ] = 0x02;								// Speed control 0x00:low, 0x01:medium, 0x02:high
	
	packet[10] = GET_FLAG(CH5_SW, 0x01)				// 0x01=TakeOff/Land  (momentary switch)
			   | GET_FLAG(CH6_SW, 0x04);			// 0x04=Emergeny Stop (momentary switch)

	CC2500_SetPower();								// Set tx_power
	CC2500_SetFreqOffset();							// Set frequency offset

	//Build real packet and send it
	static uint8_t pid=0;
	crc=0;
	
	// stop TX/RX
	CC2500_Strobe(CC2500_SIDLE);
	// flush tx FIFO
	CC2500_Strobe(CC2500_SFTX);
	// packet length
	CC2500_WriteReg(CC2500_3F_TXFIFO, 6 + 4 + 1 + 11 + 2);	// preamble + address + packet_control + payload + crc

	// preamble+address
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, (uint8_t*)"\xAA\xAA\xAA\xAA\xAA\xAA\xE7\xE7\xE7\xE7", 10);

	// packet control
	CC2500_WriteReg(CC2500_3F_TXFIFO, 0x50+(pid<<2));
	pid++;

	// payload
	//debug("P:")
	for (uint8_t i = 0; i < E016HV2_PAYLOAD_SIZE; ++i)
	{
		uint8_t byte = (bit_reverse(packet[i])<<1) | (packet[i+1]&0x01);
		//debug(" %02X",byte)
		CC2500_WriteReg(CC2500_3F_TXFIFO,byte);
		crc16_update(byte, 8);
	}

	// crc
	CC2500_WriteReg(CC2500_3F_TXFIFO,crc >> 8);
	CC2500_WriteReg(CC2500_3F_TXFIFO,crc);
	//debugln(" %04X",crc)

	// transmit
	CC2500_Strobe(CC2500_STX);
}

uint16_t E016HV2_callback()
{
	E016HV2_send_packet();
	return E016HV2_PACKET_PERIOD;
}

void E016HV2_init()
{
	//Config CC2500
	CC2500_250K_Init();
	CC2500_250K_RFChannel(E016HV2_RF_BIND_CHANNEL);		// Set bind channel

	#ifdef FORCE_E016HV2_ORIGINAL_ID
		rx_tx_addr[2]=0x27;
		rx_tx_addr[3]=0x1B;
		//rf_ch_num = 44;
	#endif
	//General ID
	//3F1B -> 68,2C1B -> 49,2B1B -> 48,2A1B -> 47,291B -> 46,281B -> 45,271B -> 44,261B -> 43,251B -> 42
	//241B -> no bind,231B -> no bind,221B -> 71,211B -> 70,201B -> 69,1F1B -> 68,1E1B -> 67,1D1B -> 66,1C1B -> 65,1B1B -> 64,1A1B -> 63,191B -> 62,181B -> 61,171B -> 60,161B -> 59
	//0C1B -> 49,051B -> 42,041B -> no bind,031B -> no bind,021B -> 71,011B -> 70,001B -> no bind
	if(rx_tx_addr[2]<3) rx_tx_addr[2]+=3;			// rx_tx_addr[2]=0 is invalid
	if(rx_tx_addr[3]==0) rx_tx_addr[3]+=64;			// rx_tx_addr[3]=0 is invalid
	rf_ch_num = (rx_tx_addr[2] + rx_tx_addr[3]) % 32 + 42;
	if(rf_ch_num>71)								// channels 72 and 73 are invalid
	{
		rx_tx_addr[2]-=2;
		rf_ch_num-=2;
	}
	
	phase=CH8_SW;
	flags=0;
	bind_counter = E016HV2_BIND_COUNT;
	BIND_IN_PROGRESS;								// Autobind protocol
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E016H_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with E016H

#if defined(E016H_NRF24L01_INO)

#include "iface_xn297.h"

//Protocols constants
#define E016H_BIND_COUNT		500
#define E016H_ADDRESS_LENGTH	5

#define E016H_PACKET_PERIOD		4080
#define E016H_PACKET_SIZE		10
#define E016H_BIND_CHANNEL		80
#define E016H_NUM_CHANNELS		4

//Channels
#define E016H_STOP_SW			CH5_SW
#define E016H_FLIP_SW			CH6_SW
#define E016H_HEADLESS_SW		CH8_SW
#define E016H_RTH_SW			CH9_SW

// E016H flags packet[1]
#define E016H_FLAG_CALIBRATE	0x80
#define E016H_FLAG_STOP			0x20
#define E016H_FLAG_FLIP			0x04
// E016H flags packet[3]
#define E016H_FLAG_HEADLESS		0x10
#define E016H_FLAG_RTH			0x04
// E016H flags packet[7]
#define E016H_FLAG_TAKEOFF		0x80
#define E016H_FLAG_HIGHRATE		0x08

static void __attribute__((unused)) E016H_send_packet()
{
    uint8_t can_flip = 0, calibrate = 1;

	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(packet, &rx_tx_addr[1], 4);
		memcpy(&packet[4], hopping_frequency, 4);
		packet[8] = 0x23;
	}
	else
	{
		// trim commands
		packet[0] = 0;
		// aileron
		uint16_t val = convert_channel_16b_limit(AILERON, 0, 0x3ff);
		can_flip |= (val < 0x100) || (val > 0x300);
		packet[1] = val >> 8;
		packet[2] = val & 0xff;
		if(val < 0x300) calibrate = 0;
		// elevator
		val = convert_channel_16b_limit(ELEVATOR, 0x3ff, 0);
		can_flip |= (val < 0x100) || (val > 0x300);
		packet[3] = val >> 8;
		packet[4] = val & 0xff;
		if(val < 0x300) calibrate = 0;
		// throttle
		val = convert_channel_16b_limit(THROTTLE, 0, 0x3ff);
		packet[5] = val >> 8;
		packet[6] = val & 0xff;
		if(val > 0x100) calibrate = 0;
		// rudder
		val = convert_channel_16b_limit(RUDDER, 0, 0x3ff);
		packet[7] = val >> 8;
		packet[8] = val & 0xff;
		if(val > 0x100) calibrate = 0;
		// flags
		packet[1] |= GET_FLAG(E016H_STOP_SW, E016H_FLAG_STOP)
				  |  (can_flip ? GET_FLAG(E016H_FLIP_SW, E016H_FLAG_FLIP) : 0)
				  |  (calibrate ? E016H_FLAG_CALIBRATE : 0);
		packet[3] |= GET_FLAG(E016H_HEADLESS_SW, E016H_FLAG_HEADLESS)
				  |  GET_FLAG(E016H_RTH_SW, E016H_FLAG_RTH);
		packet[7] |= E016H_FLAG_HIGHRATE;
		// frequency hopping
		XN297_Hopping(hopping_frequency_no++ & 0x03);
	}
	// checksum
	packet[9] = packet[0];
	for (uint8_t i=1; i < E016H_PACKET_SIZE-1; i++)
		packet[9] += packet[i];

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, E016H_PACKET_SIZE);
}

static void __attribute__((unused)) E016H_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t *)"\x5a\x53\x46\x30\x31", 5);  // bind address
	//XN297_HoppingCalib(E016H_NUM_CHANNELS);
	XN297_RFChannel(E016H_BIND_CHANNEL);
}

uint16_t E016H_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			XN297_SetTXAddr(rx_tx_addr, E016H_ADDRESS_LENGTH);
			BIND_DONE;
		}
	}
	E016H_send_packet();
	return E016H_PACKET_PERIOD;
}

static void __attribute__((unused)) E016H_initialize_txid()
{
	// tx id
    rx_tx_addr[0] = 0xa5;
    rx_tx_addr[1] = 0x00;

    // rf channels
    uint32_t lfsr=random(0xfefefefe);
    for(uint8_t i=0; i<E016H_NUM_CHANNELS; i++)
    {
		hopping_frequency[i] = (lfsr & 0xFF) % 80; 
		lfsr>>=8;
	}
}

void E016H_init()
{
	BIND_IN_PROGRESS;
	E016H_initialize_txid();
	E016H_RF_init();
	bind_counter = E016H_BIND_COUNT;
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E01X_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with E012 and E015

#if defined(E01X_CYRF6936_INO)

#include "iface_hs6200.h"

//Protocols constants
#define E01X_BIND_COUNT			500
#define E01X_INITIAL_WAIT		500
#define E01X_ADDRESS_LENGTH		5

#define E012_PACKET_PERIOD		4525
#define E012_RF_BIND_CHANNEL	0x3c
#define E012_NUM_RF_CHANNELS	4
#define E012_PACKET_SIZE		15

//#define E015_FORCE_ID
#define E015_PACKET_PERIOD		9000
#define E015_RF_CHANNEL			0x2d	// 2445 MHz
#define E015_PACKET_SIZE		10
#define E015_BIND_PACKET_SIZE	9

//Channels
#define E01X_ARM_SW			CH5_SW
#define E016H_STOP_SW		CH5_SW
#define E01X_FLIP_SW		CH6_SW
#define E01X_LED_SW			CH7_SW
#define E01X_HEADLESS_SW	CH8_SW
#define E01X_RTH_SW			CH9_SW

// E012 flags packet[1]
#define E012_FLAG_FLIP		0x40
#define E012_FLAG_HEADLESS	0x10
#define E012_FLAG_RTH		0x04
// E012 flags packet[7]
#define E012_FLAG_EXPERT	0x02

// E015 flags packet[6]
#define E015_FLAG_DISARM	0x80
#define E015_FLAG_ARM		0x40
// E015 flags packet[7]
#define E015_FLAG_FLIP		0x80
#define E015_FLAG_HEADLESS	0x10
#define E015_FLAG_RTH		0x08
#define E015_FLAG_LED		0x04
#define E015_FLAG_EXPERT	0x02
#define E015_FLAG_INTERMEDIATE 0x01

static void __attribute__((unused)) E015_check_arming()
{
	uint8_t arm_channel = E01X_ARM_SW;

	if (arm_channel != arm_channel_previous)
	{
		arm_channel_previous = arm_channel;
		if (arm_channel)
		{
			armed = 1;
			arm_flags ^= E015_FLAG_ARM;
		}
		else
		{
			armed = 0;
			arm_flags ^= E015_FLAG_DISARM;
		}
	}
}

static void __attribute__((unused)) E01X_send_packet()
{
	if(sub_protocol==E012)
	{
		packet_length=E012_PACKET_SIZE;
		packet[0] = rx_tx_addr[1];
		if(IS_BIND_IN_PROGRESS)
		{
			rf_ch_num = E012_RF_BIND_CHANNEL;
			packet[1] = 0xaa;
			memcpy(&packet[2], hopping_frequency, E012_NUM_RF_CHANNELS);
			memcpy(&packet[6], rx_tx_addr, E01X_ADDRESS_LENGTH);
		}
		else
		{
			rf_ch_num = hopping_frequency[hopping_frequency_no++];
			hopping_frequency_no %= E012_NUM_RF_CHANNELS;
			packet[1] = 0x01
				| GET_FLAG(E01X_RTH_SW,			E012_FLAG_RTH)
				| GET_FLAG(E01X_HEADLESS_SW,	E012_FLAG_HEADLESS)
				| GET_FLAG(E01X_FLIP_SW,		E012_FLAG_FLIP);
			packet[2] = convert_channel_16b_limit(AILERON,  0xc8, 0x00); // aileron
			packet[3] = convert_channel_16b_limit(ELEVATOR, 0x00, 0xc8); // elevator
			packet[4] = convert_channel_16b_limit(RUDDER,   0xc8, 0x00); // rudder
			packet[5] = convert_channel_16b_limit(THROTTLE, 0x00, 0xc8); // throttle
			packet[6] = 0xaa;
			packet[7] = E012_FLAG_EXPERT;	// rate (0-2)
			packet[8] = 0x00;
			packet[9] = 0x00;
			packet[10]= 0x00;
		}
		packet[11] = 0x00;
		packet[12] = 0x00;
		packet[13] = 0x56; 
		packet[14] = rx_tx_addr[2];
	}
	else
	{ // E015
		rf_ch_num = E015_RF_CHANNEL;
		if(IS_BIND_IN_PROGRESS)
		{
			packet[0] = 0x18;
			packet[1] = 0x04;
			packet[2] = 0x06;
			// data phase address
			memcpy(&packet[3], rx_tx_addr, E01X_ADDRESS_LENGTH);
			packet[8] = 0x63;	// unknown calculation
			// checksum
			//packet[8] = packet[3];
			//for(uint8_t i=4; i<8; i++)
			//	packet[8] += packet[i];
			packet_length=E015_BIND_PACKET_SIZE;
		}
		else
		{
			E015_check_arming();
			packet[0] = convert_channel_16b_limit(THROTTLE,	0, 225); // throttle
			packet[1] = convert_channel_16b_limit(RUDDER,   225, 0); // rudder
			packet[2] = convert_channel_16b_limit(AILERON,  0, 225); // aileron
			packet[3] = convert_channel_16b_limit(ELEVATOR, 225, 0); // elevator
			packet[4] = 0x20; // elevator trim
			packet[5] = 0x20; // aileron trim
			packet[6] = arm_flags;
			packet[7] = E015_FLAG_EXPERT
				| GET_FLAG(E01X_FLIP_SW,	E015_FLAG_FLIP)
				| GET_FLAG(E01X_LED_SW,		E015_FLAG_LED)
				| GET_FLAG(E01X_HEADLESS_SW,E015_FLAG_HEADLESS)
				| GET_FLAG(E01X_RTH_SW,		E015_FLAG_RTH);
			packet[8] = 0;
			// checksum
			packet[9] = packet[0];
			for(uint8_t i=1; i<9; i++)
				packet[9] += packet[i];
			packet_length=E015_PACKET_SIZE;
		}
	}

	HS6200_RFChannel(rf_ch_num);
	HS6200_SetPower();
	delayMicroseconds(270);		// Wait for RF channel to settle
	HS6200_SendPayload(packet, packet_length);
}

static void __attribute__((unused)) E01X_RF_init()
{
	HS6200_Init(true);	// CRC enabled

	if(sub_protocol==E012)
		HS6200_SetTXAddr((uint8_t *)"\x55\x42\x9C\x8F\xC9", E01X_ADDRESS_LENGTH);
	else //E015
		HS6200_SetTXAddr((uint8_t *)"\x62\x54\x79\x38\x53", E01X_ADDRESS_LENGTH);
}

uint16_t E01X_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			HS6200_SetTXAddr(rx_tx_addr,  E01X_ADDRESS_LENGTH);
			BIND_DONE;
		}
	}
	E01X_send_packet();
	return packet_period;
}

static void __attribute__((unused)) E012_initialize_txid()
{
    // rf channels
    uint32_t lfsr=random(0xfefefefe);
    for(uint8_t i=0; i<E012_NUM_RF_CHANNELS; i++)
    {
		hopping_frequency[i] = 0x10 + ((lfsr & 0xff) % 0x32); 
		lfsr>>=8;
	}
}

void E01X_init()
{
	BIND_IN_PROGRESS;
	if(sub_protocol==E012)
	{
		E012_initialize_txid();
		packet_period=E012_PACKET_PERIOD;
	}
	else //E015
	{
		#ifdef E015_FORCE_ID
			rx_tx_addr[0] = 0x06;
			rx_tx_addr[1] = 0xC6;
			rx_tx_addr[2] = 0xB7;
			rx_tx_addr[3] = 0x56;
			rx_tx_addr[4] = 0x8A;
		#endif

		//force the sum to give 0x63 since the id calculation is unknown
		uint8_t sum=0x63;
		for(uint8_t i=0; i < 4; i++)
			sum -= rx_tx_addr[i];
		rx_tx_addr[4] = sum;

		packet_period=E015_PACKET_PERIOD;
		armed = 0;
		arm_flags = 0;
		arm_channel_previous = E01X_ARM_SW;
	}
	E01X_RF_init();
	bind_counter = E01X_BIND_COUNT;
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/E129_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(E129_CYRF6936_INO)

#include "iface_rf2500.h"

//#define E129_FORCE_ID
//#define C186_FORCE_ID

#define E129_BIND_CH		0x2D	//45
#define E129_PAYLOAD_SIZE	16
#define C186_PAYLOAD_SIZE	19

static void __attribute__((unused)) E129_build_data_packet()
{
	//Build the packet
	memset(packet,0,packet_length);
	packet[ 0] = packet_length - 1;						// Packet length
	if(IS_BIND_IN_PROGRESS)
	{
		packet[ 1] = 0xA4;
		packet[ 2] = bit_reverse(rx_tx_addr[2]);
		packet[ 3] = bit_reverse(rx_tx_addr[3]);
		packet[ 4] = bit_reverse(rx_tx_addr[0]);
		packet[ 5] = bit_reverse(rx_tx_addr[1]);
		for(uint8_t i=0; i<4; i++)
			packet[6+i]=hopping_frequency[i]-2;
	}
	else
	{
		packet[ 1] = 0xA6;								// Set to A5 every few packets??

		//Flags
		if(sub_protocol == E129_E129)
			packet[ 2] = 0xF7;							// High rate 0xF7, low 0xF4
		else //C186
		{
			packet[ 2] = 0xFA;							// High rate 0xFA, medium 0xF7, low 0xF4
			packet[13] = bit_reverse(rx_tx_addr[2]);
			packet[14] = bit_reverse(rx_tx_addr[3]);
			packet[15] = bit_reverse(rx_tx_addr[0]);
			packet[16] = bit_reverse(rx_tx_addr[1]);
		}
		packet[ 3] = GET_FLAG(CH10_SW, 0x40)			// C159: loop flight 0x40
				   | GET_FLAG(CH11_SW, 0x08);			// C129V2: flip
		//Other flags seen in packet[3]
		//  Flag 0x04 is set on some helis (C159/C190)
		//  E129 Mode: short press=0x20->0x00->0x20->..., long press=0x10->0x30->0x10->... => C186 throttle trim is doing the same:up=short press and down=long press
		packet[ 4] = GET_FLAG(CH5_SW,  0x20)			// Take off/Land 0x20
				   | GET_FLAG(CH6_SW,  0x04)			// Emergency stop 0x04
				   | GET_FLAG(CH12_SW, 0x80);			// C190: debug mode->remote THR trim down sets 0x80
		//Other flags seen in packet[4]
		//  C190 remote LANDING sets 0x10
		//  C190 remote THR trim down sets 0x80

		//Channels and trims
		uint16_t val = convert_channel_10b(AILERON,false);
		uint8_t trim = convert_channel_8b(CH7) & 0xFC;
		packet[ 5] = trim | (val >>8);					// Trim (0x00..0x1F..0x3E) << 2 | channel >> 8
		packet[ 6] = val;								// channel (0x000...0x200...0x3FF)
		val = convert_channel_10b(ELEVATOR,false);
		trim = convert_channel_8b(CH8) & 0xFC;
		packet[ 7] = trim | (val >>8);					// Trim (0x00..0x1F..0x3E) << 2 | channel >> 8
		packet[ 8] = val;								// channel (0x000...0x200...0x3FF)
		if(packet_count>200)
			val = convert_channel_10b(THROTTLE,false);
		else
		{//Allow bind to complete with throttle not centered
			packet_count++;
			val=0x200;
		}
		packet[ 9] = (0x1F<<2) | (val >>8);				// Trim (0x00..0x1F..0x3E) << 2 | channel >> 8
		packet[10] = val;								// channel (0x000...0x200...0x3FF)
		val = convert_channel_10b(RUDDER,false);
		trim = convert_channel_8b(CH9) & 0xFC;
		packet[11] = trim | (val >>8);					// Trim (0x00..0x1F..0x3E) << 2 | channel >> 8
		packet[12] = val;								// channel (0x000...0x200...0x3FF)
	}
	//Check
	for(uint8_t i=0;i<packet_length-2;i++)
		packet[packet_length-2] += packet[i];
	if(sub_protocol == E129_C186)
		packet[packet_length-2] -= 0x80;

	RF2500_BuildPayload(packet);
}

uint16_t E129_callback()
{
	//Set RF channel
	if(phase==0)
		RF2500_RFChannel(IS_BIND_IN_PROGRESS ? E129_BIND_CH : hopping_frequency[hopping_frequency_no]);

	//Send packet
	RF2500_SendPayload();
	
	//E129 sends twice on same channel, not the C186 but there is a bug somewhere if I don't send the packets back to back
	if(phase==0)
	{
		phase++;
		return 1260;
	}

	//Bind
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			RF2500_SetTXAddr(rx_tx_addr);	// 4 bytes of address
		}

	//Build packet
	E129_build_data_packet();
	
	//Set power
	RF2500_SetPower();
	
	//Hopp
	hopping_frequency_no++;
	hopping_frequency_no &= 3;

	phase=0;
	if(sub_protocol==E129_E129)
		return 5200-1260;
	return 5500-1260;						//E129_C186
}

void E129_init()
{
	BIND_IN_PROGRESS;						// Autobind protocol
    bind_counter = 384;						// ~2sec

	//RF2500 emu init
	packet_length = sub_protocol == E129_E129?E129_PAYLOAD_SIZE:C186_PAYLOAD_SIZE;
	RF2500_Init(packet_length, true);		// 16/19 bytes, Scrambled
   
	//Freq hopping
	calc_fh_channels(4);
	for(uint8_t i=0; i<4; i++)
		if(hopping_frequency[i]==E129_BIND_CH)
			hopping_frequency[i]++;
	
    #ifdef E129_FORCE_ID
        rx_tx_addr[0]=0xC1;
        rx_tx_addr[1]=0x22;
        rx_tx_addr[2]=0x05;
        rx_tx_addr[3]=0xA3;
        hopping_frequency[0]=0x3C;			//60
        hopping_frequency[1]=0x49;			//73
        hopping_frequency[2]=0x4B;			//75
        hopping_frequency[3]=0x41;			//65
    #endif
    #ifdef C186_FORCE_ID
        rx_tx_addr[0]=0x91;
        rx_tx_addr[1]=0x02;
        rx_tx_addr[2]=0x5D;
        rx_tx_addr[3]=0x33;
        hopping_frequency[0]=0x44 + 2;
        hopping_frequency[1]=0x41 + 2;
        hopping_frequency[2]=0x43 + 2;
        hopping_frequency[3]=0x49 + 2;
    #endif

	RF2500_SetTXAddr((uint8_t*)"\xE2\x32\xE0\xC8");	// 4 bytes of bind address

	E129_build_data_packet();
	hopping_frequency_no=0;
	packet_count=0;
	phase=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
//  ESky protocol for small models since 2014 (150, 300, 150X, ...)

#if defined(ESKY150_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define ESKY150_PAYLOADSIZE 15
#define ESKY150_TX_ADDRESS_SIZE 4
#define ESKY150_BINDING_PACKET_PERIOD	2000
#define ESKY150_SENDING_PACKET_PERIOD	4800

static void __attribute__((unused)) ESKY150_RF_init()
{
	//Original TX always sets for channelx 0x22 and 0x4a
	// Use channels 2..79
	hopping_frequency[0] = rx_tx_addr[3]%37+2;
	hopping_frequency[1] = hopping_frequency[0] + 40;

	NRF24L01_Initialize();
	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x02);   // 4-byte RX/TX address
	NRF24L01_SetBitrate(NRF24L01_BR_2M);
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, ESKY150_PAYLOADSIZE);   // bytes of data payload for pipe 0
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, ESKY150_TX_ADDRESS_SIZE);

	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 1); // Dynamic payload for data pipe 0
	// Enable: Dynamic Payload Length, Payload with ACK , W_TX_PAYLOAD_NOACK
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, _BV(NRF2401_1D_EN_DPL) | _BV(NRF2401_1D_EN_ACK_PAY) | _BV(NRF2401_1D_EN_DYN_ACK));

	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}

static void __attribute__((unused)) ESKY150_bind_init()
{
	uint8_t ESKY150_addr[ESKY150_TX_ADDRESS_SIZE] = { 0x73, 0x73, 0x74, 0x63 }; //This RX address "sstc" is fixed for ESky2

	// Build packet
	packet[0]  = rx_tx_addr[0];
	packet[1]  = rx_tx_addr[1];
	packet[2]  = rx_tx_addr[2];
	packet[3]  = rx_tx_addr[3]; 
	packet[4]  = ESKY150_addr[0];
	packet[5]  = ESKY150_addr[1];
	packet[6]  = ESKY150_addr[2];
	packet[7]  = ESKY150_addr[3];
	packet[8]  = rx_tx_addr[0];
	packet[9]  = rx_tx_addr[1];
	packet[10] = rx_tx_addr[2];
	packet[11] = rx_tx_addr[3]; 
	packet[12] = 0;
	packet[13] = 0;
	packet[14] = 0;

	// Bind address
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, ESKY150_addr, ESKY150_TX_ADDRESS_SIZE);
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, ESKY150_addr, ESKY150_TX_ADDRESS_SIZE);
	
	// Bind Channel 1
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 1);
}

static void __attribute__((unused)) ESKY150_send_packet()
{
	// Build packet
	uint16_t throttle=convert_channel_16b_limit(THROTTLE,1000,2000);
	uint16_t aileron=convert_channel_16b_limit(AILERON,1000,2000);
	uint16_t elevator=convert_channel_16b_limit(ELEVATOR,1000,2000);
	uint16_t rudder=convert_channel_16b_limit(RUDDER,1000,2000);
	//set unused channels to zero, for compatibility with older 4 channel models
	uint8_t flight_mode=0;
	uint16_t aux_ch6=0;
	uint8_t aux_ch7=0;
	if(sub_protocol)
	{ // 7 channels
		flight_mode=ESKY150_convert_2bit_channel(CH5);
		aux_ch6=convert_channel_16b_limit(CH6,1000,2000);
		aux_ch7=ESKY150_convert_2bit_channel(CH7);
	}
	packet[0]  = hopping_frequency[0];
	packet[1]  = hopping_frequency[1];
	packet[2]  = ((flight_mode << 6) & 0xC0) | ((aux_ch7 << 4) & 0x30) | ((throttle >> 8) & 0xFF);
	packet[3]  = throttle & 0xFF;
	packet[4]  = ((aux_ch6 >> 4) & 0xF0) | ((aileron >> 8) & 0xFF); //and 0xFF works as values are anyways not bigger than 12 bits, but faster code like that
	packet[5]  = aileron  & 0xFF;
	packet[6]  = (aux_ch6 & 0xF0) | ((elevator >> 8) & 0xFF); //and 0xFF works as values are anyways not bigger than 12 bits, but faster code like that
	packet[7]  = elevator & 0xFF;
	packet[8]  = ((aux_ch6 << 4) & 0xF0) | ((rudder >> 8) & 0xFF); //and 0xFF works as values are anyways not bigger than 12 bits, but faster code like that
	packet[9]  = rudder & 0xFF;
	// The next 4 Bytes are sint8 trim values (TAER). As trims are already included within normal outputs, these values are set to zero.
	packet[10] = 0x00;
	packet[11] = 0x00;
	packet[12] = 0x00;
	packet[13] = 0x00;
	// Calculate checksum:
	uint8_t sum = 0;
	for (uint8_t i = 0; i < 14; ++i)
		sum += packet[i];
	packet[14] = sum;

	// Hop on 2 channels
	hopping_frequency_no++;
	hopping_frequency_no&=0x01;
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);

	// Clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_FlushTx();

	// Send packet
	NRF24L01_WritePayload(packet, ESKY150_PAYLOADSIZE);

	//Keep transmit power updated
	NRF24L01_SetPower();
}

uint8_t ESKY150_convert_2bit_channel(uint8_t num)
{
	if(Channel_data[num] > CHANNEL_MAX_COMMAND)
		return 0x03;
	else
		if(Channel_data[num] < CHANNEL_MIN_COMMAND)
			return 0x00;
		else
			if(Channel_data[num] > CHANNEL_SWITCH)
				return 0x02;
	return 0x01;	
}

uint16_t ESKY150_callback()
{
	if(IS_BIND_DONE)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(ESKY150_SENDING_PACKET_PERIOD);
		#endif
		ESKY150_send_packet();
	}
	else
	{
		NRF24L01_WritePayload(packet, ESKY150_PAYLOADSIZE);
		if (--bind_counter == 0)
		{
			BIND_DONE;
			// Change TX address from bind to normal mode
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, ESKY150_TX_ADDRESS_SIZE);
		}
		return ESKY150_BINDING_PACKET_PERIOD;
	}
	return ESKY150_SENDING_PACKET_PERIOD;
}

void ESKY150_init(void)
{
	ESKY150_RF_init();
	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter=3000;
		ESKY150_bind_init();
	}
	hopping_frequency_no=0;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky150v2_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(ESKY150V2_CC2500_INO)

#include "iface_nrf250k.h"

//#define ESKY150V2_FORCE_ID

#define ESKY150V2_PAYLOADSIZE 40
#define ESKY150V2_BINDPAYLOADSIZE 150
#define ESKY150V2_NFREQCHANNELS 70
#define ESKY150V2_TXID_SIZE 4
#define ESKY150V2_BIND_CHANNEL 0x00
#define ESKY150V2_PACKET_PERIOD 10000
#define ESKY150V2_BINDING_PACKET_PERIOD 57000

#ifdef ESKY150V2_FORCE_ID
const uint8_t PROGMEM ESKY150V2_hop[ESKY150V2_NFREQCHANNELS]= {
	0x07, 0x47, 0x09, 0x27, 0x0B, 0x42, 0x0D, 0x35, 0x17, 0x40, 0x26, 0x3D, 0x16, 0x43, 0x06, 0x2A, 0x24, 0x44,
	0x0E, 0x38, 0x20, 0x48, 0x22, 0x2D, 0x2B, 0x39, 0x0F, 0x36, 0x23, 0x46, 0x14, 0x3B, 0x1A, 0x41, 0x10, 0x2E,
	0x1E, 0x28, 0x0C, 0x49, 0x1D, 0x3E, 0x29, 0x2C, 0x25, 0x30, 0x1C, 0x2F, 0x1B, 0x33, 0x13, 0x31, 0x0A, 0x37,
	0x12, 0x3C, 0x18, 0x4B, 0x11, 0x45, 0x21, 0x4A, 0x1F, 0x3F, 0x15, 0x32, 0x08, 0x3A, 0x19, 0x34 };
/*const uint8_t PROGMEM ESKY150V2_hop2[40]= {
	0x19, 0x23, 0x13, 0x1B, 0x09, 0x22, 0x14, 0x27, 0x06, 0x26, 0x16, 0x24, 0x0B, 0x2A, 0x0E, 0x1C, 0x11, 0x1E,
	0x08, 0x29, 0x0D, 0x28, 0x18, 0x2D, 0x12, 0x20, 0x0C, 0x1A, 0x10, 0x1D, 0x07, 0x2C, 0x0A, 0x2B, 0x0F, 0x25,
	0x15, 0x1F, 0x17, 0x21 };*/
#endif

static void __attribute__((unused)) ESKY150V2_set_freq(void)
{
	calc_fh_channels(ESKY150V2_NFREQCHANNELS);
	
	#ifdef ESKY150V2_FORCE_ID
		for(uint8_t i=0; i<ESKY150V2_NFREQCHANNELS; i++)
			hopping_frequency[i]=pgm_read_byte_near( &ESKY150V2_hop[i] );
	#endif
	
	//Bind channel
	hopping_frequency[ESKY150V2_NFREQCHANNELS]=ESKY150V2_BIND_CHANNEL;
	
	//Calib all channels
	CC2500_SetFreqOffset();	// Set frequency offset
	CC2500_250K_HoppingCalib(ESKY150V2_NFREQCHANNELS+1);
}

static void __attribute__((unused)) ESKY150V2_send_packet()
{
	CC2500_SetFreqOffset();	// Set frequency offset
	CC2500_250K_Hopping(hopping_frequency_no);
	if (++hopping_frequency_no >= ESKY150V2_NFREQCHANNELS)
		hopping_frequency_no = 0;
	CC2500_SetPower();			//Set power level

	packet[0] = 0xFA;		// Unknown
	packet[1] = 0x41;		// Unknown
	packet[2] = 0x08;		// Unknown
	packet[3] = 0x00;		// Unknown
	for(uint8_t i=0;i<16;i++)
	{
		uint16_t channel=convert_channel_16b_limit(CH_TAER[i],200,1000);
		packet[4+2*i] = channel;
		packet[5+2*i] = channel>>8;
	}
	NRF250K_WritePayload(packet, ESKY150V2_PAYLOADSIZE);
}

uint16_t ESKY150V2_callback()
{
	if(IS_BIND_DONE)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(ESKY150V2_PACKET_PERIOD);
		#endif
		ESKY150V2_send_packet();
	}
	else
	{
		BIND_DONE;					//Need full power for bind to work...
		CC2500_SetPower();			//Set power level
		BIND_IN_PROGRESS;
		NRF250K_WritePayload(packet, ESKY150V2_BINDPAYLOADSIZE);
		if (--bind_counter == 0)
		{
			BIND_DONE;
			// Change TX address from bind to normal mode
			NRF250K_SetTXAddr(rx_tx_addr, ESKY150V2_TXID_SIZE);
			memset(packet,0x00,ESKY150V2_PAYLOADSIZE);
		}
		return 30000; //ESKY150V2_BINDING_PACKET_PERIOD;
	}
	return ESKY150V2_PACKET_PERIOD;
}

void ESKY150V2_init()
{
	CC2500_250K_Init();
	ESKY150V2_set_freq();
	hopping_frequency_no = 0;

	#ifdef ESKY150V2_FORCE_ID	// ID taken from TX dump
		rx_tx_addr[0]=0x87;rx_tx_addr[1]=0x5B;rx_tx_addr[2]=0x2C;rx_tx_addr[3]=0x5D;
	#endif

	memset(packet,0x00,ESKY150V2_BINDPAYLOADSIZE);

	if(IS_BIND_IN_PROGRESS)
	{
		NRF250K_SetTXAddr((uint8_t *)"\x73\x73\x74\x63", ESKY150V2_TXID_SIZE);	//Bind address
		CC2500_250K_Hopping(ESKY150V2_NFREQCHANNELS);	//Bind channel
		memcpy(packet,"\x73\x73\x74\x63", ESKY150V2_TXID_SIZE);
		memcpy(&packet[ESKY150V2_TXID_SIZE],rx_tx_addr, ESKY150V2_TXID_SIZE);
		packet[8]=0x41;								//Unknown
		packet[9]=0x88;								//Unknown
		packet[10]=0x41;							//Unknown
		memset(&packet[11],0xAA,4);					//Unknown
		memcpy(&packet[15],hopping_frequency,ESKY150V2_NFREQCHANNELS);	// hop table
		//for(uint8_t i=0; i<40; i++)				// Does not seem to be needed
		//	packet[i+85]=pgm_read_byte_near( &ESKY150V2_hop2[i] );
		bind_counter=100;
	}
	else
		NRF250K_SetTXAddr(rx_tx_addr, ESKY150V2_TXID_SIZE);
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ESky_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/esky_nrf24l01.c dated 2015-02-13

#if defined(ESKY_NRF24L01_INO)

#include "iface_nrf24l01.h"

//#define ESKY_ET4_FORCE_ID

#define ESKY_BIND_COUNT		1000
#define ESKY_STD_PACKET_PERIOD	3333
#define ESKY_ET4_PACKET_PERIOD	1190
#define ESKY_ET4_TOTAL_PACKET_PERIOD	20300
#define ESKY_ET4_BIND_PACKET_PERIOD	5000
#define ESKY_PAYLOAD_SIZE	13
#define ESKY_PACKET_CHKTIME	100 // Time to wait for packet to be sent (no ACK, so very short)

static void __attribute__((unused)) ESKY_set_data_address()
{
	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x02);     // 4-byte RX/TX address for regular packets
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, 4);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    rx_tx_addr, 4);
}

static void __attribute__((unused)) ESKY_RF_init()
{
	NRF24L01_Initialize();

	if (IS_BIND_IN_PROGRESS)
	{
		NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x01);     // 3-byte RX/TX address for bind packets
		NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t*)"\x00\x00\x00", 3);
		NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t*)"\x00\x00\x00", 3);
	}
	else
		ESKY_set_data_address();
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 50);              // Channel 50 for bind packets
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, ESKY_PAYLOAD_SIZE);  // bytes of data payload for pipe 0
	NRF24L01_WriteReg(NRF24L01_12_RX_PW_P1, ESKY_PAYLOAD_SIZE);
	NRF24L01_WriteReg(NRF24L01_13_RX_PW_P2, ESKY_PAYLOAD_SIZE);
	NRF24L01_WriteReg(NRF24L01_14_RX_PW_P3, ESKY_PAYLOAD_SIZE);
	NRF24L01_WriteReg(NRF24L01_15_RX_PW_P4, ESKY_PAYLOAD_SIZE);
	NRF24L01_WriteReg(NRF24L01_16_RX_PW_P5, ESKY_PAYLOAD_SIZE);
	NRF24L01_WriteReg(NRF24L01_17_FIFO_STATUS, 0x00);      // Just in case, no real bits to write here
}

static void __attribute__((unused)) ESKY_TXID_init()
{
	NRF24L01_FlushTx();
	if(sub_protocol==ESKY_STD)
	{
		uint16_t channel_ord = rx_tx_addr[0] % 74;
		hopping_frequency[12] = 10 + (uint8_t)channel_ord;	//channel_code
		uint8_t channel1, channel2;
		channel1 = 10 + (uint8_t)((37 + channel_ord*5) % 74);
		channel2 = 10 + (uint8_t)((     channel_ord*5) % 74) ;

		hopping_frequency[0] = channel1;
		hopping_frequency[1] = channel1;
		hopping_frequency[2] = channel1;
		hopping_frequency[3] = channel2;
		hopping_frequency[4] = channel2;
		hopping_frequency[5] = channel2;

		//end_bytes
		hopping_frequency[6] = 6;
		hopping_frequency[7] = channel1*2;
		hopping_frequency[8] = channel2*2;
		hopping_frequency[9] = 6;
		hopping_frequency[10] = channel1*2;
		hopping_frequency[11] = channel2*2;
	}
	else
	{ // ESKY_ET4
		hopping_frequency[0]  = 0x29;	//41
		hopping_frequency[1]  = 0x12;	//18
		hopping_frequency[6]  = 0x87;	//135 payload end byte
		hopping_frequency[12] = 0x84;	//132 indicates which channels to use
	}
		
	// Turn radio power on
	NRF24L01_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) ESKY_send_packet(uint8_t bind)
{
	uint8_t rf_ch = 50; // bind channel
	if (bind)
	{
		// Bind packet
		packet[0]  = rx_tx_addr[2];
		packet[1]  = rx_tx_addr[1];
		packet[2]  = rx_tx_addr[0];
		packet[3]  = hopping_frequency[12]; // channel_code encodes pair of channels to transmit on
		packet[4]  = 0x18;
		packet[5]  = 0x29;
		packet[6]  = 0;
		packet[7]  = 0;
		packet[8]  = 0;
		packet[9]  = 0;
		packet[10] = 0;
		packet[11] = 0;
		packet[12] = 0;
	}
	else
	{
		if (packet_count == 0)
			for (uint8_t i = 0; i < 6; i++)
			{
				uint16_t val=convert_channel_ppm(CH_AETR[i]);
				packet[i*2]   = val>>8;		//high byte of servo timing(1000-2000us)
				packet[i*2+1] = val&0xFF;	//low byte of servo timing(1000-2000us)
			}
		if(sub_protocol==ESKY_STD)
		{
			// Regular packet
			// Each data packet is repeated 3 times on one channel, and 3 times on another channel
			// For arithmetic simplicity, channels are repeated in rf_channels array
			rf_ch = hopping_frequency[packet_count];
			packet[12] = hopping_frequency[packet_count+6];	// end_bytes
			packet_count++;
			if (packet_count > 6) packet_count = 0;
		}
		else
		{ // ESKY_ET4
			// Regular packet
			// Each data packet is repeated 14 times alternating between 2 channels
			rf_ch = hopping_frequency[packet_count&1];
			packet_count++;
			if(packet_count>14) packet_count=0;
			packet[12] = hopping_frequency[6];	// end_byte
		}
	}
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch);
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, ESKY_PAYLOAD_SIZE);
	NRF24L01_SetPower();	//Keep transmit power updated
}

uint16_t ESKY_callback()
{
	if(IS_BIND_DONE)
	{
		#ifdef MULTI_SYNC
			if(packet_count==0)
				telemetry_set_input_sync(sub_protocol==ESKY_STD?ESKY_STD_PACKET_PERIOD*6:ESKY_ET4_TOTAL_PACKET_PERIOD);
		#endif
		ESKY_send_packet(0);
		if(sub_protocol==ESKY_ET4)
		{
			if(packet_count==0)
				return ESKY_ET4_TOTAL_PACKET_PERIOD-ESKY_ET4_PACKET_PERIOD*13;
			else
				return ESKY_ET4_PACKET_PERIOD;
		}
	}
	else
	{
		ESKY_send_packet(1);
		if (--bind_counter == 0)
		{
			ESKY_set_data_address();
			BIND_DONE;
		}
	}
	return ESKY_STD_PACKET_PERIOD;
}

void ESKY_init(void)
{
	bind_counter = ESKY_BIND_COUNT;
	rx_tx_addr[2] = rx_tx_addr[3];	// Model match
	#ifdef ESKY_ET4_FORCE_ID
	  if(sub_protocol==ESKY_ET4)
	  {
		  rx_tx_addr[0]=0x72;
		  rx_tx_addr[1]=0xBB;
		  rx_tx_addr[2]=0xCC;
	  }
	#endif
	rx_tx_addr[3] = 0xBB;
	ESKY_RF_init();
	ESKY_TXID_init();
	packet_count=0;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/EazyRC_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(EAZYRC_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_EAZYRC_ORIGINAL_ID

#define EAZYRC_PAYLOAD_SIZE			10
#define EAZYRC_RF_NUM_CHANNELS		4
#define EAZYRC_BIND_CHANNEL			18
#define EAZYRC_PACKET_PERIOD		5000

enum {
	EAZYRC_BINDTX=0,
	EAZYRC_BINDRX,
	EAZYRC_DATA,
};

static void __attribute__((unused)) EAZYRC_send_packet()
{
	//Bind:
	// TX:    C=18 S=Y A= AA BB CC DD EE P(10)= 1A A0 01 00 00 00 1E 00 78 51
	//   packet[0..2]=tx_addr, packet[6]=first rf channel, packet[8]=unk, packet[9]=sum(packet[0..8])
	// RX:    C=18 S=Y A= AA BB CC DD EE P(10)= 41 AD 01 1A A0 01 1E 00 87 4F
	//   packet[0..2]=rx_addr, packet[3..5]=tx_addr, packet[6]=first rf channel, packet[8]=unk but swapped, packet[9]=sum(packet[0..8])
	//Normal: C=30 S=Y A= 1A A0 41 AD 02 P(10)= 7F 7F 1F 19 00 00 1E 00 AB FF
	//   packet[0]=THR, packet[1]=ST, packet[2]=unk, packet[3]=unk, packet[6]=first rf channel, packet[8]=unk, packet[9]=sum(packet[0..8])
	//Bound : C=18 S=Y A= AA BB CC DD EE P(10)= 1A A0 01 41 AD 01 1E 00 79 41
	//   packet[0..2]=tx_addr, packet[3..5]=rx_addr, packet[6]=first rf channel, packet[8]=unk, packet[9]=sum(packet[0..8])
	//   sent every 12 packets in normal mode, but is it really needed if the car loose power then you need to rebind...
	//Packet period around 5ms with a large jitter

	memset(&packet[3], 0x00, 7);
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(&packet,rx_tx_addr,3);
		packet[6] = hopping_frequency[0];
		packet[8] = 0x78;						//??? packet type?
	}
	else
	{
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no &= 3;
		
		packet[0] = convert_channel_8b(THROTTLE);
		packet[1] = convert_channel_8b(AILERON);
		packet[2] = 0x1F;						//??? additional channel?
		packet[3] = 0x19;						//??? additional channel?
		packet[6] = hopping_frequency[0];
		packet[8] = 0xAB;						//??? packet type?
	}
	for(uint8_t i=0;i<EAZYRC_PAYLOAD_SIZE-1;i++)
		packet[9] += packet[i];
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, EAZYRC_PAYLOAD_SIZE);
	#ifdef DEBUG_SERIAL
		for(uint8_t i=0; i < len; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) EAZYRC_initialize_txid()
{
	rx_tx_addr[1] = rx_tx_addr[3];
	hopping_frequency[0] = (rx_tx_addr[3]%20) + 0x1E;		// Wild guess... First channel between 30 and 49so a full range of 30 to 79
	#ifdef FORCE_EAZYRC_ORIGINAL_ID
		rx_tx_addr[0] = 0x1A;
		rx_tx_addr[1] = 0xA0;
		rx_tx_addr[2] = 0x01;
		hopping_frequency[0] = 0x1E;
	#endif
	rx_tx_addr[2] = 0x01;									// Not sure if this is needed...
	for(uint8_t i=1; i<EAZYRC_RF_NUM_CHANNELS; i++)
		hopping_frequency[i] = hopping_frequency[0] + 10*i;
}

static void __attribute__((unused)) EAZYRC_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"\xAA\xBB\xCC\xDD\xEE", 5);
	XN297_SetRXAddr((uint8_t*)"\xAA\xBB\xCC\xDD\xEE", EAZYRC_PAYLOAD_SIZE);
	XN297_RFChannel(EAZYRC_BIND_CHANNEL);
}

uint16_t EAZYRC_callback()
{
	uint8_t rf,n;
	uint16_t addr;
	switch(phase)
	{
		case EAZYRC_BINDTX:
			if(XN297_IsRX())
			{
				//Example:	TX: C=18 S=Y A= AA BB CC DD EE P(10)= 1A A0 01 00 00 00 1E 00 78 51
				// packet[0..2]=tx_addr, packet[6]=first rf channel, packet[8]=unk, packet[9]=sum(packet[0..8])
				//			RX: C=18 S=Y A= AA BB CC DD EE P(10)= 41 AD 01 1A A0 01 1E 00 87 4F
				// packet[0..2]=rx_addr, packet[3..5]=tx_addr, packet[6]=first rf channel, packet[8]=unk but swapped, packet[9]=sum(packet[0..8])
				XN297_ReadPayload(packet_in, EAZYRC_PAYLOAD_SIZE);
				#ifdef DEBUG_SERIAL
					for(uint8_t i=0; i < EAZYRC_PAYLOAD_SIZE; i++)
						debug("%02X ", packet_in[i]);
					debugln();
				#endif
				//could check the validity of the packet by looking at the sum...
				if(memcmp(&packet_in[3],&rx_tx_addr,3)==0)
				{//TX ID match, TX addr to use: 1A A0 41 AD 02
					rx_tx_addr[4] = rx_tx_addr[2] + packet_in[2];	//wild guess
					rx_tx_addr[2] = packet_in[0];
					rx_tx_addr[3] = packet_in[1];
					BIND_DONE;
					XN297_SetTxRxMode(TXRX_OFF);
					XN297_SetTXAddr(rx_tx_addr, 5);
					phase = EAZYRC_DATA;
					return 5000;
				}
			}
			XN297_SetTxRxMode(TXRX_OFF);
			EAZYRC_send_packet();
			phase++;
			return 1000;
		case EAZYRC_BINDRX:
			//Wait for the packet transmission to finish
			while(XN297_IsPacketSent()==false);
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = EAZYRC_BINDTX;
			return 10000;
		case EAZYRC_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(EAZYRC_PACKET_PERIOD);
			#endif
			EAZYRC_send_packet();
			break;
	}
	return EAZYRC_PACKET_PERIOD;
}

void EAZYRC_init()
{
	BIND_IN_PROGRESS;
	EAZYRC_initialize_txid();
	EAZYRC_RF_init();
	phase = EAZYRC_BINDTX;
	packet_count = 0;
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FQ777_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with bikemike FQ777-124.ino

#if defined(FQ777_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define FQ777_INITIAL_WAIT		500
#define FQ777_PACKET_PERIOD		2000
#define FQ777_PACKET_SIZE		8
#define FQ777_BIND_COUNT		1000
#define FQ777_NUM_RF_CHANNELS	4

enum {
	FQ777_FLAG_RETURN     = 0x40,  // 0x40 when not off, !0x40 when one key return
	FQ777_FLAG_HEADLESS   = 0x04,
	FQ777_FLAG_EXPERT     = 0x01,
	FQ777_FLAG_FLIP       = 0x80,
};

const uint8_t ssv_xor[] = {0x80,0x44,0x64,0x75,0x6C,0x71,0x2A,0x36,0x7C,0xF1,0x6E,0x52,0x9,0x9D,0x1F,0x78,0x3F,0xE1,0xEE,0x16,0x6D,0xE8,0x73,0x9,0x15,0xD7,0x92,0xE7,0x3,0xBA};
uint8_t FQ777_bind_addr []   = {0xe7,0xe7,0xe7,0xe7,0x67};

static void __attribute__((unused)) ssv_pack_dpl(uint8_t addr[], uint8_t pid, uint8_t* len, uint8_t* payload, uint8_t* packed_payload)
{
	uint8_t i = 0;

	uint16_t pcf = (*len & 0x3f) << 3;
	pcf |= (pid & 0x3) << 1;
	pcf |= 0x00; // noack field
	
	uint8_t header[7] = {0};
	header[6] = pcf;
	header[5] = (pcf >> 7) | (addr[0] << 1);
	header[4] = (addr[0] >> 7) | (addr[1] << 1);
	header[3] = (addr[1] >> 7) | (addr[2] << 1);
	header[2] = (addr[2] >> 7) | (addr[3] << 1);
	header[1] = (addr[3] >> 7) | (addr[4] << 1);
	header[0] = (addr[4] >> 7);

	// calculate the crc
	crc=0x3c18;
	for (i = 0; i < 7; ++i)
		crc16_update(header[i],8);
	for (i = 0; i < *len; ++i)
		crc16_update(payload[i],8);

	// encode payload and crc
	// xor with this:
	for (i = 0; i < *len; ++i)
		payload[i] ^= ssv_xor[i];
	crc ^= ssv_xor[i++]<<8;
	crc ^= ssv_xor[i++];

	// pack the pcf, payload, and crc into packed_payload
	packed_payload[0] = pcf >> 1;
	packed_payload[1] = (pcf << 7) | (payload[0] >> 1);
	
	for (i = 0; i < *len - 1; ++i)
		packed_payload[i+2] = (payload[i] << 7) | (payload[i+1] >> 1);

	packed_payload[i+2] = (payload[i] << 7) | (crc >> 9);
	++i;
	packed_payload[i+2] = (crc >> 1 & 0x80 ) | (crc >> 1 & 0x7F);
	++i;
	packed_payload[i+2] = (crc << 7);

	*len += 4;
}

static void __attribute__((unused)) FQ777_send_packet()
{
	uint8_t packet_len = FQ777_PACKET_SIZE;
	uint8_t packet_ori[8];
	if (IS_BIND_IN_PROGRESS)
	{
		// 4,5,6 = address fields
		// last field is checksum of address fields
		packet_ori[0] = 0x20;
		packet_ori[1] = 0x15;
		packet_ori[2] = 0x05;
		packet_ori[3] = 0x06;
		packet_ori[4] = rx_tx_addr[0];
		packet_ori[5] = rx_tx_addr[1];
		packet_ori[6] = rx_tx_addr[2];
		packet_ori[7] = packet_ori[4] + packet_ori[5] + packet_ori[6];
	}
	else
	{
		// throt, yaw, pitch, roll, trims, flags/left button,00,right button
		//0-3 0x00-0x64
		//4 roll/pitch/yaw trims. cycles through one trim at a time - 0-40 trim1, 40-80 trim2, 80-C0 trim3 (center:  A0 20 60)
		//5 flags for throttle button, two buttons above throttle - def: 0x40
		//6 00 ??
		//7 checksum - add values in other fields 

		
		// Trims are usually done through the radio configuration but leaving the code here just in case...
		uint8_t trim_mod  = packet_count % 144;
		uint8_t trim_val  = 0;
		if (36 <= trim_mod && trim_mod < 72) // yaw
			trim_val  = 0x20; // don't modify yaw trim
		else
			if (108 < trim_mod && trim_mod) // pitch
				trim_val = 0xA0;
			else // roll
				trim_val = 0x60;

		packet_ori[0] = convert_channel_16b_limit(THROTTLE,0,0x64);
		packet_ori[1] = convert_channel_16b_limit(RUDDER,0,0x64);
		packet_ori[2] = convert_channel_16b_limit(ELEVATOR,0,0x64);
		packet_ori[3] = convert_channel_16b_limit(AILERON,0,0x64);
		packet_ori[4] = trim_val; // calculated above
		packet_ori[5] = GET_FLAG(CH5_SW, FQ777_FLAG_FLIP)
				  | GET_FLAG(CH7_SW, FQ777_FLAG_HEADLESS)
				  | GET_FLAG(!CH6_SW, FQ777_FLAG_RETURN)
				  | GET_FLAG(CH8_SW,FQ777_FLAG_EXPERT);
		packet_ori[6] = 0x00;
		// calculate checksum
		uint8_t checksum = 0;
		for (int i = 0; i < 7; ++i)
			checksum += packet_ori[i];
		packet_ori[7] = checksum;

		packet_count++;
	}

	ssv_pack_dpl( IS_BIND_IN_PROGRESS ? FQ777_bind_addr : rx_tx_addr, hopping_frequency_no, &packet_len, packet_ori, packet);
	
	NRF24L01_WriteReg(NRF24L01_00_CONFIG,_BV(NRF24L01_00_PWR_UP));
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no++]);
	hopping_frequency_no %= FQ777_NUM_RF_CHANNELS;
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, packet_len);
	NRF24L01_WritePayload(packet, packet_len);
	NRF24L01_WritePayload(packet, packet_len);
}

static void __attribute__((unused)) FQ777_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, FQ777_bind_addr, 5);
	NRF24L01_SetBitrate(NRF24L01_BR_250K);
}

uint16_t FQ777_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(FQ777_PACKET_PERIOD);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);
			BIND_DONE;
		}
	}
	FQ777_send_packet();
	return FQ777_PACKET_PERIOD;
}

void FQ777_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
	bind_counter = FQ777_BIND_COUNT;
	packet_count=0;
	hopping_frequency[0] = 0x4D;
	hopping_frequency[1] = 0x43;
	hopping_frequency[2] = 0x27;
	hopping_frequency[3] = 0x07;
	hopping_frequency_no=0;
	rx_tx_addr[2] = 0x00;
	rx_tx_addr[3] = 0xe7;
	rx_tx_addr[4] = 0x67;
	FQ777_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FX_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with FEI XIONG P38 plane.

#if defined(FX_NRF24L01_INO)

#include "iface_xn297.h"

#define FX_BIND_COUNT				300		//3sec
#define FX_SWITCH					20
#define FX_NUM_CHANNELS				4

#define FX816_PACKET_PERIOD			10000
#define FX816_BIND_CHANNEL			40
#define FX816_PAYLOAD_SIZE			6
#define FX816_CH_OFFSET				3

#define FX620_PACKET_PERIOD 		3250
#define FX620_BIND_PACKET_PERIOD	4500
#define FX620_BIND_CHANNEL			18
#define FX620_PAYLOAD_SIZE			7
#define FX620_CH_OFFSET				1

#define FX9630_PACKET_PERIOD		8124	//8156 on QIDI-560
#define FX9630_BIND_CHANNEL			51
#define FX9630_PAYLOAD_SIZE			8
#define FX9630_NUM_CHANNELS			3
#define FX9630_WRITE_TIME			500

#define FX_QF012_PACKET_PERIOD		12194
#define FX_QF012_RX_PAYLOAD_SIZE	3

//#define FORCE_FX620_ID
//#define FORCE_FX9630_ID
//#define FORCE_QIDI_ID

enum 
{
	FX_DATA=0,
	FX_RX,
};

static void __attribute__((unused)) FX_send_packet()
{
	static uint8_t trim_ch = 0;

	//Hopp
	if(IS_BIND_DONE)
	{
		XN297_Hopping(hopping_frequency_no++);
		if(sub_protocol >= FX9630)
		{ // FX9630 & FX_Q560 & FX_QF012
			if (hopping_frequency_no >= FX9630_NUM_CHANNELS)
			{
				hopping_frequency_no = 0;
				if(sub_protocol == FX9630)
				{
					trim_ch++;
					trim_ch &= 3;
				}
				else // FX_Q560 & FX_QF012
					trim_ch = 0;
			}
		}
		else // FX816 & FX620
		{
			hopping_frequency_no &= 0x03;
		}
	}

	memset(packet,0x00,packet_length);

	//Channels
	uint8_t val;
	if (sub_protocol >= FX9630)
	{ // FX9630 & FX_Q560 & FX_QF012
		packet[0] = convert_channel_8b(THROTTLE);
		packet[1] = convert_channel_8b(AILERON);
		packet[2] = 0xFF - convert_channel_8b(ELEVATOR);
		packet[3] = convert_channel_8b(RUDDER);
		val = trim_ch==0 ? 0x20 : (convert_channel_8b(trim_ch + CH6) >> 2);	// no trim on Throttle
		packet[4] = val;			// Trim for channel x 0C..20..34
		packet[5] = (trim_ch << 4)	// channel x << 4
					| GET_FLAG(CH5_SW, (sub_protocol == FX_QF012 ? 0x08 : 0x01))  // DR toggle swich: 0 small throw, 1 large throw / Q560 acrobatic / QF012 Special effects
					// FX9630  =>0:6G small throw, 1:6G large throw, 2:3D
					// QIDI-550=>0:3D, 1:6G, 2:Torque
					// QF012=>0:beginner(6G), 1:mid(3D), 2:expert(Gyro off) 
					| (Channel_data[CH6] < CHANNEL_MIN_COMMAND ? 0x00 : (Channel_data[CH6] > CHANNEL_MAX_COMMAND ? 0x04 : 0x02));
		if(sub_protocol == FX_Q560)
			packet[5] |= GET_FLAG(CH7_SW, 0x18);	// Q560 LED flag 0x10 conflicting with trim_ch... Corrected on new boards using 0x08 instead
		else if (sub_protocol == FX_QF012) 
      			packet[5] |=  GET_FLAG(CH7_SW, 0x40)  // QF012 invert flight
                		    | GET_FLAG(CH8_SW, 0x80);  // QF012 Restore fine tunning midpoint
	}
	else // FX816 & FX620
	{
		uint8_t offset=sub_protocol == FX816 ? FX816_CH_OFFSET:FX620_CH_OFFSET;
		val=convert_channel_8b(AILERON);
		if(val>127+FX_SWITCH)
			packet[offset] = sub_protocol == FX816 ? 1:0xFF;
		else if(val<127-FX_SWITCH)
			packet[offset] = sub_protocol == FX816 ? 2:0x00;
		else
			packet[offset] = sub_protocol == FX816 ? 0:0x7F;
		packet[offset+1] = convert_channel_16b_limit(THROTTLE,0,100);	//FX816:0x00..0x63, FX620:0x00..0x5E but that should work
	}

	//Bind and specifics
	if(sub_protocol == FX816)
	{
		if(IS_BIND_IN_PROGRESS)
			packet[0] = 0x55;
		else
			packet[0] = 0xAA;
		packet[1] = rx_tx_addr[0];
		packet[2] = rx_tx_addr[1];
	}
	else if(sub_protocol == FX620)
	{
		if(IS_BIND_IN_PROGRESS)
		{
			memcpy(packet,rx_tx_addr,3);
			packet[3] = hopping_frequency[0];
			if(bind_counter > (FX_BIND_COUNT >> 1))
				packet[5] = 0x78;
		}
		else
		{
			packet[0] = 0x1F;	// Is it based on ID??
			packet[5] = 0xAB;	// Is it based on ID??
		}
	}
	else // FX9630 & FX_Q560 & FX_QF012
	{
		if(IS_BIND_IN_PROGRESS)
		{
			memcpy(packet,rx_tx_addr, 4);
			packet[4] = hopping_frequency[1];
			packet[5] = hopping_frequency[2];
			packet[7] = 0x55;
		}
	}

	//Check
	uint8_t last_packet_idx = packet_length-1;
	if (sub_protocol >= FX9630 && IS_BIND_IN_PROGRESS)
		last_packet_idx--;
	val=0;
	for(uint8_t i=0;i<last_packet_idx;i++)
		val+=packet[i];
	if (sub_protocol >= FX9630)
		val = val ^ 0xFF;
	packet[last_packet_idx]=val;

	//Debug
	#if 0
		for(uint8_t i=0;i<packet_length;i++)
			debug("%02X ",packet[i]);
		debugln("");
	#endif
	
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, packet_length);
}

static void __attribute__((unused)) FX_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	if(sub_protocol == FX816)
	{
		XN297_SetTXAddr((uint8_t *)"\xcc\xcc\xcc\xcc\xcc", 5);
		XN297_RFChannel(FX816_BIND_CHANNEL);
		packet_period = FX816_PACKET_PERIOD;
		packet_length = FX816_PAYLOAD_SIZE;
	}
	else if(sub_protocol == FX620)
	{
		XN297_SetTXAddr((uint8_t *)"\xaa\xbb\xcc", 3);
		XN297_RFChannel(FX620_BIND_CHANNEL);
		packet_period = FX620_BIND_PACKET_PERIOD;
		packet_length = FX620_PAYLOAD_SIZE;
	}
	else // FX9630 & FX_Q560 & FX_QF012
	{
		XN297_SetTXAddr((uint8_t *)"\x56\x78\x90\x12", 4);
		XN297_RFChannel(FX9630_BIND_CHANNEL);
		packet_period = sub_protocol == FX_QF012 ? FX_QF012_PACKET_PERIOD : FX9630_PACKET_PERIOD;
		packet_length = FX9630_PAYLOAD_SIZE;
	}
}

static void __attribute__((unused)) FX_initialize_txid()
{
	if(sub_protocol == FX816)
	{
		//Only 8 IDs: the RX led does not indicate frame loss.
		//I didn't open the plane to find out if I could connect there so this is the best I came up with with few trial and errors...
		rx_tx_addr[0]=0x35+(rx_tx_addr[3]&0x07);							//Original dump=0x35
		rx_tx_addr[1]=0x09;													//Original dump=0x09
		memcpy(hopping_frequency,"\x09\x1B\x30\x42",FX_NUM_CHANNELS);		//Original dump=9=0x09,27=0x1B,48=0x30,66=0x42
		for(uint8_t i=0;i<FX_NUM_CHANNELS;i++)
			hopping_frequency[i]+=rx_tx_addr[3]&0x07;
	}
	else if(sub_protocol == FX620)
	{
		rx_tx_addr[0] = rx_tx_addr[3];
		hopping_frequency[0] = 0x18 + rx_tx_addr[3]&0x07;	// just to try something
		#ifdef FORCE_FX620_ID
			memcpy(rx_tx_addr,(uint8_t*)"\x34\xA9\x32",3);
			hopping_frequency[0] = 0x18;	//on dump: 24 34 44 54
		#endif
		for(uint8_t i=1;i<FX_NUM_CHANNELS;i++)
			hopping_frequency[i] = i*10 + hopping_frequency[0];
	}
	else // FX9630 & FX_Q560 & FX_QF012
	{
		//??? Need to find out how the first RF channel is calculated ???
		hopping_frequency[0] = 0x13;
		//Other 2 RF channels are sent during the bind phase so they can be whatever
		hopping_frequency[1] = RX_num & 0x0F + 0x1A;
		hopping_frequency[2] = rx_tx_addr[3] & 0x0F + 0x38;
		#ifdef FORCE_FX9630_ID
			memcpy(rx_tx_addr,(uint8_t*)"\xCE\x31\x9B\x73", 4);
			memcpy(hopping_frequency,"\x13\x1A\x38", FX9630_NUM_CHANNELS);		//Original dump=>19=0x13,26=0x1A,56=0x38
		#endif
		#ifdef FORCE_QIDI_ID
			memcpy(rx_tx_addr,(uint8_t*)"\x23\xDC\x76\xA2", 4);
			memcpy(hopping_frequency,"\x08\x25\x33", FX9630_NUM_CHANNELS);		//Original dump=>08=0x08,37=0x25,51=0x33

			//QIDI-560 #1
			//memcpy(rx_tx_addr,(uint8_t*)"\x38\xC7\x6D\x8D", 4);
			//memcpy(hopping_frequency,"\x0D\x20\x3A", FX9630_NUM_CHANNELS);
		#endif
	}
}

uint16_t FX_callback()
{
	#ifdef FX_HUB_TELEMETRY
		bool rx=false;
		
		switch(phase)
		{
			case FX_DATA:
				rx = XN297_IsRX();
				XN297_SetTxRxMode(TXRX_OFF);
	#endif
				#ifdef MULTI_SYNC
					telemetry_set_input_sync(packet_period);
				#endif
				if(bind_counter)
					if(--bind_counter==0)
					{
						BIND_DONE;
						if(sub_protocol == FX620)
						{
							XN297_SetTXAddr(rx_tx_addr, 3);
							packet_period = FX620_PACKET_PERIOD;
						}
						else if(sub_protocol >= FX9630)
						{ // FX9630 & FX_Q560 & FX_QF012
							XN297_SetTXAddr(rx_tx_addr, 4);
	#ifdef FX_HUB_TELEMETRY
							XN297_SetRXAddr(rx_tx_addr, FX_QF012_RX_PAYLOAD_SIZE);
	#endif
						}
					}
				FX_send_packet();
	#ifdef FX_HUB_TELEMETRY
				if(sub_protocol < FX9630)
					break;
				if(rx)
				{
					debug("RX");
					if(XN297_ReadPayload(packet_in, FX_QF012_RX_PAYLOAD_SIZE))
					{//Good CRC
						//packets: A5 00 11 -> A5 01 11
						telemetry_link = 1;
						v_lipo1 = packet_in[1] ? 60:81;		// low voltage 3.7V
						#if 0
							for(uint8_t i=0; i < FX_QF012_RX_PAYLOAD_SIZE; i++)
								debug(" %02X", packet_in[i]);
						#endif
					}
					debugln();
				}
				phase++;
				return FX9630_WRITE_TIME;
			default: //FX_RX
				/* { // Wait for packet to be sent before switching to receive mode
					uint16_t start=(uint16_t)micros(), count=0;
					while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
					{
						if(XN297_IsPacketSent())
							break;
						count++;
					}
					debug("%d",count);
				} */
				//Switch to RX
				XN297_SetTxRxMode(TXRX_OFF);
				XN297_SetTxRxMode(RX_EN);
				phase = FX_DATA;
				return packet_period - FX9630_WRITE_TIME;
		}
	#endif
	return packet_period;
}

void FX_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	FX_initialize_txid();
	FX_RF_init();
	hopping_frequency_no = 0;
	bind_counter=FX_BIND_COUNT;
	#ifdef FX_HUB_TELEMETRY
		RX_RSSI = 100;		// Dummy value
		phase = FX_DATA;
	#endif
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FY326_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/fy326_nrf24l01.c dated 2015-07-29

#if defined(FY326_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define FY326_INITIAL_WAIT		500
#define FY326_PACKET_PERIOD		1500
#define FY326_PACKET_CHKTIME	300
#define FY326_PACKET_SIZE		15
#define FY326_BIND_COUNT		16
#define FY326_RF_BIND_CHANNEL	0x17
#define FY326_NUM_RF_CHANNELS	5

enum {
    FY326_BIND1=0,
    FY326_BIND2,
    FY326_DATA,
    FY319_BIND1,
    FY319_BIND2,
};

#define rxid channel

#define CHAN_TO_TRIM(chanval) ((chanval/10)-10)
static void __attribute__((unused)) FY326_send_packet(uint8_t bind)
{
	packet[0] = rx_tx_addr[3];
	if(bind)
		packet[1] = 0x55;
	else
		packet[1] =	  GET_FLAG(CH7_SW,	0x80)	// Headless
					| GET_FLAG(CH6_SW,	0x40)	// RTH
					| GET_FLAG(CH5_SW,	0x02)	// Flip
					| GET_FLAG(CH9_SW,	0x01)	// Calibrate
					| GET_FLAG(CH8_SW,	0x04);	// Expert
	packet[2]  = convert_channel_16b_limit(AILERON, 0, 200);	// aileron
	packet[3]  = convert_channel_16b_limit(ELEVATOR, 0, 200);		// elevator
	packet[4]  = convert_channel_16b_limit(RUDDER, 0, 200);	// rudder
	packet[5]  = convert_channel_16b_limit(THROTTLE, 0, 200);		// throttle
	if(sub_protocol==FY319)
	{
		packet[6] = convert_channel_8b(AILERON);
		packet[7] = convert_channel_8b(ELEVATOR);
		packet[8] = convert_channel_8b(RUDDER);
	}
	else
	{
		packet[6]  = rx_tx_addr[0];
		packet[7]  = rx_tx_addr[1];
		packet[8]  = rx_tx_addr[2];
	}
	packet[9]  = CHAN_TO_TRIM(packet[2]);	// aileron_trim;
	packet[10] = CHAN_TO_TRIM(packet[3]);	// elevator_trim;
	packet[11] = CHAN_TO_TRIM(packet[4]);	// rudder_trim;
	packet[12] = 0;							// throttle_trim;
	packet[13] = rxid;
	packet[14] = rx_tx_addr[4];

	if (bind)
		NRF24L01_WriteReg(NRF24L01_05_RF_CH, FY326_RF_BIND_CHANNEL);
	else
	{
		NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no++]);
		hopping_frequency_no %= FY326_NUM_RF_CHANNELS;
	}

	// clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_FlushTx();

	NRF24L01_WritePayload(packet, FY326_PACKET_SIZE);

	NRF24L01_SetPower();	// Set tx_power
}

static void __attribute__((unused)) FY326_RF_init()
{
	NRF24L01_Initialize();

	if(sub_protocol==FY319)
		NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x03);   // Five-byte rx/tx address
	else
		NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x01);   // Three-byte rx/tx address
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t *)"\x15\x59\x23\xc6\x29", 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t *)"\x15\x59\x23\xc6\x29", 5);
    NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, FY326_PACKET_SIZE);
    NRF24L01_WriteReg(NRF24L01_05_RF_CH, FY326_RF_BIND_CHANNEL);
    NRF24L01_SetBitrate(NRF24L01_BR_250K);

    NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3f);
    NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x07);

	//Switch to RX
	NRF24L01_SetTxRxMode(TXRX_OFF);
	NRF24L01_SetTxRxMode(RX_EN);
}

uint16_t FY326_callback()
{
	switch (phase)
	{
		case FY319_BIND1:
			if(NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{
				NRF24L01_ReadPayload(packet, FY326_PACKET_SIZE);
				rxid = packet[13];
				packet[0] = rx_tx_addr[3];
				packet[1] = 0x80;
				packet[14]= rx_tx_addr[4];
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_SetTxRxMode(TX_EN);
				NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
				NRF24L01_FlushTx();
				bind_counter = 255;
				for(uint8_t i=2; i<6; i++)
					packet[i] = hopping_frequency[0];
				phase = FY319_BIND2;
			}
			return FY326_PACKET_CHKTIME;
			break;
		case FY319_BIND2:
			NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
			NRF24L01_FlushTx();
			NRF24L01_WritePayload(packet, FY326_PACKET_SIZE);
			if(bind_counter == 250)
				packet[1] = 0x40;
			if(--bind_counter == 0)
			{
				BIND_DONE;
				phase = FY326_DATA;
			}
			break;
		case FY326_BIND1:
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ // RX fifo data ready
				NRF24L01_ReadPayload(packet, FY326_PACKET_SIZE);
				rxid = packet[13];
				rx_tx_addr[0] = 0xAA;
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_SetTxRxMode(TX_EN);
				BIND_DONE;
				phase = FY326_DATA;
			}
			else
				if (bind_counter-- == 0)
				{
					bind_counter = FY326_BIND_COUNT;
					NRF24L01_SetTxRxMode(TXRX_OFF);
					NRF24L01_SetTxRxMode(TX_EN);
					FY326_send_packet(1);
					phase = FY326_BIND2;
					return FY326_PACKET_CHKTIME;
				}
			break;
		case FY326_BIND2:
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_TX_DS))
			{ // TX data sent -> switch to RX mode
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_FlushRx();
				NRF24L01_SetTxRxMode(RX_EN);
				phase = FY326_BIND1;
			}
			else
				return FY326_PACKET_CHKTIME;
			break;
		case FY326_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(FY326_PACKET_PERIOD);
			#endif
			FY326_send_packet(0);
			break;
	}
	return FY326_PACKET_PERIOD;
}

static void __attribute__((unused)) FY326_initialize_txid()
{
	hopping_frequency[0] = 		  (rx_tx_addr[0]&0x0f);
	hopping_frequency[1] = 0x10 + (rx_tx_addr[0] >> 4);
	hopping_frequency[2] = 0x20 + (rx_tx_addr[1]&0x0f);
	hopping_frequency[3] = 0x30 + (rx_tx_addr[1] >> 4);
	hopping_frequency[4] = 0x40 + (rx_tx_addr[2] >> 4);
	if(sub_protocol==FY319)
		for(uint8_t i=0;i<5;i++)
			hopping_frequency[i]=rx_tx_addr[0] & ~0x80;
}

void FY326_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
    rxid = 0xAA;
	bind_counter = FY326_BIND_COUNT;
	FY326_initialize_txid();
	FY326_RF_init();
	if(sub_protocol==FY319)
	{
		phase=FY319_BIND1;
	}
	else
		phase=FY326_BIND1;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Fake_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(FAKE_NRF24L01_INO)

#include "iface_nrf250k.h"

static void __attribute__((unused)) FAKE_send_packet()
{
	for(uint8_t i=0;i<5;i++)
		packet[i]=i;
	NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_RX_DR) | _BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, 5);
}

static void __attribute__((unused)) FAKE_init()
{
//	BIND_IN_PROGRESS;

	//CC2500
	option=1;
	XN297L_Init();
	CC2500_WriteReg(CC2500_07_PKTCTRL1,	0x01);   // Packet Automation Control
	CC2500_WriteReg(CC2500_08_PKTCTRL0,	0x00);   // Packet Automation Control
	CC2500_WriteReg(CC2500_12_MDMCFG2,	0x12);   // Modem Configuration
	CC2500_WriteReg(CC2500_13_MDMCFG1,	0x13);   // Modem Configuration
	CC2500_WriteReg(CC2500_04_SYNC1,	0x11);
	CC2500_WriteReg(CC2500_05_SYNC0,	0x33);
	CC2500_WriteReg(CC2500_09_ADDR,     0x99);
	CC2500_WriteReg(CC2500_06_PKTLEN,	10);

	CC2500_SetTxRxMode(RX_EN);
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_Strobe(CC2500_SRX);
	//CC2500_SetTxRxMode(TX_EN);
	XN297L_RFChannel(0);

	//NRF
/*	option=0;
	PE1_on;							//NRF24L01 antenna RF3 by default
	PE2_off;						//NRF24L01 antenna RF3 by default
	NRF24L01_Initialize();
	NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x7f);
	NRF24L01_WriteReg(NRF24L01_01_EN_AA, 0x00);//0x3f);       // AA on all pipes
	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x3f);   // Enable all pipes
	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x03);    // 5-byte address
	NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0x36);  // retransmit 1ms, 6 times
	NRF24L01_SetBitrate(NRF24L01_BR_250K);              // 1Mbps
	NRF24L01_SetPower();
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t *)"\x99\x33\x11\xAA\xAA", 5);	//Bind address
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t *)"\x99\x33\x11\xAA\xAA", 5);	//Bind address
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 0);
	NRF24L01_Activate(0x73);                          // Activate feature register
	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3f);       // Enable dynamic payload length
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x07);     // Enable all features
*/	
	/*NRF24L01_FlushTx();
    NRF24L01_SetTxRxMode(TX_EN);*/
}

uint16_t FAKE_callback()
{
	len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
	if(len) debug("L=%d, ",len);
	if(len && len < sizeof(packet_in))
	{
		CC2500_ReadData(packet_in, len);
		debug("P:");
		for(uint8_t i=0;i<len;i++)
			debug(" %02X", packet_in[i]);
	}
	if(len) debugln("");
	CC2500_Strobe(CC2500_SFRX);
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_Strobe(CC2500_SRX);

	option=0;
	//FAKE_send_packet();
	
	PE1_off;	//antenna RF2
	PE2_on;
	/*packet[0]=0x99;
	for(uint8_t i=1;i<5;i++)
		packet[i]=i;
	CC2500_WriteData(packet, 5);*/
	return 10000;
}

uint16_t initFAKE()
{
	FAKE_init();
	return 5000;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FlySky_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/FLYSKY_a7105.c dated 2015-09-28

#if defined(FLYSKY_A7105_INO)

#include "iface_a7105.h"

//FlySky constants & variables
#define FLYSKY_BIND_COUNT 2500

enum {
	// flags going to byte 10
	FLAG_V9X9_VIDEO = 0x40,
	FLAG_V9X9_CAMERA= 0x80,
	// flags going to byte 12
	FLAG_V9X9_FLIP   = 0x10,
	FLAG_V9X9_LED   = 0x20,
};

enum {
	// flags going to byte 13
	FLAG_V6X6_HLESS1= 0x80,
	// flags going to byte 14
	FLAG_V6X6_VIDEO = 0x01,
	FLAG_V6X6_YCAL  = 0x02,
	FLAG_V6X6_XCAL  = 0x04,
	FLAG_V6X6_RTH   = 0x08,
	FLAG_V6X6_CAMERA= 0x10,
	FLAG_V6X6_HLESS2= 0x20,
	FLAG_V6X6_LED   = 0x40,
	FLAG_V6X6_FLIP  = 0x80,
};

enum {
	// flags going to byte 14
	FLAG_V912_TOPBTN= 0x40,
	FLAG_V912_BTMBTN= 0x80,
};

const uint8_t PROGMEM V912_X17_SEQ[10] =  { 0x14, 0x31, 0x40, 0x49, 0x49,    // sometime first byte is 0x15 ?
											0x49, 0x49, 0x49, 0x49, 0x49, }; 

static void __attribute__((unused)) FLYSKY_apply_extension_flags()
{
	switch(sub_protocol)
	{
		case V9X9:
			if(CH5_SW)
				packet[12] |= FLAG_V9X9_FLIP;
			if(CH6_SW)
				packet[12] |= FLAG_V9X9_LED;
			if(CH7_SW)
				packet[10] |= FLAG_V9X9_CAMERA;
			if(CH8_SW)
				packet[10] |= FLAG_V9X9_VIDEO;
			break;
			
		case V6X6:
			packet[13] = 0x03; // 3 = 100% rate (0=40%, 1=60%, 2=80%)
			packet[14] = 0x00;
			if(CH5_SW) 
				packet[14] |= FLAG_V6X6_FLIP;
			if(CH6_SW) 
				packet[14] |= FLAG_V6X6_LED;
			if(CH7_SW) 
				packet[14] |= FLAG_V6X6_CAMERA;
			if(CH8_SW) 
				packet[14] |= FLAG_V6X6_VIDEO;
			if(CH9_SW)
			{ 
				packet[13] |= FLAG_V6X6_HLESS1;
				packet[14] |= FLAG_V6X6_HLESS2;
			}
			if(CH10_SW)
				packet[14] |= FLAG_V6X6_RTH;
			if(CH11_SW) 
				packet[14] |= FLAG_V6X6_XCAL;
			if(CH12_SW) 
				packet[14] |= FLAG_V6X6_YCAL;
			packet[15] = 0x10; // unknown
			packet[16] = 0x10; // unknown
			packet[17] = 0xAA; // unknown
			packet[18] = 0xAA; // unknown
			packet[19] = 0x60; // unknown, changes at irregular interval in stock TX
			packet[20] = 0x02; // unknown
			break;
			
		case V912:
			packet_count++;
			if( packet_count > 9)
				packet_count = 0;
			packet[12] |= 0x20; // bit 6 is always set ?
			packet[13] = 0x00;  // unknown
			packet[14] = 0x00;
			if(CH5_SW)
				packet[14]  = FLAG_V912_BTMBTN;
			if(CH6_SW)
				packet[14] |= FLAG_V912_TOPBTN;
			packet[15] = 0x27; // [15] and [16] apparently hold an analog channel with a value lower than 1000
			packet[16] = 0x03; // maybe it's there for a pitch channel for a CP copter ?
			packet[17] = pgm_read_byte( &V912_X17_SEQ[packet_count] ) ; // not sure what [17] & [18] are for
			if(packet_count == 0)                    // V912 Rx does not even read those bytes... [17-20]
				packet[18] = 0x02;
			else
				packet[18] = 0x00;
			packet[19] = 0x00; // unknown
			packet[20] = 0x00; // unknown
			break;
			
		case CX20:
			packet[19] = 0x00; // unknown
			packet[20] = (hopping_frequency_no<<4)|0x0A;
			break;
		default:
			break; 
	}
}

static void __attribute__((unused)) FLYSKY_send_packet()
{
    uint8_t i;
	//servodata timing range for flysky.
	//-100% =~ 0x03e8//=1000us(min)
	//+100% =~ 0x07ca//=1994us(max)
	//Center = 0x5d9//=1497us(center)
	//channel order AIL;ELE;THR;RUD;CH5;CH6;CH7;CH8
    packet[0] = IS_BIND_IN_PROGRESS ? 0xaa : 0x55;
    packet[1] = rx_tx_addr[3];
    packet[2] = rx_tx_addr[2];
    packet[3] = rx_tx_addr[1];
    packet[4] = rx_tx_addr[0];
	for(i = 0; i < 8; i++)
	{
		uint16_t temp=convert_channel_ppm(CH_AETR[i]);
		if(sub_protocol == CX20 && i==CH2) //ELEVATOR
			temp=3000-temp;
		packet[5 + i*2]=temp&0xFF;		//low byte of servo timing(1000-2000us)
		packet[6 + i*2]=(temp>>8)&0xFF;	//high byte of servo timing(1000-2000us)
	}
    FLYSKY_apply_extension_flags();

	A7105_SetPower();
	A7105_WriteData(21, IS_BIND_IN_PROGRESS ? 0x01:hopping_frequency[hopping_frequency_no & 0x0F]);
	hopping_frequency_no++;
}

uint16_t FLYSKY_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	#ifndef FORCE_FLYSKY_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter==0)
			BIND_DONE;
	}
	FLYSKY_send_packet();
	return packet_period;
}

const uint8_t PROGMEM FLYSKY_tx_channels[8][4] = {
	{ 0x12, 0x34, 0x56, 0x78},
	{ 0x18, 0x27, 0x36, 0x45},
	{ 0x41, 0x82, 0x36, 0x57},
	{ 0x84, 0x13, 0x65, 0x72},
	{ 0x87, 0x64, 0x15, 0x32},
	{ 0x76, 0x84, 0x13, 0x52},
	{ 0x71, 0x62, 0x84, 0x35},
	{ 0x71, 0x86, 0x43, 0x52}
};

void FLYSKY_init()
{
	uint8_t chanrow;
	uint8_t chanoffset;
	uint8_t temp;

	A7105_Init();
	
	// limit offset to 9 as higher values don't work with some RX (ie V912)
	// limit offset to 9 as CX20 repeats the same channels after that
	if ((rx_tx_addr[3]&0xF0) > 0x90)
		rx_tx_addr[3]=rx_tx_addr[3]-0x70;

	// Build frequency hop table
	chanrow=rx_tx_addr[3] & 0x0F;
	chanoffset=rx_tx_addr[3]/16;
	for(uint8_t i=0;i<16;i++)
	{
		temp=pgm_read_byte_near(&FLYSKY_tx_channels[chanrow>>1][i>>2]);
		if(i&0x02)
			temp&=0x0F;
		else
			temp>>=4;
		temp*=0x0A;
		if(i&0x01)
			temp+=0x50;
		if(sub_protocol==CX20)
		{
			if(temp==0x0A)
				temp+=0x37;
			if(temp==0xA0)
			{
				if (chanoffset<4)
					temp=0x37;
				else if (chanoffset<9)
					temp=0x2D;
				else
					temp=0x29;
			}
		}
		hopping_frequency[((chanrow&1)?15-i:i)]=temp-chanoffset;
	}
	hopping_frequency_no=0;
	packet_count=0;
	if(sub_protocol==CX20)
		packet_period=3984;
	else
		packet_period=1510;	//1460 on deviation but not working with the latest V911 bricks... Turnigy 9X v2 is 1533, Flysky TX for 9XR/9XR Pro is 1510, V911 TX is 1490.
	if(IS_BIND_IN_PROGRESS)
		bind_counter = FLYSKY_BIND_COUNT;
	else
		bind_counter = 0;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyDVX_common.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

/******************************/
/**  FrSky D and X routines  **/
/******************************/

#if defined(FRSKYD_CC2500_INO) || defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO) || defined(FRSKY_RX_CC2500_INO) || defined(FRSKYR9_SX1276_INO)
	uint8_t FrSkyFormat=0;
	uint8_t FrSkyX_chanskip;
#endif

#if defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO) || defined(FRSKY_RX_CC2500_INO) || defined(FRSKYR9_SX1276_INO)
//**CRC**
const uint16_t PROGMEM FrSkyX_CRC_Short[]={
	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7 };
static uint16_t __attribute__((unused)) FrSkyX_CRCTable(uint8_t val)
{
	uint16_t word ;
	word = pgm_read_word(&FrSkyX_CRC_Short[val&0x0F]) ;
	val /= 16 ;
	return word ^ (0x1081 * val) ;
}
uint16_t FrSkyX_crc(uint8_t *data, uint8_t len, uint16_t init=0)
{
	uint16_t crc = init;
	for(uint8_t i=0; i < len; i++)
		crc = (crc<<8) ^ FrSkyX_CRCTable((uint8_t)(crc>>8) ^ *data++);
	return crc;
}
#endif

#if defined(FRSKYX_CC2500_INO) || defined(FRSKYR9_SX1276_INO)
static void __attribute__((unused)) FrSkyX_channels(uint8_t offset)
{
	static uint8_t chan_start=0;

	//packet[7] = FLAGS 00 - standard packet
	//10, 12, 14, 16, 18, 1A, 1C, 1E - failsafe packet
	//20 - range check packet
	#ifdef FAILSAFE_ENABLE
		#define FRSKYX_FAILSAFE_TIMEOUT 1032
		static uint16_t failsafe_count=0;
		static uint8_t FS_flag=0,failsafe_chan=0;
		if (FS_flag == 0  &&  failsafe_count > FRSKYX_FAILSAFE_TIMEOUT  &&  chan_start == 0  &&  IS_FAILSAFE_VALUES_on)
		{
			FS_flag = 0x10;
			failsafe_chan = 0;
		} else if (FS_flag & 0x10 && failsafe_chan < (FrSkyFormat & 0x01 ? 8-1:16-1))
		{
			FS_flag = 0x10 | ((FS_flag + 2) & 0x0F);					//10, 12, 14, 16, 18, 1A, 1C, 1E - failsafe packet
			failsafe_chan ++;
		} else if (FS_flag & 0x10)
		{
			FS_flag = 0;
			failsafe_count = 0;
			FAILSAFE_VALUES_off;
		}
		failsafe_count++;
		if(protocol==PROTO_FRSKY_R9)
			failsafe_count++;					// R9 is 20ms, X is 9ms
		packet[offset] = FS_flag;
	#else
		packet[offset] = 0;
	#endif
	//
	packet[offset+1] = 0;						//??
	//
	uint8_t chan_index = chan_start;
	uint16_t ch1,ch2;
	for(uint8_t i = offset+2; i < 12+offset+2 ; i+=3)
	{//12 bytes of channel data
		#ifdef FAILSAFE_ENABLE
			if( (FS_flag & 0x10) && ((failsafe_chan & 0x07) == (chan_index & 0x07)) )
				ch1 = FrSkyX_scaleForPXX_FS(failsafe_chan);
			else
		#endif
				ch1 = FrSkyX_scaleForPXX(chan_index);
		chan_index++;
		//
		#ifdef FAILSAFE_ENABLE
			if( (FS_flag & 0x10) && ((failsafe_chan & 0x07) == (chan_index & 0x07)) )
				ch2 = FrSkyX_scaleForPXX_FS(failsafe_chan);
			else
		#endif
				ch2 = FrSkyX_scaleForPXX(chan_index);
		chan_index++;
		//3 bytes per channel
		packet[i] = ch1;
		packet[i+1]=(((ch1>>8) & 0x0F)|(ch2 << 4));
		packet[i+2]=ch2>>4;
	}
	if(FrSkyFormat & 0x01)											//In X8 mode send only 8ch every 9ms
		chan_start = 0 ;
	else
		chan_start^=0x08;
}
#endif


#if defined(FRSKYD_CC2500_INO) || defined(FRSKYX_CC2500_INO) || defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO) || defined(FRSKY_RX_CC2500_INO)
enum {
	FRSKY_BIND		= 0,
	FRSKY_BIND_DONE	= 1000,
	FRSKY_DATA1,
	FRSKY_DATA2,
	FRSKY_DATA3,
	FRSKY_DATA4,
	FRSKY_DATA5,
};

void Frsky_init_hop(void)
{
	uint8_t val;
	uint8_t channel = rx_tx_addr[0]&0x07;
	uint8_t channel_spacing = rx_tx_addr[1];
	//Filter bad tables
	if(channel_spacing<0x02) channel_spacing+=0x02;
	if(channel_spacing>0xE9) channel_spacing-=0xE7;
	if(channel_spacing%0x2F==0) channel_spacing++;
		
	hopping_frequency[0]=channel;
	for(uint8_t i=1;i<50;i++)
	{
		channel=(channel+channel_spacing) % 0xEB;
		val=channel;
		if((val==0x00) || (val==0x5A) || (val==0xDC))
			val++;
		hopping_frequency[i]=i>46?0:val;
	}
}

void FrSkyX2_init_hop(void)
{
	uint16_t id=(rx_tx_addr[2]<<8) + rx_tx_addr[3];
	//Increment
	uint8_t inc = (id % 46) + 1;
	if( inc == 12 || inc ==35 ) inc++;							//Exception list from dumps
	//Start offset
	uint8_t offset = id % 5;

	debug("hop: ");
	uint8_t channel;
	for(uint8_t i=0; i<47; i++)
	{
		channel = 5 * (uint16_t(inc * i) % 47) + offset;
		//Exception list from dumps
		if(FrSkyFormat & 2 )// LBT or FCC
		{//LBT
			if( channel <=1 || channel == 43 || channel == 44 || channel == 87 || channel == 88 || channel == 129 || channel == 130 || channel == 173 || channel == 174)
				channel += 2;
			else if( channel == 216 || channel == 217 || channel == 218)
				channel += 3;
		}
		else //FCC
			if ( channel == 3 || channel == 4 || channel == 46 || channel == 47 || channel == 90 || channel == 91  || channel == 133 || channel == 134 || channel == 176 || channel == 177 || channel == 220 || channel == 221 )
				channel += 2;
		//Store
		hopping_frequency[i] = channel;
		debug(" %02X",channel);
	}
	debugln("");
	hopping_frequency[47] = 0;									//Bind freq
}

void Frsky_init_clone(void)
{
	debugln("Clone mode");
	uint16_t temp = FRSKYD_CLONE_EEPROM_OFFSET;
	if(protocol==PROTO_FRSKYX)
		temp=FRSKYX_CLONE_EEPROM_OFFSET;
	else if(protocol==PROTO_FRSKYX2)
		temp=FRSKYX2_CLONE_EEPROM_OFFSET;
	FrSkyFormat=eeprom_read_byte((EE_ADDR)temp++);
	/*	FRSKY_RX_D8			=0,
	FRSKY_RX_D16FCC		=1,
	FRSKY_RX_D16LBT		=2,
	FRSKY_RX_D16v2FCC	=3,
	FRSKY_RX_D16v2LBT	=4,*/
	if(protocol==PROTO_FRSKYX)
		FrSkyFormat >>= 1;
	else
		FrSkyFormat >>= 2;
	FrSkyFormat <<= 1;	//FCC_16/LBT_16
	if(sub_protocol==XCLONE_8)
		FrSkyFormat++;	//FCC_8/LBT_8
	rx_tx_addr[3] = eeprom_read_byte((EE_ADDR)temp++);
	rx_tx_addr[2] = eeprom_read_byte((EE_ADDR)temp++);
	rx_tx_addr[1] = eeprom_read_byte((EE_ADDR)temp++);
	memset(hopping_frequency,0x00,50);
	if(protocol!=PROTO_FRSKYX2)
	{//D8 and D16v1
		for (uint8_t ch = 0; ch < 47; ch++)
			hopping_frequency[ch] = eeprom_read_byte((EE_ADDR)temp++);
	}
	else
		FrSkyX2_init_hop();
}

#endif
/******************************/
/**  FrSky V, D and X routines  **/
/******************************/
#if defined(FRSKYV_CC2500_INO) || defined(FRSKYD_CC2500_INO) || defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO)
	const PROGMEM uint8_t FRSKY_common_startreg_cc2500_conf[]= {
		 CC2500_02_IOCFG0 ,		
		 CC2500_00_IOCFG2 ,
		 CC2500_17_MCSM1 ,
		 CC2500_18_MCSM0 ,
		 CC2500_06_PKTLEN ,
		 CC2500_07_PKTCTRL1 ,
		 CC2500_08_PKTCTRL0 ,
		 CC2500_3E_PATABLE ,
		 CC2500_0B_FSCTRL1 ,
		 CC2500_0C_FSCTRL0 ,	// replaced by option value
		 CC2500_0D_FREQ2 ,	
		 CC2500_0E_FREQ1 ,
		 CC2500_0F_FREQ0 ,
		 CC2500_10_MDMCFG4 ,		
		 CC2500_11_MDMCFG3 ,
		 CC2500_12_MDMCFG2 ,
		 CC2500_13_MDMCFG1 ,
		 CC2500_14_MDMCFG0 ,
		 CC2500_15_DEVIATN  };

	#if defined(FRSKYV_CC2500_INO)
		const PROGMEM uint8_t FRSKYV_cc2500_conf[]= {
		/*02_IOCFG0*/  	 0x06 ,		
		/*00_IOCFG2*/  	 0x06 ,
		/*17_MCSM1*/   	 0x0c ,
		/*18_MCSM0*/   	 0x18 ,
		/*06_PKTLEN*/  	 0xff ,
		/*07_PKTCTRL1*/	 0x04 ,
		/*08_PKTCTRL0*/	 0x05 ,
		/*3E_PATABLE*/ 	 0xfe ,
		/*0B_FSCTRL1*/ 	 0x08 ,
		/*0C_FSCTRL0*/ 	 0x00 ,
		/*0D_FREQ2*/   	 0x5c ,	
		/*0E_FREQ1*/   	 0x58 ,
		/*0F_FREQ0*/   	 0x9d ,
		/*10_MDMCFG4*/ 	 0xAA ,		
		/*11_MDMCFG3*/ 	 0x10 ,
		/*12_MDMCFG2*/ 	 0x93 ,
		/*13_MDMCFG1*/ 	 0x23 ,
		/*14_MDMCFG0*/ 	 0x7a ,
		/*15_DEVIATN*/ 	 0x41  };
	#endif

	#if defined(FRSKYD_CC2500_INO)
		const PROGMEM uint8_t FRSKYD_cc2500_conf[]= {
		/*02_IOCFG0*/  	 0x06 ,		
		/*00_IOCFG2*/  	 0x06 ,
		/*17_MCSM1*/   	 0x0c ,
		/*18_MCSM0*/   	 0x18 ,
		/*06_PKTLEN*/  	 0x19 ,
		/*07_PKTCTRL1*/	 0x04 ,
		/*08_PKTCTRL0*/	 0x05 ,
		/*3E_PATABLE*/ 	 0xff ,
		/*0B_FSCTRL1*/ 	 0x08 ,
		/*0C_FSCTRL0*/ 	 0x00 ,
		/*0D_FREQ2*/   	 0x5c ,	
		/*0E_FREQ1*/   	 0x76 ,
		/*0F_FREQ0*/   	 0x27 ,
		/*10_MDMCFG4*/ 	 0xAA ,		
		/*11_MDMCFG3*/ 	 0x39 ,
		/*12_MDMCFG2*/ 	 0x11 ,
		/*13_MDMCFG1*/ 	 0x23 ,
		/*14_MDMCFG0*/ 	 0x7a ,
		/*15_DEVIATN*/ 	 0x42  };
	#endif

	#if defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO)
		const PROGMEM uint8_t FRSKYX_cc2500_conf[]= {
	//FRSKYX
		/*02_IOCFG0*/  	 0x06 ,
		/*00_IOCFG2*/  	 0x06 ,
		/*17_MCSM1*/   	 0x0c ,	//X2->0x0E -> RX stays in RX and TX stays in TX???
		/*18_MCSM0*/   	 0x18 ,
		/*06_PKTLEN*/  	 0x1E ,
		/*07_PKTCTRL1*/	 0x04 ,
		/*08_PKTCTRL0*/	 0x01 , //X2->0x05 -> CRC enabled
		/*3E_PATABLE*/ 	 0xff ,
		/*0B_FSCTRL1*/ 	 0x0A ,
		/*0C_FSCTRL0*/ 	 0x00 ,
		/*0D_FREQ2*/   	 0x5c ,	
		/*0E_FREQ1*/   	 0x76 ,
		/*0F_FREQ0*/   	 0x27 ,
		/*10_MDMCFG4*/ 	 0x7B ,
		/*11_MDMCFG3*/ 	 0x61 ,	//X2->0x84 -> bitrate 70K->77K
		/*12_MDMCFG2*/ 	 0x13 ,
		/*13_MDMCFG1*/ 	 0x23 ,
		/*14_MDMCFG0*/ 	 0x7a ,
		/*15_DEVIATN*/ 	 0x51  };
		const PROGMEM uint8_t FRSKYXEU_cc2500_conf[]= {
		/*02_IOCFG0*/  	 0x06 ,
		/*00_IOCFG2*/  	 0x06 ,
		/*17_MCSM1*/   	 0x0E ,
		/*18_MCSM0*/   	 0x18 ,
		/*06_PKTLEN*/  	 0x23 ,
		/*07_PKTCTRL1*/	 0x04 ,
		/*08_PKTCTRL0*/	 0x01 , //X2->0x05 -> CRC enabled
		/*3E_PATABLE*/ 	 0xff ,
		/*0B_FSCTRL1*/ 	 0x08 ,
		/*0C_FSCTRL0*/ 	 0x00 ,
		/*0D_FREQ2*/   	 0x5c ,
		/*0E_FREQ1*/   	 0x80 ,
		/*0F_FREQ0*/   	 0x00 ,
		/*10_MDMCFG4*/ 	 0x7B ,
		/*11_MDMCFG3*/ 	 0xF8 ,
		/*12_MDMCFG2*/ 	 0x03 ,
		/*13_MDMCFG1*/ 	 0x23 ,
		/*14_MDMCFG0*/ 	 0x7a ,
		/*15_DEVIATN*/ 	 0x53  };
		const PROGMEM uint8_t FRSKYL_cc2500_conf[]= {
		/*02_IOCFG0*/  	 0x02 ,
		/*00_IOCFG2*/  	 0x02 ,
		/*17_MCSM1*/   	 0x0C ,
		/*18_MCSM0*/   	 0x18 ,
		/*06_PKTLEN*/  	 0xFF ,
		/*07_PKTCTRL1*/	 0x00 ,
		/*08_PKTCTRL0*/	 0x02 ,
		/*3E_PATABLE*/ 	 0xFE ,
		/*0B_FSCTRL1*/ 	 0x0A ,
		/*0C_FSCTRL0*/ 	 0x00 ,
		/*0D_FREQ2*/   	 0x5c ,
		/*0E_FREQ1*/   	 0x76 ,
		/*0F_FREQ0*/   	 0x27 ,
		/*10_MDMCFG4*/ 	 0x5C ,
		/*11_MDMCFG3*/ 	 0x3B ,
		/*12_MDMCFG2*/ 	 0x00 ,
		/*13_MDMCFG1*/ 	 0x03 ,
		/*14_MDMCFG0*/ 	 0x7A ,
		/*15_DEVIATN*/ 	 0x47  };
	#endif

	const PROGMEM uint8_t FRSKY_common_end_cc2500_conf[][2]= {
		{ CC2500_19_FOCCFG,   0x16 },
		{ CC2500_1A_BSCFG,    0x6c },	
		{ CC2500_1B_AGCCTRL2, 0x43 },
		{ CC2500_1C_AGCCTRL1, 0x40 },
		{ CC2500_1D_AGCCTRL0, 0x91 },
		{ CC2500_21_FREND1,   0x56 },
		{ CC2500_22_FREND0,   0x10 },
		{ CC2500_23_FSCAL3,   0xa9 },
		{ CC2500_24_FSCAL2,   0x0A },
		{ CC2500_25_FSCAL1,   0x00 },
		{ CC2500_26_FSCAL0,   0x11 },
		{ CC2500_29_FSTEST,   0x59 },
		{ CC2500_2C_TEST2,    0x88 },
		{ CC2500_2D_TEST1,    0x31 },
		{ CC2500_2E_TEST0,    0x0B },
		{ CC2500_03_FIFOTHR,  0x07 },
		{ CC2500_09_ADDR,     0x00 } };

	void FRSKY_init_cc2500(const uint8_t *ptr)
	{
		for(uint8_t i=0;i<19;i++)
		{
			uint8_t reg=pgm_read_byte_near(&FRSKY_common_startreg_cc2500_conf[i]);
			uint8_t val=pgm_read_byte_near(&ptr[i]);
			if(reg==CC2500_0C_FSCTRL0)
				val=option;
			CC2500_WriteReg(reg,val);
		}
		for(uint8_t i=0;i<17;i++)
		{
			uint8_t reg=pgm_read_byte_near(&FRSKY_common_end_cc2500_conf[i][0]);
			uint8_t val=pgm_read_byte_near(&FRSKY_common_end_cc2500_conf[i][1]);
			CC2500_WriteReg(reg,val);
		}
		CC2500_SetTxRxMode(TX_EN);
		CC2500_SetPower();
		CC2500_Strobe(CC2500_SIDLE);    // Go to idle...
	}
#endif

#if defined(FRSKYX_CC2500_INO) || defined(FRSKYR9_SX1276_INO)
	uint8_t FrSkyX_TX_Seq, FrSkyX_TX_IN_Seq;
	uint8_t FrSkyX_RX_Seq ;

	#ifdef SPORT_SEND
		struct t_FrSkyX_TX_Frame
		{
			uint8_t count;
			uint8_t payload[8];
		} ;
		// Store FrskyX telemetry
		struct t_FrSkyX_TX_Frame FrSkyX_TX_Frames[4] ;
	#endif
	
	static void __attribute__((unused)) FrSkyX_seq_sport(uint8_t start, uint8_t end)
	{
		for (uint8_t i=start+1;i<=end;i++)
			packet[i]=0;
		packet[start] = FrSkyX_RX_Seq << 4;
		#ifdef SPORT_SEND
			if (FrSkyX_TX_IN_Seq!=0xFF)
			{//RX has replied at least once
				if (FrSkyX_TX_IN_Seq & 0x08)
				{//Request init
					//debugln("Init");
					FrSkyX_TX_Seq = 0 ;	
					for(uint8_t i=0;i<4;i++)
						FrSkyX_TX_Frames[i].count=0;						//Discard frames in current output buffer
				}
				else if (FrSkyX_TX_IN_Seq & 0x04)
				{//Retransmit the requested packet
					debugln("Retry:%d",FrSkyX_TX_IN_Seq&0x03);
					packet[start] |= FrSkyX_TX_IN_Seq&0x03;
					packet[start+1]  = FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq&0x03].count;
					for (uint8_t i=start+2;i<start+2+FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq&0x03].count;i++)
						packet[i] = FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq&0x03].payload[i];
				}
				else if ( FrSkyX_TX_Seq != 0x08 )
				{
					if(FrSkyX_TX_Seq==FrSkyX_TX_IN_Seq)
					{//Send packet from the incoming radio buffer
						//debugln("Send:%d",FrSkyX_TX_Seq);
						packet[start] |= FrSkyX_TX_Seq;
						uint8_t nbr_bytes=0;
						for (uint8_t i=start+2;i<=end;i++)
						{
							if(SportHead==SportTail)
								break; //buffer empty
							packet[i]=SportData[SportHead];
							FrSkyX_TX_Frames[FrSkyX_TX_Seq].payload[i-start+2]=SportData[SportHead];
							SportHead=(SportHead+1) & (MAX_SPORT_BUFFER-1);
							nbr_bytes++;
						}
						packet[start+1]=nbr_bytes;
						FrSkyX_TX_Frames[FrSkyX_TX_Seq].count=nbr_bytes;
						if(nbr_bytes)
						{//Check the buffer status
							uint8_t used = SportTail;
							if ( SportHead > SportTail )
								used += MAX_SPORT_BUFFER - SportHead ;
							else
								used -= SportHead ;
							if ( used < (MAX_SPORT_BUFFER>>1) )
							{
								DATA_BUFFER_LOW_off;
								debugln("Ok buf:%d",used);
							}
						}
						FrSkyX_TX_Seq = ( FrSkyX_TX_Seq + 1 ) & 0x03 ;		//Next iteration send next packet
					}
					else
					{//Not in sequence somehow, transmit what the receiver wants but why not asking for retransmit...
						//debugln("RX_Seq:%d,TX:%d",FrSkyX_TX_IN_Seq,FrSkyX_TX_Seq);
						packet[start] |= FrSkyX_TX_IN_Seq;
						packet[start+1] = FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq].count;
						for (uint8_t i=start+2;i<start+2+FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq].count;i++)
							packet[i] = FrSkyX_TX_Frames[FrSkyX_TX_IN_Seq].payload[i-start+2];
					}
				}
				else
					packet[start] |= 0x08 ;									//FrSkyX_TX_Seq=8 at startup
			}
			if(packet[start+1])
			{//Debug
				debug("SP: ");
				for(uint8_t i=0;i<packet[start+1];i++)
					debug("%02X ",packet[start+2+i]);
				debugln("");
			}
		#else
			packet[start] |= FrSkyX_TX_Seq ;//TX=8 at startup
			if ( !(FrSkyX_TX_IN_Seq & 0xF8) )
				FrSkyX_TX_Seq = ( FrSkyX_TX_Seq + 1 ) & 0x03 ;				// Next iteration send next packet
		#endif // SPORT_SEND
	}

	static void __attribute__((unused)) FrSkyX_telem_init(void)
	{
		FrSkyX_TX_Seq = 0x08 ;				// Request init
		#ifdef SPORT_SEND
			FrSkyX_TX_IN_Seq = 0xFF ;		// No sequence received yet
			for(uint8_t i=0;i<4;i++)
				FrSkyX_TX_Frames[i].count=0;// discard frames in current output buffer
			SportHead=SportTail=0;			// empty data buffer
		#endif
		FrSkyX_RX_Seq = 0 ;					// Seq 0 to start with
		#ifdef TELEMETRY
			telemetry_lost=1;
			telemetry_link=0;					//Stop sending telemetry
		#endif
	}
#endif

#if defined(FRSKYX_CC2500_INO) || defined(FRSKYL_CC2500_INO)
static void __attribute__((unused)) FrSkyX_set_start(uint8_t ch )
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[ch]);
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[ch]);
}		

static void __attribute__((unused)) FrSkyX_RF_init()
{
	if(protocol==PROTO_FRSKYL)
		FRSKY_init_cc2500(FRSKYL_cc2500_conf);
	else
		FRSKY_init_cc2500((FrSkyFormat&2)?FRSKYXEU_cc2500_conf:FRSKYX_cc2500_conf); // LBT or FCC
	if(protocol==PROTO_FRSKYX2)
	{
		CC2500_WriteReg(CC2500_08_PKTCTRL0, 0x05);		// Enable CRC
		if(!(FrSkyFormat&2))
		{ // FCC
			CC2500_WriteReg(CC2500_17_MCSM1, 0x0E);		//0x0E -> RX stays in RX and TX stays in TX???
			CC2500_WriteReg(CC2500_11_MDMCFG3, 0x84);	// bitrate 70K->77K
		}
	}
	//
	for(uint8_t c=0;c < 48;c++)
	{//calibrate hop channels
		CC2500_Strobe(CC2500_SIDLE);    
		CC2500_WriteReg(CC2500_0A_CHANNR,hopping_frequency[c]);
		CC2500_Strobe(CC2500_SCAL);
		delayMicroseconds(900);//
		calData[c] = CC2500_ReadReg(CC2500_25_FSCAL1);
	}
	//#######END INIT########		
}

static void __attribute__((unused)) FrSkyX_initialize_data(uint8_t adr)
{
	CC2500_WriteReg(CC2500_18_MCSM0,    0x8);	
	CC2500_WriteReg(CC2500_09_ADDR, adr ? 0x03 : rx_tx_addr[3]);
	CC2500_WriteReg(CC2500_07_PKTCTRL1,0x05);	// check address
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyD_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(FRSKYD_CC2500_INO)

#include "iface_cc2500.h"

static void __attribute__((unused)) FRSKYD_RF_init()
{
	FRSKY_init_cc2500(FRSKYD_cc2500_conf);	

	CC2500_WriteReg(CC2500_1B_AGCCTRL2, IS_BIND_IN_PROGRESS ? 0x43 : 0x03);
	CC2500_WriteReg(CC2500_09_ADDR, IS_BIND_IN_PROGRESS ? 0x03 : rx_tx_addr[3]);
	CC2500_WriteReg(CC2500_07_PKTCTRL1, 0x05);
	CC2500_Strobe(CC2500_SIDLE);	// Go to idle...
	//
	CC2500_WriteReg(CC2500_0A_CHANNR, 0x00);
	CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);
	CC2500_Strobe(CC2500_SFRX);
	//#######END INIT########		
}
	
static void __attribute__((unused)) FRSKYD_build_bind_packet()
{
	//11 03 01 d7 2d 00 00 1e 3c 5b 78 00 00 00 00 00 00 01
	//11 03 01 19 3e 00 02 8e 2f bb 5c 00 00 00 00 00 00 01
	packet[0] = 0x11;                
	packet[1] = 0x03;                
	packet[2] = 0x01;                
	packet[3] = rx_tx_addr[3];
	packet[4] = rx_tx_addr[2];
	uint16_t idx = ((state -FRSKY_BIND) % 10) * 5;
	packet[5] = idx;
	packet[6] = hopping_frequency[idx++];
	packet[7] = hopping_frequency[idx++];
	packet[8] = hopping_frequency[idx++];
	packet[9] = hopping_frequency[idx++];
	packet[10] = hopping_frequency[idx++];
	packet[11] = 0x00;
	packet[12] = 0x00;
	packet[13] = 0x00;
	packet[14] = 0x00;
	packet[15] = 0x00;
	packet[16] = 0x00;
	packet[17] = rx_tx_addr[1];
}

static void __attribute__((unused)) FRSKYD_data_frame()
{//pachet[4] is telemetry user frame counter(hub)
	//11 d7 2d 22 00 01 c9 c9 ca ca 88 88 ca ca c9 ca 88 88
	//11 57 12 00 00 01 f2 f2 f2 f2 06 06 ca ca ca ca 18 18
	packet[0] = 0x11;             //Length
	packet[1] = rx_tx_addr[3];
	packet[2] = rx_tx_addr[2];
	packet[3] = counter;//	
	#if defined TELEMETRY
		packet[4] = telemetry_counter;
	#else
		packet[4] = 0x00;
	#endif

	packet[5] = rx_tx_addr[1];
	//
	packet[10] = 0;
	packet[11] = 0;
	packet[16] = 0;
	packet[17] = 0;
	for(uint8_t i = 0; i < 8; i++)
	{
		uint16_t value;
			value = convert_channel_frsky(i);
		if(i < 4)
		{
			packet[6+i] = value & 0xff;
			packet[10+(i>>1)] |= ((value >> 8) & 0x0f) << (4 *(i & 0x01));
		} 
		else
		{
			packet[8+i] = value & 0xff;
			packet[16+((i-4)>>1)] |= ((value >> 8) & 0x0f) << (4 * ((i-4) & 0x01));
		}
	}
} 

void FRSKYD_init(void)
{
	//FrskyD init hop
	if (sub_protocol==DCLONE)
		Frsky_init_clone();
	else
	{
		for(uint8_t i=0;i<50;i++)
		{
			uint8_t freq = (i * 0x1e) % 0xeb;
			if(i == 3 || i == 23 || i == 47)
				freq++;
			if(i > 47)
				freq=0;
			hopping_frequency[i]=freq;
		}
		rx_tx_addr[1]=1;		// keep compatibility with already bound RXs
	}
	
	packet_count=0;
	if(IS_BIND_IN_PROGRESS)
	{
		FRSKYD_RF_init();
		state = FRSKY_BIND;
	}
	else
	{
		state = FRSKY_BIND_DONE;
	}
}	
		
uint16_t FRSKYD_callback(void)
{ 
	if (state < FRSKY_BIND_DONE)
	{
		FRSKYD_build_bind_packet();
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, 0x00);
		CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);		
		CC2500_Strobe(CC2500_SFRX);//0x3A
		CC2500_WriteData(packet, packet[0]+1);
		if(IS_BIND_DONE)
			state = FRSKY_BIND_DONE;
		else
			state++;
		return 9000;
	}
	if (state == FRSKY_BIND_DONE)
	{
		BIND_DONE;
		FRSKYD_RF_init();
		counter = 0;
		state = FRSKY_DATA2;
	}
	else
		if (state == FRSKY_DATA5)
		{
			CC2500_Strobe(CC2500_SRX);//0x34 RX enable
			state = FRSKY_DATA1;	
			return 9200;
		}
	counter = (counter + 1) % 188;	
	if (state == FRSKY_DATA4)
	{	//telemetry receive
		CC2500_SetTxRxMode(RX_EN);
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[counter % 47]);
		CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);
		state++;
		return 1300;
	}
	else
	{
		if (state == FRSKY_DATA1)
		{
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(9000);
			#endif
			len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
			if (len && len<=(0x11+3))// 20bytes
			{		
				CC2500_ReadData(packet_in, len);				//received telemetry packets
				#if defined(TELEMETRY)
					if(packet_in[len-1] & 0x80)
					{//with valid crc
						packet_count=0;
						frsky_process_telemetry(packet_in,len);	//check if valid telemetry packets and buffer them.
					}
				#endif
			}
			else
			{
				packet_count++;
				// restart sequence on missed packet - might need count or timeout instead of one missed
				if(packet_count>100)
				{//~1sec
					packet_count=0;
					#if defined TELEMETRY
						telemetry_link=0;//no link frames
						packet_in[6]=0;//no user frames.
					#endif
				}
			}
			CC2500_SetTxRxMode(TX_EN);
			CC2500_SetPower();	// Set tx_power
		}
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[counter % 47]);
		CC2500_SetFreqOffset();
		CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);
		CC2500_Strobe(CC2500_SFRX);        
		FRSKYD_data_frame();
		CC2500_WriteData(packet, packet[0]+1);
		state++;
	}				
	return state == FRSKY_DATA4 ? 7500 : 9000;		
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyL_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */


#if defined(FRSKYL_CC2500_INO)

#include "iface_cc2500.h"

//#define FRSKYL_FORCE_ID
#define FRSKYL_PACKET_LEN	256
#define FRSKYL_PERIOD		18000

uint8_t FrSkyL_buffer[FRSKYL_PACKET_LEN];

static void __attribute__((unused)) FrSkyL_build_bind_packet()
{
	//Header
	packet[0] = 0x4E;				// Unknown but constant
	//Bind packet
	memset(&packet[1],0x00,3);
	//ID
	packet[4 ] = rx_tx_addr[3];		// ID
	packet[5 ] = rx_tx_addr[2];		// ID
	int idx = ((state -FRSKY_BIND) % 10) * 5;
	packet[6 ] = idx;
	packet[7 ] = hopping_frequency[idx++];
	packet[8 ] = hopping_frequency[idx++];
	packet[9 ] = hopping_frequency[idx++];
	packet[10] = hopping_frequency[idx++];
	packet[11] = hopping_frequency[idx++];
	packet[12] = rx_tx_addr[1];		// ID or hw ver?
	packet[13] = RX_num;
	packet[14] = 0x00;				// Unknown but constant
	//CRC
	uint16_t lcrc = FrSkyX_crc(&packet[1], 14);
	packet[15] = lcrc >> 8;
	packet[16] = lcrc;
	//Debug
/*	debug("Bind:");
	for(uint8_t i=0;i<17;i++)
		debug(" %02X",packet[i]);
	debugln("");*/
}

static void __attribute__((unused)) FrSkyL_build_packet()
{
	static uint8_t chan_offset=0;
	uint16_t chan_0,chan_1;

	//Header
	packet[0 ] = 0x4E;				// Unknown but constant
	//ID
	packet[1 ] = rx_tx_addr[3];		// ID
	packet[2 ] = rx_tx_addr[2];		// ID
	packet[3 ] = rx_tx_addr[1];		// ID or hw ver?
	//skip_hop
	packet[4 ] = (FrSkyX_chanskip<<6)|hopping_frequency_no; 
	packet[5 ] = FrSkyX_chanskip>>2;
	//Channels
	uint8_t startChan = chan_offset;
	for(uint8_t i = 0; i <9 ; i+=3)
	{//9 bytes of channel data
		chan_0 = FrSkyX_scaleForPXX(startChan,6);
		startChan++;
		//
		chan_1 = FrSkyX_scaleForPXX(startChan,6);
		startChan++;
		//
		packet[6+i] = lowByte(chan_0);									//3 bytes*4
		packet[6+i+1]=(((chan_0>>8) & 0x0F)|(chan_1 << 4));
		packet[6+i+2]=chan_1>>4;
	}
	if(sub_protocol & 0x01 )											//6ch mode only??
		chan_offset = 0 ;
	else
		chan_offset^=0x06;
	//CRC
	uint16_t lcrc = FrSkyX_crc(&packet[1], 14, RX_num);
	packet[15] = lcrc >> 8;
	packet[16] = lcrc;
	//Debug
	/*debug("Norm:");
	for(uint8_t i=0;i<17;i++)
		debug(" %02X",packet[i]);
	debugln("");*/
}

static void __attribute__((unused))  FrSkyL_encode_packet(bool type)
{
	#define FRSKYL_BIT0 0xED
	#define FRSKYL_BIT1 0x712
	
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	uint8_t idx = 0,len=6;
	if(type)
	{//just replace packet content
		idx=66;
		len=17;
	}

	//debugln("Encode:");
	for (uint8_t i = 0; i < len; i++)
	{
		uint8_t tmp=packet[i];
		//debug("%02X =",tmp);
		for(uint8_t j=0;j<8;j++)
		{
			bits <<= 11;
			if(tmp&0x01)
				bits |= FRSKYL_BIT1;
			else
				bits |= FRSKYL_BIT0;
			tmp >>=1;
			bitsavailable += 11;
			while (bitsavailable >= 8) {
				uint32_t bits_tmp=bits>>(bitsavailable-8);
				bitsavailable -= 8;
				FrSkyL_buffer[idx] = bits_tmp;
				//debug(" %02X",FrSkyL_buffer[idx]);
				idx++;
			}
		}
		//debugln("");
	}
}

uint16_t FRSKYL_callback()
{
	static uint8_t written=0, send=0;
	switch(send)
	{
		case 1:
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SFTX);
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, FrSkyL_buffer, 64);
			CC2500_Strobe(CC2500_STX);
			CC2500_Strobe(CC2500_SIDLE);	// This cancels the current transmission???
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, FrSkyL_buffer, 64);
			CC2500_Strobe(CC2500_SFTX);		// This just clears what we've written???
			CC2500_Strobe(CC2500_STX);
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, FrSkyL_buffer, 64);
			written=64;
			send++;
			return 2623;
		case 2:
			len=FRSKYL_PACKET_LEN-written;
			if(len>31)
				len=31;
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, FrSkyL_buffer+written, len);
			written+=len;
			if(len!=31)			//everything has been sent
			{
				send=0;
				return 2936;
			}
			return 1984;
	}
	
	switch(state)
	{	
		default: 
			//Bind
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(9000);
			#endif
			FrSkyX_set_start(47);
			CC2500_SetPower();
			CC2500_Strobe(CC2500_SFRX);
			//		
			FrSkyL_build_bind_packet();
			FrSkyL_encode_packet(true);

			CC2500_Strobe(CC2500_SIDLE);
			if(IS_BIND_DONE)
				state = FRSKY_BIND_DONE;
			else
			{
				state++;
				send=1;
			}
			return 537;
		case FRSKY_BIND_DONE:
			FrSkyX_initialize_data(0);
			hopping_frequency_no=0;
			BIND_DONE;
			state++;													//FRSKY_DATA1
			break;

		case FRSKY_DATA1:
			CC2500_SetFreqOffset();
			FrSkyX_set_start(hopping_frequency_no);
			FrSkyL_build_packet();
			FrSkyL_encode_packet(true);
			CC2500_SetPower();
			hopping_frequency_no = (hopping_frequency_no+FrSkyX_chanskip)%47;
			send=1;
			return 537;
	}		
	return 1;		
}

void FRSKYL_init()
{
	set_rx_tx_addr(MProtocol_id_master);
	rx_tx_addr[1]=0x02;		// ID related, hw version?

	#ifdef FRSKYL_FORCE_ID
		rx_tx_addr[3]=0x0E;
		rx_tx_addr[2]=0x1C;
		rx_tx_addr[1]=0x02;
	#endif
	FrSkyX2_init_hop();
	
	while(!FrSkyX_chanskip)
		FrSkyX_chanskip=random(0xfefefefe)%47;

	FrSkyX_RF_init();

	//Prepare frame
	memset(FrSkyL_buffer,0x00,FRSKYL_PACKET_LEN-3);
	memset(&FrSkyL_buffer[FRSKYL_PACKET_LEN-3],0x55,3);
	memset(packet,0xAA,6);
	FrSkyL_encode_packet(false);
	/*debugln("Frame:");
	for(uint16_t i=0;i<FRSKYL_PACKET_LEN;i++)
	{
		debug(" %02X",FrSkyL_buffer[i]);
		if(i%11==10)
			debugln("");
	}
	debugln("");*/
	
	if(IS_BIND_IN_PROGRESS)
	{	   
		state = FRSKY_BIND;
		FrSkyX_initialize_data(1);
	}
	else
	{
		state = FRSKY_DATA1;
		FrSkyX_initialize_data(0);
	}
}	
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyR9_sx1276.ino"
#if defined(FRSKYR9_SX1276_INO)
#include "iface_sx1276.h"

#define DISP_FREQ_TABLE

#define FLEX_FREQ	29
#define FCC_FREQ	43
#define EU_FREQ		19

enum {
	FRSKYR9_FREQ=0,
	FRSKYR9_DATA,
	FRSKYR9_RX1,
	FRSKYR9_RX2,
};

void FrSkyR9_set_frequency()
{
	uint8_t data[3];
	uint16_t num=0;
	hopping_frequency_no += FrSkyX_chanskip;
	switch(sub_protocol & 0xFD)
	{
		case R9_868:
			if(IS_BIND_DONE)							// if bind is in progress use R9_915 instead
			{
				hopping_frequency_no %= FLEX_FREQ;
				num=hopping_frequency_no;
				if(hopping_frequency_no>=FLEX_FREQ-2)
					num+=FrSkyX_chanskip-FLEX_FREQ+2;	// the last 2 values are FrSkyX_chanskip and FrSkyX_chanskip+1
				num <<= 5;
				num += 0xD700;
				break;
			}//else use R9_915
		case R9_915:
			hopping_frequency_no %= FLEX_FREQ;
			num=hopping_frequency_no;
			if(hopping_frequency_no>=FLEX_FREQ-2)
				num+=FrSkyX_chanskip-FLEX_FREQ+2;		// the last 2 values are FrSkyX_chanskip and FrSkyX_chanskip+1
			num <<= 5;
			num += 0xE4C0;
			break;
		case R9_FCC:
			hopping_frequency_no %= FCC_FREQ;
			num=hopping_frequency_no;
			num <<= 5;
			num += 0xE200;
			break;
		case R9_EU:
			hopping_frequency_no %= EU_FREQ;
			num=hopping_frequency_no;
			num <<= 4;
			num += 0xD7D0;
			break;
	}
	data[0] = num>>8;
	data[1] = num&0xFF;
	data[2] = 0x00;

	#ifdef DISP_FREQ_TABLE
		if(phase==0xFF)
			debugln("F%d=%02X%02X%02X=%lu", hopping_frequency_no, data[0], data[1], data[2], (uint32_t)((data[0]<<16)+(data[1]<<8)+data[2])*61);
	#endif
	SX1276_WriteRegisterMulti(SX1276_06_FRFMSB, data, 3);
}

static void __attribute__((unused)) FrSkyR9_build_packet()
{
	//ID
	packet[0] = rx_tx_addr[1];
	packet[1] = rx_tx_addr[2];
	packet[2] = rx_tx_addr[3];

	//Hopping
	packet[3] = hopping_frequency_no;	// current channel index
	packet[4] = FrSkyX_chanskip;		// step size and last 2 channels start index

	//RX number
	packet[5] = RX_num;					// receiver number from OpenTX

	//Channels
	FrSkyX_channels(6);					// Set packet[6]=failsafe, packet[7]=0?? and packet[8..19]=channels data

	//Bind
	if(IS_BIND_IN_PROGRESS)
	{// 915 0x01=CH1-8_TELEM_ON 0x41=CH1-8_TELEM_OFF 0xC1=CH9-16_TELEM_OFF 0x81=CH9-16_TELEM_ON
		packet[6] = 0x01;				// bind indicator
		if(sub_protocol & 1)
			packet[6] |= 0x20;			// 868
		if(binding_idx&0x01)
			packet[6] |= 0x40;			// telem OFF
		if(binding_idx&0x02)
			packet[6] |= 0x80;			// ch9-16
	}

	//Sequence and send SPort
	FrSkyX_seq_sport(20,23);			//20=RX|TXseq, 21=bytes count, 22&23=data

	//CRC
	uint16_t crc = FrSkyX_crc(packet, 24);
	packet[24] = crc;					// low byte
	packet[25] = crc >> 8;				// high byte
}

static uint8_t __attribute__((unused)) FrSkyR9_CRC8(uint8_t *p, uint8_t l)
{
	uint8_t crc = 0xFF;
	for (uint8_t i = 0; i < l; i++)
    {
		crc = crc ^ p[i];
		for ( uint8_t j = 0; j < 8; j++ ) 
			if ( crc & 0x80 )
			{
				crc <<= 1;
				crc ^= 0x07;
			}
			else
				crc <<= 1;
	}
	return crc;
}

static void __attribute__((unused)) FrSkyR9_build_EU_packet()
{
	//ID
	packet[0] = rx_tx_addr[1];
	packet[1] = rx_tx_addr[2];
	packet[2] = rx_tx_addr[3];

	//Hopping
	packet[3] = FrSkyX_chanskip;		// step size and last 2 channels start index

	//RX number
	packet[4] = RX_num;					// receiver number from OpenTX

	//Channels
	//TODO FrSkyX_channels(5,4);			// Set packet[5]=failsafe and packet[6..11]=4 channels data

	//Bind
	if(IS_BIND_IN_PROGRESS)
	{
		packet[5] = 0x01;				// bind indicator
		if((sub_protocol & 2) == 0)
			packet[5] |= 0x10;			// 16CH
		// if(sub_protocol & 1)
			// packet[5] |= 0x20;			// 868
		if(binding_idx&0x01)
			packet[5] |= 0x40;			// telem OFF
		if(binding_idx&0x02)
			packet[5] |= 0x80;			// ch9-16
	}

	//Sequence and send SPort
	packet[12] = (FrSkyX_RX_Seq << 4)|0x08;	//TX=8 at startup

	//CRC
	packet[13] = FrSkyR9_CRC8(packet, 13);
}

void FRSKYR9_init()
{
	//Check frequencies
	#ifdef DISP_FREQ_TABLE
		phase=0xFF;
		FrSkyX_chanskip=1;
		hopping_frequency_no=0xFF;
		for(uint8_t i=0;i<FCC_FREQ;i++)
			FrSkyR9_set_frequency();
	#endif

	//Reset ID
	set_rx_tx_addr(MProtocol_id_master);

	//FrSkyX_chanskip
	FrSkyX_chanskip = 1 + (random(0xfefefefe) % 24);
	debugln("chanskip=%d", FrSkyX_chanskip);
	
	//Set FrSkyFormat
	if((sub_protocol & 0x02) == 0)
		FrSkyFormat=0;											// 16 channels
	else
		FrSkyFormat=1;											// 8 channels
	debugln("%dCH", FrSkyFormat&1 ? 8:16);
	
	//EU packet length
	if( (sub_protocol & 0xFD) == R9_EU )
		packet_length=14;
	else
		packet_length=26;

	//SX1276 Init
	SX1276_SetMode(true, false, SX1276_OPMODE_SLEEP);
	SX1276_SetMode(true, false, SX1276_OPMODE_STDBY);

	// uint8_t buffer[2];
	// buffer[0] = 0x00;
	// buffer[1] = 0x00;
	// SX1276_WriteRegisterMulti(SX1276_40_DIOMAPPING1, buffer, 2);

	SX1276_SetDetectOptimize(true, SX1276_DETECT_OPTIMIZE_SF6);
	SX1276_ConfigModem1(SX1276_MODEM_CONFIG1_BW_500KHZ, SX1276_MODEM_CONFIG1_CODING_RATE_4_5, true);
	SX1276_ConfigModem2(6, false, false);
	SX1276_ConfigModem3(false, false);
	SX1276_SetPreambleLength(9);
	SX1276_SetDetectionThreshold(SX1276_MODEM_DETECTION_THRESHOLD_SF6);
	SX1276_SetLna(1, true);
	SX1276_SetHopPeriod(0);										// 0 = disabled, we hop frequencies manually
	//RF Power
	SX1276_SetPaDac(false);										// Disable 20dBm mode
	#if MULTI_5IN1_INTERNAL == JP_T18
		SX1276_SetPaConfig(true, 7, 0);							// Lowest power for the T18: 2dBm
	#else
		SX1276_SetPaConfig(true, 7, option);					// Use PA_HP on PA_BOOST, power=17-(15-option) dBm with option equal or lower to 15
	#endif
	SX1276_SetOcp(true,27);										// Set OCP to max 240mA
	SX1276_SetTxRxMode(TX_EN);									// Set RF switch to TX
	//Enable all IRQ flags
	SX1276_WriteReg(SX1276_11_IRQFLAGSMASK,0x00);
	FrSkyX_telem_init();
	
	hopping_frequency_no=0;
	phase=FRSKYR9_FREQ;
}

uint16_t FRSKYR9_callback()
{
	switch (phase)
	{
		case FRSKYR9_FREQ:
			//Force standby
			SX1276_SetMode(true, false, SX1276_OPMODE_STDBY);
			//Set frequency
			FrSkyR9_set_frequency(); 							// Set current center frequency
			//Set power
			// max power: 15dBm (10.8 + 0.6 * MaxPower [dBm])
			// output_power: 2 dBm ( (if pa_boost_pin == true))
			#if MULTI_5IN1_INTERNAL != JP_T18
				if(option != prev_option)
				{	// Set RF power if it has changed
					SX1276_SetPaConfig(true, 7, option);		// Use PA_HP on PA_BOOST, power=17-(15-option) dBm with option equal or lower to 15
					prev_option = option;
				}
			#endif
			//Build packet
			if( packet_length == 26 )
				FrSkyR9_build_packet();
			else
				FrSkyR9_build_EU_packet();
			phase++;
			return 460;											// Frequency settle time
		case FRSKYR9_DATA:
			//Set RF switch to TX
			SX1276_SetTxRxMode(TX_EN);
			//Send packet
			SX1276_WritePayloadToFifo(packet, packet_length);
			SX1276_SetMode(true, false, SX1276_OPMODE_TX);
#if not defined TELEMETRY
			phase=FRSKYR9_FREQ;
			return 20000-460;
#else
			phase++;
			return 11140;										// Packet send time
		case FRSKYR9_RX1:
			//Force standby
			SX1276_SetMode(true, false, SX1276_OPMODE_STDBY);
			//RX packet size is 13
			SX1276_WriteReg(SX1276_22_PAYLOAD_LENGTH, 13);
			//Reset pointer
			SX1276_WriteReg(SX1276_0D_FIFOADDRPTR, 0x00);
			//Set RF switch to RX
			SX1276_SetTxRxMode(RX_EN);
			//Clear all IRQ flags
			SX1276_WriteReg(SX1276_12_REGIRQFLAGS,0xFF);
			//Switch to RX
			SX1276_WriteReg(SX1276_01_OPMODE, 0x85);
			phase++;
			return 7400;
		case FRSKYR9_RX2:
			if( (SX1276_ReadReg(SX1276_12_REGIRQFLAGS)&0xF0) == (_BV(SX1276_REGIRQFLAGS_RXDONE) | _BV(SX1276_REGIRQFLAGS_VALIDHEADER)) )
			{
				if(SX1276_ReadReg(SX1276_13_REGRXNBBYTES)==13)
				{
					SX1276_ReadRegisterMulti(SX1276_00_FIFO,packet_in,13);
					if( packet_in[9]==rx_tx_addr[1] && packet_in[10]==rx_tx_addr[2] && FrSkyX_crc(packet_in, 11, rx_tx_addr[1]+(rx_tx_addr[2]<<8))==(packet_in[11]+(packet_in[12]<<8)) )
					{
						if(packet_in[0]&0x80)
							RX_RSSI=packet_in[0]<<1;
						else
							v_lipo1=(packet_in[0]<<1)+1;
						//TX_LQI=~(SX1276_ReadReg(SX1276_19_PACKETSNR)>>2)+1;
						TX_RSSI=SX1276_ReadReg(SX1276_1A_PACKETRSSI)-157;
						for(uint8_t i=0;i<9;i++)
							packet[4+i]=packet_in[i];			// Adjust buffer to match FrSkyX
						frsky_process_telemetry(packet,len);	// Process telemetry packet
						pps_counter++;
						if(TX_LQI==0)
							TX_LQI++;							// Recover telemetry right away
					}
				}
			}
			if (millis() - pps_timer >= 1000)
			{//1 packet every 20ms
				pps_timer = millis();
				debugln("%d pps", pps_counter);
				TX_LQI = pps_counter<<1;						// Max=100%
				pps_counter = 0;
			}
			if(TX_LQI==0)
				FrSkyX_telem_init();							// Reset telemetry
			else
				telemetry_link=1;								// Send telemetry out anyway
			phase=FRSKYR9_FREQ;
			break;
#endif
	}
	return 1000;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyV_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(FRSKYV_CC2500_INO)

#define FRSKYV_BIND_COUNT 200

enum {
	FRSKYV_DATA1=0,
	FRSKYV_DATA2,
	FRSKYV_DATA3,
	FRSKYV_DATA4,
	FRSKYV_DATA5
};


#include "iface_cc2500.h"
static uint8_t __attribute__((unused)) FRSKYV_crc8(uint8_t result, uint8_t *data, uint8_t len)
{
	for(uint8_t i = 0; i < len; i++)
	{
		result = result ^ data[i];
		for(uint8_t j = 0; j < 8; j++)
			if(result & 0x80)
				result = (result << 1) ^ 0x07;
			else
				result = result << 1;
	}
	return result;
}

static uint8_t __attribute__((unused)) FRSKYV_crc8_le(uint8_t *data, uint8_t len)
{
	uint8_t result = 0xD6;

	for(uint8_t i = 0; i < len; i++)
	{
		result = result ^ data[i];
		for(uint8_t j = 0; j < 8; j++)
			if(result & 0x01)
				result = (result >> 1) ^ 0x83;
			else
				result = result >> 1;
	}
	return result;
}

static void __attribute__((unused)) FRSKYV_build_bind_packet()
{
    //0e 03 01 57 12 00 06 0b 10 15 1a 00 00 00 61
    packet[0] = 0x0e;                //Length
    packet[1] = 0x03;                //Packet type
    packet[2] = 0x01;                //Packet type
    packet[3] = rx_tx_addr[3];
    packet[4] = rx_tx_addr[2];
    packet[5] = (binding_idx % 10) * 5;
    packet[6] = packet[5] * 5 + 6;
    packet[7] = packet[5] * 5 + 11;
    packet[8] = packet[5] * 5 + 16;
    packet[9] = packet[5] * 5 + 21;
    packet[10] = packet[5] * 5 + 26;
    packet[11] = 0x00;
    packet[12] = 0x00;
    packet[13] = 0x00;
    packet[14] = FRSKYV_crc8(0x93, packet, 14);
}

static uint8_t __attribute__((unused)) FRSKYV_calc_channel()
{
	uint32_t temp=seed;
	temp = (temp * 0xaa) % 0x7673;
	seed = temp;
	return (seed & 0xff) % 0x32;
}

static void __attribute__((unused)) FRSKYV_build_data_packet()
{
	uint8_t idx = 0;			// transmit lower channels
	
	packet[0] = 0x0e;
	packet[1] = rx_tx_addr[3];
	packet[2] = rx_tx_addr[2];
	packet[3] = seed & 0xff;
	packet[4] = seed >> 8;
	if (phase == FRSKYV_DATA1 || phase == FRSKYV_DATA3)
		packet[5] = 0x0f;
	else
		if(phase == FRSKYV_DATA2 || phase == FRSKYV_DATA4)
		{
			packet[5] = 0xf0;
			idx=4;				// transmit upper channels
		}
		else
			packet[5] = 0x00;
	for(uint8_t i = 0; i < 4; i++)
	{
		uint16_t value = convert_channel_frsky(i+idx);
		packet[2*i + 6] = value & 0xff;
		packet[2*i + 7] = value >> 8;
	}
	packet[14] = FRSKYV_crc8(crc8, packet, 14);
}

uint16_t FRSKYV_callback(void)
{
	if(IS_BIND_DONE)
	{	// Normal operation
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(9006);
		#endif
		uint8_t chan = FRSKYV_calc_channel();
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_SetFreqOffset();
		CC2500_WriteReg(CC2500_0A_CHANNR, chan * 5 + 6);
		FRSKYV_build_data_packet();

		if (phase == FRSKYV_DATA5)
		{
			CC2500_SetPower();
			phase = FRSKYV_DATA1;
		}
		else
			phase++;

		CC2500_WriteData(packet, packet[0]+1);
		return 9006;
	}
	// Bind mode
	FRSKYV_build_bind_packet();
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, 0x00);
	CC2500_WriteData(packet, packet[0]+1);
	binding_idx++;
	if(binding_idx>=FRSKYV_BIND_COUNT)
		BIND_DONE;
	return 53460;
}

void FRSKYV_init(void)
{
	//ID is 15 bits. Using rx_tx_addr[2] and rx_tx_addr[3] since we want to use RX_Num for model match
	rx_tx_addr[2]&=0x7F;
	crc8 = FRSKYV_crc8_le(rx_tx_addr+2, 2);

	FRSKY_init_cc2500(FRSKYV_cc2500_conf);
	seed = 1;
	binding_idx=0;
	phase = FRSKYV_DATA1;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSkyX_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(FRSKYX_CC2500_INO)

#include "iface_cc2500.h"

static void __attribute__((unused)) FrSkyX_build_bind_packet()
{
	//Header
	packet[0] = packet_length;				// Number of bytes in the packet (after this one)
	packet[1] = 0x03;						// Bind packet
	packet[2] = 0x01;						// Bind packet

	//ID
	packet[3] = rx_tx_addr[3];				// ID
	packet[4] = rx_tx_addr[2];				// ID

	if(protocol==PROTO_FRSKYX)
	{
		int idx = ((state -FRSKY_BIND) % 10) * 5;
		packet[5] = idx;
		packet[6] = hopping_frequency[idx++];
		packet[7] = hopping_frequency[idx++];
		packet[8] = hopping_frequency[idx++];
		packet[9] = hopping_frequency[idx++];
		packet[10] = hopping_frequency[idx++];
		packet[11] = rx_tx_addr[1];			// ID
		packet[12] = RX_num;
		//
		memset(&packet[13], 0, packet_length - 14);
		if(binding_idx&0x01)
			memcpy(&packet[13],(void *)"\x55\xAA\x5A\xA5",4);	// Telem off
		if(binding_idx&0x02)
			memcpy(&packet[17],(void *)"\x55\xAA\x5A\xA5",4);	// CH9-16
	}
	else
	{
		//packet 1D 03 01 0E 1C 02 00 00 32 0B 00 00 A8 26 28 01 A1 00 00 00 3E F6 87 C7 00 00 00 00 C9 C9
		//Unknown bytes
		if(state & 0x01)
			memcpy(&packet[7],"\x00\xCC\x00\x00\x00\x70\x14\x15\x00\xD3\x08\x00\x00\xCE\xE2\x85\xC7\x00\x00\x00\x00",21);
		else
			memcpy(&packet[7],"\x27\xFB\x00\x00\x00\xBC\xEF\x19\x00\x26\x07\x00\x00\xB7\xED\x85\xC7\xA7\xA7\xA7\xA7",21);
		//ID
		packet[5] = rx_tx_addr[1];			// ID
		packet[6] = RX_num;
		//Bind flags
		if(binding_idx&0x01)
			packet[7] |= 0x40;				// Telem off
		if(binding_idx&0x02)
			packet[7] |= 0x80;				// CH9-16
		//Replace the ID
		packet[20] ^= rx_tx_addr[3]; 		// Update the ID
		packet[21] ^= rx_tx_addr[2]; 		// Update the ID
		packet[22] ^= rx_tx_addr[1] & 0x3F;	// Update the ID
		//Xor
		for(uint8_t i=3; i<packet_length-1; i++)
			packet[i] ^= 0xA7;
	}
	//CRC
	uint16_t lcrc = FrSkyX_crc(&packet[3], packet_length-4);
	packet[packet_length-1] = lcrc >> 8;
	packet[packet_length]   = lcrc;

	/*//Debug
	debug("Bind:");
	for(uint8_t i=0;i<=packet_length;i++)
		debug(" %02X",packet[i]);
	debugln("");*/
}

static void __attribute__((unused)) FrSkyX_build_packet()
{
	//0x1D 0xB3 0xFD 0x02 0x56 0x07 0x15 0x00 0x00 0x00 0x04 0x40 0x00 0x04 0x40 0x00 0x04 0x40 0x00 0x04 0x40 0x08 0x00 0x00 0x00 0x00 0x00 0x00 0x96 0x12
    // data frames sent every 9ms; failsafe every 9 seconds
	//
	//Header
	packet[0] = packet_length;			// Number of bytes in the packet (after this one)
	packet[1] = rx_tx_addr[3];			// ID
	packet[2] = rx_tx_addr[2];			// ID
	packet[3] = rx_tx_addr[1];			// Unknown but constant ID?
	//  
	packet[4] = (FrSkyX_chanskip<<6)|hopping_frequency_no; 
	packet[5] = FrSkyX_chanskip>>2;
	packet[6] = RX_num;

	//Channels
	FrSkyX_channels(7);					// Set packet[7]=failsafe, packet[8]=0?? and packet[9..20]=channels data
	
	//Sequence and send SPort
	FrSkyX_seq_sport(21,packet_length-((protocol==PROTO_FRSKYX && (FrSkyFormat & 2 )) ? 4 : 2)); //21=RX|TXseq, 22=bytes count, 23..packet_length-2=data

	//CRC
	uint16_t lcrc = FrSkyX_crc(&packet[3], packet_length-4);
	packet[packet_length-1] = lcrc >> 8;
	packet[packet_length]   = lcrc;

	/*//Debug
	debug("Norm:");
	for(uint8_t i=0;i<=packet_length;i++)
		debug(" %02X",packet[i]);
	debugln("");*/
}

uint16_t FRSKYX_callback()
{
	#if defined MULTI_EU
		if(sub_protocol == CH_16 || sub_protocol == CH_8)
			return 9000;
	#endif
	switch(state)
	{	
		default: 
			FrSkyX_set_start(47);		
			CC2500_SetPower();
			CC2500_Strobe(CC2500_SFRX);
			//		
			FrSkyX_build_bind_packet();
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_WriteData(packet, packet[0]+1);
			if(IS_BIND_DONE)
				state = FRSKY_BIND_DONE;
			else
				state++;
			break;
		case FRSKY_BIND_DONE:
			FrSkyX_initialize_data(0);
			hopping_frequency_no=0;
			BIND_DONE;
			state++;														//FRSKY_DATA1
			break;

		case FRSKY_DATA1:
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_SetFreqOffset();
			FrSkyX_set_start(hopping_frequency_no);
			FrSkyX_build_packet();
			if(FrSkyFormat & 2)
			{// LBT
				CC2500_Strobe(CC2500_SRX);									//Acquire RSSI
				state++;
				return 400;		// LBT
			}
		case FRSKY_DATA2:
			if(FrSkyFormat & 2)
			{
				uint16_t rssi=0;
				for(uint8_t i=0;i<4;i++)
					rssi += CC2500_ReadReg(CC2500_34_RSSI | CC2500_READ_BURST);	// 0.5 db/count, RSSI value read from the RSSI status register is a 2's complement number
				rssi>>=2;
				#if 0
					uint8_t rssi_level=convert_channel_8b(CH16)>>1;			//CH16 0..127
					if ( rssi > rssi_level && rssi < 128)					//test rssi level dynamically
				#else
					if ( rssi > 14 && rssi < 128)							//if RSSI above -65dBm (12=-70) => ETSI requirement
				#endif
				{
					LBT_POWER_on;											//Reduce to low power before transmitting
					debugln("Busy %d %d",hopping_frequency_no,rssi);
				}
			}
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SFTX);										//Flush the TXFIFO
			CC2500_SetTxRxMode(TX_EN);
			CC2500_SetPower();
			hopping_frequency_no = (hopping_frequency_no+FrSkyX_chanskip)%47;
			CC2500_WriteData(packet, packet[0]+1);
			state=FRSKY_DATA3;
			if(FrSkyFormat & 2)
				return 4000;	// LBT
			else
				return 5200;	// FCC
		case FRSKY_DATA3:
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SFRX);										//Flush the RXFIFO
			CC2500_SetTxRxMode(RX_EN);
			CC2500_Strobe(CC2500_SRX);
			state++;
			if(FrSkyFormat & 2)
				return 4200;	// LBT
			else
				return 3400;	// FCC
		case FRSKY_DATA4:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(9000);
			#endif
			#if defined TELEMETRY
				len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;	
				if (len && len <= 17)										//Telemetry frame is 17 bytes
				{
					//debug("Telem:");
					CC2500_ReadData(packet_in, len);						//Read what has been received so far
					if(len<17)
					{//not all bytes were received
						uint8_t last_len=CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
						if(last_len==17)									//All bytes received
						{
							CC2500_ReadData(packet_in+len, last_len-len);	//Finish to read
							len=17;
						}
					}
					if(len==17 && (protocol==PROTO_FRSKYX || (protocol==PROTO_FRSKYX2 && (packet_in[len-1] & 0x80))) )
					{//Telemetry received with valid crc for FRSKYX2
						//Debug
						//for(uint8_t i=0;i<len;i++)
						//	debug(" %02X",packet_in[i]);
						if(frsky_process_telemetry(packet_in,len))			//Check and process telemetry packet
						{//good packet received
							pps_counter++;
							if(TX_LQI==0)
								TX_LQI++;									//Recover telemetry right away
						}
					}
					//debugln("");
				}
				if (millis() - pps_timer >= 900)
				{//1 packet every 9ms
					pps_timer = millis();
					debugln("%d pps", pps_counter);
					TX_LQI = pps_counter;									//Max=100%
					pps_counter = 0;
				}
				if(TX_LQI==0)
					FrSkyX_telem_init();									//Reset telemetry
				else
					telemetry_link=1;										//Send telemetry out anyway
			#endif
			state = FRSKY_DATA1;
			return 400;	// FCC & LBT
	}
	return 9000;
}

void FRSKYX_init()
{
	set_rx_tx_addr(MProtocol_id_master);
	FrSkyFormat = sub_protocol;
	
	if (sub_protocol==XCLONE_16||sub_protocol==XCLONE_8)
		Frsky_init_clone();
	else
	{
		if(protocol==PROTO_FRSKYX)
			Frsky_init_hop();
		else
		{
			#ifdef FRSKYX2_FORCE_ID
				rx_tx_addr[3]=0x0E;
				rx_tx_addr[2]=0x1C;
				FrSkyX_chanskip=18;
			#endif
			FrSkyX2_init_hop();
		}
		rx_tx_addr[1]=0x02;		// ID related, hw version?
	}
	
	if(protocol==PROTO_FRSKYX && (FrSkyFormat & 2 ))
		packet_length = 0x20;	// FrSkyX V1 LBT
	else
		packet_length = 0x1D;

	packet_count=0;
	while(!FrSkyX_chanskip)
		FrSkyX_chanskip=random(0xfefefefe)%47;

	FrSkyX_RF_init();

	if(IS_BIND_IN_PROGRESS)
	{	   
		memset(packet, 0, packet_length);
		state = FRSKY_BIND;
		FrSkyX_initialize_data(1);
	}
	else
		state = FRSKY_BIND_DONE;
	FrSkyX_telem_init();
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/FrSky_Rx_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(FRSKY_RX_CC2500_INO)

#include "iface_cc2500.h" 

 #define FRSKY_RX_D16FCC_LENGTH	0x1D+1
 #define FRSKY_RX_D16LBT_LENGTH	0x20+1
 #define FRSKY_RX_D16v2_LENGTH	0x1D+1
 #define FRSKY_RX_D8_LENGTH		0x11+1
 #define FRSKY_RX_FORMATS		5

enum
{
	FRSKY_RX_D8			=0,
	FRSKY_RX_D16FCC		=1,
	FRSKY_RX_D16LBT		=2,
	FRSKY_RX_D16v2FCC	=3,
	FRSKY_RX_D16v2LBT	=4,
};

enum {
	FRSKY_RX_TUNE_START,
	FRSKY_RX_TUNE_LOW,
	FRSKY_RX_TUNE_HIGH,
	FRSKY_RX_BIND,
	FRSKY_RX_DATA,
};

const PROGMEM uint8_t FRSKY_RX_common_reg[][2] = {
	{CC2500_02_IOCFG0, 0x01},
	{CC2500_18_MCSM0, 0x18},
	{CC2500_07_PKTCTRL1, 0x05},
	{CC2500_3E_PATABLE, 0xFF},
	{CC2500_0C_FSCTRL0, 0},
	{CC2500_0D_FREQ2, 0x5C},
	{CC2500_13_MDMCFG1, 0x23},
	{CC2500_14_MDMCFG0, 0x7A},
	{CC2500_19_FOCCFG, 0x16},
	{CC2500_1A_BSCFG, 0x6C},
	{CC2500_1B_AGCCTRL2, 0x03},
	{CC2500_1C_AGCCTRL1, 0x40},
	{CC2500_1D_AGCCTRL0, 0x91},
	{CC2500_21_FREND1, 0x56},
	{CC2500_22_FREND0, 0x10},
	{CC2500_23_FSCAL3, 0xA9},
	{CC2500_24_FSCAL2, 0x0A},
	{CC2500_25_FSCAL1, 0x00},
	{CC2500_26_FSCAL0, 0x11},
	{CC2500_29_FSTEST, 0x59},
	{CC2500_2C_TEST2, 0x88},
	{CC2500_2D_TEST1, 0x31},
	{CC2500_2E_TEST0, 0x0B},
	{CC2500_03_FIFOTHR, 0x07},
	{CC2500_09_ADDR, 0x03},
};

const PROGMEM uint8_t FRSKY_RX_d16fcc_reg[][2] = {
	{CC2500_17_MCSM1, 0x0C},
	{CC2500_0E_FREQ1, 0x76},
	{CC2500_0F_FREQ0, 0x27},
	{CC2500_06_PKTLEN, 0x1E},
	{CC2500_08_PKTCTRL0, 0x01},
	{CC2500_0B_FSCTRL1, 0x0A},
	{CC2500_10_MDMCFG4, 0x7B},
	{CC2500_11_MDMCFG3, 0x61},
	{CC2500_12_MDMCFG2, 0x13},
	{CC2500_15_DEVIATN, 0x51},
};

const PROGMEM uint8_t FRSKY_RX_d16lbt_reg[][2] = {
	{CC2500_17_MCSM1, 0x0E},
	{CC2500_0E_FREQ1, 0x80},
	{CC2500_0F_FREQ0, 0x00},
	{CC2500_06_PKTLEN, 0x23},
	{CC2500_08_PKTCTRL0, 0x01},
	{CC2500_0B_FSCTRL1, 0x08},
	{CC2500_10_MDMCFG4, 0x7B},
	{CC2500_11_MDMCFG3, 0xF8},
	{CC2500_12_MDMCFG2, 0x03},
	{CC2500_15_DEVIATN, 0x53},
};

const PROGMEM uint8_t FRSKY_RX_d8_reg[][2] = {
	{CC2500_17_MCSM1,    0x0C},
	{CC2500_0E_FREQ1,    0x76},
	{CC2500_0F_FREQ0,    0x27},
	{CC2500_06_PKTLEN,   0x19},
	{CC2500_08_PKTCTRL0, 0x05},
	{CC2500_0B_FSCTRL1,  0x08},
	{CC2500_10_MDMCFG4,  0xAA},
	{CC2500_11_MDMCFG3,  0x39},
	{CC2500_12_MDMCFG2,  0x11},
	{CC2500_15_DEVIATN,  0x42},
};

static uint8_t FRSKY_RX_chanskip;
static int8_t  FRSKY_RX_finetune;
static uint8_t FRSKY_RX_format;

static void __attribute__((unused)) FRSKY_RX_strobe_rx()
{
	 CC2500_Strobe(CC2500_SIDLE);
	 CC2500_Strobe(CC2500_SFRX);
	 CC2500_Strobe(CC2500_SRX);
}

static void __attribute__((unused)) FRSKY_RX_initialise_cc2500() {
	const uint8_t FRSKY_RX_length[] = { FRSKY_RX_D8_LENGTH, FRSKY_RX_D16FCC_LENGTH, FRSKY_RX_D16LBT_LENGTH, FRSKY_RX_D16v2_LENGTH, FRSKY_RX_D16v2_LENGTH };
	packet_length = FRSKY_RX_length[FRSKY_RX_format];
	CC2500_Reset();
	CC2500_Strobe(CC2500_SIDLE);
	for (uint8_t i = 0; i < sizeof(FRSKY_RX_common_reg) / 2; i++)
		CC2500_WriteReg(pgm_read_byte_near(&FRSKY_RX_common_reg[i][0]), pgm_read_byte_near(&FRSKY_RX_common_reg[i][1]));

	switch (FRSKY_RX_format)
	{
		case FRSKY_RX_D16v2FCC:
		case FRSKY_RX_D16FCC:
			for (uint8_t i = 0; i < sizeof(FRSKY_RX_d16fcc_reg) / 2; i++)
				CC2500_WriteReg(pgm_read_byte_near(&FRSKY_RX_d16fcc_reg[i][0]), pgm_read_byte_near(&FRSKY_RX_d16fcc_reg[i][1]));
			if(FRSKY_RX_format==FRSKY_RX_D16v2FCC)
			{
				CC2500_WriteReg(CC2500_08_PKTCTRL0, 0x05);	// Enable CRC
				CC2500_WriteReg(CC2500_17_MCSM1, 0x0E);		// Go/Stay in RX mode
				CC2500_WriteReg(CC2500_11_MDMCFG3, 0x84);	// bitrate 70K->77K
			}
			break;
		case FRSKY_RX_D16v2LBT:
		case FRSKY_RX_D16LBT:
			for (uint8_t i = 0; i < sizeof(FRSKY_RX_d16lbt_reg) / 2; i++)
				CC2500_WriteReg(pgm_read_byte_near(&FRSKY_RX_d16lbt_reg[i][0]), pgm_read_byte_near(&FRSKY_RX_d16lbt_reg[i][1]));
			if(FRSKY_RX_format==FRSKY_RX_D16v2LBT)
				CC2500_WriteReg(CC2500_08_PKTCTRL0, 0x05);	// Enable CRC
			break;
		case FRSKY_RX_D8:
			for (uint8_t i = 0; i < sizeof(FRSKY_RX_d8_reg) / 2; i++)
				CC2500_WriteReg(pgm_read_byte_near(&FRSKY_RX_d8_reg[i][0]), pgm_read_byte_near(&FRSKY_RX_d8_reg[i][1]));
			CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);
			break;
	}
	CC2500_WriteReg(CC2500_0A_CHANNR, 0);  // bind channel
	rx_disable_lna = IS_POWER_FLAG_on;
	CC2500_SetTxRxMode(rx_disable_lna ? TXRX_OFF : RX_EN); // lna disable / enable
	FRSKY_RX_strobe_rx();
	delayMicroseconds(1000); // wait for RX to activate
}

static void __attribute__((unused)) FRSKY_RX_set_channel(uint8_t channel)
{
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[channel]);
	if(FRSKY_RX_format == FRSKY_RX_D8)
		CC2500_WriteReg(CC2500_23_FSCAL3, 0x89);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[channel]);
	FRSKY_RX_strobe_rx();
}

static void __attribute__((unused)) FRSKY_RX_calibrate()
{
	FRSKY_RX_strobe_rx();
	for (unsigned c = 0; c < 47; c++)
	{
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[c]);
		CC2500_Strobe(CC2500_SCAL);
		delayMicroseconds(900);
		calData[c] = CC2500_ReadReg(CC2500_25_FSCAL1);
	}
}

static uint8_t __attribute__((unused)) frskyx_rx_check_crc_id(bool bind,bool init)
{
	/*debugln("RX");
	for(uint8_t i=0; i<packet_length;i++)
		debug(" %02X",packet[i]);
	debugln("");*/
	
	if(bind && packet[0]!=packet_length-1 && packet[1] !=0x03 && packet[2] != 0x01)
		return false;
	uint8_t offset=bind?3:1;
	
	// Check D8 checksum
	if (FRSKY_RX_format == FRSKY_RX_D8)
	{
		if((packet[packet_length+1] & 0x80) != 0x80)	// Check CRC_OK flag in status byte 2
			return false; 								// Bad CRC
		if(init)
		{//Save TXID
			rx_tx_addr[3] = packet[3];
			rx_tx_addr[2] = packet[4];
			rx_tx_addr[1] = packet[17];
		}
		else
			if(rx_tx_addr[3] != packet[offset] || rx_tx_addr[2] != packet[offset+1] || rx_tx_addr[1] != packet[bind?17:5])
				return false;							// Bad address
		return true;									// Full match
	}

	// Check D16v2 checksum
	if (FRSKY_RX_format == FRSKY_RX_D16v2LBT || FRSKY_RX_format == FRSKY_RX_D16v2FCC)
		if((packet[packet_length+1] & 0x80) != 0x80)	// Check CRC_OK flag in status byte 2
			return false;
	//debugln("HW Checksum ok");

	// Check D16 checksum
	uint16_t lcrc = FrSkyX_crc(&packet[3], packet_length - 5);		// Compute crc
	uint16_t rcrc = (packet[packet_length-2] << 8) | (packet[packet_length-1] & 0xff);	// Received crc
	if(lcrc != rcrc)
		return false; 									// Bad CRC
	//debugln("Checksum ok");

	if (bind && (FRSKY_RX_format == FRSKY_RX_D16v2LBT || FRSKY_RX_format == FRSKY_RX_D16v2FCC))
		for(uint8_t i=3; i<packet_length-2; i++)		//unXOR bind packet
			packet[i] ^= 0xA7;
	
	uint8_t offset2=0;
	if (bind && (FRSKY_RX_format == FRSKY_RX_D16LBT || FRSKY_RX_format == FRSKY_RX_D16FCC))
		offset2=6;
	if(init)
	{//Save TXID
		rx_tx_addr[3] = packet[3];
		rx_tx_addr[2] = packet[4];
		rx_tx_addr[1] = packet[5+offset2];
		rx_tx_addr[0] = packet[6+offset2];				// RXnum
	}
	else
		if(rx_tx_addr[3] != packet[offset] || rx_tx_addr[2] != packet[offset+1] || rx_tx_addr[1] != packet[offset+2+offset2])
			return false;								// Bad address
	//debugln("Address ok");
	
	if(!bind && rx_tx_addr[0] != packet[6])
		return false;									// Bad RX num
	
	//debugln("Match");
	return true;										// Full match
}

static void __attribute__((unused)) FRSKY_RX_build_telemetry_packet()
{
	uint16_t raw_channel[8];
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	uint8_t idx = 0;
	uint8_t i;

	if (FRSKY_RX_format == FRSKY_RX_D8)
	{// decode D8 channels
		raw_channel[0] = ((packet[10] & 0x0F) << 8 | packet[6]);
		raw_channel[1] = ((packet[10] & 0xF0) << 4 | packet[7]);
		raw_channel[2] = ((packet[11] & 0x0F) << 8 | packet[8]);
		raw_channel[3] = ((packet[11] & 0xF0) << 4 | packet[9]);
		raw_channel[4] = ((packet[16] & 0x0F) << 8 | packet[12]);
		raw_channel[5] = ((packet[16] & 0xF0) << 4 | packet[13]);
		raw_channel[6] = ((packet[17] & 0x0F) << 8 | packet[14]);
		raw_channel[7] = ((packet[17] & 0xF0) << 4 | packet[15]);
		for (i = 0; i < 8; i++) {
			if (raw_channel[i] < 1290)
				raw_channel[i] = 1290;
			rx_rc_chan[i] = min(((raw_channel[i] - 1290) << 4) / 15, 2047);
		}
	}
	else
	{// decode D16 channels
		raw_channel[0] = ((packet[10] << 8) & 0xF00) | packet[9];
		raw_channel[1] = ((packet[11] << 4) & 0xFF0) | (packet[10] >> 4);
		raw_channel[2] = ((packet[13] << 8) & 0xF00) | packet[12];
		raw_channel[3] = ((packet[14] << 4) & 0xFF0) | (packet[13] >> 4);
		raw_channel[4] = ((packet[16] << 8) & 0xF00) | packet[15];
		raw_channel[5] = ((packet[17] << 4) & 0xFF0) | (packet[16] >> 4);
		raw_channel[6] = ((packet[19] << 8) & 0xF00) | packet[18];
		raw_channel[7] = ((packet[20] << 4) & 0xFF0) | (packet[19] >> 4);	
		for (i = 0; i < 8; i++) {
			// ignore failsafe channels
			if(packet[7] != 0x10+(i<<1)) {
				uint8_t shifted = (raw_channel[i] & 0x800)>0;
				uint16_t channel_value = raw_channel[i] & 0x7FF;
				if (channel_value < 64)
					rx_rc_chan[shifted ? i + 8 : i] = 0;
				else
					rx_rc_chan[shifted ? i + 8 : i] = min(((channel_value - 64) << 4) / 15, 2047);
			}
		}
	}

	// buid telemetry packet
	packet_in[idx++] = RX_LQI;
	packet_in[idx++] = RX_RSSI;
	packet_in[idx++] = 0;  // start channel
	packet_in[idx++] = FRSKY_RX_format == FRSKY_RX_D8 ? 8 : 16; // number of channels in packet

	// pack channels
	for (i = 0; i < packet_in[3]; i++) {
		bits |= ((uint32_t)rx_rc_chan[i]) << bitsavailable;
		bitsavailable += 11;
		while (bitsavailable >= 8) {
			packet_in[idx++] = bits & 0xff;
			bits >>= 8;
			bitsavailable -= 8;
		}
	}
}

static void __attribute__((unused)) FRSKY_RX_data()
{
	uint16_t temp = FRSKY_RX_EEPROM_OFFSET;
	FRSKY_RX_format = eeprom_read_byte((EE_ADDR)temp++) % FRSKY_RX_FORMATS;
	rx_tx_addr[3] = eeprom_read_byte((EE_ADDR)temp++);
	rx_tx_addr[2] = eeprom_read_byte((EE_ADDR)temp++);
	rx_tx_addr[1] = eeprom_read_byte((EE_ADDR)temp++);
	rx_tx_addr[0] = RX_num;
	FRSKY_RX_finetune = eeprom_read_byte((EE_ADDR)temp++);
	debug("format=%d, ", FRSKY_RX_format);
	debug("addr[3]=%02X, ", rx_tx_addr[3]);
	debug("addr[2]=%02X, ", rx_tx_addr[2]);
	debug("addr[1]=%02X, ", rx_tx_addr[1]);
	debug("rx_num=%02X, ",  rx_tx_addr[0]);
	debugln("tune=%d", (int8_t)FRSKY_RX_finetune);
	if(FRSKY_RX_format != FRSKY_RX_D16v2LBT && FRSKY_RX_format != FRSKY_RX_D16v2FCC)
	{//D8 & D16v1
		for (uint8_t ch = 0; ch < 47; ch++)
			hopping_frequency[ch] = eeprom_read_byte((EE_ADDR)temp++);
	}
	else
	{
		FrSkyFormat=FRSKY_RX_format == FRSKY_RX_D16v2FCC?0:2;
		FrSkyX2_init_hop();
	}
	debug("ch:");
	for (uint8_t ch = 0; ch < 47; ch++)
		debug(" %02X", hopping_frequency[ch]);
	debugln("");

	FRSKY_RX_initialise_cc2500();
	FRSKY_RX_calibrate();
	CC2500_WriteReg(CC2500_18_MCSM0, 0x08); // FS_AUTOCAL = manual
	CC2500_WriteReg(CC2500_09_ADDR, rx_tx_addr[3]); // set address
	CC2500_WriteReg(CC2500_07_PKTCTRL1, 0x05); // check address
	if (option == 0)
		CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
	else
		CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	FRSKY_RX_set_channel(hopping_frequency_no);
	phase = FRSKY_RX_DATA;
}

void FRSKY_RX_init()
{
	if(sub_protocol == FRSKY_ERASE)
	{
		if(IS_BIND_IN_PROGRESS)
		{// Clear all cloned addresses
			uint16_t addr[]={ FRSKYD_CLONE_EEPROM_OFFSET+1, FRSKYX_CLONE_EEPROM_OFFSET+1, FRSKYX2_CLONE_EEPROM_OFFSET+1 };
			for(uint8_t i=0; i<3;i++)
				for(uint8_t j=0; j<3;j++)
					eeprom_write_byte((EE_ADDR)(addr[i]+j), 0xFF);
			packet_count = 100;
		}			
	}
	else
	{
		FRSKY_RX_chanskip = 1;
		hopping_frequency_no = 0;
		rx_data_started = false;
		FRSKY_RX_finetune = 0;
		telemetry_link = 0;
		packet_count = 0;
		if (IS_BIND_IN_PROGRESS)
		{
			FRSKY_RX_format = FRSKY_RX_D8;
			FRSKY_RX_initialise_cc2500();
			phase = FRSKY_RX_TUNE_START;
			debugln("FRSKY_RX_TUNE_START");
		}
		else
			FRSKY_RX_data();
	}
}

uint16_t FRSKY_RX_callback()
{
	static int8_t read_retry = 0;
	static int8_t tune_low, tune_high;
	uint8_t len, ch;

	if(sub_protocol == FRSKY_ERASE)
	{
		if(packet_count)
			packet_count--;
		else
			BIND_DONE;
		return 10000;	//  Nothing to do...
	}

	if(IS_BIND_DONE && phase != FRSKY_RX_DATA)
		FRSKY_RX_init();	// Abort bind

	if ((prev_option != option) && (phase >= FRSKY_RX_DATA))
	{
		if (option == 0)
			CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
		else
			CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
		prev_option = option;
	}

	if (rx_disable_lna != IS_POWER_FLAG_on)
	{
		rx_disable_lna = IS_POWER_FLAG_on;
		CC2500_SetTxRxMode(rx_disable_lna ? TXRX_OFF : RX_EN);
	}

	len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
	switch(phase)
	{
		case FRSKY_RX_TUNE_START:
			if (len == packet_length + 2) //+2=RSSI+LQI+CRC
			{
				CC2500_ReadData(packet, len);
				if(frskyx_rx_check_crc_id(true,true))
				{
					FRSKY_RX_finetune = -127;
					CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
					phase = FRSKY_RX_TUNE_LOW;
					debugln("FRSKY_RX_TUNE_LOW");
					FRSKY_RX_strobe_rx();
					state = 0;
					return 1000;
				}
			}
			FRSKY_RX_format = (FRSKY_RX_format + 1) % FRSKY_RX_FORMATS; // switch to next format (D8, D16FCC, D16LBT, D16v2FCC, D16v2LBT)
			FRSKY_RX_initialise_cc2500();
			FRSKY_RX_finetune += 10;
			CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
			FRSKY_RX_strobe_rx();
			return 18000;

		case FRSKY_RX_TUNE_LOW:
			if (len == packet_length + 2) //+2=RSSI+LQI+CRC
			{
				CC2500_ReadData(packet, len);
				if(frskyx_rx_check_crc_id(true,false)) {
					tune_low = FRSKY_RX_finetune;
					FRSKY_RX_finetune = 127;
					CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
					phase = FRSKY_RX_TUNE_HIGH;
					debugln("FRSKY_RX_TUNE_HIGH");
					FRSKY_RX_strobe_rx();
					return 1000;
				}
			}
			FRSKY_RX_finetune += 1;
			CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
			FRSKY_RX_strobe_rx();
			return 18000;

		case FRSKY_RX_TUNE_HIGH:
			if (len == packet_length + 2) //+2=RSSI+LQI+CRC
			{
				CC2500_ReadData(packet, len);
				if(frskyx_rx_check_crc_id(true,false)) {
					tune_high = FRSKY_RX_finetune;
					FRSKY_RX_finetune = (tune_low + tune_high) / 2;
					CC2500_WriteReg(CC2500_0C_FSCTRL0, (int8_t)FRSKY_RX_finetune);
					if(tune_low < tune_high)
					{
						phase = FRSKY_RX_BIND;
						debugln("FRSKY_RX_TUNE_HIGH");
					}
					else
					{
						phase = FRSKY_RX_TUNE_START;
						debugln("FRSKY_RX_TUNE_START");
					}
					FRSKY_RX_strobe_rx();
					return 1000;
				}
			}
			FRSKY_RX_finetune -= 1;
			CC2500_WriteReg(CC2500_0C_FSCTRL0, FRSKY_RX_finetune);
			FRSKY_RX_strobe_rx();
			return 18000;

		case FRSKY_RX_BIND:
			if (len == packet_length + 2) //+2=RSSI+LQI+CRC
			{
				CC2500_ReadData(packet, len);
				if(frskyx_rx_check_crc_id(true,false)) {
					if(FRSKY_RX_format != FRSKY_RX_D16v2LBT && FRSKY_RX_format != FRSKY_RX_D16v2FCC)
					{// D8 & D16v1
						if(packet[5] <= 0x2D)
						{
							for (ch = 0; ch < 5; ch++)
								hopping_frequency[packet[5]+ch] = packet[6+ch];
							state |= 1 << (packet[5] / 5);
						}
					}
					else
						state = 0x3FF; //No hop table for D16v2
					if (state == 0x3FF)
					{
						debugln("Bind complete");
						BIND_DONE;
						// store format, finetune setting, txid, channel list
						uint16_t temp = FRSKY_RX_EEPROM_OFFSET;
						if(sub_protocol==FRSKY_CLONE)
						{
							if(FRSKY_RX_format==FRSKY_RX_D8)
								temp=FRSKYD_CLONE_EEPROM_OFFSET;
							else if(FRSKY_RX_format == FRSKY_RX_D16FCC || FRSKY_RX_format == FRSKY_RX_D16LBT)
								temp=FRSKYX_CLONE_EEPROM_OFFSET;
							else
								temp=FRSKYX2_CLONE_EEPROM_OFFSET;
						}
						eeprom_write_byte((EE_ADDR)temp++, FRSKY_RX_format);
						eeprom_write_byte((EE_ADDR)temp++, rx_tx_addr[3]);
						eeprom_write_byte((EE_ADDR)temp++, rx_tx_addr[2]);
						eeprom_write_byte((EE_ADDR)temp++, rx_tx_addr[1]);
						if(sub_protocol == FRSKY_RX || sub_protocol == FRSKY_CPPM)	// FRSKY_RX, FRSKY_CPPM
							eeprom_write_byte((EE_ADDR)temp++, FRSKY_RX_finetune);
						if(FRSKY_RX_format != FRSKY_RX_D16v2FCC && FRSKY_RX_format != FRSKY_RX_D16v2LBT)
							for (ch = 0; ch < 47; ch++)
								eeprom_write_byte((EE_ADDR)temp++, hopping_frequency[ch]);
						FRSKY_RX_data();
						debugln("FRSKY_RX_DATA");
					}
				}
				FRSKY_RX_strobe_rx();
			}
			return 1000;

		case FRSKY_RX_DATA:
			if (len == packet_length + 2) //+2=RSSI+LQI+CRC
			{
				CC2500_ReadData(packet, len);
				if(frskyx_rx_check_crc_id(false,false))
				{
					RX_RSSI = packet[len-2];
					if(RX_RSSI >= 128)
						RX_RSSI -= 128;
					else
						RX_RSSI += 128;
					bool chanskip_valid=true;
					// hop to next channel
					if (FRSKY_RX_format != FRSKY_RX_D8)
					{//D16v1 & D16v2
						if(rx_data_started)
						{
							if(FRSKY_RX_chanskip != (((packet[4] & 0xC0) >> 6) | ((packet[5] & 0x3F) << 2)))
							{
								chanskip_valid=false;	// chanskip value has changed which surely indicates a bad frame
								packet_count++;
								if(packet_count>5)		// the TX must have changed chanskip...
									FRSKY_RX_chanskip = ((packet[4] & 0xC0) >> 6) | ((packet[5] & 0x3F) << 2);	// chanskip init
							}
							else
								packet_count=0;
						}
						else
							FRSKY_RX_chanskip = ((packet[4] & 0xC0) >> 6) | ((packet[5] & 0x3F) << 2);	// chanskip init
					}
					hopping_frequency_no = (hopping_frequency_no + FRSKY_RX_chanskip) % 47;
					FRSKY_RX_set_channel(hopping_frequency_no);
					if(chanskip_valid)
					{
						if ((telemetry_link & 0x7F) == 0)
						{ // send channels to TX
							FRSKY_RX_build_telemetry_packet();
							telemetry_link = 1;
							#ifdef SEND_CPPM
								if(sub_protocol == FRSKY_CPPM)
									telemetry_link |= 0x80;		// Disable telemetry output
							#endif
						}
						pps_counter++;
					}
					rx_data_started = true;
					read_retry = 0;
				}
			}
			
			// packets per second
			if (millis() - pps_timer >= 1000) {
				pps_timer = millis();
				debugln("%d pps", pps_counter);
				RX_LQI = pps_counter;
				if(pps_counter==0)	// no packets for 1 sec or more...
				{// restart the search
					rx_data_started=false;
					packet_count=0;
				}
				pps_counter = 0;
			}

			// skip channel if no packet received in time
			if (read_retry++ >= 9) {
				hopping_frequency_no = (hopping_frequency_no + FRSKY_RX_chanskip) % 47;
				FRSKY_RX_set_channel(hopping_frequency_no);
				if(rx_data_started)
					read_retry = 0;
				else
					read_retry = -50; // retry longer until first packet is catched
			}
			break;
	}
	return 1000;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Futaba_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with main deviation/sfhss_cc2500.c dated 2016-03-23

#if defined(FUTABA_CC2500_INO)

#include "iface_cc2500.h"

//#define SFHSS_DEBUG_TIMING

#define SFHSS_COARSE	0

#define SFHSS_PACKET_LEN 13
#define SFHSS_TX_ID_LEN   2

uint8_t	fhss_code=0; // 0-27

enum {
    SFHSS_START = 0x00,
    SFHSS_CAL   = 0x01,
    SFHSS_DATA1 = 0x02,
    SFHSS_DATA2 = 0x03,
    SFHSS_TUNE  = 0x04
};

#define SFHSS_FREQ0_VAL 0xC4

// Some important initialization parameters, all others are either default,
// or not important in the context of transmitter
// IOCFG2   2F - GDO2_INV=0 GDO2_CFG=2F - HW0
// IOCFG1   2E - GDO1_INV=0 GDO1_CFG=2E - High Impedance
// IOCFG0   2F - GDO0 same as GDO2, TEMP_SENSOR_ENABLE=off
// FIFOTHR  07 - 33 decimal TX threshold
// SYNC1    D3
// SYNC0    91
// PKTLEN   0D - Packet length, 0D bytes
// PKTCTRL1 04 - APPEND_STATUS on, all other are receive parameters - irrelevant
// PKTCTRL0 0C - No whitening, use FIFO, CC2400 compatibility on, use CRC, fixed packet length
// ADDR     29
// CHANNR   10
// FSCTRL1  06 - IF 152343.75Hz, see page 65
// FSCTRL0  00 - zero freq offset
// FREQ2    5C - synthesizer frequency 2399999633Hz for 26MHz crystal, ibid
// FREQ1    4E
// FREQ0    C4
// MDMCFG4  7C - CHANBW_E - 01, CHANBW_M - 03, DRATE_E - 0C. Filter bandwidth = 232142Hz
// MDMCFG3  43 - DRATE_M - 43. Data rate = 128143bps
// MDMCFG2  83 - disable DC blocking, 2-FSK, no Manchester code, 15/16 sync bits detected (irrelevant for TX)
// MDMCFG1  23 - no FEC, 4 preamble bytes, CHANSPC_E - 03
// MDMCFG0  3B - CHANSPC_M - 3B. Channel spacing = 249938Hz (each 6th channel used, resulting in spacing of 1499628Hz)
// DEVIATN  44 - DEVIATION_E - 04, DEVIATION_M - 04. Deviation = 38085.9Hz
// MCSM2    07 - receive parameters, default, irrelevant
// MCSM1    0C - no CCA (transmit always), when packet received stay in RX, when sent go to IDLE
// MCSM0    08 - no autocalibration, PO_TIMEOUT - 64, no pin radio control, no forcing XTAL to stay in SLEEP
// FOCCFG   1D - not interesting, Frequency Offset Compensation
// FREND0   10 - PA_POWER = 0
const PROGMEM uint8_t SFHSS_init_values[] = {
  /* 00 */ 0x2F, 0x2E, 0x2F, 0x07, 0xD3, 0x91, 0x0D, 0x04,
  /* 08 */ 0x0C, 0x29, 0x10, 0x06, 0x00, 0x5C, 0x4E, SFHSS_FREQ0_VAL + SFHSS_COARSE,
  /* 10 */ 0x7C, 0x43, 0x83, 0x23, 0x3B, 0x44, 0x07, 0x0C,
  /* 18 */ 0x08, 0x1D, 0x1C, 0x43, 0x40, 0x91, 0x57, 0x6B,
  /* 20 */ 0xF8, 0xB6, 0x10, 0xEA, 0x0A, 0x11, 0x11
};

static void __attribute__((unused)) SFHSS_rf_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i < 39; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&SFHSS_init_values[i]));

	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	
	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}

static void __attribute__((unused)) SFHSS_tune_chan()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, rf_ch_num*6+16);
	CC2500_Strobe(CC2500_SCAL);
}

static void __attribute__((unused)) SFHSS_tune_chan_fast()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, rf_ch_num*6+16);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[rf_ch_num]);
}

static void __attribute__((unused)) SFHSS_tune_freq()
{
	if ( prev_option != option )
	{
		CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
		CC2500_WriteReg(CC2500_0F_FREQ0, SFHSS_FREQ0_VAL + SFHSS_COARSE);
		prev_option = option ;
		phase = SFHSS_START;	// Restart the tune process if option is changed to get good tuned values
	}
}

static void __attribute__((unused)) SFHSS_calc_next_chan()
{
    rf_ch_num += fhss_code + 2;
    if (rf_ch_num > 29)
	{
        if (rf_ch_num < 31)
			rf_ch_num += fhss_code + 2;
        rf_ch_num -= 31;
    }
}

// Channel values are 12-bit values between 1020 and 2020, 1520 is the middle.
// Futaba @140% is 2070...1520...970
// Values grow down and to the right.
static void __attribute__((unused)) SFHSS_send_packet()
{
	uint16_t ch[4];
	// command.bit0 is the packet number indicator: =0 -> SFHSS_DATA1, =1 -> SFHSS_DATA2
	// command.bit1 is unknown but seems to be linked to the payload[0].bit0 but more dumps are needed: payload[0]=0x82 -> =0, payload[0]=0x81 -> =1
	// command.bit2 is the failsafe transmission indicator: =0 -> normal data, =1->failsafe data
	// command.bit3 is the channels indicator: =0 -> CH1-4, =1 -> CH5-8
	
	//Coding below matches the Futaba T8J transmission scheme DATA1->CH1-4, DATA2->CH5-8, DATA1->CH5-8, DATA2->CH1-4,...
	// XK, T10J and TM-FH are different with a classic DATA1->CH1-4, DATA2->CH5-8,...
	//Failsafe is sent twice every couple of seconds (unknown but >5s) 
	
	uint8_t command= (phase == SFHSS_DATA1) ? 0 : 1;	// Building packet for Data1 or Data2
	counter+=command;
	#ifdef FAILSAFE_ENABLE
		if( (counter&0x3FC) == 0x3FC && IS_FAILSAFE_VALUES_on)
		{	// Transmit failsafe data twice every 7s
			if( ((counter&1)^(command&1)) == 0 )
				command|=0x04;							// Failsafe
		}
		else
	#endif
			command|=0x02;								// Assuming packet[0] == 0x81
	counter&=0x3FF;										// Reset failsafe counter
	if(counter&1) command|=0x08;						// Transmit lower and upper channels twice in a row

	uint8_t ch_offset = (command&0x08) >> 1;			// CH1..CH4 or CH5..CH8

	#ifdef FAILSAFE_ENABLE
		if(command&0x04)
		{	//Failsafe data are:
			// 0 to 1023 -> no output on channel
			// 1024-2047 -> hold output on channel
			// 2048-4095 -> channel_output=(data&0x3FF)*5/4+880 in s
			// Notes:
			//    2048-2559 -> does not look valid since it only covers the range from 1520s to 2160s 
			//    2560-3583 -> valid for any channel values from 880s to 2160s
			//    3584-4095 -> looks to be used for the throttle channel with values ranging from 880s to 1520s
			for(uint8_t i=0;i<4;i++)
			{
				uint16_t val=Failsafe_data[CH_AETR[ch_offset+i]];
				if(val==FAILSAFE_CHANNEL_HOLD)
					ch[i]=1024;
				else if(val==FAILSAFE_CHANNEL_NOPULSES)
					ch[i]=0;
				else
				{ //Use channel value
					ch[i] = convert_channel_16b_nolimit(CH_AETR[ch_offset+i],3571,2571,true); //3472,2672: not enough throw
				}
			}
		}
		else
	#endif
		{	//Normal data
			for(uint8_t i=0;i<4;i++)
				ch[i] = convert_channel_16b_nolimit(CH_AETR[ch_offset+i],2020,1020,false);
		}

	
	// XK		[0]=0x81 [3]=0x00 [4]=0x00
	// T8J		[0]=0x81 [3]=0x42 [4]=0x07
	// T10J		[0]=0x81 [3]=0x0F [4]=0x09
	// TM-FH	[0]=0x82 [3]=0x9A [4]=0x06
	packet[0] = 0x81;	// can be 80 or 81 for Orange, only 81 for XK
	packet[1] = rx_tx_addr[0];
	packet[2] = rx_tx_addr[1];
	packet[3] = 0x00;	// unknown but prevents some receivers to bind if not 0
	packet[4] = 0x00;	// unknown but prevents some receivers to bind if not 0
	packet[5] = (rf_ch_num << 3) | ((ch[0] >> 9) & 0x07);
	packet[6] = (ch[0] >> 1);
	packet[7] = (ch[0] << 7) | ((ch[1] >> 5) & 0x7F );
	packet[8] = (ch[1] << 3) | ((ch[2] >> 9) & 0x07 );
	packet[9] = (ch[2] >> 1);
	packet[10] = (ch[2] << 7) | ((ch[3] >> 5) & 0x7F );
	packet[11] = (ch[3] << 3) | ((fhss_code >> 2) & 0x07 );
	packet[12] = (fhss_code << 6) | command;

    CC2500_WriteData(packet, SFHSS_PACKET_LEN);
}

uint16_t SFHSS_callback()
{
#ifdef SFHSS_DEBUG_TIMING
	static uint16_t prev_adjust_timing=1024;
	uint16_t adjust_timing = (Channel_data[CH15]>>3) - (1024>>3);	// +-102 @ 100%
#endif

	switch(phase)
	{
		case SFHSS_START:
			rf_ch_num = 0;
			SFHSS_tune_chan();
			phase = SFHSS_CAL;
			return 2000;
		case SFHSS_CAL:
			calData[rf_ch_num]=CC2500_ReadReg(CC2500_25_FSCAL1);
			if (++rf_ch_num < 30)
				SFHSS_tune_chan();
			else
			{
				rf_ch_num = 0;
				counter = 0;
				phase = SFHSS_DATA1;
			}
			return 2000;

		/* Work cycle: 6.8ms */
#define SFHSS_PACKET_PERIOD	6800
#define SFHSS_DATA2_TIMING	1625	// Adjust this value between 1600 and 1650 if your RX(s) are not operating properly
		case SFHSS_DATA1:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(6800);
			#endif
			SFHSS_send_packet();
			phase = SFHSS_DATA2;
#ifdef SFHSS_DEBUG_TIMING
			return SFHSS_DATA2_TIMING - adjust_timing;
#else
			return SFHSS_DATA2_TIMING;								// original 1650
#endif
		case SFHSS_DATA2:
			SFHSS_send_packet();
			SFHSS_calc_next_chan();
			phase = SFHSS_TUNE;
#ifdef SFHSS_DEBUG_TIMING
			if(prev_adjust_timing != adjust_timing)
			{
				debugln("A:%d",(uint16_t)(SFHSS_DATA2_TIMING - adjust_timing));
				prev_adjust_timing = adjust_timing;
			}
			return SFHSS_PACKET_PERIOD -2000 -(SFHSS_DATA2_TIMING - adjust_timing);
#else
			return SFHSS_PACKET_PERIOD -2000 -SFHSS_DATA2_TIMING;	// original 2000
#endif
		case SFHSS_TUNE:
			phase = SFHSS_DATA1;
			SFHSS_tune_freq();
			SFHSS_tune_chan_fast();
			CC2500_SetPower();
			return 2000;											// original 3150
	}
	return 0;
}

// Generate internal id
static void __attribute__((unused)) SFHSS_get_tx_id()
{
	// Some receivers (Orange) behaves better if they tuned to id that has
	//  no more than 6 consecutive zeros and ones
	uint32_t fixed_id;
	uint8_t run_count = 0;
	// add guard for bit count
	fixed_id = 1 ^ (MProtocol_id & 1);
	for (uint8_t i = 0; i < 16; ++i)
	{
		fixed_id = (fixed_id << 1) | (MProtocol_id & 1);
		MProtocol_id >>= 1;
		// If two LS bits are the same
		if ((fixed_id & 3) == 0 || (fixed_id & 3) == 3)
		{
			if (++run_count > 6)
			{
				fixed_id ^= 1;
				run_count = 0;
			}
		}
		else
			run_count = 0;
	}
	//    fixed_id = 0xBC11;
	rx_tx_addr[0] = fixed_id >> 8;
	rx_tx_addr[1] = fixed_id >> 0;
}

void SFHSS_init()
{
	BIND_DONE;	// Not a TX bind protocol
	SFHSS_get_tx_id();

	fhss_code=random(0xfefefefe)%28; // Initialize it to random 0-27 inclusive

	SFHSS_rf_init();
	phase = SFHSS_START;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GD00X_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with GD005 C-17 and GD006 DA62 planes.

#if defined(GD00X_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_GD00X_ORIGINAL_ID

#define GD00X_INITIAL_WAIT    500
#define GD00X_PACKET_PERIOD   3500
#define GD00X_RF_BIND_CHANNEL 2
#define GD00X_RF_NUM_CHANNELS 4
#define GD00X_PAYLOAD_SIZE    15
#define GD00X_BIND_COUNT	  857	//3sec

#define GD00X_V2_BIND_PACKET_PERIOD	5110
#define GD00X_V2_RF_BIND_CHANNEL	0x43
#define GD00X_V2_RF_NUM_CHANNELS	2
#define GD00X_V2_PAYLOAD_SIZE		6

// flags going to packet[11]
#define	GD00X_FLAG_DR		0x08
#define	GD00X_FLAG_LIGHT	0x04

// flags going to packet[4]
#define	GD00X_V2_FLAG_DR	0x40
#define	GD00X_V2_FLAG_LIGHT	0x80

static void __attribute__((unused)) GD00X_send_packet()
{
	static uint8_t prev_CH6=false;

	if(sub_protocol==GD_V1)
	{
		packet[0] = IS_BIND_IN_PROGRESS?0xAA:0x55;
		memcpy(packet+1,rx_tx_addr,4);
		uint16_t channel=convert_channel_ppm(AILERON);
		packet[5 ] = channel;
		packet[6 ] = channel>>8;
		channel=convert_channel_ppm(THROTTLE);
		packet[7 ] = channel;
		packet[8 ] = channel>>8;
		channel=convert_channel_ppm(CH5);		// TRIM
		packet[9 ] = channel;
		packet[10] = channel>>8;
		packet[11] = GET_FLAG(!CH7_SW, GD00X_FLAG_DR)
				   | GET_FLAG(CH6_SW, GD00X_FLAG_LIGHT);
		packet[12] = 0x00;
		packet[13] = 0x00;
		packet[14] = 0x00;
	}
	else
	{//GD_V2
		if(IS_BIND_IN_PROGRESS)
			for(uint8_t i=0; i<5;i++)
				packet[i]=rx_tx_addr[i];
		else
		{
			packet[0]=convert_channel_16b_limit(THROTTLE,0,100);	// 0..100

			// Deadband is needed on aileron, 40 gives +-6%
			packet[1]=convert_channel_8b_limit_deadband(AILERON,0x3F,0x20,0x00,40);	// Aileron: 3F..20..00
			// Trims must be in a seperate channel for this model
			packet[2]=0x3F-(convert_channel_8b(CH5)>>2);			// Trim: 0x3F..0x20..0x00

			uint8_t seq=((packet_count*3)/7)%5;
			packet[4]=seq
					| GET_FLAG(!CH7_SW, GD00X_V2_FLAG_DR);

			if(CH6_SW!=prev_CH6)
			{ // LED switch is temporary
				len=43;
				prev_CH6=CH6_SW;
			}
			if(len)
			{ // Send the light flag for a couple of packets
				packet[4] |= GD00X_V2_FLAG_LIGHT;
				len--;
			}

			packet[3]=(packet[0]+packet[1]+packet[2]+packet[4])^(crc8);

			if( (packet_count%12) == 0 )
				hopping_frequency_no ^= 1;			// Toggle between the 2 frequencies
			packet_count++;
			if(packet_count>34) packet_count=0;		// Full period
			if( seq == (((packet_count*3)/7)%5) )
			{
				if(packet_period==2700)
					packet_period=3000;
				else
					packet_period=2700;
			}
			else
				packet_period=4300;
		}
		packet[5]='D';
	}

	if(IS_BIND_DONE)
	{
		XN297_Hopping(hopping_frequency_no);
		if(sub_protocol==GD_V1)
		{
			hopping_frequency_no++;
			hopping_frequency_no &= GD00X_RF_NUM_CHANNELS-1;	// 4 RF channels
		}
	}

	// Send
	XN297_SetFreqOffset();
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, packet_length);
}

static void __attribute__((unused)) GD00X_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	if(sub_protocol==GD_V1)
		XN297_SetTXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", 5);
	else
		XN297_SetTXAddr((uint8_t*)"GDKNx", 5);
	XN297_HoppingCalib(sub_protocol==GD_V1?GD00X_RF_NUM_CHANNELS:GD00X_V2_RF_NUM_CHANNELS);	// Calibrate all channels
	XN297_RFChannel(sub_protocol==GD_V1?GD00X_RF_BIND_CHANNEL:GD00X_V2_RF_BIND_CHANNEL);		// Set bind channel
}

static void __attribute__((unused)) GD00X_initialize_txid()
{
	if(sub_protocol==GD_V1)
	{
		uint8_t start=76+(rx_tx_addr[0]&0x03);
		for(uint8_t i=0; i<GD00X_RF_NUM_CHANNELS;i++)
			hopping_frequency[i]=start-(i<<1);
		#ifdef FORCE_GD00X_ORIGINAL_ID
			rx_tx_addr[0]=0x1F;					// or 0xA5 or 0x26
			rx_tx_addr[1]=0x39;					// or 0x37 or 0x35
			rx_tx_addr[2]=0x12;					// Constant on 3 TXs
			rx_tx_addr[3]=0x13;					// Constant on 3 TXs
			for(uint8_t i=0; i<GD00X_RF_NUM_CHANNELS;i++)
				hopping_frequency[i]=79-(i<<1);	// or 77 or 78
		#endif
	}
	else
	{
		//Generate 64 different IDs
		rx_tx_addr[1]=0x00;
		rx_tx_addr[2]=0x00;
		rx_tx_addr[1+((rx_tx_addr[3]&0x10)>>4)]=rx_tx_addr[3]&0x8F;
		rx_tx_addr[0]=0x65;
		rx_tx_addr[3]=0x95;
		rx_tx_addr[4]=0x47;	//'G'

		crc8=rx_tx_addr[0]^rx_tx_addr[1]^rx_tx_addr[2];
		//hopping calculation
		hopping_frequency[0]=(0x15+(crc8^rx_tx_addr[3]))&0x1F;
		if( hopping_frequency[0] == 0x0F )
			hopping_frequency[0]=0x0E;
		else if( (hopping_frequency[0]&0xFE) == 0x10 )
			hopping_frequency[0]+=2;
		hopping_frequency[1]=0x20+hopping_frequency[0];

		#ifdef FORCE_GD00X_ORIGINAL_ID
			//ID 1
			rx_tx_addr[0]=0x65;
			rx_tx_addr[1]=0x00;
			rx_tx_addr[2]=0x00;
			rx_tx_addr[3]=0x95;
			rx_tx_addr[4]=0x47;	//'G'
			hopping_frequency[0]=0x05;
			hopping_frequency[1]=0x25;
			//ID 2
			rx_tx_addr[0]=0xFD;
			rx_tx_addr[1]=0x09;
			rx_tx_addr[2]=0x00;
			rx_tx_addr[3]=0x65;
			rx_tx_addr[4]=0x47;	//'G'
			hopping_frequency[0]=0x06;
			hopping_frequency[1]=0x26;
			//ID 3
			rx_tx_addr[0]=0x67;
			rx_tx_addr[1]=0x0F;
			rx_tx_addr[2]=0x00;
			rx_tx_addr[3]=0x69;
			rx_tx_addr[4]=0x47;	//'G'
			hopping_frequency[0]=0x16;
			hopping_frequency[1]=0x36;
		#endif
	}
}

uint16_t GD00X_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
			BIND_DONE;
	GD00X_send_packet();
	return packet_period;
}

void GD00X_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	GD00X_initialize_txid();
	GD00X_RF_init();
	hopping_frequency_no = 0;
	bind_counter=GD00X_BIND_COUNT;
	packet_period=sub_protocol==GD_V1?GD00X_PACKET_PERIOD:GD00X_V2_BIND_PACKET_PERIOD;
	packet_length=sub_protocol==GD_V1?GD00X_PAYLOAD_SIZE:GD00X_V2_PAYLOAD_SIZE;
	packet_count=0;
	len=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/GW008_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with Global Drone GW008 protocol.
// There are 3 versions of this small quad, this protocol is for the one with a XNS104 IC in the stock Tx and PAN159CY IC in the quad (SOCs with built-in xn297 compatible RF).
// The xn297 version is compatible with the CX10 protocol (green pcb).
// The LT8910 version is not supported yet.

#if defined(GW008_NRF24L01_INO)

#include "iface_xn297.h"

#define GW008_INITIAL_WAIT    500
#define GW008_PACKET_PERIOD   2400
#define GW008_RF_BIND_CHANNEL 2
#define GW008_PAYLOAD_SIZE    15

enum {
	GW008_BIND1,
	GW008_BIND2,
	GW008_DATA
};

static void __attribute__((unused)) GW008_send_packet()
{
	packet[0] = rx_tx_addr[0];
	if(IS_BIND_IN_PROGRESS)
	{
		packet[1] = 0x55;
		packet[2] = hopping_frequency[0];
		packet[3] = hopping_frequency[1];
		packet[4] = hopping_frequency[2];
		packet[5] = hopping_frequency[3];
		memset(&packet[6], 0, 7);
		packet[13] = 0xaa;
	}
	else
	{
		XN297_Hopping((hopping_frequency_no++)/2);
		hopping_frequency_no %= 8;

		packet[1] = 0x01 | GET_FLAG(CH5_SW, 0x40); // flip
		packet[2] = convert_channel_16b_limit(AILERON , 200, 0); // aileron
		packet[3] = convert_channel_16b_limit(ELEVATOR, 0, 200); // elevator
		packet[4] = convert_channel_16b_limit(RUDDER  , 200, 0); // rudder
		packet[5] = convert_channel_16b_limit(THROTTLE, 0, 200); // throttle
		packet[6] = 0xaa;
		packet[7] = 0x02; // max rate
		packet[8] = 0x00;
		packet[9] = 0x00;
		packet[10]= 0x00;
		packet[11]= 0x00;
		packet[12]= 0x00;
		packet[13]= rx_tx_addr[2];
	}
	packet[14] = rx_tx_addr[1];

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, GW008_PAYLOAD_SIZE, 0);
}

static void __attribute__((unused)) GW008_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	
	XN297_SetTXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", 5);
	XN297_SetRXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", GW008_PAYLOAD_SIZE);

	//XN297_HoppingCalib(8);
	XN297_RFChannel(GW008_RF_BIND_CHANNEL);
}

static void __attribute__((unused)) GW008_initialize_txid()
{
	uint32_t lfsr = random(0xfefefefe) + ((uint32_t)random(0xfefefefe) << 16);
    for(uint8_t i=0; i<4; i++)
        hopping_frequency[i] = 0x10 + ((lfsr >> (i*8)) % 0x37);
}

uint16_t GW008_callback()
{
	switch(phase)
	{
		case GW008_BIND1:
			if(XN297_IsRX() &&	// RX fifo data ready
				XN297_ReadEnhancedPayload(packet, GW008_PAYLOAD_SIZE) == GW008_PAYLOAD_SIZE &&	// check payload size
				packet[0] == rx_tx_addr[0] && packet[14] == rx_tx_addr[1])			// check tx id
			{
				XN297_SetTxRxMode(TXRX_OFF);
				XN297_SetTxRxMode(TX_EN);
				rx_tx_addr[2] = packet[13];
				BIND_DONE;
				phase = GW008_DATA;
			}
			else
			{
				XN297_SetTxRxMode(TXRX_OFF);
				XN297_SetTxRxMode(TX_EN);
				GW008_send_packet();
				phase = GW008_BIND2;
				return 850; // minimum value 750 for STM32
			}
			break;
		case GW008_BIND2:
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = GW008_BIND1;
			return 5000;
		case GW008_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(GW008_PACKET_PERIOD);
			#endif
			GW008_send_packet();
			break;
	}
	return GW008_PACKET_PERIOD;
}

void GW008_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	GW008_initialize_txid();
	phase = GW008_BIND1;
	GW008_RF_init();
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H36_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(H36_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_H36_ORIGINAL_ID

#define H36_PAYLOAD_SIZE		13
#define H36_RF_NUM_CHANNELS		4
#define H36_BIND_PACKET_PERIOD	10285
#define H36_BIND_COUNT			648		//3sec

enum {
	H36_DATA1=0,
	H36_DATA2,
	H36_DATA3,
	H36_DATA4,
};

static void __attribute__((unused)) H36_send_packet()
{
	if(IS_BIND_DONE && phase == H36_DATA1)
	{
		hopping_frequency_no++;
		hopping_frequency_no&=3;
		XN297_Hopping(hopping_frequency_no);
	}

	packet[0] = 0x2E; 							// constant?
	memcpy(&packet[2],rx_tx_addr,3);
	if(IS_BIND_IN_PROGRESS)
	{//Bind
		memcpy(&packet[5],hopping_frequency,4);
		memset(&packet[9], 0x00, 3);
		packet[12] = 0xED; 						// constant?
		bind_counter--;
		if(bind_counter == 0)
			BIND_DONE;
	}
	else
	{//Normal
		packet[5] = convert_channel_8b(THROTTLE);
		packet[6] = convert_channel_8b(RUDDER);
		packet[7] = convert_channel_8b(ELEVATOR);
		packet[8] = convert_channel_8b(AILERON);
		packet[9] = GET_FLAG(CH6_SW,  0x02)		//Headless
				   |GET_FLAG(CH7_SW,  0x04);	//RTH(temporary)
		packet[10] = 0x20; 						//Trim A centered(0x20)
		packet[11] = CH5_SW?0x60:0x20;			//Flip(0x40)|Trim E centered(0x20)
		packet[12] = 0xA0; 						//High(0x80)/Low(0x40) rates|Trim R centered(0x20)?
	}
	//crc
	packet[1]=0xAA;
	for(uint8_t i=5;i<12;i++)
		packet[1] ^= packet[i];
	//Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, H36_PAYLOAD_SIZE);
	#ifdef DEBUG_SERIAL
		debug("H%d P",hopping_frequency_no);
		for(uint8_t i=0; i < H36_PAYLOAD_SIZE; i++)
			debug(" %02X", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) H36_initialize_txid()
{
	rx_tx_addr[0] = rx_tx_addr[3];
	calc_fh_channels(4);
	#ifdef FORCE_H36_ORIGINAL_ID
		if(!RX_num)
		{
			memcpy(rx_tx_addr,(uint8_t *)"\x00\x11\x00",3);
			memcpy(hopping_frequency,(uint8_t *)"\x36\x3A\x31\x2B",4);	//54, 58, 49, 43 
		}
	#endif
}

static void __attribute__((unused)) H36_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"\xCC\x6C\x47\x90\x53", 5);
	XN297_RFChannel(50);		//Bind channel
}

uint16_t H36_callback()
{
	H36_send_packet();
	switch(phase)
	{
		case H36_DATA1:
			phase++;
			return 1830;
		case H36_DATA2:
		case H36_DATA3:
			phase++;
			return 3085;
		default://DATA4
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(18500);
			#endif
			phase = H36_DATA1;
			break;
	}
	return 10500;
}

void H36_init()
{
	BIND_IN_PROGRESS;	// Autobind protocol
	H36_initialize_txid();
	H36_RF_init();
	phase = H36_DATA1;
	hopping_frequency_no = 0;
	bind_counter = H36_BIND_COUNT;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/H8_3D_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with EAchine 3D X4, CG023/CG031, Attop YD-822/YD-829/YD-829C and H8_3D/JJRC H20/H22
// Merged CG023 and H8_3D protocols
// Last sync with hexfet new_protocols/cg023_nrf24l01.c dated 2015-10-03
// Last sync with hexfet new_protocols/h8_3d_nrf24l01.c dated 2015-11-18

#if defined(H8_3D_NRF24L01_INO)

#include "iface_xn297.h"

#define H8_3D_PACKET_PERIOD		1800
#define H20H_PACKET_PERIOD		9340
#define H20MINI_PACKET_PERIOD	3100
#define H8_3D_INITIAL_WAIT		500
#define H8_3D_PACKET_SIZE		20
#define H8_3D_RF_NUM_CHANNELS	4
#define H20H_BIND_RF			0x49
#define H8_3D_BIND_COUNT		1000

enum H8_3D_FLAGS {
    // flags going to packet[17]
    H8_3D_FLAG_FLIP      = 0x01,
    H8_3D_FLAG_RATE_MID  = 0x02,
    H8_3D_FLAG_RATE_HIGH = 0x04,
    H8_3D_FLAG_LIGTH	 = 0x08, // Light on H22
    H8_3D_FLAG_HEADLESS  = 0x10, // RTH + headless on H8, headless on JJRC H20, RTH on H22
    H8_3D_FLAG_RTH		 = 0x20, // 360 flip mode on H8 3D and H22, RTH on JJRC H20
};

enum H8_3D_FLAGS_2 {
    // flags going to packet[18]
    H8_3D_FLAG_VIDEO      = 0x80,
    H8_3D_FLAG_PICTURE    = 0x40,
    H8_3D_FLAG_CALIBRATE1 = 0x20,  // H8 3D acc calibration, H20,H20H headless calib
    H8_3D_FLAG_CALIBRATE2 = 0x10,  // H11D, H20, H20H acc calibration
    H8_3D_FLAG_CAM_DN     = 0x08,
    H8_3D_FLAG_CAM_UP     = 0x04,
};

static void __attribute__((unused)) H8_3D_send_packet()
{
	if(sub_protocol==H20H)
		packet[0] = 0x14;
	else // H8_3D, H20MINI, H30MINI
		packet[0] = 0x13;

	packet[1] = rx_tx_addr[0]; 
	packet[2] = rx_tx_addr[1];
	packet[3] = rx_tx_addr[2];
	packet[4] = rx_tx_addr[3];
	packet[8] = rx_tx_addr[0]+rx_tx_addr[1]+rx_tx_addr[2]+rx_tx_addr[3]; // txid checksum
	memset(&packet[9], 0, 10);
	if (IS_BIND_IN_PROGRESS)
	{    
		packet[5] = 0x00;
		packet[6] = 0x00;
		packet[7] = 0x01;
	}
	else
	{
		packet[5] = hopping_frequency_no;
		packet[7] = 0x03;

		rudder = convert_channel_16b_limit(RUDDER,0x44,0xBC);			// yaw right : 0x80 (neutral) - 0xBC (right)
		if(sub_protocol!=H20H)
		{ // H8_3D, H20MINI, H30MINI
			packet[6] = 0x08;
			packet[9] = convert_channel_8b(THROTTLE);					// throttle  : 0x00 - 0xFF
			packet[15] = 0x20;	// trims
			packet[16] = 0x20;	// trims
			if (rudder<=0x80)
				rudder=0x80-rudder;										// yaw left  : 0x00 (neutral) - 0x3C (left)
			if(rudder==0x01 || rudder==0x81)
				rudder=0x00;	// Small deadband
		}
		else
		{ //H20H
			packet[6] = hopping_frequency_no == 0 ? 8 - packet_count : 16 - packet_count;
			packet[9] = convert_channel_16b_limit(THROTTLE, 0x43, 0xBB);	// throttle : 0x43 - 0x7F - 0xBB
			packet[15]= 0x40;	// trims
			packet[16]= 0x40;	// trims
			rudder--;													// rudder : 0x43 - 0x7F - 0xBB
			if (rudder>=0x7F-1 && rudder<=0x7F+1)
				rudder=0x7F;	// Small deadband
		}
		packet[10] = rudder;
		packet[11] = convert_channel_16b_limit(ELEVATOR, 0x43, 0xBB);	// elevator : 0x43 - 0x7F - 0xBB
		packet[12] = convert_channel_16b_limit(AILERON,  0x43, 0xBB);	// aileron  : 0x43 - 0x7F - 0xBB
		// neutral trims
		packet[13] = 0x20;
		packet[14] = 0x20;
		// flags
		packet[17] = 					  H8_3D_FLAG_RATE_HIGH
					| GET_FLAG(CH5_SW,H8_3D_FLAG_FLIP)
					| GET_FLAG(CH6_SW,H8_3D_FLAG_LIGTH) //H22 light
					| GET_FLAG(CH9_SW,H8_3D_FLAG_HEADLESS)
					| GET_FLAG(CH10_SW,H8_3D_FLAG_RTH); // 180/360 flip mode on H8 3D
		packet[18] =  GET_FLAG(CH7_SW,H8_3D_FLAG_PICTURE)
					| GET_FLAG(CH8_SW,H8_3D_FLAG_VIDEO)
					| GET_FLAG(CH11_SW,H8_3D_FLAG_CALIBRATE1)
					| GET_FLAG(CH12_SW,H8_3D_FLAG_CALIBRATE2);
		if(Channel_data[CH13]<CHANNEL_MIN_COMMAND)
			packet[18] |= H8_3D_FLAG_CAM_DN;
		if(CH13_SW)
			packet[18] |= H8_3D_FLAG_CAM_UP;
	}
	uint8_t  sum = packet[9];
	for (uint8_t i=10; i < H8_3D_PACKET_SIZE-1; i++)
		sum += packet[i];
	packet[19] = sum; // data checksum
	
	// RF channel
	if(sub_protocol!=H20H)
	{ // H8_3D, H20MINI, H30MINI
		XN297_RFChannel(IS_BIND_IN_PROGRESS ? hopping_frequency[0] : hopping_frequency[hopping_frequency_no++]);
		hopping_frequency_no %= H8_3D_RF_NUM_CHANNELS;
	}
	else
	{ // H20H
		XN297_RFChannel(IS_BIND_IN_PROGRESS ? H20H_BIND_RF : hopping_frequency[packet_count>>3]);  
		if(IS_BIND_DONE)
		{
			packet_count++;
			if(packet_count>15)
			{
				packet_count = 0;
				hopping_frequency_no = 0;
			}
			else
				if(packet_count > 7)
					hopping_frequency_no = 1;
		}
	}
	
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, H8_3D_PACKET_SIZE);
}

static void __attribute__((unused)) H8_3D_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);

	if(sub_protocol==H20H)
		XN297_SetTXAddr((uint8_t *)"\xEE\xDD\xCC\xBB\x11", 5);
	else // H8_3D, H20MINI, H30MINI
		XN297_SetTXAddr((uint8_t *)"\xC4\x57\x09\x65\x21", 5);
}

uint16_t H8_3D_callback()
{
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			BIND_DONE;
			packet_count=0;
		}
	}
	#ifdef MULTI_SYNC
	else
		telemetry_set_input_sync(packet_period);
	#endif

	H8_3D_send_packet();
	return	packet_period;
}

// captured from H20H stock transmitters
const uint8_t PROGMEM h20h_tx_rf_map[3][6] = {{/*ID*/0x83, 0x3c, 0x60, 0x00, /*RF*/0x47, 0x3e},
											  {/*ID*/0x5c, 0x2b, 0x60, 0x00, /*RF*/0x4a, 0x3c},
											  {/*ID*/0x57, 0x07, 0x00, 0x00, /*RF*/0x41, 0x48} };
// captured from H20 Mini / H30 Mini stock transmitters
const uint8_t PROGMEM h20mini_tx_rf_map[4][8] =  {{/*ID*/0xb4, 0xbb, 0x09, 0x00, /*RF*/0x3e, 0x45, 0x47, 0x4a},
												  {/*ID*/0x94, 0x9d, 0x0b, 0x00, /*RF*/0x3e, 0x43, 0x49, 0x4a},
												  {/*ID*/0xd1, 0xd0, 0x00, 0x00, /*RF*/0x3f, 0x42, 0x46, 0x4a},
												  {/*ID*/0xcb, 0xcd, 0x04, 0x00, /*RF*/0x41, 0x43, 0x46, 0x4a}};
static void __attribute__((unused)) H8_3D_initialize_txid()
{
	uint8_t id_num=rx_tx_addr[4];
	switch(sub_protocol)
	{
		case H8_3D:
            for(uint8_t i=0; i<4; i++)
                hopping_frequency[i] = 6 + (0x0f*i) + (((rx_tx_addr[i] >> 4) + (rx_tx_addr[i] & 0x0f)) % 0x0f);
			break;
		case H20H:
            id_num%=3; // 3 different IDs
			for(uint8_t i=0; i<4; i++)
			{
				rx_tx_addr[i] = pgm_read_byte_near(&h20h_tx_rf_map[id_num][i]);
				if(i<2)
					hopping_frequency[i] = pgm_read_byte_near(&h20h_tx_rf_map[id_num][i+4]);
			}
			break;
		case H20MINI:
		case H30MINI:
            id_num%=4; // 4 different IDs
			for(uint8_t i=0; i<4; i++)
			{
				rx_tx_addr[i] = pgm_read_byte_near(&h20mini_tx_rf_map[id_num][i]);
				hopping_frequency[i] = pgm_read_byte_near(&h20mini_tx_rf_map[id_num][i+4]);
			}
			break;
	}
}

void H8_3D_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
    bind_counter = H8_3D_BIND_COUNT;
	H8_3D_initialize_txid();
	H8_3D_RF_init();
	switch(sub_protocol)
	{
        case H8_3D:
			packet_period=H8_3D_PACKET_PERIOD;
			break;
		case H20H:
			packet_period=H20H_PACKET_PERIOD;
			break;
		case H20MINI:
		case H30MINI:
			packet_period=H20MINI_PACKET_PERIOD;
			break;
	}
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/HOTT_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(HOTT_CC2500_INO)

#include "iface_cc2500.h"

//#define HOTT_FORCE_ID		// Force ID of original dump

#define HOTT_TX_PACKET_LEN	50
#define HOTT_RX_PACKET_LEN	22
#define HOTT_PACKET_PERIOD	10000
#define HOTT_NUM_RF_CHANNELS 75
#define HOTT_COARSE	0

enum {
    HOTT_START = 0x00,
    HOTT_CAL   = 0x01,
    HOTT_DATA1 = 0x02,
    HOTT_DATA2 = 0x03,
    HOTT_RX1   = 0x04,
    HOTT_RX2   = 0x05,
};

#ifdef HOTT_FW_TELEMETRY
	#define HOTT_SENSOR_TYPE 6
	#define HOTT_SENSOR_SEARCH_PERIOD 2000
	uint8_t HOTT_sensor_cur=0;
	uint8_t HOTT_sensor_pages=0;
	uint8_t HOTT_sensor_valid=false;
	uint8_t HOTT_sensor_ok[HOTT_SENSOR_TYPE];
	uint8_t HOTT_sensor_seq=0;
#endif

#define HOTT_FREQ0_VAL 0x6E

// Some important initialization parameters, all others are either default,
// or not important in the context of transmitter
// FIFOTHR  00
// SYNC1    D3
// SYNC0    91
// PKTLEN   32 - Packet length, 50 bytes
// PKTCTRL1 04 - APPEND_STATUS on=RSSI+LQI, all other are receive parameters - irrelevant
// PKTCTRL0 44 - whitening, use FIFO, use CRC, fixed packet length
// ADDR     00
// CHANNR   10
// FSCTRL1  09 - IF 
// FSCTRL0  00 - zero freq offset
// FREQ2    5C - synthesizer frequencyfor 26MHz crystal
// FREQ1    6C
// FREQ0    B9
// MDMCFG4  2D - 
// MDMCFG3  3B - 
// MDMCFG2  73 - disable DC blocking, MSK, no Manchester code, 32 bits sync word
// MDMCFG1  A3 - FEC enable, 4 preamble bytes, CHANSPC_E - 03
// MDMCFG0  AA - CHANSPC_M - AA
// DEVIATN  47 - 
// MCSM2    07 - 
// MCSM1    00 - always use CCA, go to IDLE when done
// MCSM0    08 - disable autocalibration, PO_TIMEOUT - 64, no pin radio control, no forcing XTAL to stay in SLEEP
// FOCCFG   1D
const PROGMEM uint8_t HOTT_init_values[] = {
  /* 00 */ 0x2F, 0x2E, 0x2F, 0x00, 0xD3, 0x91, 0x32, 0x04,
  /* 08 */ 0x44, 0x00, 0x00, 0x09, 0x00, 0x5C, 0x6C, HOTT_FREQ0_VAL + HOTT_COARSE,
  /* 10 */ 0x2D, 0x3B, 0x73, 0xA3, 0xAA, 0x47, 0x07, 0x00,
  /* 18 */ 0x08, 0x1D, 0x1C, 0xC7, 0x09, 0xF0, 0x87, 0x6B,
  /* 20 */ 0xF0, 0xB6, 0x10, 0xEA, 0x0A, 0x00, 0x11
};

static void __attribute__((unused)) HOTT_rf_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i < 39; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&HOTT_init_values[i]));

	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	
	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}

static void __attribute__((unused)) HOTT_tune_chan()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, (rf_ch_num+1)*3);
	CC2500_Strobe(CC2500_SCAL);
}

static void __attribute__((unused)) HOTT_tune_chan_fast()
{
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_WriteReg(CC2500_0A_CHANNR, (rf_ch_num+1)*3);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[rf_ch_num]);
}

static void __attribute__((unused)) HOTT_tune_freq()
{
	if ( prev_option != option )
	{
		CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
		CC2500_WriteReg(CC2500_0F_FREQ0, HOTT_FREQ0_VAL + HOTT_COARSE);
		prev_option = option ;
		phase = HOTT_START;								// Restart the tune process if option is changed to get good tuned values
	}
}

const uint8_t PROGMEM HOTT_hop[][HOTT_NUM_RF_CHANNELS]=
	{	{ 48, 37, 16, 62, 9, 50, 42, 22, 68, 0, 55, 35, 21, 74, 1, 56, 31, 20, 70, 11, 45, 32, 24, 71, 8, 54, 38, 26, 61, 13, 53, 30, 15, 65, 7, 52, 34, 28, 60, 3, 47, 39, 18, 69, 2, 49, 44, 23, 72, 5, 51, 43, 19, 64, 12, 46, 33, 17, 67, 6, 58, 36, 29, 73, 14, 57, 41, 25, 63, 4, 59, 40, 27, 66, 10 },
		{ 50, 23, 5, 34, 67, 53, 22, 12, 39, 62, 51, 21, 10, 33, 63, 59, 16, 1, 43, 66, 49, 19, 8, 30, 71, 47, 24, 2, 35, 68, 45, 25, 14, 41, 74, 55, 18, 4, 32, 61, 54, 17, 11, 31, 72, 52, 28, 6, 38, 65, 46, 15, 9, 40, 60, 48, 26, 3, 37, 70, 58, 29, 0, 36, 64, 56, 20, 7, 42, 69, 57, 27, 13, 44, 73 },
		{ 73, 51, 39, 18, 9, 64, 56, 34, 16, 12, 66, 58, 36, 25, 11, 61, 47, 40, 15, 8, 71, 50, 43, 20, 6, 62, 54, 42, 19, 3, 63, 46, 44, 29, 14, 72, 49, 33, 22, 5, 69, 57, 30, 21, 10, 70, 45, 35, 26, 7, 65, 59, 31, 28, 1, 67, 48, 32, 24, 0, 60, 55, 41, 17, 2, 74, 52, 38, 27, 4, 68, 53, 37, 23, 13 },
		{ 52, 60, 40, 21, 14, 50, 72, 41, 23, 13, 59, 61, 39, 16, 6, 58, 66, 33, 17, 5, 55, 64, 43, 20, 12, 54, 74, 35, 29, 3, 46, 63, 37, 22, 10, 48, 65, 31, 27, 9, 49, 73, 38, 24, 11, 56, 70, 32, 15, 1, 51, 71, 44, 18, 8, 45, 67, 36, 25, 7, 57, 62, 34, 28, 2, 53, 69, 42, 19, 4, 47, 68, 30, 26, 0 },
		{ 50, 16, 34, 6, 71, 51, 24, 40, 7, 68, 57, 27, 33, 14, 70, 55, 26, 30, 5, 74, 47, 28, 44, 11, 67, 49, 15, 32, 9, 61, 52, 22, 37, 13, 66, 59, 18, 42, 3, 62, 46, 29, 31, 12, 60, 48, 19, 38, 1, 72, 58, 17, 36, 4, 64, 53, 21, 39, 0, 63, 56, 20, 41, 2, 65, 45, 25, 35, 10, 69, 54, 23, 43, 8, 73 },
		{ 55, 38, 12, 62, 23, 52, 44, 3, 66, 18, 54, 36, 10, 74, 16, 56, 42, 9, 70, 17, 58, 33, 5, 69, 20, 50, 40, 1, 63, 24, 53, 37, 13, 65, 15, 48, 34, 4, 61, 22, 57, 31, 6, 64, 26, 46, 35, 11, 72, 21, 47, 30, 7, 68, 29, 45, 32, 8, 60, 19, 49, 43, 2, 67, 27, 51, 39, 0, 71, 28, 59, 41, 14, 73, 25 },
		{ 70, 32, 18, 10, 58, 69, 38, 22, 2, 54, 67, 36, 19, 12, 57, 62, 34, 20, 14, 52, 63, 41, 15, 3, 51, 73, 42, 28, 6, 48, 60, 43, 29, 5, 45, 64, 31, 17, 4, 56, 65, 35, 26, 13, 53, 61, 37, 23, 1, 49, 68, 40, 16, 9, 47, 71, 39, 25, 7, 50, 66, 33, 24, 8, 59, 72, 44, 27, 11, 46, 74, 30, 21, 0, 55 },
		{ 6, 45, 71, 27, 44, 10, 46, 74, 22, 32, 0, 55, 69, 21, 33, 4, 50, 66, 18, 38, 7, 57, 62, 19, 36, 1, 48, 70, 20, 40, 8, 47, 68, 15, 43, 2, 58, 61, 26, 42, 3, 56, 72, 23, 34, 14, 54, 67, 16, 37, 5, 59, 64, 24, 30, 12, 52, 65, 25, 39, 13, 49, 73, 17, 31, 9, 53, 60, 28, 35, 11, 51, 63, 29, 41 },
		{ 31, 65, 50, 20, 13, 37, 66, 45, 23, 5, 32, 69, 54, 19, 7, 39, 74, 52, 27, 1, 42, 64, 53, 22, 4, 43, 70, 58, 16, 3, 40, 71, 57, 17, 0, 35, 63, 56, 18, 9, 44, 72, 51, 21, 6, 33, 67, 46, 25, 11, 30, 73, 55, 15, 8, 36, 62, 48, 24, 10, 41, 60, 49, 29, 14, 34, 61, 47, 26, 2, 38, 68, 59, 28, 12 },
		{ 67, 22, 49, 36, 13, 64, 28, 57, 37, 6, 65, 29, 46, 39, 3, 70, 26, 45, 35, 1, 62, 24, 58, 34, 10, 68, 19, 53, 33, 4, 66, 21, 52, 31, 7, 74, 18, 47, 32, 5, 61, 16, 51, 38, 8, 72, 23, 55, 30, 12, 73, 17, 59, 44, 0, 60, 15, 50, 43, 14, 63, 27, 48, 42, 11, 71, 20, 54, 41, 9, 69, 25, 56, 40, 2 },
		{ 19, 38, 14, 66, 57, 18, 44, 7, 74, 48, 23, 30, 6, 71, 58, 26, 32, 5, 61, 46, 20, 34, 0, 68, 45, 24, 36, 1, 70, 50, 27, 33, 10, 63, 52, 16, 42, 9, 65, 51, 15, 41, 11, 64, 53, 22, 37, 3, 60, 56, 28, 35, 4, 67, 49, 17, 39, 13, 69, 54, 25, 43, 2, 73, 55, 21, 31, 8, 62, 47, 29, 40, 12, 72, 59 },
		{ 4, 52, 64, 28, 44, 14, 46, 74, 16, 32, 11, 50, 68, 27, 36, 0, 47, 70, 26, 34, 13, 57, 61, 18, 38, 6, 56, 62, 19, 40, 5, 58, 67, 17, 31, 12, 54, 63, 22, 33, 3, 53, 72, 21, 41, 10, 48, 66, 15, 35, 7, 45, 60, 20, 37, 9, 51, 69, 25, 42, 2, 59, 71, 24, 39, 1, 55, 65, 23, 30, 8, 49, 73, 29, 43 },
		{ 44, 66, 19, 1, 56, 35, 62, 20, 4, 54, 39, 70, 24, 5, 55, 31, 74, 26, 12, 58, 32, 60, 17, 10, 45, 37, 63, 22, 3, 50, 33, 64, 16, 7, 51, 34, 61, 21, 8, 48, 38, 68, 29, 0, 46, 36, 72, 28, 14, 49, 42, 69, 25, 6, 57, 43, 65, 18, 2, 52, 30, 71, 23, 13, 47, 41, 67, 15, 9, 53, 40, 73, 27, 11, 59 },
		{ 12, 16, 36, 46, 69, 6, 20, 44, 58, 62, 11, 19, 34, 48, 71, 1, 18, 42, 50, 74, 3, 25, 31, 47, 65, 0, 24, 33, 45, 72, 2, 23, 35, 56, 64, 10, 22, 38, 49, 63, 7, 26, 37, 51, 70, 14, 21, 30, 53, 67, 5, 15, 40, 52, 66, 9, 17, 39, 55, 60, 13, 27, 41, 54, 73, 4, 28, 32, 57, 61, 8, 29, 43, 59, 68 },
		{ 63, 42, 18, 2, 57, 71, 34, 22, 10, 48, 67, 36, 25, 4, 46, 60, 31, 28, 6, 47, 74, 37, 15, 0, 55, 65, 32, 24, 12, 56, 66, 40, 27, 14, 52, 62, 38, 19, 3, 50, 73, 33, 29, 11, 53, 61, 35, 16, 7, 58, 72, 41, 26, 5, 59, 69, 30, 20, 9, 51, 68, 44, 23, 1, 49, 70, 39, 17, 8, 54, 64, 43, 21, 13, 45 },
		{ 52, 1, 71, 17, 36, 47, 7, 64, 26, 32, 53, 5, 60, 20, 42, 57, 2, 66, 18, 34, 56, 4, 63, 24, 35, 46, 13, 72, 22, 30, 48, 0, 67, 21, 39, 50, 3, 74, 16, 31, 59, 14, 61, 23, 37, 45, 6, 65, 19, 44, 51, 11, 62, 27, 41, 55, 9, 68, 15, 38, 58, 8, 70, 29, 40, 54, 10, 69, 28, 33, 49, 12, 73, 25, 43 }
		};
const uint16_t PROGMEM HOTT_hop_val[] = { 0xC06B, 0xC34A, 0xDB24, 0x8E09, 0x272E, 0x217F, 0x155B, 0xEDE8, 0x1D31, 0x0986, 0x56F7, 0x6454, 0xC42D, 0x01D2, 0xC253, 0x1180 };

static void __attribute__((unused)) HOTT_TXID_init()
{
	packet[0] = pgm_read_word_near( &HOTT_hop_val[num_ch] );
	packet[1] = pgm_read_word_near( &HOTT_hop_val[num_ch] )>>8;

	for(uint8_t i=0; i<HOTT_NUM_RF_CHANNELS; i++)
		hopping_frequency[i]=pgm_read_byte_near( &HOTT_hop[num_ch][i] );
	#ifdef HOTT_FORCE_ID
		memcpy(rx_tx_addr,"\x7C\x94\x00\x0D\x50",5);	//TX1
		memcpy(rx_tx_addr,"\xEA\x4D\x00\x01\x50",5);	//TX2
	#endif
	memset(&packet[30],0xFF,9);
	packet[39]=0x07;									// unknown and constant
	if(IS_BIND_IN_PROGRESS)
	{
		memset(&packet[40],0xFA,5);
		memcpy(&packet[45],rx_tx_addr,5);
	}
	else
	{
		memcpy(&packet[40],rx_tx_addr,5);
		uint16_t addr=HOTT_EEPROM_OFFSET+RX_num*5;
		debug("RXID: ");
		for(uint8_t i=0;i<5;i++)
		{
			packet[45+i]=eeprom_read_byte((EE_ADDR)(addr+i));
			debug(" %02X",packet[45+i]);
		}
		debugln("");
	}
}

static void __attribute__((unused)) HOTT_prep_data_packet() {
	static uint8_t upper = 0;								// toggles between sending channels 1..8,9..12 and 1..8,13..16
	
	packet[2] = hopping_frequency_no;						// send next frequency to be used
	packet[3] = upper;										// indicate upper or lower channels (only supporting 16 channels)										
	
	#ifdef FAILSAFE_ENABLE
		static uint8_t failsafe_count = 0;					// failsafe packet state machine (need to send two packets)

		if(IS_FAILSAFE_VALUES_on && IS_BIND_DONE) {			// if TX wants to send failsafe data and RX is connected
			failsafe_count++;								// prepare to send next packet

			if(failsafe_count >= 3) {						// done sending two failsafe channel data packets
				FAILSAFE_VALUES_off;					
				failsafe_count = 0;
			}
		}
		else
			failsafe_count = 0;
	#endif

	// Channels value are PPM*2, -100%=1100s, +100%=1900s, order TAER
	//
	// Note: failsafe packets are differnt to normal operation packets
	// normal operation toggles between sending channels 1..8,9..12 and 1..8,13..16 using bit0 as high/low indicator in packet[3]
	// while failsafe packets send channels 1..12, 13..24 (and probably 25..32) using bit0 in packet[3] as packet type indicator
	// packet[3] = 0x40 -> failsafe packet with data for channels 1..12
	// packet[3] = 0x41 -> failsafe packet with data for channels 13..24
	//
	uint16_t val;
	for(uint8_t i = 0 ; i < 12*2 ; i += 2) {				// working 12 channels (using 2 bytes per channel)
		uint8_t chIndex = i >> 1 ;							// normal operation channel number
		uint8_t fschIndex = chIndex;						// linear channel number for failsafe
		
		if(upper && chIndex >= 8) chIndex += 4;				// for normal operation toggle between channels 1..8,9..12 and 1..8,13..16
		val = Channel_data[chIndex];						// get normal operation channel data
		val = (((val << 2) + val) >> 2)+ 860*2;				// convert channel data 0..2047 to 1720..4278 <-> -125%<->+125%
															// val = (val*5/4+860*2)

		#ifdef FAILSAFE_ENABLE
			if(failsafe_count == 1 || failsafe_count == 2) {// failsafe data needs to be sent to RX
				uint16_t fs = 0x8000;						// default failsafe mode is hold

				if(failsafe_count == 1) {					// send fail safe packet containing channels 1..12
					packet[3] = 0x40;						// indicate packet has failsafe values for channels 1..12
					fs = Failsafe_data[fschIndex];			// get failsafe channel data
				} else {									// send fail safe packet containing channels 13..24
					packet[3] = 0x41;						// indicate packet has failsafe values for channels 13..24
					if(fschIndex < 4)						// we only work 16 channels so send channels 13..16, rest default
						fs = Failsafe_data[fschIndex+12];	// get failsafe channel data 13..16
				  } 

				if( fs == FAILSAFE_CHANNEL_HOLD ||			// treat HOLD and NOPULSES as channel hold 
					fs == FAILSAFE_CHANNEL_NOPULSES)
					val = 0x8000;							// set channel failsafe mode hold flag
				else {
					val = (((fs << 2) + fs) >> 2) +860*2; 	// convert channel data 0..2047 to 1720..4278 <-> -125%<->+125%
					val |= 0x4000;							// set channel failsafe mode position flag					
				}
			} 
		#endif

		packet[i + 4]   = val;								// first channel data at packet[4] and packet[5]
		packet[i + 4+1] = val >> 8;
	}

	upper ^= 0x01;											// toggle to upper and lower channels

	packet[28] = 0x80;										// no sensor
	packet[29] = 0x02;										// 0x02 when bind starts then when RX replies cycle in sequence 0x1A/22/2A/0A/12, 0x02 during normal packets, 0x01->text config menu, 0x0A->no more RX telemetry

	#ifdef HOTT_FW_TELEMETRY
		if(IS_BIND_DONE)
		{
			static uint8_t prev_SerialRX_val=0;
			if(HoTT_SerialRX)
			{//Text mode
				uint8_t sensor=HoTT_SerialRX_val&0xF0;
				if((sensor&0x80) && sensor!=0xF0 && (HoTT_SerialRX_val&0x0F) >= 0x07)
				{//Valid Text query
					if(sensor==0x80) HoTT_SerialRX_val&=0x0F;	// RX only
					if(prev_SerialRX_val!=HoTT_SerialRX_val)
					{
						prev_SerialRX_val=HoTT_SerialRX_val;
						packet[28] = HoTT_SerialRX_val;			// send the button being pressed only once
					}
					else
						packet[28] = HoTT_SerialRX_val | 0x0F;	// no button pressed
				}
				else
					packet[28] = 0x0F;							// RX, no button pressed
				if(sub_protocol == HOTT_SYNC)
					packet[29] = ((HOTT_sensor_seq+1)<<3) | 1;	// Telemetry packet sequence
				else
					packet[29] = 0x01;							// 0x01->Text config menu
			}
			else
			{
				packet[28] = 0x89+HOTT_sensor_cur;				// 0x89/8A/8B/8C/8D/8E during normal packets
				if(sub_protocol == HOTT_SYNC)
					packet[29] = ((HOTT_sensor_seq+1)<<3) | 2;	// Telemetry packet sequence
			}
			//debugln("28=%02X,29=%02X",packet[28],packet[29]);
		}
	#endif

	CC2500_WriteReg(CC2500_06_PKTLEN, HOTT_TX_PACKET_LEN);
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, packet, HOTT_TX_PACKET_LEN);
	#if 0
		debug("RF:%02X P:",rf_ch_num);
		for(uint8_t i=0;i<HOTT_TX_PACKET_LEN;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
	hopping_frequency_no++;
	hopping_frequency_no %= HOTT_NUM_RF_CHANNELS;
	rf_ch_num=hopping_frequency[hopping_frequency_no];
}

uint16_t HOTT_callback()
{
	switch(phase)
	{
		case HOTT_START:
			rf_ch_num = 0;
			HOTT_tune_chan();
			phase = HOTT_CAL;
			return 2000;
		case HOTT_CAL:
			calData[rf_ch_num]=CC2500_ReadReg(CC2500_25_FSCAL1);
			if (++rf_ch_num < HOTT_NUM_RF_CHANNELS)
				HOTT_tune_chan();
			else
			{
				hopping_frequency_no = 0;
				rf_ch_num=hopping_frequency[hopping_frequency_no];
				counter = 0;
				CC2500_SetTxRxMode(RX_EN);
				phase = HOTT_DATA1;
			}
			return 2000;

		/* Work cycle: 10ms */
		case HOTT_DATA1:
			//Set RF freq, setup LBT and prep packet
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(HOTT_PACKET_PERIOD);
			#endif
			//Clear all
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SNOP);
			CC2500_Strobe(CC2500_SFTX);
			CC2500_Strobe(CC2500_SFRX);
			CC2500_WriteReg(CC2500_04_SYNC1, 0xD3);
			CC2500_WriteReg(CC2500_05_SYNC0, 0x91);
			//Set RF freq
			HOTT_tune_freq();
			HOTT_tune_chan_fast();
			//Setup LBT
			CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0xFF);
			CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0x0C);
			CC2500_Strobe(CC2500_SRX);
			//Prep packet
			HOTT_prep_data_packet();
			//Listen
			CC2500_WriteReg(CC2500_17_MCSM1, 0x10);		//??
			CC2500_WriteReg(CC2500_18_MCSM0, 0x18);		//??
			CC2500_Strobe(CC2500_SRX);					//??
			phase++;		//HOTT_DATA2
			return 1095;
		case HOTT_DATA2:
			//LBT
			if((CC2500_ReadReg(CC2500_38_PKTSTATUS | CC2500_READ_BURST)&0x10)==0)
			{ //Channel is busy
				LBT_POWER_on;										// Reduce to low power before transmitting
				debugln("Busy %d",rf_ch_num);
			}
			CC2500_WriteReg(CC2500_17_MCSM1, 0x00);		//??
			CC2500_WriteReg(CC2500_18_MCSM0, 0x08);		//??
			CC2500_SetPower();
			//Send packet
			CC2500_SetTxRxMode(TX_EN);
			CC2500_Strobe(CC2500_STX);
			phase++;		//HOTT_RX1
			return 3880;
		case HOTT_RX1:
			//Clear all
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SFTX);
			CC2500_Strobe(CC2500_SFRX);
			//RX
			if(packet[29] & 0xF8)
			{// Sync telemetry
				CC2500_WriteReg(CC2500_04_SYNC1, 0x2C);
				CC2500_WriteReg(CC2500_05_SYNC0, 0x6E);
			}
			CC2500_SetTxRxMode(RX_EN);
			CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0xC7);
			CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0x09);
			CC2500_WriteReg(CC2500_06_PKTLEN, HOTT_RX_PACKET_LEN);
			CC2500_Strobe(CC2500_SRX);
			phase++;		//HOTT_RX2
			return 4025;
		case HOTT_RX2:
			//Telemetry
			len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
			if (len==HOTT_RX_PACKET_LEN+2)
			{
				CC2500_ReadData(packet_in, len);
				if((packet_in[HOTT_RX_PACKET_LEN+1]&0x80) && memcmp(rx_tx_addr,packet_in,5)==0)
				{ // CRC OK and TX ID matches
					if(IS_BIND_IN_PROGRESS)
					{
						//GR-16:  D4 20 F2 E6 F6 31 BD 01 00 90 00 FF 03 00 9E 1B 00 00 00 00 00 00
						//GR-12L: D4 20 F2 E6 F6 6E EE 01 00 B1 00 FF 03 00 0E 08 10 00 02 00 00 00
						//Vector: D4 20 F2 E6 F6 00 00 3A 01 A1 00 00 1A 24 35 1A 00 24 00 00 00 1A
						//        -----TXID----- -----RXID----- ---------------Unknown-------------
						debug("B:");
						for(uint8_t i=0;i<HOTT_RX_PACKET_LEN;i++)
							debug(" %02X", packet_in[i]);
						debugln("");
						uint16_t addr=HOTT_EEPROM_OFFSET+RX_num*5;
						for(uint8_t i=0; i<5; i++)
							eeprom_write_byte((EE_ADDR)(addr+i),packet_in[5+i]);
						BIND_DONE;
						HOTT_TXID_init();
					}
					#ifdef HOTT_FW_TELEMETRY
						else
						{	//Telemetry
							// [0..4] = TXID
							// [5..9] = RXID
							// [10] = holds warnings issued by hott devices
							// [11] = telmetry pages. For sensors 0x00 to 0x04, for config mennu 0x00 to 0x12.
							// Normal telem page 0 = 0x55, 0x32, 0x38, 0x55, 0x64, 0x32, 0xD0, 0x07, 0x00, 0x55
							//   Page 0 [12] = [21] = [15]
							//   Page 0 [13] = RX_Voltage Cur*10 in V
							//   Page 0 [14] = Temperature-20 in C
							//   Page 0 [15] = RX_RSSI CC2500 formated (a<128:a/2-71dBm, a>=128:(a-256)/2-71dBm)
							//   Page 0 [16] = RX_LQI in %
							//   Page 0 [17] = RX_Voltage Min*10 in V
							//   Page 0 [18,19] = [19]<<8+[18]=max lost packet time in ms, max value seems 2s=0x7D0
							//   Page 0 [20] = rx events
							//
							// Config menu consists of the different telem pages put all together
							//   Page X [12] = seems like all the telem pages with the same value are going together to make the full config menu text. Seen so far 'a', 'b', 'c', 'd' 
							//   Page X [13..21] = 9 ascii chars to be displayed, char is highlighted when ascii|0x80
							//   Screen display is 21 characters large which means that once the first 21 chars are filled go to the begining of the next line
							//   Menu commands are sent through TX packets:
							//     packet[28]= 0xXF=>no key press, 0xXD=>down, 0xXB=>up, 0xX9=>enter, 0xXE=>right, 0xX7=>left with X=0 or D
							//     packet[29]= 0xX1/0xX9 with X=0 or X counting 0,1,1,2,2,..,9,9
							// Reduce telemetry to 14 bytes
							packet_in[0]= packet_in[HOTT_RX_PACKET_LEN];
							packet_in[1]= TX_LQI;
							uint8_t hott_warnings = packet_in[10];						// save warnings from hott devices
							bool send_telem=true;
							HOTT_sensor_seq++;											// Increment RX sequence counter
							if(packet[29] & 1)
							{ //Text mode
								HOTT_sensor_seq %= 19;									// 19 pages in Text mode
								HOTT_sensor_pages = 0;
								HOTT_sensor_valid = false;
								packet_in[10] = 0x80;									// Marking telem Text mode
								packet_in[12] = 0;
								for(uint8_t i=0; i<HOTT_SENSOR_TYPE;i++)
									packet_in[12] |= HOTT_sensor_ok[i]<<i;				// Send detected sensors
							}
							else
							{ //Binary sensor
								HOTT_sensor_seq %= 5;									// 5 pages in binary mode per sensor
								if(state==0 && HOTT_sensor_ok[0]==false && HOTT_sensor_ok[1]==false && HOTT_sensor_ok[2]==false && HOTT_sensor_ok[3]==false && HOTT_sensor_ok[4]==false && HOTT_sensor_ok[5]==false)
									HOTT_sensor_seq=0;									// No sensors always ask page 0
								if(state)
									state--;
								if( packet_in[11]==1 )									// Page 1
								{
									if( packet_in[12] == (HOTT_sensor_cur+9)<<4 )
									{ //Requested sensor is sending: 0x90/A0/B0/C0/D0/E0
										HOTT_sensor_pages = 0;							// Sensor first page received
										HOTT_sensor_valid = true;						// Data from the expected sensor is being received
										HOTT_sensor_ok[(packet_in[12]>>4)-9]=true;					
									}
									else
									{
										HOTT_sensor_valid = false;
										HOTT_sensor_pages = 0x1E;						// Switch to next sensor
									}
								}
								if(packet_in[11])
								{ //Page != 0
									if(HOTT_sensor_valid)								// Valid
									{
										packet_in[10] = HOTT_sensor_cur+9;				// Mark telem with sensor ID
										HOTT_sensor_pages |= 1<<packet_in[11];			// Page received
									}
									else
										send_telem=false;								// Do not send
								}
								else
									packet_in[10]=0;									// Mark telem with sensor 0=RX
							}
							debug("T%d=",send_telem);
							for(uint8_t i=10;i < HOTT_RX_PACKET_LEN; i++)
							{
								packet_in[i-8]=packet_in[i];
								debug(" %02X",packet_in[i]);
							}
							packet_in[14] = hott_warnings;								// restore saved warnings from hott devices
							debugln("");
							if(send_telem)
								telemetry_link=2;
							if((HOTT_sensor_pages&0x1E) == 0x1E)						// All 4 pages received from the sensor
							{ //Next sensor
								uint8_t loop=0;
								do
								{
									HOTT_sensor_cur++;									// Switch to next sensor
									HOTT_sensor_cur %= HOTT_SENSOR_TYPE;
									loop++;
								}
								while(HOTT_sensor_ok[HOTT_sensor_cur]==false && loop<HOTT_SENSOR_TYPE+1 && state==0);
								HOTT_sensor_valid=false;
								HOTT_sensor_pages=0;
								HOTT_sensor_seq=0;
								debugln("Sensor:%02X",HOTT_sensor_cur+9);
							}										
						}
						pps_counter++;
					#endif
				}
			}
			#ifdef HOTT_FW_TELEMETRY
				packet_count++;
				if(packet_count>=100)
				{
					TX_LQI=pps_counter;
					if(pps_counter==0)
					{ // lost connection with RX, power cycle? research sensors again.
						HOTT_sensor_cur=3;
						HOTT_sensor_seq=0;
						HOTT_sensor_valid=false;
						for(uint8_t i=0; i<HOTT_SENSOR_TYPE;i++)
							HOTT_sensor_ok[i]=false;	// no sensors detected
						state=HOTT_SENSOR_SEARCH_PERIOD;
					}
					pps_counter=packet_count=0;
				}
			#endif
			phase=HOTT_DATA1;
			return 1000;
	}
	return 0;
}

void HOTT_init()
{
	num_ch=random(0xfefefefe)%16;
	HOTT_TXID_init();
	HOTT_rf_init();
	#ifdef HOTT_FW_TELEMETRY
		HoTT_SerialRX_val=0;
		HoTT_SerialRX=false;
		HOTT_sensor_cur=3;
		HOTT_sensor_pages=0;
		HOTT_sensor_valid=false;
		HOTT_sensor_seq=0;
		for(uint8_t i=0; i<HOTT_SENSOR_TYPE;i++)
			HOTT_sensor_ok[i]=false;	// no sensors detected
		packet_count=0;
		state=HOTT_SENSOR_SEARCH_PERIOD;
	#endif
	phase = HOTT_START;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/HS6200_EMU.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifdef CYRF6936_INSTALLED
#include "iface_hs6200.h"

static bool HS6200_crc;
static uint16_t HS6200_crc_init;
static uint8_t HS6200_address_length, HS6200_tx_addr[5];

static void __attribute__((unused)) HS6200_Init(bool crc_en)
{
	CYRF_GFSK1M_Init(32, 1);	//Dummy number of bytes for now
	HS6200_crc = crc_en;
}

static void __attribute__((unused)) HS6200_SetTXAddr(const uint8_t* addr, uint8_t addr_len)
{
	// precompute address crc
	crc = 0xffff;
	for(uint8_t i=0; i<addr_len; i++)
		crc16_update(addr[addr_len-1-i], 8);
	HS6200_crc_init=crc;
	memcpy(HS6200_tx_addr, addr, addr_len);
	HS6200_address_length = addr_len;
}

static uint16_t __attribute__((unused)) HS6200_calc_crc(uint8_t* msg, uint8_t len)
{
    uint8_t pos;
    
	crc = HS6200_crc_init;
    // pcf + payload
    for(pos=0; pos < len-1; pos++)
        crc16_update(msg[pos], 8);
    // last byte (1 bit only)
    if(len > 0)
        crc16_update(msg[pos+1], 1);
    return crc;
}

static void __attribute__((unused)) HS6200_SendPayload(uint8_t* msg, uint8_t len)
{
	static const uint8_t HS6200_scramble[] = { 0x80,0xf5,0x3b,0x0d,0x6d,0x2a,0xf9,0xbc,0x51,0x8e,0x4c,0xfd,0xc1,0x65,0xd0 }; // todo: find all 32 bytes ...
	uint8_t payload[32];
	const uint8_t no_ack = 1; // never ask for an ack
	static uint8_t pid;
	uint8_t pos = 0;

	if(len > sizeof(HS6200_scramble))
		len = sizeof(HS6200_scramble);

	// address
	for(int8_t i=HS6200_address_length-1; i>=0; i--)
		payload[pos++] = HS6200_tx_addr[i];

	// guard bytes
	payload[pos++] = HS6200_tx_addr[0];
	payload[pos++] = HS6200_tx_addr[0];

	// packet control field
	payload[pos++] = ((len & 0x3f) << 2) | (pid & 0x03);
	payload[pos] = (no_ack & 0x01) << 7;
	pid++;

	// scrambled payload
	if(len > 0)
	{
		payload[pos++] |= (msg[0] ^ HS6200_scramble[0]) >> 1; 
		for(uint8_t i=1; i<len; i++)
			payload[pos++] = ((msg[i-1] ^ HS6200_scramble[i-1]) << 7) | ((msg[i] ^ HS6200_scramble[i]) >> 1);
		payload[pos] = (msg[len-1] ^ HS6200_scramble[len-1]) << 7; 
	}

	// crc
	if(HS6200_crc)
	{
		uint16_t crc = HS6200_calc_crc(&payload[HS6200_address_length+2], len+2);
		uint8_t hcrc = crc >> 8;
		uint8_t lcrc = crc & 0xff;
		payload[pos++] |= (hcrc >> 1);
		payload[pos++] = (hcrc << 7) | (lcrc >> 1);
		payload[pos++] = lcrc << 7;
	}

	#if 0
		debug("E:");
		for(uint8_t i=0; i<pos; i++)
			debug(" %02X",payload[i]);
		debugln("");
	#endif

	//CYRF wants LSB first
	for(uint8_t i=0; i<pos; i++)
		payload[i]=bit_reverse(payload[i]);
	//Send
	CYRF_WriteRegister(CYRF_01_TX_LENGTH, pos);
	CYRF_GFSK1M_SendPayload(payload, pos);
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Height_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with FZ-410 TX

#if defined(HEIGHT_A7105_INO)

#include "iface_a7105.h"

//#define HEIGHT_FORCEID

#define HEIGHT_BIND_COUNT	220		// 5 sec
#define HEIGHT_BIND_CH		0x18	// TX, RX for bind end is 0x17

static void __attribute__((unused)) HEIGHT_build_packet()
{
    packet[0] = 0xA5;
    packet[1] = rx_tx_addr[2];
    packet[2] = rx_tx_addr[3];
	packet[3] = convert_channel_8b(AILERON);	//00..80..FF
	packet[4] = convert_channel_8b(ELEVATOR);	//00..80..FF
	packet[5] = convert_channel_8b(THROTTLE);	//00..FF
	packet[6] = convert_channel_8b(RUDDER);		//00..80..FF
    packet[7] = convert_channel_8b(CH5);		//00..80..FF
    if(sub_protocol == HEIGHT_8CH)
	{
		packet[8] = convert_channel_8b(CH6);	//00..80..FF
		packet[9] = convert_channel_8b(CH7);	//00..80..FF
		packet[10] = convert_channel_8b(CH8);	//00..80..FF
	}
}

uint16_t HEIGHT_callback()
{
	#ifndef FORCE_HEIGHT_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x1B;
		packet[1] = rx_tx_addr[2];
		packet[2] = rx_tx_addr[3];
		A7105_WriteData(3, HEIGHT_BIND_CH);
		if (bind_counter--==0)
			BIND_DONE;
		return 22700;
	}
	else
	{
		if(phase>19)
		{
			phase=0;
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(20*1500);
			#endif
			HEIGHT_build_packet();
			A7105_WriteData(sub_protocol?11:8, hopping_frequency[0]);
			A7105_SetPower();
		}
		else
		{
			A7105_WriteReg(A7105_0F_PLL_I, hopping_frequency[(phase&0x02)>>1]);
			A7105_Strobe(A7105_TX);
		}
		phase++;
	}
	return 1500;
}

void HEIGHT_init()
{
	A7105_Init();

	hopping_frequency[0]=((random(0xfefefefe) & 0x0F)+2)<<2;
	hopping_frequency[1]=hopping_frequency[0]+0x50;
	
	#ifdef HEIGHT_FORCEID
		rx_tx_addr[2]=0x35;
		rx_tx_addr[3]=0xD0;
		hopping_frequency[0]=0x18;
		hopping_frequency[1]=0x68;
	#endif
	
	phase=255;
	bind_counter = HEIGHT_BIND_COUNT;
}
#endif
// Normal packet is 8 bytes: 0xA5 0xAF 0x59 0x84 0x7A 0x00 0x80 0xFF
// Protocol is using AETR channel order, 1 byte per channel 00..80..FF including trim. Channels are in packet [3,4,5,6].
// packet[0,1,2,7] values are constant in normal mode.
// packet[0]=0xA5 -> normal mode
// packet[1,2] ->ID
// packet[7]=0xFF -> ???
// Channel values are updated every 30ms which is quite slow, slower than PPM... 
// Packets are sent every 1500s on 2 different channels. 2 times on first channel, 2 times on second channel and restart. The channels are changing between the files 0x08, 0x58 and 0x18, 0x68.
//
// Bind is sending 3 bytes on channel 0x18: 0x1B 0x35 0xD0 every 22.7ms
// packet[0]=0x1B -> bind mode
// packet[1,2] ->ID
// It listens for the model on channel 0x17 and recieves 0x1B 0x35 0xD0 when the plane accepts bind.
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hisky_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/hisky_nrf24l01.c dated 2015-03-27

#if defined(HISKY_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define HISKY_BIND_COUNT 1000
#define HISKY_TXID_SIZE 5
#define HISKY_FREQUENCE_NUM  20
//
uint8_t bind_buf_arry[4][10];

static void __attribute__((unused)) HISKY_build_binding_packet(void)
{
	uint8_t i;
	uint16_t sum=0;
	uint8_t sum_l,sum_h;

	for(i=0;i<5;i++)
		sum += rx_tx_addr[i];

	sum_l = (uint8_t)sum;//low byte
	sum >>= 8;
	sum_h = (uint8_t)sum;//high bye

	bind_buf_arry[0][0] = 0xff;
	bind_buf_arry[0][1] = 0xaa;
	bind_buf_arry[0][2] = 0x55;

	for(i=3;i<8;i++)
		bind_buf_arry[0][i] = rx_tx_addr[i-3];

	for(i=1;i<4;i++)
	{
		bind_buf_arry[i][0] = sum_l;
		bind_buf_arry[i][1] = sum_h;
		bind_buf_arry[i][2] = i-1;
	}

	for(i=0;i<7;i++)
	{	bind_buf_arry[1][i+3] = hopping_frequency[i];
		bind_buf_arry[2][i+3] = hopping_frequency[i+7];
		bind_buf_arry[3][i+3] = hopping_frequency[i+14];
	}
}

static void __attribute__((unused)) HISKY_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 81);			// binding packet must be set in channel 81
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, 10);		// payload size = 10
	#ifndef MULTI_AIR
	if(sub_protocol==HK310)
		NRF24L01_SetBitrate(NRF24L01_BR_250K);			// 250Kbps
	#endif
}

// HiSky channel sequence: AILE  ELEV  THRO  RUDD  GEAR  PITCH, channel data value is from 0 to 1000
// Channel 7 - Gyro mode, 0 - 6 axis, 3 - 3 axis 
static void __attribute__((unused)) HISKY_build_ch_data()
{
	uint16_t temp;
	uint8_t i,j;
	for (i = 0; i< 8; i++) {
		j=CH_AETR[i];
		temp=convert_channel_16b_limit(j,0,1000);            			
		if (j == CH3) // It is clear that hisky's throttle stick is made reversely, so I adjust it here on purpose
			temp = 1000 - temp;
		if (j == CH7)
			temp = temp < 400 ? 0 : 3; // Gyro mode, 0 - 6 axis, 3 - 3 axis 
		packet[i] = (uint8_t)(temp&0xFF);
		packet[i<4?8:9]>>=2;
		packet[i<4?8:9]|=(temp>>2)&0xc0;
	}
}

uint16_t HISKY_callback()
{
	phase++;
	#ifdef MULTI_AIR
		if(sub_protocol==HK310)
		{
			SUB_PROTO_INVALID;
			return 10000;
		}
	#else
	if(sub_protocol==HK310)
		switch(phase)
		{
			case 1:
				NRF24L01_SetPower();
				phase=2;
				break;
			case 3:
				if (! bind_counter)
					NRF24L01_WritePayload(packet,10); // 2 packets per 5ms
				break;
			case 4:
				phase=6;
				break;
			case 7:	// build packet
				#ifdef MULTI_SYNC
					telemetry_set_input_sync(5000);
				#endif
				#ifdef FAILSAFE_ENABLE
					if(IS_FAILSAFE_VALUES_on && hopping_frequency_no==0)
					{ //  send failsafe every 100ms
						convert_failsafe_HK310(RUDDER,  &packet[0],&packet[1]);
						convert_failsafe_HK310(THROTTLE,&packet[2],&packet[3]);
						convert_failsafe_HK310(CH5,    &packet[4],&packet[5]);
						packet[7]=0xAA;
						packet[8]=0x5A;
						FAILSAFE_VALUES_off;
					}
					else
				#endif
					{
						convert_channel_HK310(RUDDER,  &packet[0],&packet[1]);
						convert_channel_HK310(THROTTLE,&packet[2],&packet[3]);
						convert_channel_HK310(CH5,    &packet[4],&packet[5]);
						packet[7]=0x55;
						packet[8]=0x67;
					}
				phase=8;
				break;
		}
	#endif
	switch(phase)
	{
		case 1:
			NRF24L01_FlushTx();
			break;
		case 2:
			if (bind_counter != 0)
			{
				//Set TX id and channel for bind packet
				NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t *)"\x12\x23\x23\x45\x78", 5);
				NRF24L01_WriteReg(NRF24L01_05_RF_CH, 81);
			}
			break;
		case 3:
			if (bind_counter != 0)
			{
				bind_counter--;//
				if (! bind_counter) //Binding complete
					BIND_DONE;//
				//Send bind packet
				NRF24L01_WritePayload(bind_buf_arry[binding_idx],10);
				binding_idx++;
				if (binding_idx >= 4)
					binding_idx = 0;
			}
			break;
		case 4:
			if (bind_counter != 0)
				NRF24L01_FlushTx();
			break;
		case 5:
			//Set TX power
			NRF24L01_SetPower();
			break;
		case 6:
			//Set TX id and channel for normal packet
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);
			hopping_frequency_no++;
			if (hopping_frequency_no >= HISKY_FREQUENCE_NUM)
				hopping_frequency_no = 0;
			break;
		case 7:
			//Build normal packet
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(9000);
			#endif
			HISKY_build_ch_data();
			break;
		case 8:
			break;
		default:
			//Send normal packet
			phase = 0;
			NRF24L01_WritePayload(packet,10);
			break;
	}
	return 1000;  // send 1 binding packet and 1 data packet per 9ms	
}

static void __attribute__((unused)) HISKY_initialize_tx_id()
{
	//Generate frequency hopping table	
	#ifndef MULTI_AIR
	if(sub_protocol==HK310)
	{
		// for HiSky surface protocol, the transmitter always generates hop channels in sequential order. 
		// The transmitter only generates the first hop channel between 0 and 49. So the channel range is from 0 to 69.
		hopping_frequency_no=rx_tx_addr[0]%50;
		for(uint8_t i=0;i<HISKY_FREQUENCE_NUM;i++)
			hopping_frequency[i]=hopping_frequency_no++;	// Sequential order hop channels...
	}
	else
	#endif
		// HiSky air protocol uses TX id as an address for nRF24L01, and uses frequency hopping sequence
		// which does not depend on this id and is passed explicitly in binding sequence. So we are free
		// to generate this sequence as we wish. It should be in the range [02..77]
		calc_fh_channels(HISKY_FREQUENCE_NUM);
}

void HISKY_init()
{
	HISKY_initialize_tx_id();
	HISKY_build_binding_packet();
	HISKY_RF_init();
	phase = 0;
	hopping_frequency_no = 0;
	binding_idx = 0;

	if(IS_BIND_IN_PROGRESS)
		bind_counter = HISKY_BIND_COUNT;
	else 
		bind_counter = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hitec_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(HITEC_CC2500_INO)

#include "iface_cc2500.h"

//#define HITEC_FORCE_ID	//Use the ID and hopping table from the original dump

#define HITEC_COARSE			0

#define HITEC_PACKET_LEN		13
#define HITEC_TX_ID_LEN			2
#define HITEC_BIND_COUNT		444	// 10sec
#define HITEC_NUM_FREQUENCE		21
#define HITEC_BIND_NUM_FREQUENCE 14

enum {
    HITEC_START = 0x00,
    HITEC_CALIB = 0x01,
    HITEC_PREP  = 0x02,
    HITEC_DATA1 = 0x03,
    HITEC_DATA2 = 0x04,
    HITEC_DATA3 = 0x05,
    HITEC_DATA4	= 0x06,
    HITEC_RX1	= 0x07,
    HITEC_RX2	= 0x08,
};

const PROGMEM uint8_t HITEC_init_values[] = {
  /* 00 */ 0x2F, 0x2E, 0x2F, 0x07, 0xD3, 0x91, 0xFF, 0x04,
  /* 08 */ 0x45, 0x00, 0x00, 0x12, 0x00, 0x5C, 0x85, 0xE8 + HITEC_COARSE,
  /* 10 */ 0x3D, 0x3B, 0x73, 0x73, 0x7A, 0x01, 0x07, 0x30,
  /* 18 */ 0x08, 0x1D, 0x1C, 0xC7, 0x40, 0xB0, 0x87, 0x6B,
  /* 20 */ 0xF8, 0xB6, 0x10, 0xEA, 0x0A, 0x00, 0x11
};

static void __attribute__((unused)) HITEC_CC2500_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i < 39; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&HITEC_init_values[i]));

	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	prev_option = option;

	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
}

// Generate RF channels
static void __attribute__((unused)) HITEC_RF_channels()
{
	//Normal hopping
	uint8_t idx = 0;
	uint32_t rnd = MProtocol_id;

	while (idx < HITEC_NUM_FREQUENCE)
	{
		uint8_t i;
		uint8_t count_0_47 = 0, count_48_93 = 0, count_94_140 = 0;

		rnd = rnd * 0x0019660D + 0x3C6EF35F; // Randomization
		// Use least-significant byte and make sure it's pair.
		uint8_t next_ch = ((rnd >> 8) % 141) & 0xFE;
		// Check that it's not duplicated and spread uniformly
		for (i = 0; i < idx; i++) {
			if(hopping_frequency[i] == next_ch)
				break;
			if(hopping_frequency[i] <= 47)
				count_0_47++;
			else if (hopping_frequency[i] <= 93)
				count_48_93++;
			else
				count_94_140++;
		}
		if (i != idx)
			continue;
		if ( (next_ch <= 47 && count_0_47 < 8) || (next_ch >= 48 && next_ch <= 93 && count_48_93 < 8) || (next_ch >= 94 && count_94_140 < 8) )
			hopping_frequency[idx++] = next_ch;//find hopping frequency
	}
}

static void __attribute__((unused)) HITEC_tune_chan()
{
	CC2500_Strobe(CC2500_SIDLE);
	if(IS_BIND_IN_PROGRESS)
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency_no*10);
	else
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[hopping_frequency_no]);
	CC2500_Strobe(CC2500_SFTX);
	CC2500_Strobe(CC2500_SCAL);
	CC2500_Strobe(CC2500_STX);
}

static void __attribute__((unused)) HITEC_change_chan_fast()
{
	CC2500_Strobe(CC2500_SIDLE);
	if(IS_BIND_IN_PROGRESS)
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency_no*10);
	else
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[hopping_frequency_no]);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[hopping_frequency_no]);
}

static void __attribute__((unused)) HITEC_build_packet()
{
	static boolean F5_frame=false;
	static uint8_t F5_counter=0;
	uint8_t offset;
	
	packet[1] = rx_tx_addr[1];
	packet[2] = rx_tx_addr[2];
	packet[3] = rx_tx_addr[3];
	packet[22] = 0xEE;			// unknown always 0xEE
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x16;		// 22 bytes to follow
		memset(packet+5,0x00,14);
		switch(bind_phase)
		{
			case 0x72:			// first part of the hopping table
				for(uint8_t i=0;i<14;i++)
					packet[5+i]=hopping_frequency[i]>>1;
				break;
			case 0x73:			// second part of the hopping table
				for(uint8_t i=0;i<7;i++)
					packet[5+i]=hopping_frequency[i+14]>>1;
				break;
			case 0x74:
				packet[7]=0x55;	// unknown but bind does not complete if not there
				packet[8]=0x55;	// unknown but bind does not complete if not there
				break;
			case 0x7B:
				packet[5]=hopping_frequency[13]>>1;	// if not there the Optima link is jerky...
				packet[14]=0x2A;
				packet[15]=0x46; // unknown but if 0x45 then 17=0x46, if 0x46 then 17=0x46 or 0x47, if 0x47 then 0x45 or 0x46
				packet[16]=0x2A;
				packet[17]=0x47;
				packet[18]=0x2A;
				break;
		}
		if(sub_protocol==MINIMA)
			packet[4] = bind_phase+0x10;
		else
			packet[4] = bind_phase;	// Optima: increments based on RX answer
		packet[19] = 0x08;		// packet sequence
		offset=20;				// packet[20] and [21]
	}
	else
	{
		packet[0] = 0x1A;		// 26 bytes to follow
		for(uint8_t i=0;i<9;i++)
		{
			uint16_t ch = convert_channel_16b_nolimit(i,0x1B87,0x3905,false);
			packet[4+2*i] = ch >> 8;
			packet[5+2*i] = ch & 0xFF;
		}
		packet[23] = 0x80;		// packet sequence
		offset=24;				// packet[24] and [25]
		packet[26] = 0x00;		// unknown always 0 and the RX doesn't seem to care about the value?
	}

	if(F5_frame)
	{// No idea what it is but Minima RXs are expecting these frames to work to work
		packet[offset] = 0xF5;
		packet[offset+1] = 0xDF;
		if((F5_counter%9)==0)
			packet[offset+1] -= 0x04;	// every 8 packets send 0xDB
		F5_counter++;
		F5_counter%=59;					// every 6 0xDB packets wait only 4 to resend instead of 8
		F5_frame=false;					// alternate
		if(IS_BIND_IN_PROGRESS)
			packet[offset+1]++;			// when binding the values are 0xE0 and 0xDC
	}
	else
	{
		packet[offset] = 0x00;
		packet[offset+1] = 0x00;
		F5_frame=true;					// alternate
	}
/*	debug("P:");
	for(uint8_t i=0;i<packet[0]+1;i++)
		debug("%02X,",packet[i]);
	debugln("");
*/
}

static void __attribute__((unused)) HITEC_send_packet()
{
	CC2500_WriteData(packet, packet[0]+1);
	if(IS_BIND_IN_PROGRESS)
	{
		packet[19] >>= 1;	// packet sequence
		if( (packet[4] & 0xFE) ==0x82 )
		{ // Minima
			packet[4] ^= 1;					// alternate 0x82 and 0x83
			if( packet[4] & 0x01 )
				for(uint8_t i=0;i<7;i++)	// 0x83
					packet[5+i]=hopping_frequency[i+14]>>1;
			else
				for(uint8_t i=0;i<14;i++)	// 0x82
					packet[5+i]=hopping_frequency[i]>>1;
		}
	}
	else
		packet[23] >>= 1;	// packet sequence
}

uint16_t HITEC_callback()
{
	switch(phase)
	{
		case HITEC_START:
			HITEC_CC2500_init();
			bind_phase=0x72;
			if(IS_BIND_IN_PROGRESS)
			{
				bind_counter = HITEC_BIND_COUNT;
				rf_ch_num=HITEC_BIND_NUM_FREQUENCE;
			}
			else
			{
				bind_counter=0;
				rf_ch_num=HITEC_NUM_FREQUENCE;
				//Set TXID
				CC2500_WriteReg(CC2500_05_SYNC0,rx_tx_addr[2]);
				CC2500_WriteReg(CC2500_04_SYNC1,rx_tx_addr[3]);
			}
			hopping_frequency_no=0;
			HITEC_tune_chan();
			phase = HITEC_CALIB;
			return 2000;
		case HITEC_CALIB:
			calData[hopping_frequency_no]=CC2500_ReadReg(CC2500_25_FSCAL1);
			hopping_frequency_no++;
			if (hopping_frequency_no < rf_ch_num)
				HITEC_tune_chan();
			else
			{
				hopping_frequency_no = 0;
				phase = HITEC_PREP;
			}
			return 2000;

		/* Work cycle: 22.5ms */
#define HITEC_PACKET_PERIOD	22500
#define HITEC_PREP_TIMING	462
#define HITEC_DATA_TIMING	2736
#define HITEC_RX1_TIMING	4636
		case HITEC_PREP:
			if ( prev_option == option )
			{	// No user frequency change
				#ifdef MULTI_SYNC
					telemetry_set_input_sync(HITEC_PACKET_PERIOD);
				#endif
				HITEC_change_chan_fast();
				hopping_frequency_no++;
				if(hopping_frequency_no>=rf_ch_num)
					hopping_frequency_no=0;
				CC2500_SetPower();
				CC2500_SetTxRxMode(TX_EN);
				HITEC_build_packet();
				phase++;
			}
			else
				phase = HITEC_START;	// Restart the tune process if option is changed to get good tuned values
			return HITEC_PREP_TIMING;
		case HITEC_DATA1:
		case HITEC_DATA2:
		case HITEC_DATA3:
		case HITEC_DATA4:
			HITEC_send_packet();
			phase++;
			return HITEC_DATA_TIMING;
		case HITEC_RX1:
			CC2500_SetTxRxMode(RX_EN);
			CC2500_Strobe(CC2500_SRX);	// Turn RX ON
			phase++;
			return HITEC_RX1_TIMING;
		case HITEC_RX2:
			uint8_t len=CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;
			if(len && len<TELEMETRY_BUFFER_SIZE)
			{ // Something has been received
				CC2500_ReadData(packet_in, len);
				if( (packet_in[len-1] & 0x80) && packet_in[0]==len-3 && packet_in[1]==rx_tx_addr[1] && packet_in[2]==rx_tx_addr[2] && packet_in[3]==rx_tx_addr[3])
				{ //valid crc && length ok && tx_id ok
					debug("RX:l=%d",len);
					for(uint8_t i=0;i<len;i++)
						debug(",%02X",packet_in[i]);
					if(IS_BIND_IN_PROGRESS)
					{
						if(len==13)	// Bind packets have a length of 13
						{ // bind packet: 0A,00,E5,F2,7X,05,06,07,08,09,00
							debug(",bind");
							boolean check=true;
							for(uint8_t i=5;i<10;i++)
								if(packet_in[i]!=i) check=false;
							if((packet_in[4]&0xF0)==0x70 && check)
							{
								bind_phase=packet_in[4]+1;
								if(bind_phase==0x7B)
									bind_counter=164;	// in dumps the RX stops to reply at 0x7B so wait a little and exit
							}
						}
					}
					else
						if( len==15 && packet_in[4]==0 && packet_in[12]==0 )
						{	// Valid telemetry packets
							// no station:
							//		0C,1C,A1,2B,00,00,00,00,00,00,00,8D,00,64,8E	-> 00 8D=>RX battery voltage 0x008D/28=5.03V
							// with HTS-SS:
							//		0C,1C,A1,2B,00,11,AF,00,2D,00,8D,11,00,4D,96	-> 00 8D=>RX battery voltage 0x008D/28=5.03V
							//		0C,1C,A1,2B,00,12,00,00,00,00,00,12,00,52,93
							//		0C,1C,A1,2B,00,13,00,00,00,00,46,13,00,52,8B	-> 46=>temperature2 0x46-0x28=30C
							//		0C,1C,A1,2B,00,14,00,00,00,00,41,14,00,2C,93	-> 41=>temperature1 0x41-0x28=25C
							//		0C,1C,A1,2B,00,15,00,2A,00,0E,00,15,00,44,96	-> 2A 00=>rpm1=420, 0E 00=>rpm2=140 
							//		0C,1C,A1,2B,00,16,00,00,00,00,00,16,00,2C,8E
							//		0C,1C,A1,2B,00,17,00,00,00,42,44,17,00,48,8D	-> 42=>temperature3 0x42-0x28=26C,44=>temperature4 0x44-0x28=28C
							//		0C,1C,A1,2B,00,18,00,00,00,00,00,18,00,50,92
							debug(",telem,%02x",packet_in[14]&0x7F);
							#if defined(HITEC_FW_TELEMETRY) || defined(HITEC_HUB_TELEMETRY)
								TX_RSSI = packet_in[13];
								if(TX_RSSI >=128)
									TX_RSSI -= 128;
								else
									TX_RSSI += 128;
								TX_LQI = packet_in[14]&0x7F;
							#endif
							#if defined(HITEC_FW_TELEMETRY)
								if(sub_protocol==OPT_FW)
								{
									// 8 bytes telemetry packets => see at the end of this file how to fully decode it
									packet_in[0]=TX_RSSI;				// TX RSSI
									packet_in[1]=TX_LQI;				// TX LQI
									uint8_t offset=packet_in[5]==0?1:0;
									for(uint8_t i=5;i < 11; i++)
										packet_in[i-3]=packet_in[i+offset];	// frame number followed by 5 bytes of data
									telemetry_link=2;			// telemetry forward available
								}
							#endif
							#if defined(HITEC_HUB_TELEMETRY)
								if(sub_protocol==OPT_HUB)
								{
									switch(packet_in[5])		// telemetry frame number
									{
										case 0x00:
											v_lipo1 = (packet_in[10])<<5 | (packet_in[11])>>3;	// calculation in float is volt=(packet_in[10]<<8+packet_in[11])/28
											break;
										case 0x11:
											v_lipo1 = (packet_in[9])<<5 | (packet_in[10])>>3;	// calculation in float is volt=(packet_in[9]<<8+packet_in[10])/28
											break;
										case 0x18:
											v_lipo2 =  (packet_in[6])<<5 | (packet_in[7])>>3;	// calculation in float is volt=(packet_in[6]<<8+packet_in[7])/10
											break;
									}
									telemetry_link=1;			// telemetry hub available
								}
							#endif
						}
					debugln("");
				}
			}
			CC2500_Strobe(CC2500_SFRX);	// Flush the RX FIFO buffer
			phase = HITEC_PREP;
			if(bind_counter)
			{
				bind_counter--;
				if(!bind_counter)
				{
					BIND_DONE;
					phase=HITEC_START;
				}
			}
			return (HITEC_PACKET_PERIOD -HITEC_PREP_TIMING -4*HITEC_DATA_TIMING -HITEC_RX1_TIMING);
	}
	return 0;
}

void HITEC_init()
{
	HITEC_RF_channels();
	#ifdef HITEC_FORCE_ID	// ID and channels taken from dump
		rx_tx_addr[1]=0x00;
		rx_tx_addr[2]=0x03;
		rx_tx_addr[3]=0x6A;
		memcpy((void *)hopping_frequency,(void *)"\x00\x3A\x4A\x32\x0C\x58\x2A\x10\x26\x20\x08\x60\x68\x70\x78\x80\x88\x56\x5E\x66\x6E",HITEC_NUM_FREQUENCE);
	#endif
	phase = HITEC_START;
}

/* Full telemetry 
packet[0] = TX RSSI value
packet[1] = TX LQI value
packet[2] = frame number
packet[3-7] telemetry data

The frame number takes the following values: 0x00, 0x11, 0x12, ..., 0x1C. The frames can be present or not, they also do not have to follow each others.
Here is a description of the telemetry data for each frame number:
- frame 0x00
data byte 0 -> 0x00				unknown
data byte 1 -> 0x00				unknown
data byte 2 -> 0x00				unknown
data byte 3 -> RX Batt Volt_H
data byte 4 -> RX Batt Volt_L => RX Batt=(Volt_H*256+Volt_L)/28
- frame 0x11
data byte 0 -> 0xAF				start of frame
data byte 1 -> 0x00				unknown
data byte 2 -> 0x2D				station type 0x2D=standard station nitro or electric, 0xAC=advanced station
data byte 3 -> RX Batt Volt_H
data byte 4 -> RX Batt Volt_L => RX Batt=(Volt_H*256+Volt_L)/28
- frame 0x12
data byte 0 -> Lat_sec_H		GPS : latitude second
data byte 1 -> Lat_sec_L		signed int : 1/100 of second
data byte 2 -> Lat_deg_min_H	GPS : latitude degree.minute
data byte 3 -> Lat_deg_min_L	signed int : +=North, - = south
data byte 4 -> Time_second		GPS Time
- frame 0x13
data byte 0 -> 					GPS Longitude second
data byte 1 -> 					signed int : 1/100 of second
data byte 2 -> 					GPS Longitude degree.minute
data byte 3 -> 					signed int : +=Est, - = west
data byte 4 -> Temp2			Temperature2=Temp2-40C
- frame 0x14
data byte 0 -> Speed_H
data byte 1 -> Speed_L			GPS Speed=Speed_H*256+Speed_L km/h
data byte 2 -> Alti_sea_H
data byte 3 -> Alti_sea_L		GPS Altitude=Alti_sea_H*256+Alti_sea_L m
data byte 4 -> Temp1			Temperature1=Temp1-40C
- frame 0x15
data byte 0 -> FUEL
data byte 1 -> RPM1_L
data byte 2 -> RPM1_H			RPM1=RPM1_H*256+RPM1_L
data byte 3 -> RPM2_L
data byte 4 -> RPM2_H			RPM2=RPM2_H*256+RPM2_L
- frame 0x16
data byte 0 -> Date_year		GPS Date
data byte 1 -> Date_month
data byte 2 -> Date_day
data byte 3 -> Time_hour		GPS Time
data byte 4 -> Time_min
- frame 0x17
data byte 0 -> COURSEH
data byte 1 -> COURSEL			GPS heading = COURSEH*256+COURSEL in degrees
data byte 2 -> Count			GPS satellites
data byte 3 -> Temp3			Temperature3=Temp2-40C
data byte 4 -> Temp4			Temperature4=Temp3-40C
- frame 0x18
data byte 0 -> Volt_L			Volt=(Volt_H*256+Volt_L)/10 V
data byte 1 -> Volt_H
data byte 2 -> AMP_L
data byte 3 -> AMP_H			Amp=(AMP1_*256+AMP_L -180)/14 in signed A
- frame 0x19					Servo sensor
data byte 0 -> AMP_Servo1		Amp=AMP_Servo1/10 in A
data byte 1 -> AMP_Servo2		Amp=AMP_Servo2/10 in A
data byte 2 -> AMP_Servo3		Amp=AMP_Servo3/10 in A
data byte 3 -> AMP_Servo4		Amp=AMP_Servo4/10 in A
- frame 0x1A
data byte 2 -> ASpeed_H			Air speed=ASpeed_H*256+ASpeed_L km/h
data byte 3 -> ASpeed_L
- frame 0x1B					Variometer sensor
data byte 0 -> Alti1H
data byte 1 -> Alti1L			Altitude unfiltered
data byte 2 -> Alti2H
data byte 3 -> Alti2L			Altitude filtered
- frame 0x1C					Unknown
- frame 0x22					Unknown
*/
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hontai_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(HONTAI_NRF24L01_INO)

#include "iface_xn297.h"	// mix of nrf and xn297 at 1Mb...

#define HONTAI_BIND_COUNT			80
#define HONTAI_PACKET_PERIOD		13500
#define FQ777_951_PACKET_PERIOD		10000
#define HONTAI_INITIAL_WAIT			500
#define HONTAI_BIND_PACKET_SIZE		10
#define HONTAI_PACKET_SIZE			12
#define HONTAI_RF_BIND_CHANNEL		0
#define HONTAI_XKK170_RF_BIND_CHANNEL	20
#define HONTAI_XKK170_PACKET_PERIOD	8085

//#define FORCE_HONTAI_XKK170_ORIGINAL_ID

enum{
	HONTAI_FLAG_FLIP		= 0x01,
	HONTAI_FLAG_PICTURE		= 0x02,
	HONTAI_FLAG_VIDEO		= 0x04,
	HONTAI_FLAG_HEADLESS	= 0x08,
	HONTAI_FLAG_RTH			= 0x10,
	HONTAI_FLAG_CALIBRATE	= 0x20,
};

static void __attribute__((unused)) HONTAI_send_packet()
{
	if (IS_BIND_IN_PROGRESS)
	{
		memcpy(packet, rx_tx_addr, 5);
		memset(&packet[5], 0, 3);
		//if(sub_protocol == HONTAI_XKK170)
		//	packet[6] = 0xD2;
		packet_length = HONTAI_BIND_PACKET_SIZE;
	}
	else
	{
		/*if(sub_protocol == JJRCX1)
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no++]);
		else*/
			XN297_Hopping(hopping_frequency_no++);
		hopping_frequency_no %= 3;
		memset(packet,0,HONTAI_PACKET_SIZE);
		for(uint8_t i=0; i<4; i++)
			packet[i+3] = convert_channel_8b(CH_TAER[i]);
		if(sub_protocol != HONTAI_XKK170)
		{
			//Drive trims
			packet[7] = (packet[4]>>3)-16;
			packet[8] = (packet[6]>>3)-16;
			packet[9] = (packet[5]>>3)-16;
			//Reverse aileron
			packet[4] ^= 0xFF;
			//Limit range
			for(uint8_t i=3; i<7; i++)
				packet[i] >>= 2;			//00..63
		}
		else
		{//K170
			//packet[2] = 0xAB; //This value keeps changing when touching any button... Left over from debug?
			//Sticks
			for(uint8_t i=1; i<4; i++)
				packet[i+3] = convert_channel_16b_limit(CH_TAER[i],0x28,0xD8);
			packet[6] ^= 0xFF;	//Reverse rudder
			//flags
			packet[1] =  GET_FLAG(CH8_SW, 0x04);	//Gyro calibration (momentary)
			//			|GET_FLAG(CH_SW, 0x08)		//Unk long press second top right button (momentary)
			//			|GET_FLAG(CH_SW, 0x10)		//Unk short press second top right button (toggle)
			//			|GET_FLAG(CH_SW, 0x40)		//Unk short press second top left button (momentary)
			//			|GET_FLAG(CH_SW, 0x80);		//Unk long press second top left button (momentary)
			uint8_t rate = 0x80;					//Mid rate
			if(CH5_SW)
				rate = 0xC0;						//High rate
			else if(Channel_data[CH5] < CHANNEL_MIN_COMMAND)
				rate = 0x40;						//Low rate
			packet[8] = rate
						|GET_FLAG(CH7_SW, 0x04)		//Take-off/Landing (momentary)
						|GET_FLAG(CH6_SW, 0x10);	//Emergency (momentary)
			//Trims
			packet[7] = ((convert_channel_8b(CH9)^0xFF)>>2)-31;	// Trim Aileron
			packet[9] = ( convert_channel_8b(CH10)     >>2)-32;	// Trim Elevator
		}
		
		switch(sub_protocol)
		{
			case HONTAI:
				packet[0]  = 0x0B;
				packet[3] |= GET_FLAG(CH7_SW, 0x01);				// Picture
				packet[4] |= GET_FLAG(CH10_SW, 0x80)				// RTH
						  |  GET_FLAG(CH9_SW, 0x40);				// Headless
				packet[5] |= GET_FLAG(CH11_SW, 0x80)				// Calibrate
						  |  GET_FLAG(CH5_SW, 0x40);				// Flip
				packet[6] |= GET_FLAG(CH8_SW, 0x80);				// Video
				break;
			case JJRCX1:
				packet[0]  = GET_FLAG(CH6_SW, 0x02);				// Arm
				packet[3] |= GET_FLAG(CH7_SW, 0x01);				// Picture
				packet[4] |= 0x80;									// unknown
				packet[5] |= GET_FLAG(CH11_SW, 0x80)				// Calibrate
						  |  GET_FLAG(CH5_SW, 0x40);				// Flip
				packet[6] |= GET_FLAG(CH8_SW, 0x80);				// Video
				packet[8]  = 0xC0									// high rate, no rudder trim
						  |  GET_FLAG(CH10_SW, 0x02)				// RTH
						  |  GET_FLAG(CH9_SW, 0x01);				// Headless
				break;
			case X5C1:
				packet[0]  = 0x0B;
				packet[3] |= GET_FLAG(CH7_SW, 0x01);				// Picture
				packet[4]  = 0x80									// unknown
						  |  GET_FLAG(CH6_SW, 0x40);				// Lights
				packet[5] |= GET_FLAG(CH11_SW, 0x80)				// Calibrate
						  |  GET_FLAG(CH5_SW, 0x40);				// Flip
				packet[6] |= GET_FLAG(CH8_SW, 0x80);				// Video
				packet[7] <<= 1;									// Aileron trim
				packet[8]  = 0xC0									// high rate, no rudder trim
						  |  GET_FLAG(CH10_SW, 0x02)				// RTH
						  |  GET_FLAG(CH9_SW, 0x01);				// Headless
				packet[9] <<= 1;									// Elevator trim
				break;
			case FQ777_951:
				packet[0]  = GET_FLAG(CH7_SW, 0x01)					// Picture
						  |  GET_FLAG(CH8_SW, 0x02);				// Video
				packet[3] |= GET_FLAG(CH5_SW, 0x01);				// Flip
				packet[4] |= 0xC0;									// High rate (mid=0xa0, low=0x60)
				packet[5] |= GET_FLAG(CH11_SW, 0x80);				// Calibrate
				packet[6] |= GET_FLAG(CH9_SW, 0x40);				// Headless
				break;
		}
		packet_length = HONTAI_PACKET_SIZE;
	}

	if(sub_protocol != HONTAI_XKK170)
	{
		// CRC 16 bits reflected in and out
		crc=0xFFFF;
		for(uint8_t i=0; i< packet_length-2; i++)
			crc16_update(bit_reverse(packet[i]),8);
		crc ^= 0xFFFF;
		packet[packet_length-2]=bit_reverse(crc>>8);
		packet[packet_length-1]=bit_reverse(crc);
	}
	else
		memset(&packet[packet_length-2], 0xAA, 2);

	// Power on, TX mode, 2byte CRC
	/*if(sub_protocol == JJRCX1)
	{
		NRF24L01_SetPower();
		NRF24L01_SetTxRxMode(TX_EN);
		NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
		NRF24L01_FlushTx();
	}
	else*/
	{
		XN297_SetPower();
		XN297_SetTxRxMode(TX_EN);
	}

	if(sub_protocol == JJRCX1)
		NRF24L01_WritePayload(packet, packet_length);
	else
		XN297_WritePayload(packet, packet_length);
	#ifdef DEBUG_SERIAL
		for(uint8_t i=0; i < packet_length; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) HONTAI_RF_init()
{

	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);	// this will select the nrf and initialize it, therefore both sub protocols can use common instructions
	if(sub_protocol == JJRCX1)
	{
		//NRF24L01_Initialize();
		NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t*)"\xd2\xb5\x99\xb3\x4a", 5);
		NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0xff);	// JJRC uses dynamic payload length
		NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3f);			// match other stock settings even though AA disabled...
		NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x07);
		//NRF24L01_WriteReg(NRF24L01_05_RF_CH, HONTAI_RF_BIND_CHANNEL);
	}
	else
	{
		memcpy(rx_id,(const uint8_t*)"\xD2\xB5\x99\xB3\x41",5);
		if(sub_protocol == HONTAI_XKK170)
			rx_id[4] = 0x4A;
		XN297_SetTXAddr(rx_id, 5);
		//XN297_HoppingCalib(3);
	}
	XN297_RFChannel(sub_protocol==HONTAI_XKK170?HONTAI_XKK170_RF_BIND_CHANNEL:HONTAI_RF_BIND_CHANNEL);
}

const uint8_t PROGMEM HONTAI_hopping_frequency[3] = { 0x05, 0x19, 0x28 };

const uint8_t PROGMEM HONTAI_addr_vals[4][16] = {
	{0x24, 0x26, 0x2a, 0x2c, 0x32, 0x34, 0x36, 0x4a, 0x4c, 0x4e, 0x54, 0x56, 0x5a, 0x64, 0x66, 0x6a},
	{0x92, 0x94, 0x96, 0x9a, 0xa4, 0xa6, 0xac, 0xb2, 0xb4, 0xb6, 0xca, 0xcc, 0xd2, 0xd4, 0xd6, 0xda},
	{0x93, 0x95, 0x99, 0x9b, 0xa5, 0xa9, 0xab, 0xad, 0xb3, 0xb5, 0xc9, 0xcb, 0xcd, 0xd3, 0xd5, 0xd9},
	{0x25, 0x29, 0x2b, 0x2d, 0x33, 0x35, 0x49, 0x4b, 0x4d, 0x59, 0x5b, 0x65, 0x69, 0x6b, 0x6d, 0x6e}};

static void __attribute__((unused)) HONTAI_init2()
{
	uint8_t data_tx_addr[5];

	//TX address
	data_tx_addr[0] = pgm_read_byte_near( &HONTAI_addr_vals[0][ rx_tx_addr[3]       & 0x0f]);
	data_tx_addr[1] = pgm_read_byte_near( &HONTAI_addr_vals[1][(rx_tx_addr[3] >> 4) & 0x0f]);
	data_tx_addr[2] = pgm_read_byte_near( &HONTAI_addr_vals[2][ rx_tx_addr[4]       & 0x0f]);
	data_tx_addr[3] = pgm_read_byte_near( &HONTAI_addr_vals[3][(rx_tx_addr[4] >> 4) & 0x0f]);
	data_tx_addr[4] = 0x24;
	#ifdef DEBUG_SERIAL
		debug("A N");
		for(uint8_t i=0; i < 5; i++)
			debug(" %02X", data_tx_addr[i]);
		debugln();
	#endif
	if(sub_protocol == JJRCX1)
		NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, data_tx_addr, 5);
	else
		XN297_SetTXAddr(data_tx_addr, 5);

	//Hopping frequency table
	uint8_t val;
	for(uint8_t i=0;i<3;i++)
	{
		if(sub_protocol==HONTAI_XKK170)
			val = 60+10*i;
		else
		{
			val = pgm_read_byte_near( &HONTAI_hopping_frequency[i] );
			if(sub_protocol == JJRCX1)
				val += 5;
		}
		hopping_frequency[i] = val;
	}
	hopping_frequency_no=0;
	#ifdef DEBUG_SERIAL
		debug("H");
		for(uint8_t i=0; i < 3; i++)
			debug(" %d(%02X)", hopping_frequency[i], hopping_frequency[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) HONTAI_initialize_txid()
{
	rx_tx_addr[4] = rx_tx_addr[2]; 
	// First three bytes some kind of model id? - set same as stock tx
	if(sub_protocol == JJRCX1 || sub_protocol == X5C1)
	{//JJRCX1 & X5C1
		rx_tx_addr[0] = 0x4B;
		rx_tx_addr[1] = 0x59;
		rx_tx_addr[2] = 0x3A;
	}
	else
	{//HONTAI, FQ777_951, HONTAI_XKK170
		rx_tx_addr[0] = 0x4C;
		rx_tx_addr[1] = 0x4B;
		rx_tx_addr[2] = 0x3A;
		#ifdef FORCE_HONTAI_XKK170_ORIGINAL_ID
			if(sub_protocol == HONTAI_XKK170)
			{
				rx_tx_addr[3] = 0x5A;
				rx_tx_addr[4] = 0x06;
			}
		#endif
	}
	#ifdef DEBUG_SERIAL
		debug("A B");
		for(uint8_t i=0; i < 5; i++)
			debug(" %02X", rx_tx_addr[i]);
		debugln();
	#endif
}

uint16_t HONTAI_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			HONTAI_init2();
			BIND_DONE;
		}
	}
	HONTAI_send_packet();
	return packet_period;
}

void HONTAI_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	bind_counter = HONTAI_BIND_COUNT;
	HONTAI_RF_init();
	HONTAI_initialize_txid();
	if(sub_protocol == FQ777_951)
		packet_period = FQ777_951_PACKET_PERIOD;
	else if(sub_protocol == HONTAI_XKK170)
		packet_period = HONTAI_XKK170_PACKET_PERIOD;
	else
		packet_period = HONTAI_PACKET_PERIOD;
			
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Hubsan_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with Hubsan H102D, H107/L/C/D and H107P/C+/D+
// Last sync with hexfet new_protocols/hubsan_a7105.c dated 2015-12-11

#if defined(HUBSAN_A7105_INO)

#include "iface_a7105.h"

enum{
	// flags going to packet[9] (H107)
	HUBSAN_FLAG_VIDEO= 0x01,   // record video
	HUBSAN_FLAG_FLIP = 0x08,   // enable flips
	HUBSAN_FLAG_LED  = 0x04    // enable LEDs
};

enum{
	// flags going to packet[9] (H107 Plus series)
	HUBSAN_FLAG_HEADLESS = 0x08, // headless mode
};

enum{
	// flags going to packet[9] (H301)
	FLAG_H301_VIDEO = 0x01,
	FLAG_H301_STAB  = 0x02,
	FLAG_H301_LED   = 0x10,
	FLAG_H301_RTH   = 0x40,
};

enum{
	// flags going to packet[13] (H107 Plus series)
	HUBSAN_FLAG_SNAPSHOT  = 0x01,
	HUBSAN_FLAG_FLIP_PLUS = 0x80,
};

enum{
	// flags going to packet[9] (H501S)
	FLAG_H501_VIDEO     = 0x01,
	FLAG_H501_LED       = 0x04,
	FLAG_H122D_FLIP     = 0x08,	//H122D
	FLAG_H501_RTH       = 0x20,
	FLAG_H501_HEADLESS1 = 0x40,
	FLAG_H501_GPS_HOLD  = 0x80,
	};

enum{
	// flags going to packet[11] (H122D & H123D)
	FLAG_H123D_FMODES   = 0x03,	//H123D 3 FMODES: Sport mode 1, Sport mode 2, Acro
	FLAG_H122D_OSD	    = 0x20,	//H122D OSD
};

enum{
	// flags going to packet[13] (H501S)
	FLAG_H501_SNAPSHOT  = 0x01,
	FLAG_H501_HEADLESS2 = 0x02,
	FLAG_H501_ALT_HOLD  = 0x08,
};

uint32_t hubsan_id_data;

enum {
	BIND_1,
	BIND_2,
	BIND_3,
	BIND_4,
	BIND_5,
	BIND_6,
	BIND_7,
	BIND_8,
	DATA_1,
	DATA_2,
	DATA_3,
	DATA_4,
	DATA_5,
};
#define HUBSAN_WAIT_WRITE 0x80

static void __attribute__((unused)) hubsan_update_crc()
{
	uint8_t sum = 0;
	for(uint8_t i = 0; i < 15; i++)
		sum += packet[i];
	packet[15] = (256 - (sum % 256)) & 0xFF;
}

static void __attribute__((unused)) hubsan_build_bind_packet(uint8_t bind_state)
{
	static uint8_t handshake_counter;
	if(phase < BIND_7)
		handshake_counter = 0;
	memset(packet, 0, 16);
	packet[0] = bind_state;
	packet[1] = channel;
	packet[2] = (MProtocol_id >> 24) & 0xFF;
	packet[3] = (MProtocol_id >> 16) & 0xFF;
	packet[4] = (MProtocol_id >>  8) & 0xFF;
	packet[5] = (MProtocol_id >>  0) & 0xFF;
	if(hubsan_id_data == ID_NORMAL && sub_protocol != H501)
	{
		packet[6] = 0x08;
		packet[7] = 0xe4;
		packet[8] = 0xea;
		packet[9] = 0x9e;
		packet[10] = 0x50;
		//const uint32_t txid = 0xdb042679; 
		packet[11] = 0xDB;
		packet[12] = 0x04;
		packet[13] = 0x26;
		packet[14] = 0x79;
	}
	else
	{ //ID_PLUS
		if(phase >= BIND_3)
		{
			packet[7] = 0x62;
			packet[8] = 0x16;
		}
		if(phase == BIND_7)
			packet[2] = handshake_counter++;
	}
	hubsan_update_crc();
}

//cc : throttle  observed range: 0x00 - 0xFF (smaller is down)
//ee : rudder    observed range: 0x34 - 0xcc (smaller is right)52-204-60%
//gg : elevator  observed range: 0x3e - 0xbc (smaller is up)62-188 -50%
//ii : aileron   observed range: 0x45 - 0xc3 (smaller is right)69-195-50%
static void __attribute__((unused)) hubsan_build_packet()
{
	static uint8_t vtx_freq = 0, h501_packet = 0; 
	memset(packet, 0, 16);
	if(vtx_freq != option || packet_count==100) // set vTX frequency (H107D)
	{
		vtx_freq = option;
		packet[0] = 0x40;	// vtx data packet
		packet[1] = (vtx_freq>0xF2)?0x17:0x16;
		packet[2] = vtx_freq+0x0D;	// 5645 - 5900 MHz
		packet[3] = 0x82;
		packet_count++;      
	}
	else //20 00 00 00 80 00 7d 00 84 02 64 db 04 26 79 7b
	{
		packet[0] = 0x20;	// normal data packet
		packet[2] = convert_channel_8b(THROTTLE);		//Throtle
	}
	packet[4] = 0xFF - convert_channel_8b(RUDDER);		//Rudder is reversed
	packet[6] = 0xFF - convert_channel_8b(ELEVATOR);	//Elevator is reversed
	packet[8] = convert_channel_8b(AILERON);			//Aileron
	if(hubsan_id_data == ID_NORMAL && sub_protocol==H107)
	{// H107/L/C/D, H102D
		if( packet_count < 100)
		{
			packet[9] = 0x02 | HUBSAN_FLAG_LED | HUBSAN_FLAG_FLIP; // sends default value for the 100 first packets
			packet_count++;
		}
		else
		{
			packet[9] = 0x02;
			// Channel 5
			if(CH5_SW)	packet[9] |= HUBSAN_FLAG_FLIP;
			// Channel 6
			if(CH6_SW)	packet[9] |= HUBSAN_FLAG_LED;
			// Channel 8
			if(CH8_SW)	packet[9] |= HUBSAN_FLAG_VIDEO; // H102D
		}
		packet[10] = 0x64;
		//const uint32_t txid = 0xdb042679; 
		packet[11] = 0xDB;
		packet[12] = 0x04;
		packet[13] = 0x26;
		packet[14] = 0x79;
	} else 	if(sub_protocol==H301)
	{// H301
		if( packet_count < 100)
		{
			packet[9] = FLAG_H301_STAB; // sends default value for the 100 first packets
			packet_count++;
		}
		else
		{
            packet[9] = GET_FLAG(CH6_SW, FLAG_H301_LED)
                      | GET_FLAG(CH7_SW, FLAG_H301_STAB)
                      | GET_FLAG(CH8_SW, FLAG_H301_VIDEO)
                      | GET_FLAG(CH5_SW, FLAG_H301_RTH);
		}
		packet[10] = 0x18; // ?
		packet[12] = 0x5c; // ?
		packet[14] = 0xf6; // ?
	}
	else
	{ //ID_PLUS && H501
		packet[3] = sub_protocol==H501 ? 0x00:0x64;
		packet[5] = sub_protocol==H501 ? 0x00:0x64;
		packet[7] = sub_protocol==H501 ? 0x00:0x64;

		if(sub_protocol==H501)
		{ // H501S
			packet[9] = 0x02
					   | GET_FLAG(CH6_SW, FLAG_H501_LED)
					   | GET_FLAG(CH8_SW, FLAG_H501_VIDEO)
					   | GET_FLAG(CH12_SW, FLAG_H122D_FLIP)	// H122D specific -> flip
					   | GET_FLAG(CH5_SW, FLAG_H501_RTH)
					   | GET_FLAG(CH10_SW, FLAG_H501_GPS_HOLD)
					   | GET_FLAG(CH9_SW, FLAG_H501_HEADLESS1);
			//packet[10]= 0x1A;

			//packet[11] content 0x00 is default
			//H123D specific -> Flight modes
			packet[11] = 0x41;	// Sport mode 1
			if(Channel_data[CH13]>CHANNEL_MAX_COMMAND)
				packet[11]=0x43;	// Acro
			else if(Channel_data[CH13]>CHANNEL_MIN_COMMAND)
				packet[11]=0x42;	// Sport mode 2
			//H122D specific -> OSD but useless...
			//packet[11]|= 0x80
			//		  | GET_FLAG(CHXX_SW,FLAG_H122D_OSD); 

			packet[13] = GET_FLAG(CH9_SW, FLAG_H501_HEADLESS2)
					   | GET_FLAG(CH11_SW, FLAG_H501_ALT_HOLD)
					   | GET_FLAG(CH7_SW, FLAG_H501_SNAPSHOT);
		}
		else
		{ // H107P/C+/D+
			packet[9] = 0x06;
			//FLIP|LIGHT|PICTURE|VIDEO|HEADLESS
			if(CH8_SW)	packet[9] |= HUBSAN_FLAG_VIDEO;
			if(CH9_SW)	packet[9] |= HUBSAN_FLAG_HEADLESS;
			packet[10]= 0x19;
			packet[12]= 0x5C; // ghost channel ?
			packet[13] = 0;
			if(CH7_SW)	packet[13]  = HUBSAN_FLAG_SNAPSHOT;
			if(CH5_SW)	packet[13] |= HUBSAN_FLAG_FLIP_PLUS;
			packet[14]= 0x49; // ghost channel ?
		}
		if(packet_count < 100)
		{ // set channels to neutral for first 100 packets
			packet[2] = 0x80; // throttle neutral is at mid stick on plus series
			packet[4] = 0x80;
			packet[6] = 0x80;
			packet[8] = 0x80;
			packet[9] = 0x06;
			packet[13]= 0x00;
			packet_count++;
		}
		if(sub_protocol==H501)
		{ // H501S
			h501_packet++;
			if(h501_packet == 10)
			{
				memset(packet, 0, 16);
				packet[0] = 0xe8;
			}
			else if(h501_packet == 20)
			{
				memset(packet, 0, 16);
				packet[0] = 0xe9;
			}
			if(h501_packet >= 20) h501_packet = 0;
		}
	}
	hubsan_update_crc();
}

#ifdef HUBSAN_HUB_TELEMETRY
static uint8_t __attribute__((unused)) hubsan_check_integrity() 
{
    if( (packet[0]&0xFE) != 0xE0 )
		return 0;
	uint8_t sum = 0;
    for(uint8_t i = 0; i < 15; i++)
        sum += packet[i];
	return ( packet[15] == (uint8_t)(-sum) );
}
#endif

uint16_t HUBSAN_callback() 
{
#ifdef HUBSAN_HUB_TELEMETRY
	static uint8_t rfMode=0;
#endif
	static uint8_t txState=0;
	uint16_t delay;
	uint8_t i;

	#ifndef FORCE_HUBSAN_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	switch(phase)
	{
		case BIND_1:
			bind_phase++;
			if(bind_phase >= 20 && sub_protocol != H501)
			{
				if(hubsan_id_data == ID_NORMAL)
					hubsan_id_data = ID_PLUS;
				else
					hubsan_id_data = ID_NORMAL;
				A7105_WriteID(hubsan_id_data);    
				bind_phase = 0;
			}
		case BIND_3:
		case BIND_5:
		case BIND_7:
			hubsan_build_bind_packet(phase == BIND_7 ? 9 : (phase == BIND_5 ? 1 : phase + 1 - BIND_1));
			A7105_Strobe(A7105_STANDBY);
			A7105_WriteData(16, channel);
			phase |= HUBSAN_WAIT_WRITE;
			return 3000;
		case BIND_1 | HUBSAN_WAIT_WRITE:
		case BIND_3 | HUBSAN_WAIT_WRITE:
		case BIND_5 | HUBSAN_WAIT_WRITE:
		case BIND_7 | HUBSAN_WAIT_WRITE:
			//wait for completion
			for(i = 0; i< 20; i++)
				if(! (A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			A7105_SetTxRxMode(RX_EN);
			A7105_Strobe(A7105_RX);
			phase &= ~HUBSAN_WAIT_WRITE;
			if(hubsan_id_data == ID_PLUS)
			{
				if(phase == BIND_7 && packet[2] == 9)
				{
					phase = DATA_1;
					A7105_WriteReg(A7105_1F_CODE_I, 0x0F);
					BIND_DONE;
					return 4500;
				}
			}
			phase++;
			return 4500; //7.5msec elapsed since last write
		case BIND_2:
		case BIND_4:
		case BIND_6:
			A7105_SetTxRxMode(TX_EN);
			if(A7105_ReadReg(A7105_00_MODE) & 0x01) {
				phase = BIND_1;
				return 4500; //No signal, restart binding procedure.  12msec elapsed since last write
			}
			A7105_ReadData(16);
			phase++;
			if (phase == BIND_5)
				A7105_WriteID(((uint32_t)packet[2] << 24) | ((uint32_t)packet[3] << 16) | ((uint32_t)packet[4] << 8) | packet[5]);
			return 500;  //8msec elapsed time since last write;
		case BIND_8:
			A7105_SetTxRxMode(TX_EN);
			if(A7105_ReadReg(A7105_00_MODE) & 0x01) {
				phase = BIND_7;
				return 15000; //22.5msec elapsed since last write
			}
			A7105_ReadData(16);
			if(packet[1] == 9 && hubsan_id_data == ID_NORMAL) {
				phase = DATA_1;
				A7105_WriteReg(A7105_1F_CODE_I, 0x0F);
				BIND_DONE;
				return 28000; //35.5msec elapsed since last write
			} else {
				phase = BIND_7;
				return 15000; //22.5 msec elapsed since last write
			}
		case DATA_1:
		case DATA_2:
		case DATA_3:
		case DATA_4:
		case DATA_5:
			if( txState == 0) { // send packet
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(10000);
			#endif
#ifdef HUBSAN_HUB_TELEMETRY
				rfMode = A7105_TX;
#endif
				if( phase == DATA_1)
						A7105_SetPower(); //Keep transmit power in sync
				hubsan_build_packet();
				A7105_Strobe(A7105_STANDBY);
				uint8_t ch;
				if((phase == DATA_5 && hubsan_id_data == ID_NORMAL) && sub_protocol == H107)
					ch = channel + 0x23;
				else
					ch = channel;
				A7105_WriteData(16, ch);
				if (phase == DATA_5)
					phase = DATA_1;
				else
					phase++;
				delay=3000;
			}
			else {
#ifdef HUBSAN_HUB_TELEMETRY
				if( rfMode == A7105_TX)
				{// switch to rx mode 3ms after packet sent
					for( i=0; i<10; i++)
					{
						if( !(A7105_ReadReg(A7105_00_MODE) & 0x01)) {// wait for tx completion
							A7105_SetTxRxMode(RX_EN);
							A7105_Strobe(A7105_RX); 
							rfMode = A7105_RX;
							break;
						}
					}
				}
				if( rfMode == A7105_RX)
				{ // check for telemetry frame
					for( i=0; i<10; i++)
					{
						if( !(A7105_ReadReg(A7105_00_MODE) & 0x01))
						{ // data received
							A7105_ReadData(16);
							if( hubsan_check_integrity() )
							{
								v_lipo1=packet[13]*2;// hubsan lipo voltage 8bits the real value is h_lipo/10(0x2A=42 -> 4.2V)
								telemetry_link=1;
							}	
							A7105_Strobe(A7105_RX);
							// Read TX RSSI
							int16_t temp=256-(A7105_ReadReg(A7105_1D_RSSI_THOLD)*8)/5;		// value from A7105 is between 8 for maximum signal strength to 160 or less
							if(temp<0) temp=0;
							else if(temp>255) temp=255;
							TX_RSSI=temp;
							break;
						}
					}
				}
#endif
				delay=1000;
			}
			if (++txState == 8) { // 3ms + 7*1ms
				A7105_SetTxRxMode(TX_EN);
				txState = 0;
			}
			return delay;
	}
	return 0;
}

void HUBSAN_init()
{
	const uint8_t allowed_ch[] = {0x14, 0x1e, 0x28, 0x32, 0x3c, 0x46, 0x50, 0x5a, 0x64, 0x6e, 0x78, 0x82};
	A7105_Init();

	channel = allowed_ch[MProtocol_id % sizeof(allowed_ch)];
	hubsan_id_data=ID_NORMAL;

	if(IS_BIND_IN_PROGRESS || sub_protocol==H107)
	{
		BIND_IN_PROGRESS;	// autobind protocol
		phase = BIND_1;
	}
	else 
	{
		phase = DATA_1;
		A7105_WriteID(MProtocol_id);
		A7105_WriteReg(A7105_1F_CODE_I, 0x0F);
	}
	packet_count=0;
	bind_phase=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/IKEA_Ansluta_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// This module makes it possible to bind to and control the IKEA "Ansluta" line
// of remote-controlled lights.
// To bind, first switch the receiver into binding mode, then the TX.
// Once bound, the TX can send one of three commands:
//   lights off, lights dimmed 50% and lights on.
// Those are mapped to throttle ranges 0..0x55, 0x56..0xAA, 0xAB..0xFF.
#if defined(IKEAANSLUTA_CC2500_INO)

#include "iface_cc2500.h"

#define IKEAANSLUTA_BIND_COUNT	30  // ~ 2sec autobind/65ms per loop = 30 binding packets

// Commands
#define IKEAANSLUTA_LIGHT_OFF 0x01
#define IKEAANSLUTA_LIGHT_DIM 0x02  // 50% dimmed light
#define IKEAANSLUTA_LIGHT_ON  0x03
#define IKEAANSLUTA_PAIR 0xFF

void IKEAANSLUTA_send_command(uint8_t command){
      CC2500_Strobe(CC2500_SIDLE);
      packet[4] = option;
      packet[5] = command;
      CC2500_WriteData(packet, 8);
}

uint16_t IKEAANSLUTA_callback(void)
{
    if (bind_counter) {
        IKEAANSLUTA_send_command(IKEAANSLUTA_PAIR);
        if(--bind_counter == 0) {
            BIND_DONE;
            CC2500_SetPower();
        }
    }
    else {
        uint8_t throttle = convert_channel_8b(THROTTLE);
        uint8_t cmd = throttle <= 0x55 ? IKEAANSLUTA_LIGHT_OFF : 
                      throttle <= 0xAA ? IKEAANSLUTA_LIGHT_DIM :
                      IKEAANSLUTA_LIGHT_ON;
        IKEAANSLUTA_send_command(cmd);
    }
    return 65535; // 65ms loop cycle is more than enough here (we could make it even longer if not for uint16_t)
}

// Register initialization values as a continuous memory block (to save on flash memory)
const PROGMEM uint8_t IKEAANSLUTA_init_values[] = {
  0xFF, // CC2500_06_PKTLEN
  0x04, // CC2500_07_PKTCTRL1
  0x05, // CC2500_08_PKTCTRL0
  0x00, // CC2500_09_ADDR  (unused, default)
  0x10, // CC2500_0A_CHANNR
  0x09, // CC2500_0B_FSCTRL1
  0x00, // CC2500_0C_FSCTRL0
  0x5D, // CC2500_0D_FREQ2
  0x93, // CC2500_0E_FREQ1
  0xB1, // CC2500_0F_FREQ0
  0x2D, // CC2500_10_MDMCFG4
  0x3B, // CC2500_11_MDMCFG3
  0x73, // CC2500_12_MDMCFG2
  0xA2, // CC2500_13_MDMCFG1
  0xF8, // CC2500_14_MDMCFG0
  0x01, // CC2500_15_DEVIATN
  0x07, // CC2500_16_MCSM2
  0x30, // CC2500_17_MCSM1
  0x18, // CC2500_18_MCSM0
  0x1D, // CC2500_19_FOCCFG
  0x1C, // CC2500_1A_BSCFG
  0xC7, // CC2500_1B_AGCCTRL2
  0x00, // CC2500_1C_AGCCTRL1
  0xB2, // CC2500_1D_AGCCTRL0
  0x87, // CC2500_1E_WOREVT1 (unused, default)
  0x6b, // CC2500_1F_WOREVT0 (unused, default)
  0xf8, // CC2500_20_WORCTRL (unused, default)
  0xB6, // CC2500_21_FREND1
  0x10, // CC2500_22_FREND0
  0xEA, // CC2500_23_FSCAL3
  0x0A, // CC2500_24_FSCAL2
  0x00, // CC2500_25_FSCAL1
  0x11, // CC2500_26_FSCAL0
  0x41, // CC2500_27_RCCTRL1
  0x00, // CC2500_28_RCCTRL0
};

void IKEAANSLUTA_init(void)
{
    if (IS_BIND_DONE) bind_counter = 0;
    else bind_counter = IKEAANSLUTA_BIND_COUNT;

    // All packets we send are the same
    packet[0] = 0x06;
    packet[1] = 0x55;
    packet[2] = 0x01;
    // Bytes 3&4 are the transmitter address (to which the RX binds)
    // Byte 5 is the command.
    packet[3] = rx_tx_addr[3];  // <pseudorandom tx-fixed value> + <rx_num>
    // packet[4] = option;
    // packet[5] = 0x00; // Command goes here
    packet[6] = 0xAA;
    packet[7] = 0xFF;

    // Configure & initialize CC2500
	for (uint8_t i = 0; i <= CC2500_28_RCCTRL0-CC2500_06_PKTLEN; ++i)
		CC2500_WriteReg(CC2500_06_PKTLEN+i, pgm_read_byte_near(&IKEAANSLUTA_init_values[i]));    
    CC2500_SetTxRxMode(TX_EN);
    CC2500_SetPower();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/J6Pro_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(J6PRO_CYRF6936_INO)

#include "iface_cyrf6936.h"

enum PktState {
    J6PRO_BIND,
    J6PRO_BIND_01,
    J6PRO_BIND_03_START,
    J6PRO_BIND_03_CHECK,
    J6PRO_BIND_05_1,
    J6PRO_BIND_05_2,
    J6PRO_BIND_05_3,
    J6PRO_BIND_05_4,
    J6PRO_BIND_05_5,
    J6PRO_BIND_05_6,
    J6PRO_CHANSEL,
    J6PRO_CHAN_1,
    J6PRO_CHAN_2,
    J6PRO_CHAN_3,
    J6PRO_CHAN_4,
};

const uint8_t j6pro_data_code[] = {0x02, 0xf9, 0x93, 0x97, 0x02, 0xfa, 0x5c, 0xe3, 0x01, 0x2b, 0xf1, 0xdb, 0x01, 0x32, 0xbe, 0x6f}; // unneeded since this is the default table after a reset

static void __attribute__((unused)) j6pro_build_bind_packet()
{
    packet[0] = 0x01;  //Packet type
    packet[1] = 0x01;  //FIXME: What is this? Model number maybe?
    packet[2] = 0x56;  //FIXME: What is this?
    packet[3] = cyrfmfg_id[0];
    packet[4] = cyrfmfg_id[1];
    packet[5] = cyrfmfg_id[2];
    packet[6] = cyrfmfg_id[3];
    packet[7] = cyrfmfg_id[4];
    packet[8] = cyrfmfg_id[5];
}

static void __attribute__((unused)) j6pro_build_data_packet()
{
    uint8_t i;
    uint32_t upperbits = 0;
    uint16_t value;
    packet[0] = 0xaa; //FIXME what is this?
    for (i = 0; i < 12; i++)
    {
        value = convert_channel_10b(CH_AETR[i], false);
        packet[i+1] = value & 0xff;
        upperbits |= (value >> 8) << (i * 2);
    }
    packet[13] = upperbits & 0xff;
    packet[14] = (upperbits >> 8) & 0xff;
    packet[15] = (upperbits >> 16) & 0xff;
}

static void __attribute__((unused)) j6pro_cyrf_init()
{
    /* Initialise CYRF chip */
    CYRF_WriteRegister(CYRF_28_CLK_EN, 0x02);
    CYRF_WriteRegister(CYRF_32_AUTO_CAL_TIME, 0x3c);
    CYRF_WriteRegister(CYRF_35_AUTOCAL_OFFSET, 0x14);
    CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB, 0x05);
    CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB, 0x55);
    //CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
    //CYRF_SetPower(0x05);
    CYRF_WriteRegister(CYRF_06_RX_CFG, 0x4a);
    CYRF_SetPower(0x28);
    CYRF_WriteRegister(CYRF_12_DATA64_THOLD, 0x0e);
    CYRF_WriteRegister(CYRF_10_FRAMING_CFG, 0xee);
    CYRF_WriteRegister(CYRF_1F_TX_OVERRIDE, 0x00);
    CYRF_WriteRegister(CYRF_1E_RX_OVERRIDE, 0x00);
    
	//Same as default reset but issues if not configured...
	CYRF_ConfigDataCode(j6pro_data_code);
    CYRF_WritePreamble(0x333302);

    CYRF_GetMfgData(cyrfmfg_id);
	//Model match
	cyrfmfg_id[3]+=RX_num;
}

static void __attribute__((unused)) cyrf_bindinit()
{
    /* Use when binding */
    CYRF_SetPower(0x28); //Deviation using max power, replaced by bind power...
    //CYRF_ConfigRFChannel(0x52);
    CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[19]);
    CYRF_ConfigCRCSeed(0x0000);
    //CYRF_WriteRegister(CYRF_06_RX_CFG, 0x4a);
    //CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x80);
    //CYRF_ConfigRFChannel(0x52);
    //CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
    //CYRF_WriteRegister(CYRF_02_TX_CTRL, 0x40);
    j6pro_build_bind_packet();
}

static void __attribute__((unused)) cyrf_datainit()
{
    /* Use when already bound */
    uint8_t sop_idx = (0xff & (cyrfmfg_id[0] + cyrfmfg_id[1] + cyrfmfg_id[2] + cyrfmfg_id[3] - cyrfmfg_id[5])) % 19;
    crc =  (0xff & (cyrfmfg_id[1] - cyrfmfg_id[4] + cyrfmfg_id[5])) |
           ((0xff & (cyrfmfg_id[2] + cyrfmfg_id[3] - cyrfmfg_id[4] + cyrfmfg_id[5])) << 8);
    //CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
    CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[sop_idx]);
    CYRF_ConfigCRCSeed(crc);
}

static void __attribute__((unused)) j6pro_set_radio_channels()
{
    //FIXME: Query free channels
    //lowest channel is 0x08, upper channel is 0x4d?
    CYRF_FindBestChannels(hopping_frequency, 3, 5, 8, 77, FIND_CHANNEL_ANY);
    hopping_frequency[3] = hopping_frequency[0];
}

uint16_t J6PRO_callback()
{
    uint16_t start;

    switch(phase)
    {
        case J6PRO_BIND:
            cyrf_bindinit();
            phase = J6PRO_BIND_01;
            //no break because we want to send the 1st bind packet now
        case J6PRO_BIND_01:
            CYRF_ConfigRFChannel(0x52);
            CYRF_SetTxRxMode(TX_EN);
            //CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
            CYRF_WriteDataPacketLen(packet, 0x09);
            phase = J6PRO_BIND_03_START;
            return 3000; //3msec
        case J6PRO_BIND_03_START:
            start=(uint16_t)micros();
            while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)				// Wait max 500s
				if((CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80) == 0x00)
					break;										// Packet transmission complete
			CYRF_ConfigRFChannel(0x53);
            CYRF_SetTxRxMode(RX_EN);
            //CYRF_WriteRegister(CYRF_06_RX_CFG, 0x4a);
            CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x80);
            phase = J6PRO_BIND_03_CHECK;
            return 30000; //30msec
        case J6PRO_BIND_03_CHECK:
            {
            uint8_t rx = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
            if((rx & 0x1a) == 0x1a) {
                rx = CYRF_ReadRegister(CYRF_0A_RX_LENGTH);
                if(rx == 0x0f) {
                    rx = CYRF_ReadRegister(CYRF_09_RX_COUNT);
                    if(rx == 0x0f) {
                        //Expected and actual length are both 15
                        CYRF_ReadDataPacketLen(packet, rx);
                        if (packet[0] == 0x03 &&
                            packet[3] == cyrfmfg_id[0] &&
                            packet[4] == cyrfmfg_id[1] &&
                            packet[5] == cyrfmfg_id[2] &&
                            packet[6] == cyrfmfg_id[3] &&
                            packet[7] == cyrfmfg_id[4] &&
                            packet[8] == cyrfmfg_id[5])
                        {
                            //Send back Ack
                            packet[0] = 0x05;
                            CYRF_ConfigRFChannel(0x54);
                            CYRF_SetTxRxMode(TX_EN);
                            phase = J6PRO_BIND_05_1;
                            return 2000; //2msec
                         }
                    }
                }
            }
            phase = J6PRO_BIND_01;
            return 500;
            }
        case J6PRO_BIND_05_1:
        case J6PRO_BIND_05_2:
        case J6PRO_BIND_05_3:
        case J6PRO_BIND_05_4:
        case J6PRO_BIND_05_5:
        case J6PRO_BIND_05_6:
            //CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
            CYRF_WriteDataPacketLen(packet, 0x0f);
            phase = phase + 1;
            return 4600; //4.6msec
        case J6PRO_CHANSEL:
            BIND_DONE;
            j6pro_set_radio_channels();
            cyrf_datainit();
            phase = J6PRO_CHAN_1;
        case J6PRO_CHAN_1:
			#ifdef MULTI_SYNC
                telemetry_set_input_sync(24550);
			#endif
			//Keep transmit power updated
            CYRF_SetPower(0x28);
            j6pro_build_data_packet();
            //return 3400;
        case J6PRO_CHAN_2:
            //return 3500;
        case J6PRO_CHAN_3:
            //return 3750
        case J6PRO_CHAN_4:
            CYRF_ConfigRFChannel(hopping_frequency[phase - J6PRO_CHAN_1]);
            CYRF_SetTxRxMode(TX_EN);
            CYRF_WriteDataPacket(packet);
            if (phase == J6PRO_CHAN_4) {
                phase = J6PRO_CHAN_1;
                return 13900;
            }
            phase = phase + 1;
            return 3550;
    }
    return 0;
}

void J6PRO_init()
{
    j6pro_cyrf_init();

	if(IS_BIND_IN_PROGRESS)
        phase = J6PRO_BIND;
    else
        phase = J6PRO_CHANSEL;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/JIABAILE_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(JIABAILE_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_JIABAILE_ORIGINAL_ID
//#define FORCE_JIABAILE_GYRO_ORIGINAL_ID

#define JIABAILE_PAYLOAD_SIZE			8
#define JIABAILE_RX_PAYLOAD_SIZE		7
#define JIABAILE_RF_NUM_CHANNELS		3
#define JIABAILE_BIND_PACKET_PERIOD		12700
#define JIABAILE_PACKET_PERIOD			2408
#define JIABAILE_GYRO_PACKET_PERIOD		8205
#define JIABAILE_BIND_COUNT				160		//2 sec
#define JIABAILE_WRITE_TIME				1000

enum {
	JIABAILE_BIND=0,
	JIABAILE_RX,
	JIABAILE_PREP_DATA,
	JIABAILE_DATA,
};

static uint8_t __attribute__((unused)) JIABAILE_channel(uint8_t num)
{
	uint8_t val=convert_channel_16b_limit(num,0,100);
	if(val > 50+num)
	{
		packet[3] |= 0x01;
		return val-50;
	}
	if(val < 50-num)
	{
		packet[3] |= 0x02;
		return 50-val;
	}
	return 0;
}

static void __attribute__((unused)) JIABAILE_send_packet()
{
	if(!(sub_protocol == JIABAILE_GYRO && IS_BIND_IN_PROGRESS))
	{
		hopping_frequency_no++;
		if(hopping_frequency_no > 2)
			hopping_frequency_no = 0;
		XN297_Hopping(hopping_frequency_no);
	}

	if(sub_protocol == JIABAILE_STD)
	{//Std
		memcpy(packet,rx_tx_addr,3);
		memset(&packet[3], 0x00, 4);
		if(IS_BIND_DONE)
		{//Normal
			packet[4] = convert_channel_16b_limit(RUDDER,0,50)-25;	//ST Trim
			packet[6] = JIABAILE_channel(AILERON);					//ST
			packet[3] ^= 0x03;										//Reverse ST channel
			packet[3] <<= 2;										//Move ST channel where it should be
			packet[5] = JIABAILE_channel(ELEVATOR);					//TH
			packet[3] |= GET_FLAG(CH5_SW,  0x20)					//Low speed
						|GET_FLAG(CH7_SW,  0x40)					//Flash light
						|GET_FLAG(!CH6_SW,  0x80);					//Light
			if(!CH5_SW && Channel_data[CH5] > CHANNEL_MIN_COMMAND)
				packet[3] |= 0x10;									//Mid speed
		}
		else
		{
			bind_counter--;
			if(!bind_counter)
			{
				BIND_DONE;
				phase = JIABAILE_PREP_DATA;
			}
		}
		packet[7] = 0x55 + hopping_frequency[hopping_frequency_no];
		for(uint8_t i=0;i<JIABAILE_PAYLOAD_SIZE-1;i++)
			packet[7] += packet[i];
	}
	else
	{//Gyro
		if(bind_counter)
		{
			bind_counter--;
			if(!bind_counter)
			{
				BIND_DONE;
				XN297_SetTXAddr(rx_tx_addr, 4);
			}
		}
		uint8_t crc_pos;
		if(IS_BIND_IN_PROGRESS)
		{
			memcpy(packet,rx_tx_addr,4);
			packet[4] = hopping_frequency[1];
			packet[5] = hopping_frequency[2];
			crc_pos = 6;
			packet[7] = 0x55;
		}
		else
		{
			packet[0] = convert_channel_16b_limit(CH2,0x60,0xA0);	//Throttle
			packet[1] = convert_channel_16b_limit(CH1,0x40,0xC0);	//Steering
			if(Channel_data[CH5] < CHANNEL_MIN_COMMAND)
				packet[2] = 0x02;										//High speed
			else if(CH5_SW)
				packet[2] = 0x00;										//Low speed
			else
				packet[2] = 0x01;										//Mid speed
			packet[3] = convert_channel_8b(CH3) ^0xFF;					//Gyro
			uint8_t val = GET_FLAG(CH6_SW,  0x04)						//Light
						 |GET_FLAG(CH7_SW,  0x08);						//Flash
			if(Channel_data[CH4] > CHANNEL_MAX_COMMAND)
				val |= 0x01;											//Trim right
			else if(Channel_data[CH4] < CHANNEL_MIN_COMMAND)
				val |= 0x02;											//Trim left
			packet[4] = val;
			packet[5] = packet[6] = 0x00;								//?
			crc_pos = 7;
		}
		uint8_t sum=0;
		for(uint8_t i=0; i<crc_pos; i++)
			sum += packet[i];
		sum ^= 0xFF;
		packet[crc_pos] = sum;	
	}
	
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, JIABAILE_PAYLOAD_SIZE);
	#if 0
		debug("B%d ",bind_counter);
		debug("H%d RF%d",hopping_frequency_no,hopping_frequency[hopping_frequency_no]);
		for(uint8_t i=0; i < JIABAILE_PAYLOAD_SIZE; i++)
			debug(" %02X", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) JIABAILE_initialize_txid()
{
	if(sub_protocol == JIABAILE_STD)
	{//Std
		rx_tx_addr[0] = rx_tx_addr[3];
		#ifdef FORCE_JIABAILE_ORIGINAL_ID
			memcpy(rx_tx_addr,(uint8_t *)"\xCB\x03\xA5",3);
			//memcpy(rx_tx_addr,(uint8_t *)"\x3D\x08\xA2",3);
			//Normal frequencies are calculated from the car ID...
			//memcpy(&hopping_frequency[3],(uint8_t *)"\x23\x2D\x4B",3);	//35,45,75
			memcpy(&hopping_frequency[3],(uint8_t *)"\x24\x43\x4C",3);	//36,67,76
		#endif
		//Bind frequencies
		memcpy(hopping_frequency,(uint8_t *)"\x07\x27\x45",3);	//7,39,69
	}
	else
	{//Gyro
		rx_tx_addr[0] += RX_num;
		uint8_t val = (rx_tx_addr[0] & 0x0F) + 5;	//5..20
		for(uint8_t i=0; i<3; i++)
			hopping_frequency[i] = val+ 20*i;		//hopping_frequency[1,2] could be whatever but...
		#ifdef FORCE_JIABAILE_GYRO_ORIGINAL_ID
			if(RX_num)
			{
				memcpy(rx_tx_addr,(uint8_t *)"\x7D\x82\x28\xC2",4);
				memcpy(hopping_frequency,(uint8_t *)"\x12\x1B\x35",3);	//18,27,53
			}
			else
			{
				memcpy(rx_tx_addr,(uint8_t *)"\x0C\xF3\x59\xB3",4);
				memcpy(hopping_frequency,(uint8_t *)"\x11\x1C\x36",3);	//17,28,54
			}
		#endif
		debugln("ID: %02X %02X %02X %02X, HOP: %2d %2d %2d",rx_tx_addr[0],rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3],hopping_frequency[0],hopping_frequency[1],hopping_frequency[2]);
	}
}

static void __attribute__((unused)) JIABAILE_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	//Bind address
	if(sub_protocol == JIABAILE_STD)
	{//Std
		memcpy(rx_id,(uint8_t*)"\xA7\x07\x57\xA7\x26", 5);
		XN297_SetTXAddr(rx_id, 5);
		XN297_SetRXAddr(rx_id, JIABAILE_RX_PAYLOAD_SIZE);
	}
	else
	{//Gyro
		XN297_SetTXAddr((uint8_t*)"\x14\x41\x11\x13", 4);
		XN297_RFChannel(0x29);	//41
	}
}

uint16_t JIABAILE_callback()
{
	uint8_t sum;
	uint16_t addr;

	switch(phase)
	{
		case JIABAILE_BIND:
			phase++;		// JIABAILE_RX but is overwritten if RX or bind timeout
			if(XN297_IsRX())
			{
				if(XN297_ReadPayload(packet_in, JIABAILE_RX_PAYLOAD_SIZE))
				{//CRC OK
					#ifdef DEBUG_SERIAL
						debug("RX");
						for(uint8_t i=0; i < JIABAILE_RX_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
						debugln();
					#endif
					//RX: CB 03 A5 9D 05 A2 68
					if(memcmp(packet_in,rx_tx_addr,3)==0)
					{//TX ID match
						//Check packet
						sum=0xAA + hopping_frequency[hopping_frequency_no];
						for(uint8_t i=0; i < JIABAILE_RX_PAYLOAD_SIZE-1; i++)
							sum+=packet_in[i];
						if(sum==packet_in[6])
						{
							//Write the RXID
							#ifdef DEBUG_SERIAL
								debug("RXID ");
								for(uint8_t i=0; i < 3; i++)
									debug(" %02X", packet_in[3+i]);
								debugln();
							#endif
							addr=JIABAILE_EEPROM_OFFSET+RX_num*3;
							for(uint8_t i=0;i<3;i++)
								eeprom_write_byte((EE_ADDR)(addr+i),packet_in[3+i]);
							//Switch to normal mode
							BIND_DONE;
							phase = JIABAILE_PREP_DATA;
						}
			#ifdef DEBUG_SERIAL
						else
							debug("Wrong Sum");
					}
					else
						debug("Wrong TX ID");
				}
				else
					debug("Bad CRC");
				debugln("");
			#else
					}
				}
			#endif
			}
			XN297_SetTxRxMode(TXRX_OFF);
			JIABAILE_send_packet();
			return JIABAILE_WRITE_TIME;
		case JIABAILE_RX:
			//Wait for the packet transmission to finish
			while(XN297_IsPacketSent()==false);
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = JIABAILE_BIND;
			return JIABAILE_BIND_PACKET_PERIOD - JIABAILE_WRITE_TIME;
		case JIABAILE_PREP_DATA:
			//Read the RXID
			addr=JIABAILE_EEPROM_OFFSET+RX_num*3;
			for(uint8_t i=0;i<3;i++)
				rx_id[i+1] = eeprom_read_byte((EE_ADDR)(addr+i));
			#ifdef DEBUG_SERIAL
				debug("RXID ");
				for(uint8_t i=0; i < 3; i++)
					debug(" %02X", rx_id[i+1]);
			#endif
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTXAddr(rx_id, 5);
			//Set the normal frequencies
			sum=rx_id[1]&0x07;
			hopping_frequency[0] = (sum>4?30:8) + sum;
			if(sum==4 || sum ==7)
				hopping_frequency[0]++;
			hopping_frequency[1] = 40 + sum;
			if((sum & 0x06) == 0x06)
				hopping_frequency[1] += 21;
			hopping_frequency[2] = 70 + sum;
			#ifdef DEBUG_SERIAL
				debug(" RF");
				for(uint8_t i=0; i < 3; i++)
					debug(" %d", hopping_frequency[i]);
				debugln();
			#endif
			phase++;
		default:	//JIABAILE_DATA
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(packet_period);
			#endif
			JIABAILE_send_packet();
			break;
	}
	return packet_period;
}

void JIABAILE_init()
{
	JIABAILE_initialize_txid();
	JIABAILE_RF_init();
	if(sub_protocol == JIABAILE_STD)
	{//Std
		if(IS_BIND_IN_PROGRESS)
		{
			phase = JIABAILE_BIND;
			bind_counter = JIABAILE_BIND_COUNT;
		}
		else
			phase = JIABAILE_PREP_DATA;
		packet_period = JIABAILE_PACKET_PERIOD;
	}
	else
	{//Gyro
		phase = JIABAILE_DATA;
		bind_counter = IS_BIND_IN_PROGRESS?JIABAILE_BIND_COUNT>>2:1;
		packet_period = JIABAILE_GYRO_PACKET_PERIOD;
	}	
	hopping_frequency_no = 0;
}

#endif
/*
// CAR RX debug code

static void __attribute__((unused)) JIABAILE_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	//Bind address
	memcpy(rx_id,(uint8_t*)"\xA7\x07\x57\xA7\x26", 5);
	XN297_SetTXAddr(rx_id, 5);
	XN297_SetRXAddr(rx_id, JIABAILE_PAYLOAD_SIZE);
	XN297_RFChannel(7);
	rx_tx_addr[0] = 0x00;
	rx_tx_addr[1] = RX_num;
	rx_tx_addr[2] = 0x00;
}

uint16_t JIABAILE_callback()
{
	switch(phase)
	{
		case JIABAILE_BIND:
			if(XN297_IsRX())
			{
				if(XN297_ReadPayload(packet_in, JIABAILE_PAYLOAD_SIZE))
				{//CRC OK
					XN297_SetTxRxMode(TXRX_OFF);
					#ifdef DEBUG_SERIAL
						debug("RX Bind");
						for(uint8_t i=0; i < JIABAILE_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
						debugln();
					#endif
					memcpy(packet,packet_in,3);
					memcpy(&packet[3],rx_tx_addr,3);
					packet[6]=0xAA + 7;
					for(uint8_t i=0; i < JIABAILE_RX_PAYLOAD_SIZE-1; i++)
						packet[6]+=packet[i];
					XN297_SetTxRxMode(TX_EN);
					memcpy(&rx_id[1],rx_tx_addr,3);
					bind_counter = 10;
					phase = JIABAILE_RX;
				}
			}
			return JIABAILE_WRITE_TIME;
		case JIABAILE_RX:
			if(bind_counter)
			{
				bind_counter--;
				XN297_WritePayload(packet, JIABAILE_RX_PAYLOAD_SIZE);
				#ifdef DEBUG_SERIAL
					debug("TX Bind");
					for(uint8_t i=0; i < JIABAILE_RX_PAYLOAD_SIZE; i++)
						debug(" %02X", packet[i]);
					debugln();
				#endif
				return JIABAILE_PACKET_PERIOD;
			}
			//Wait for the packet transmission to finish
			//while(XN297_IsPacketSent()==false);
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetRXAddr(rx_id, JIABAILE_PAYLOAD_SIZE);
			hopping_frequency_no++;
			if(hopping_frequency_no>84)
				hopping_frequency_no = 0;
			debug(".");
			XN297_RFChannel(hopping_frequency_no);
			XN297_SetTxRxMode(RX_EN);
			phase = JIABAILE_DATA;
			return JIABAILE_BIND_PACKET_PERIOD;
		case JIABAILE_DATA:
			if(XN297_IsRX())
			{
				debugln("");
				if(XN297_ReadPayload(packet_in, JIABAILE_PAYLOAD_SIZE))
				{//CRC OK
					#ifdef DEBUG_SERIAL
						debug("CH=%d=%02X P:",hopping_frequency_no,hopping_frequency_no);
						for(uint8_t i=0; i < JIABAILE_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
					#endif
					//Check packet
					uint8_t sum=0x55 + hopping_frequency_no;
					for(uint8_t i=0; i < JIABAILE_PAYLOAD_SIZE-1; i++)
						sum+=packet_in[i];
					if(sum==packet_in[7])
					{
						debug("Good channel");
					}
					else
						debug("Wrong Sum");
				}
				else
					debug("Bad CRC");
				debugln("");
			}
			phase = JIABAILE_RX;
			break;
	}
	return JIABAILE_PACKET_PERIOD;
}

void JIABAILE_init()
{
	JIABAILE_RF_init();
	XN297_SetTxRxMode(TXRX_OFF);
	XN297_SetTxRxMode(RX_EN);
	phase = JIABAILE_BIND;
	hopping_frequency_no = 7;
}
*/

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/JJRC345_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with JJRC345

#if defined(JJRC345_NRF24L01_INO)

#include "iface_xn297.h"

//#define JJRC345_FORCE_ID

#define JJRC345_PACKET_PERIOD		7450 // Timeout for callback in uSec
#define JJRC345_INITIAL_WAIT		500
#define JJRC345_PACKET_SIZE			16
#define JJRC345_RF_BIND_CHANNEL		5
#define SKYTMBLR_RF_BIND_CHANNEL	40
#define JJRC345_BIND_COUNT			500
#define JJRC345_NUM_CHANNELS		4


enum JJRC345_FLAGS {
    // flags going to packet[8]
	JJRC345_FLAG_HEADLESS	= 0x40,
	JJRC345_FLAG_RTH		= 0x80,
    // flags going to packet[9]
	SKYTMBLR_FLAG_UNK1	    = 0x40,
	SKYTMBLR_FLAG_UNK2	    = 0x80,
    // flags going to packet[10]
	SKYTMBLR_FLAG_LED	    = 0x40,
	SKYTMBLR_FLAG_UNK3	    = 0x80,
};

static uint8_t __attribute__((unused)) JJRC345_convert_channel(uint8_t num)
{
	uint8_t val=convert_channel_8b(num);
	// 7E..60..41..01, 80 center, 81..C1..E0..FE
	if(val<0x80)
	{
		val=0x80-val;	// 80..01
		if(val>0x7E)
			val=0x7E;	// 7E..01
	}
	else if(val>0xFE)
		val=0xFE;			// 81..FE
	return val;
}

static void __attribute__((unused)) JJRC345_send_packet()
{
	packet[0] = 0x00;
	packet[2] = 0x00;
	if (IS_BIND_IN_PROGRESS)
	{ //00 05 00 0A 46 4A 41 47 00 00 40 46 A5 4A F1 18
		packet[1]  = (sub_protocol == JJRC345 ? JJRC345_RF_BIND_CHANNEL:SKYTMBLR_RF_BIND_CHANNEL);
		packet[4]  = hopping_frequency[0];
		packet[5]  = hopping_frequency[1];
		packet[6]  = hopping_frequency[2];
		packet[7]  = hopping_frequency[3];
		packet[12] = 0xa5;
	}
	else
	{ //00 41 00 0A 00 80 80 80 00 00 40 46 00 49 F1 18
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no %= JJRC345_NUM_CHANNELS;
		packet[1]  = hopping_frequency[hopping_frequency_no];	// next packet will be sent on this channel

		packet[4]  = convert_channel_8b(THROTTLE);				// throttle: 00..FF
		packet[5]  = JJRC345_convert_channel(RUDDER);			// rudder: 70..60..41..01, 80 center, 81..C1..E0..F0
		packet[6]  = JJRC345_convert_channel(ELEVATOR);			// elevator: 70..60..41..01, 80 center, 81..C1..E0..F0
		packet[7]  = JJRC345_convert_channel(AILERON);			// aileron: 70..60..41..01, 80 center, 81..C1..E0..F0

		if(CH5_SW)	//Flip
		{
			if(packet[6]>0xF0)
				packet[6]=0xFF;
			else if(packet[6]<0x80 && packet[6]>0x70)
				packet[6]=0x7F;
			if(packet[7]>0xF0)
				packet[7]=0xFF;
			else if(packet[7]<0x80 && packet[7]>0x70)
				packet[7]=0x7F;
		}
		
		packet[12] = 0x02;										// Rate: 00-01-02
	}

	packet[3] = 0x00;											// Checksum upper bits

	packet[8] = 0x00											// Rudder trim, 00 when not used, 01..1F when trimmed left, 20..3F
				| GET_FLAG(CH6_SW ,JJRC345_FLAG_HEADLESS)		// 0x40 HeadLess
				| GET_FLAG(CH7_SW ,JJRC345_FLAG_RTH);			// 0x80 RTH
	packet[9] = 0x00												// Elevator trim, 00 when not used, 20..25 when trimmed up, 0..1F when trimmed down
				| GET_FLAG(CH9_SW ,SKYTMBLR_FLAG_UNK1)			// 0x40 Unknown
				| GET_FLAG(CH10_SW,SKYTMBLR_FLAG_UNK2);			// 0x80 Unknown
	packet[10] = 0x00											// Aileron  trim, 00 when not used, 00..1F when trimmed left, 21..3F when trimmed right
				| GET_FLAG(!CH8_SW,SKYTMBLR_FLAG_LED)			// 0x40 LED
				| GET_FLAG(CH11_SW,SKYTMBLR_FLAG_UNK3);			// 0x80 Unknown

	packet[11] = hopping_frequency[0];							// First hopping frequency

	// Checksum
	uint16_t sum=2;
	for (uint8_t i = 0; i < 13; i++)
		sum += packet[i];
	packet[13]=sum;
	packet[3]=((sum>>8)<<2)+2;
	
	// TX ID
	packet[14] = rx_tx_addr[2];
	packet[15] = rx_tx_addr[3];

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, JJRC345_PACKET_SIZE);
}

static void __attribute__((unused)) JJRC345_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
    XN297_SetTXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", 5);
	//XN297_HoppingCalib(JJRC345_NUM_CHANNELS);
	XN297_RFChannel(sub_protocol == JJRC345 ? JJRC345_RF_BIND_CHANNEL:SKYTMBLR_RF_BIND_CHANNEL);	// Bind channel
}

uint16_t JJRC345_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(JJRC345_PACKET_PERIOD);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter==0)
			BIND_DONE;
	}
	JJRC345_send_packet();
	return	JJRC345_PACKET_PERIOD;
}

static void __attribute__((unused)) JJRC345_initialize_txid()
{
	calc_fh_channels(JJRC345_NUM_CHANNELS);
	
	#ifdef JJRC345_FORCE_ID
		//TX 1
		rx_tx_addr[2]=0x1B;
		rx_tx_addr[3]=0x12;
        hopping_frequency[0] = 0x3f;
        hopping_frequency[1] = 0x49;
        hopping_frequency[2] = 0x47;
        hopping_frequency[3] = 0x47;
		//TX 2
		rx_tx_addr[2]=0xF1;
		rx_tx_addr[3]=0x18;
        hopping_frequency[0] = 0x46;
        hopping_frequency[1] = 0x4A;
        hopping_frequency[2] = 0x41;
        hopping_frequency[3] = 0x47;
	#endif
}

void JJRC345_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
    bind_counter = JJRC345_BIND_COUNT;
	JJRC345_initialize_txid();
	JJRC345_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Joysway_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(JOYSWAY_A7105_INO)

#include "iface_a7105.h"

//#define JOYSWAY_FORCE_ID

static void __attribute__((unused)) JOYSWAY_send_packet()
{
	static uint8_t next_ch = 0x30;
	
	//RF frequency
	if (packet_count == 254)
	{
		packet_count = 0;
		A7105_WriteID(0x5475c52a);
		rf_ch_num = 0x0a;
	}
	else if (packet_count == 2)
	{
		A7105_WriteID(MProtocol_id);
		rf_ch_num = 0x30;
	}
	else
	{
		if (packet_count & 0x01)
			rf_ch_num = 0x30;
		else
			rf_ch_num = next_ch;
	}
	if (! (packet_count & 0x01))
	{
		next_ch++;
		if (next_ch >= 0x45)
			next_ch = 0x30;
	}

	//Payload
	packet[0] = packet_count == 0 ? 0xdd : 0xff;
	//ID
	packet[1] = rx_tx_addr[0];
	packet[2] = rx_tx_addr[1];
	packet[3] = rx_tx_addr[2];
	packet[4] = rx_tx_addr[3];
	packet[5] = 0x00;
	//Channels
	for (uint8_t i = 0; i < 4; i++)
		packet[ 6 + (i & 0x01) + ((i & 0x02)<<1)] = convert_channel_16b_limit(i, 0x00, 0xCC);
	packet[8] = 0x64;
	packet[9] = 0x64;
	packet[12] = 0x64;
	packet[13] = 0x64;
	packet[14] = packet_count == 0 ? 0x30 : 0xaa;
	//Check
	uint8_t value = 0;
	for (uint8_t i = 0; i < 15; i++)
		value += packet[i];
	packet[15] = value;

	//Send
	#if 0
		debug("ch=%02X P=",rf_ch_num);
		for(uint8_t i=0; i<16; i++)
			debug("%02X ", packet[i]);
		debugln("");
	#endif
	A7105_WriteData(16, rf_ch_num);
	A7105_SetPower();
	packet_count++;
}

uint16_t JOYSWAY_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(6000);
	#endif
	#ifndef FORCE_JOYSWAY_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif

	JOYSWAY_send_packet();
	return 6000;
}

void JOYSWAY_init()
{
	BIND_DONE;		// not a bind protocol

	MProtocol_id &= 0x00FFFFFF;
	MProtocol_id |= 0xF8000000;
	#ifdef JOYSWAY_FORCE_ID
		MProtocol_id = 0xf82dcaa0;
	#endif

	set_rx_tx_addr(MProtocol_id);

	A7105_Init();
	
	packet_count = 2;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KF606_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with KF606 plane.

#if defined(KF606_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_KF606_ORIGINAL_ID
//#define FORCE_MIG320_ORIGINAL_ID
//#define FORCE_ZCZ50_ORIGINAL_ID

#define KF606_INITIAL_WAIT    500
#define KF606_PACKET_PERIOD   3000
#define KF606_RF_BIND_CHANNEL 7
#define KF606_PAYLOAD_SIZE    4
#define KF606_BIND_COUNT	  857	//3sec
#define KF606_RF_NUM_CHANNELS 2

static void __attribute__((unused)) KF606_send_packet()
{
	uint8_t len = KF606_PAYLOAD_SIZE;
	if(IS_BIND_IN_PROGRESS)
	{
		if(sub_protocol != KF606_ZCZ50)
		{
			packet[0] = 0xAA;
			memcpy(&packet[1],rx_tx_addr,3);
		}
		else
			memcpy(packet,rx_tx_addr,4);
	}
	else
	{
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no ^= 1;			// 2 RF channels

		packet[0] = 0x55;
		packet[1] = convert_channel_8b(THROTTLE);					// 0..255
		// Deadband is needed on aileron, 40 gives +-6%
		switch(sub_protocol)
		{
			case KF606_KF606:
				packet[2] = convert_channel_8b_limit_deadband(AILERON,0x20,0x80,0xE0,40);	// Aileron: Max values:20..80..E0, Low rates:50..80..AF, High rates:3E..80..C1
				packet[3] = convert_channel_16b_limit(CH5,0xC1,0xDF);						// Aileron trim must be on a separated channel C1..D0..DF
				break;
			case KF606_MIG320:
				packet[2] = convert_channel_8b_limit_deadband(AILERON,0x00,0x80,0xFF,40);	// Aileron: High rate:2B..80..DA
				packet[3] = convert_channel_16b_limit(CH5,0x01,0x1F);						// Aileron trim must be on a separated channel 01..10..1F
				packet[3] += (packet[2]-0x80)>>3;											// Drive trims for more aileron authority
				if(packet[3] > 0x80)
					packet[3] = 0x01;
				else if(packet[3] > 0x1F)
					packet[3] = 0x1F;
				packet[3] |= GET_FLAG(CH6_SW, 0xC0);										// 0xC0 and 0xE0 are both turning the LED off, not sure if there is another hidden feature
				break;
			case KF606_ZCZ50:
				len--;																		// uses only 3 bytes of payload
				packet[0] = packet[1];														// Throttle: 0x00..0xFF
				packet[1] = convert_channel_8b_limit_deadband(AILERON,0x20,0x80,0xE0,40);	// Aileron: Max values:20..80..E0, low rate 0x52..0x80..0xB1, high rate: 0x41..0x80..0xC3.
				packet[2] = convert_channel_16b_limit(CH5,0x01,0x1F);						// Trim: 0x01..0x10..0x1F
				packet[2] |= GET_FLAG(CH6_SW, 0xC0);										// Unknown: 0x00 or 0xC0. Left top switch on original TX changes nothing on my plane. Maybe ON/OFF for main motor?
				break;
		}
	}

	if(sub_protocol == KF606_MIG320)
	{
		len++;
		packet[4] = 0;	// additional channel?
	}

	#if 0
		for(uint8_t i=0; i<len; i++)
			debug("%02X ",packet[i]);
		debugln("");
	#endif

	// Send
	XN297_SetPower();
	XN297_SetFreqOffset();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, len);
}

static void __attribute__((unused)) KF606_initialize_txid()
{
	rx_tx_addr[0]=rx_tx_addr[3];	// Use RX_num;
	hopping_frequency[0]=(rx_tx_addr[0]&0x3F)+9;
	hopping_frequency[1]=hopping_frequency[0]+3;
	#ifdef FORCE_KF606_ORIGINAL_ID
		//TX1
		rx_tx_addr[0]=0x57;
		rx_tx_addr[1]=0x02;
		rx_tx_addr[2]=0x00;
		hopping_frequency[0]=0x20;
		hopping_frequency[1]=0x23;
		//TX2
		rx_tx_addr[0]=0x25;
		rx_tx_addr[1]=0x04;
		rx_tx_addr[2]=0x00;
		hopping_frequency[0]=0x2E;
		hopping_frequency[1]=0x31;
	#endif
	#ifdef FORCE_MIG320_ORIGINAL_ID
		rx_tx_addr[0]=0xBB;
		rx_tx_addr[1]=0x13;
		rx_tx_addr[2]=0x00;
		hopping_frequency[0]=68;
		hopping_frequency[1]=71;
	#endif
	if(sub_protocol == KF606_ZCZ50)
	{
		rx_tx_addr[1] = rx_tx_addr[0];
		rx_tx_addr[0]=0xAA;
	}
	#ifdef FORCE_ZCZ50_ORIGINAL_ID
		rx_tx_addr[0]=0xAA;
		rx_tx_addr[1]=0x67;
		rx_tx_addr[2]=0x64;
		rx_tx_addr[3]=0x01;
		hopping_frequency[0]=48;
		hopping_frequency[1]=51;
	#endif
}

static void __attribute__((unused)) KF606_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	XN297_SetTXAddr((uint8_t*)"\xe7\xe7\xe7\xe7\xe7", 5);
	XN297_HoppingCalib(KF606_RF_NUM_CHANNELS);					// Calibrate all channels
	XN297_RFChannel(KF606_RF_BIND_CHANNEL);						// Set bind channel
}

uint16_t KF606_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(KF606_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, sub_protocol != KF606_ZCZ50 ? 3 : 4);
		}
	KF606_send_packet();
	return KF606_PACKET_PERIOD;
}

void KF606_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	KF606_initialize_txid();
	KF606_RF_init();
	hopping_frequency_no = 0;
	bind_counter=KF606_BIND_COUNT;
}

#endif

// MIG320 protocol
// Bind
// 250K C=7 S=Y A= E7 E7 E7 E7 E7 P(5)= AA BB 13 00 00
// 3ms on ch7
// Normal
// 250K C=68 S=Y A= BB 13 00 P(5)= 55 00 80 10 00
// P[1] = THR 00..FF
// P[2] = AIL 2B..80..DA
// P[3] = TRIM 01..10..1F
// channels 68=BB&3F+9 and 71


// ZCZ50v2 protocol (with fake front propeller)
// Bind
// 250K C=7 S=Y A= E7 E7 E7 E7 E7 P(4)= AA 67 64 01
// 3ms on ch7
// Normal
// 250K C=48 S=Y A= AA 67 64 01 P(3)= 00 80 10
// P[0] = THR 0x00..0xFF
// P[1] = AIL low rate 0x52..0x80..0xB1, high rate: 0x41..0x80..0xC3
// P[2] = TRIM 0x01..0x10..0x1F + UNKNOWN 0x00 or 0xC0

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/KN_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/KN_nrf24l01.c dated 2015-11-09

#if defined(KN_NRF24L01_INO)

#include "iface_nrf24l01.h"

// Wait for RX chip stable - 10ms
#define KN_INIT_WAIT_MS  10000

//Payload(16 bytes) plus overhead(10 bytes) is 208 bits, takes about 0.4ms or 0.2ms
//to send for the rate of 500kb/s and 1Mb/s respectively.

// Callback timeout period for sending bind packets, minimum 250
#define KN_BINDING_PACKET_PERIOD  1000

// Timeout for sending data packets, in uSec, KN protocol requires 2ms
#define KN_WL_SENDING_PACKET_PERIOD  2000
// Timeout for sending data packets, in uSec, KNFX protocol requires 1.2 ms
#define KN_FX_SENDING_PACKET_PERIOD  1200

// packets to be sent during binding, last 0.5 seconds in WL Toys and 0.2 seconds in Feilun
#define KN_WL_BIND_COUNT 500
#define KN_FX_BIND_COUNT 200 

#define KN_PAYLOADSIZE 16

//24L01 has 126 RF channels, can we use all of them?
#define KN_MAX_RF_CHANNEL 73

//KN protocol for WL Toys changes RF frequency every 10 ms, repeats with only 4 channels.
//Feilun variant uses only 2 channels, so we will just repeat the hopping channels later
#define KN_RF_CH_COUNT 4

//KN protocol for WL Toys sends 4 data packets every 2ms per frequency, plus a 2ms gap.
#define KN_WL_PACKET_SEND_COUNT 5
//KN protocol for Feilun sends 8 data packets every 1.2ms per frequency, plus a 0.3ms gap.
#define KN_FX_PACKET_SEND_COUNT 8
 
#define KN_TX_ADDRESS_SIZE 5

enum {
    KN_PHASE_PRE_BIND,
    KN_PHASE_BINDING,
    KN_PHASE_PRE_SEND,
    KN_PHASE_SENDING,
};

enum {
	KN_FLAG_DR     = 0x01, // Dual Rate: 1 - full range
	KN_FLAG_TH     = 0x02, // Throttle Hold: 1 - hold
	KN_FLAG_IDLEUP = 0x04, // Idle up: 1 - 3D
	KN_FLAG_RES1   = 0x08, // HoverDebugging
	KN_FLAG_RES2   = 0x10,
	KN_FLAG_RES3   = 0x20,
	KN_FLAG_GYRO3  = 0x40, // 0 - 6G mode, 1 - 3G mode
	KN_FLAG_GYROR  = 0x80  // Always 0 so far
};

//-------------------------------------------------------------------------------------------------
// This function init 24L01 regs and packet data for binding
// Send tx address, hopping table (for Wl Toys), and data rate to the KN receiver during binding.
// It seems that KN can remember these parameters, no binding needed after power up.
// Bind uses fixed TX address "KNDZK", 1 Mbps data rate and channel 83
//-------------------------------------------------------------------------------------------------
static void __attribute__((unused)) kn_bind_init()
{
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t*)"KNDZK", 5);
	packet[0]  = 'K';
	packet[1]  = 'N';
	packet[2]  = 'D';
	packet[3]  = 'Z';
	//Use first four bytes of tx_addr
	packet[4]  = rx_tx_addr[0];
	packet[5]  = rx_tx_addr[1];
	packet[6]  = rx_tx_addr[2];
	packet[7]  = rx_tx_addr[3];

	if(sub_protocol==WLTOYS)
	{
		packet[8]  = hopping_frequency[0];
		packet[9]  = hopping_frequency[1];
		packet[10] = hopping_frequency[2];
		packet[11] = hopping_frequency[3];
	}
	else
	{
		packet[8]  = 0x00;
		packet[9]  = 0x00;
		packet[10] = 0x00;
		packet[11] = 0x00;
	}
	packet[12] = 0x00;
	packet[13] = 0x00;
	packet[14] = 0x00;
	packet[15] = 0x01;	//(USE1MBPS_YES) ? 0x01 : 0x00;

	//Set RF channel
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 83);
}

//-------------------------------------------------------------------------------------------------
// Update control data to be sent
// Do it once per frequency, so the same values will be sent 4 times
// KN uses 4 10-bit data channels plus a 8-bit switch channel
//
// The packet[0] is used for pitch/throttle, the relation is hard coded, not changeable.
// We can change the throttle/pitch range though.
//
// How to use trim? V977 stock controller can trim 6-axis mode to eliminate the drift.
//-------------------------------------------------------------------------------------------------
static void __attribute__((unused)) kn_update_packet_control_data()
{
	uint16_t value;
	value = convert_channel_10b(THROTTLE, false);
	packet[0]  = (value >> 8) & 0xFF;
	packet[1]  = value & 0xFF;
	value = convert_channel_10b(AILERON, false);
	packet[2]  = (value >> 8) & 0xFF;
	packet[3]  = value & 0xFF;
	value = convert_channel_10b(ELEVATOR, false);
	packet[4]  = (value >> 8) & 0xFF;
	packet[5]  = value & 0xFF;
	value = convert_channel_10b(RUDDER, false);
	packet[6]  = (value >> 8) & 0xFF;
	packet[7]  = value & 0xFF;
	// Trims, middle is 0x64 (100) range 0-200
	packet[8]  = convert_channel_16b_limit(CH9,0,200); // 0x64; // T
	packet[9]  = convert_channel_16b_limit(CH10,0,200); // 0x64; // A
	packet[10] = convert_channel_16b_limit(CH11,0,200); // 0x64; // E
	packet[11] = convert_channel_16b_limit(CH12,0,200); // 0x64; // R

	packet[12] = GET_FLAG(CH5_SW,  KN_FLAG_DR)
				|GET_FLAG(CH6_SW,  KN_FLAG_TH)
				|GET_FLAG(CH7_SW,  KN_FLAG_IDLEUP)
				|GET_FLAG(CH8_SW,  KN_FLAG_GYRO3)
				|GET_FLAG(CH13_SW, KN_FLAG_RES1);	//Hover debugging

	packet[13] = 0x00;
	if(sub_protocol==WLTOYS)
		packet[13] = (packet_sent << 5) | (hopping_frequency_no << 2);

	packet[14] = 0x00;
	packet[15] = 0x00;

	NRF24L01_SetPower();
}


//-------------------------------------------------------------------------------------------------
// This function generate RF TX packet address
// V977 can remember the binding parameters; we do not need rebind when power up.
// This requires the address must be repeatable for a specific RF ID at power up.
//-------------------------------------------------------------------------------------------------
static void __attribute__((unused)) kn_calculate_tx_addr()
{
	if(sub_protocol==FEILUN)
	{
		uint8_t addr2;
		// Generate TXID with sum of minimum 256 and maximum 256+MAX_RF_CHANNEL-32
		rx_tx_addr[1] = 1 + rx_tx_addr[0] % (KN_MAX_RF_CHANNEL-33);
		addr2 = 1 + rx_tx_addr[2] % (KN_MAX_RF_CHANNEL-33);
		if ((uint16_t)(rx_tx_addr[0] + rx_tx_addr[1]) < 256)
			rx_tx_addr[2] = addr2;
		else
			rx_tx_addr[2] = 0x00;
		rx_tx_addr[3] = 0x00;
		while((uint16_t)(rx_tx_addr[0] + rx_tx_addr[1] + rx_tx_addr[2] + rx_tx_addr[3]) < 257)
			rx_tx_addr[3] += addr2;
	}
    //The 5th byte is a constant, must be 'K'
    rx_tx_addr[4] = 'K';
}

//-------------------------------------------------------------------------------------------------
// This function generates "random" RF hopping frequency channel numbers.
// These numbers must be repeatable for a specific seed
// The generated number range is from 0 to MAX_RF_CHANNEL. No repeat or adjacent numbers
//
// For Feilun variant, the channels are calculated from TXID, and since only 2 channels are used
// we copy them to fill up to MAX_RF_CHANNEL
//-------------------------------------------------------------------------------------------------
static void __attribute__((unused)) kn_calculate_freqency_hopping_channels()
{
	if(sub_protocol==WLTOYS)
	{
		uint8_t idx = 0;
		uint32_t rnd = MProtocol_id;
		while (idx < KN_RF_CH_COUNT)
		{
			uint8_t i;
			rnd = rnd * 0x0019660D + 0x3C6EF35F; // Randomization

			// Use least-significant byte. 73 is prime, so channels 76..77 are unused
			uint8_t next_ch = ((rnd >> 8) % KN_MAX_RF_CHANNEL) + 2;
			// Keep the distance 2 between the channels - either odd or even
			if (((next_ch ^ MProtocol_id) & 0x01 )== 0)
				continue;
			// Check that it's not duplicate and spread uniformly
			for (i = 0; i < idx; i++)
				if(hopping_frequency[i] == next_ch)
					break;
			if (i != idx)
				continue;
			hopping_frequency[idx++] = next_ch;
		}
	}
	else
	{//FEILUN
		hopping_frequency[0] = rx_tx_addr[0] + rx_tx_addr[1] + rx_tx_addr[2] + rx_tx_addr[3]; // - 256; ???
		hopping_frequency[1] = hopping_frequency[0] + 32;
		hopping_frequency[2] = hopping_frequency[0];
		hopping_frequency[3] = hopping_frequency[1];
	}
}

//-------------------------------------------------------------------------------------------------
// This function setup 24L01
// V977 uses one way communication, receiving only. 24L01 RX is never enabled.
// V977 needs payload length in the packet. We should configure 24L01 to enable Packet Control Field(PCF)
//   Some RX reg settings are actually for enable PCF
//-------------------------------------------------------------------------------------------------
static void __attribute__((unused)) KN_RF_init()
{
	kn_calculate_tx_addr();
	kn_calculate_freqency_hopping_channels();

	NRF24L01_Initialize();

	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, 0x20);   // bytes of data payload for pipe 0
	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 1); // Dynamic payload for data pipe 0
	// Enable: Dynamic Payload Length to enable PCF
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, _BV(NRF2401_1D_EN_DPL));

	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}
  
//================================================================================================
// Private Functions
//================================================================================================
void KN_init()
{
	if(sub_protocol==WLTOYS)
	{
		packet_period = KN_WL_SENDING_PACKET_PERIOD;
		bind_counter  = KN_WL_BIND_COUNT;
		packet_count  = KN_WL_PACKET_SEND_COUNT;
		seed = KN_WL_PACKET_SEND_COUNT * KN_WL_SENDING_PACKET_PERIOD;
	}
	else
	{
		packet_period = KN_FX_SENDING_PACKET_PERIOD;
		bind_counter  = KN_FX_BIND_COUNT;
		packet_count  = KN_FX_PACKET_SEND_COUNT;
		seed = KN_FX_PACKET_SEND_COUNT * KN_FX_SENDING_PACKET_PERIOD;
	}
	KN_RF_init();
	phase = IS_BIND_IN_PROGRESS ? KN_PHASE_PRE_BIND : KN_PHASE_PRE_SEND;
}

uint16_t KN_callback()
{
	switch (phase)
	{
		case KN_PHASE_PRE_BIND:
			kn_bind_init();
			phase=KN_PHASE_BINDING;
			//Do once, no break needed
		case KN_PHASE_BINDING:
			if(bind_counter>0)
			{
				bind_counter--;
				NRF24L01_WritePayload(packet, KN_PAYLOADSIZE);
				return KN_BINDING_PACKET_PERIOD;
			}
			BIND_DONE;
			//Continue
		case KN_PHASE_PRE_SEND:
			packet_sent = 0;
			hopping_frequency_no = 0;
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, KN_TX_ADDRESS_SIZE);
			phase = KN_PHASE_SENDING;
			//Do once, no break needed
		case KN_PHASE_SENDING:
			if(packet_sent >= packet_count)
			{
				#ifdef MULTI_SYNC
					telemetry_set_input_sync(seed);
				#endif
				packet_sent = 0;
				hopping_frequency_no++;
				if(hopping_frequency_no >= KN_RF_CH_COUNT) hopping_frequency_no = 0;
				kn_update_packet_control_data();
				NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);
			}
			else
			{
				// Update sending count and RF channel index.
				// The protocol sends 4 data packets every 2ms per frequency, plus a 2ms gap.
				// Each data packet need a packet number and RF channel index
				packet[13] = 0x00;
				if(sub_protocol==WLTOYS)
					packet[13] = (packet_sent << 5) | (hopping_frequency_no << 2);
			}
			NRF24L01_WritePayload(packet, KN_PAYLOADSIZE);
			packet_sent++;
			return packet_period;
	} //switch
 
    //Bad things happened, reset
    packet_sent = 0;
    phase = KN_PHASE_PRE_SEND;
    return packet_period;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kamtom_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(KAMTOM_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_KAMTOM_ORIGINAL_ID

#define KAMTOM_PAYLOAD_SIZE			16
#define KAMTOM_RF_NUM_CHANNELS		4
#define KAMTOM_BIND_COUNT			2000
#define KAMTOM_WRITE_TIME			650
#define KAMTOM_BIND_CHANNEL			0x28	//40
#define KAMTOM_PACKET_PERIOD		3585


enum {
	KAMTOM_DATA,
	KAMTOM_RX,
};

static void __attribute__((unused)) KAMTOM_send_packet()
{
	if(bind_counter)
	{
		bind_counter--;
		if(!bind_counter)
			BIND_DONE;
	}

	memset(packet, 0x00, 16);

	if(IS_BIND_DONE)
	{//Normal
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no &= 3;

		//RXID
		packet[0] = rx_tx_addr[0];
		packet[2] = rx_tx_addr[1];
		//Next RF channel
		packet[1] = hopping_frequency[hopping_frequency_no];
		//Channels and trims
		for(uint8_t i=0; i<6; i++)
		{
			packet[4+i] = convert_channel_s8b(CH_TAER[i]);
			if(i>3) //ST_TR and TH_TR
				packet[4+i] >>= 2;
		}
		//packet[11] = 0x00;	//??
		//TH_DR
		packet[12] = convert_channel_16b_limit(CH7,0x25,0x64);
	}
	else
	{
		packet[1] = KAMTOM_BIND_CHANNEL;
		memcpy(&packet[4],hopping_frequency,4);
		packet[12] = 0xA5;
	}
	packet[10] = 0x40;	//??
	//Checksum
	uint16_t sum = packet[1];
	for(uint8_t i=4;i<13;i++)
		 sum += packet[i];
	packet[13] = sum;
	packet[3] = (sum>>6) & 0xFC;
	//TXID
	packet[14] = rx_tx_addr[2];
	packet[15] = rx_tx_addr[3];
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, KAMTOM_PAYLOAD_SIZE,false);
	#if 0
	//def DEBUG_SERIAL
		for(uint8_t i=0; i < KAMTOM_PAYLOAD_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) KAMTOM_initialize_txid()
{
	calc_fh_channels(4);
	#ifdef FORCE_KAMTOM_ORIGINAL_ID
		rx_tx_addr[0] = 0xC7;
		rx_tx_addr[1] = 0x78;
		rx_tx_addr[2] = 0x2C;
		rx_tx_addr[3] = 0x25;
		hopping_frequency[0] = 59;
		hopping_frequency[1] = 59;
		hopping_frequency[2] = 71;
		hopping_frequency[3] = 65;
	#endif
}

static void __attribute__((unused)) KAMTOM_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	//Address
	XN297_SetTXAddr((uint8_t*)"\xCC\xDD\xEE\xDD", 4);
	XN297_SetRXAddr((uint8_t*)"\xCC\xDD\xEE\xDD", KAMTOM_PAYLOAD_SIZE);
	XN297_RFChannel(KAMTOM_BIND_CHANNEL);
}

uint16_t KAMTOM_callback()
{
	static bool rx=false;
	
	switch(phase)
	{
		case KAMTOM_DATA:
			rx = XN297_IsRX();
			XN297_SetTxRxMode(TXRX_OFF);
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(KAMTOM_PACKET_PERIOD);
			#endif
			KAMTOM_send_packet();
			if(rx)
			{
				uint8_t val=XN297_ReadEnhancedPayload(packet_in, KAMTOM_PAYLOAD_SIZE);
				if(val==KAMTOM_PAYLOAD_SIZE)
				{
					BIND_DONE;
					if(packet_in[0] == 0xA0 && packet_in[14] == rx_tx_addr[2] && packet_in[15] == rx_tx_addr[3])
					{//Good packet with our TXID
						rx_tx_addr[0] = packet_in[9];
						rx_tx_addr[1] = packet_in[10];
						#ifdef KAMTOM_HUB_TELEMETRY
							v_lipo1 = packet_in[1] == 0x03 ? 0x00:0xFF;		// low voltage
							telemetry_link = 1;
						#endif
					}
					#if 0
						for(uint8_t i=0; i < KAMTOM_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
						debugln();
					#endif
				}
			}
			phase++;
			return KAMTOM_WRITE_TIME;
		default: //KAMTOM_RX
			//{ // Wait for packet to be sent before switching to receive mode
			//	uint16_t start=(uint16_t)micros();
			//	while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
			//		if(XN297_IsPacketSent())
			//			break;
			//}
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = KAMTOM_DATA;
			return KAMTOM_PACKET_PERIOD - KAMTOM_WRITE_TIME;
	}
	return 0;
}

void KAMTOM_init()
{
	KAMTOM_initialize_txid();
	KAMTOM_RF_init();

	bind_counter = KAMTOM_BIND_COUNT;
	phase = KAMTOM_DATA;
	hopping_frequency_no = 0;
	#ifdef KAMTOM_HUB_TELEMETRY
		RX_RSSI = 100;		// Dummy value
	#endif
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho2_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(KYOSHO2_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define KYOSHO2_PACKET_PERIOD			1120
#define KYOSHO2_BIND_PACKET_PERIOD		1600
#define KYOSHO2_BIND_COUNT				6000	// about 9sec
#define KYOSHO2_BIND_CHANNEL			0x50
#define KYOSHO2_PAYLOAD_SIZE			28
#define KYOSHO2_RF_CHANNELS				15
#define KYOSHO2_START_RF_CHANNEL		0x13	// No idea where it comes from... ID or unknown bytes during the bind?
#define KYOSHO2_NUM_CHANNEL				10		// Only 4 on the dumps but there is space for 10 channels in the payload...

#define FORCE_KYOSHO2_ID

bool KYOSHO2_resend;
//
static void __attribute__((unused)) KYOSHO2_send_packet()
{
	if(KYOSHO2_resend == true)
	{
		NRF24L01_Strobe(NRF24L01_E3_REUSE_TX_PL);
		if(IS_BIND_DONE)
			KYOSHO2_resend = false;
		return;
	}
	
	memset(packet,0x00,KYOSHO2_PAYLOAD_SIZE);
	
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(packet, (uint8_t*)"\x01\x02\x05\x08\x1A\x2B\x3C\x4D", 8);	// unknown bytes, parameters on how to build the rf channels?
		memcpy(&packet[8], rx_tx_addr, 4);
	}
	else
	{
		memcpy(packet, rx_tx_addr, 4);
		//Hopp
		packet[6] = hopping_frequency_no + KYOSHO2_START_RF_CHANNEL;
		packet[7] = hopping_frequency[hopping_frequency_no];
		NRF24L01_WriteReg(NRF24L01_05_RF_CH, packet[6+(rf_ch_num&0x01)]);
		rf_ch_num++;
		//Channels
		uint16_t temp;
		for (uint8_t i = 0; i< KYOSHO2_NUM_CHANNEL; i++)
		{
			temp=convert_channel_16b_limit(i,0,0x3FF);
			packet[8+i*2] = temp >> 8;
			packet[9+i*2] = temp;
		}
	}
	//Send
    NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));	// Reset flags
    NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet,KYOSHO2_PAYLOAD_SIZE);
	NRF24L01_SetPower();
	KYOSHO2_resend = true;
	
	#if 0
		for(uint8_t i=0;i<KYOSHO2_PAYLOAD_SIZE;i++)
			debug("%02X ", packet[i]);
		debugln("");
	#endif
}

static void __attribute__((unused)) KYOSHO2_RF_init()
{
	NRF24L01_Initialize();
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, KYOSHO2_BIND_CHANNEL);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t*)"\x69\x53\x10\xAC\xEF", 5);
}

static void __attribute__((unused)) KYOSHO2_initialize_tx_id()
{
	hopping_frequency_no = rx_tx_addr[3]%KYOSHO2_RF_CHANNELS;
	hopping_frequency[0] = 0x4A;
	#ifdef FORCE_KYOSHO2_ID
		memcpy(rx_tx_addr, (uint8_t*)"\x0A\xBD\x31\xDF", 4);
		hopping_frequency[0] = 0x4A;						// No idea where it comes from... ID or unknown bytes during the bind?
	#endif
	for(uint8_t i=1;i<KYOSHO2_RF_CHANNELS;i++)
	{
		if(hopping_frequency[i-1]+5 < 0x50)
			hopping_frequency[i] = hopping_frequency[i-1]+5;
		else
			hopping_frequency[i] = hopping_frequency[i-1]-0x21;
	}
	#if 0
		for(uint8_t i=0;i<KYOSHO2_RF_CHANNELS;i++)
			debugln("1:%02X, 2: %02X", i + KYOSHO2_START_RF_CHANNEL, hopping_frequency[i]);
		debugln("Selected 1:%02X, 2: %02X", hopping_frequency_no + KYOSHO2_START_RF_CHANNEL, hopping_frequency[hopping_frequency_no]);
	#endif
}

uint16_t KYOSHO2_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(KYOSHO2_PACKET_PERIOD);
	#endif
	KYOSHO2_send_packet();
	if(bind_counter)
	{
		if(--bind_counter==0)
		{
			BIND_DONE;
			KYOSHO2_resend = false;
		}
		return KYOSHO2_BIND_PACKET_PERIOD;
	}
	return KYOSHO2_PACKET_PERIOD;
}

void KYOSHO2_init()
{
	KYOSHO2_initialize_tx_id();
	KYOSHO2_RF_init();
	rf_ch_num = 0;

	if(IS_BIND_IN_PROGRESS)
		bind_counter = KYOSHO2_BIND_COUNT;
	else 
		bind_counter = 0;
	KYOSHO2_resend = false;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho3_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(KYOSHO3_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define KYOSHO3_FORCE_ID
//#define KYOSHO3_DEBUG

#define KYOSHO3_BIND_PACKET_SIZE	4
#define KYOSHO3_PACKET_SIZE			9

const uint8_t PROGMEM KYOSHO3_init_vals[][2] = {
	//Init from dump
	{CYRF_0B_PWR_CTRL, 0x00},					// PMU
	{CYRF_32_AUTO_CAL_TIME, 0x3C},				// Default init value
	{CYRF_35_AUTOCAL_OFFSET, 0x14},				// Default init value
	{CYRF_03_TX_CFG, 0x28 | CYRF_BIND_POWER},	// 8DR Mode, 64 chip codes
	{CYRF_10_FRAMING_CFG, 0xA4},				// SOP and LEN enable
	{CYRF_1F_TX_OVERRIDE, 0x05},				// Disable CRC, Data invert
	{CYRF_1E_RX_OVERRIDE, 0x04},				// CRC check disabled
	//{CYRF_11_DATA32_THOLD, 0x04},				// ???Using 64 chip...
	{CYRF_12_DATA64_THOLD, 0x0E},				// Default
	{CYRF_06_RX_CFG, 0x52},						// AGC disabled, LNA enabled, override enabled
};

static uint16_t __attribute__((unused)) KYOSHO3_send_packet()
{
	CYRF_SetPower(0x28);
	if(IS_BIND_IN_PROGRESS)
	{
		if(--bind_counter==0)
			BIND_DONE;
		packet[0] = 0xAA;
		//ID
		memcpy(&packet[1],&rx_tx_addr[1],3);
		CYRF_WriteDataPacketLen(packet, KYOSHO3_BIND_PACKET_SIZE);
		#ifdef KYOSHO3_DEBUG
			debug("P:");
			for(uint8_t i=0;i<KYOSHO3_BIND_PACKET_SIZE;i++)
				debug(" %02X",packet[i]);
			debugln("");
		#endif
		return 2434;
	}
	else
	{
		//ID
		memcpy(packet,&rx_tx_addr[1],3);
		//Channels
		for(uint8_t i=0;i<4;i++)
		{
			packet[3] >>= 2;
			packet[3] |= Channel_data[i]<<6;
			packet[4+i]  = Channel_data[i]>>3;
		}
		//Checksum
		packet[8] = packet[3];
		for(uint8_t i=4;i<8;i++)
			packet[8] += packet[i];
		//Timing
		phase ^= 0x01;
		CYRF_WriteDataPacketLen(packet, KYOSHO3_PACKET_SIZE);
		#ifdef KYOSHO3_DEBUG
			debug("P:");
			for(uint8_t i=0;i<KYOSHO3_PACKET_SIZE;i++)
				debug(" %02X",packet[i]);
			debugln("");
		#endif
		if(phase)
			return 9047;
	}
	return 6957;
}

uint16_t KYOSHO3_callback()
{
	return KYOSHO3_send_packet();
}

void KYOSHO3_init()
{ 
	//Config CYRF registers
	for(uint8_t i = 0; i < sizeof(KYOSHO3_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&KYOSHO3_init_vals[i][0]), pgm_read_byte_near(&KYOSHO3_init_vals[i][1]));
	CYRF_WritePreamble(0x333304);

	//Find a free even channel
	CYRF_FindBestChannels(hopping_frequency,1,1,0x04,0x50, FIND_CHANNEL_EVEN);

	#ifdef KYOSHO3_FORCE_ID					// data taken from TX dump
		rx_tx_addr[1] = 0x01;
		rx_tx_addr[2] = 0xAB;
		rx_tx_addr[3] = 0x31;
		hopping_frequency[0] = 0x04;
	#endif
	#ifdef KYOSHO3_DEBUG
		debugln("ID: %02X %02X %02X",rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3]);
		debugln("RF CH: %02X",hopping_frequency[0]);
	#endif

	if(IS_BIND_IN_PROGRESS)
		CYRF_ConfigRFChannel(0x04);
	else
		CYRF_ConfigRFChannel(hopping_frequency[0]);
	
	bind_counter = 8217;
	phase = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Kyosho_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(KYOSHO_A7105_INO)

#include "iface_a7105.h"

//#define KYOSHO_FORCE_ID_FHSS
//#define KYOSHO_FORCE_ID_HYPE
//#define KYOSHO_FORCE_ID_SYNCRO

//Kyosho constants & variables
#define KYOSHO_BIND_COUNT 2500

#ifndef MULTI_AIR
static void __attribute__((unused)) KYOSHO_send_packet()
{
	//ID
	packet[1] = rx_tx_addr[0];
	packet[2] = rx_tx_addr[1];
	packet[3] = rx_tx_addr[2];
	packet[4] = rx_tx_addr[3];
	//unknown may be RX ID on some other remotes
	memset(packet+5,0xFF,4);

	if(IS_BIND_IN_PROGRESS)
	{
		packet[ 0]  = 0xBC;						// bind indicator
		packet[ 9] &= 0x01;
		packet[ 9] ^= 0x01;						// high/ low part of the RF table
		packet[10]  = 0x00;
		//RF table
		for(uint8_t i=0; i<16;i++)
			packet[i+11]=hopping_frequency[i+(packet[9]<<4)];
		//TX type
		packet[27]  = (bind_counter & 0x40) ? 0x05:0x07;	// FHSS is 5 and Syncro is 7
		//Unknown
		packet[28]  = 0x00;
		memset(packet+29,0xFF,8);
		//frequency hop during bind
		if(packet[9])
			rf_ch_num=0x8C;
		else
			rf_ch_num=0x0D;
	}
	else
	{
		packet[ 0]  = 0x58;						// normal packet
		//FHSS  14 channels: steering, throttle, ...
		//Syncro 6 channels: steering, throttle, ...
		for(uint8_t i = 0; i < 14; i++) 		//needed? i < (sub_protocol==KYOSHO_FHSS?14:6); i++)
		{
			uint16_t temp = convert_channel_ppm(i);
			packet[ 9 + i*2] = temp&0xFF;		// low byte of servo timing(1000-2000us)
			packet[10 + i*2] = (temp>>8)&0xFF;	// high byte of servo timing(1000-2000us)
		}
		// if(sub_protocol==KYOSHO_SYNCRO) 	// needed?
		// {
			// memcpy(&packet[21],&hopping_frequency[11],6);
			// packet[27]  = 0x07;
			// packet[28]  = 0x00;
			// memset(packet+29,0xFF,8);
			// packet[34] = 0x0F;
			// packet[36] = 0x0F;
		// }
		rf_ch_num=hopping_frequency[hopping_frequency_no];
		hopping_frequency_no++;
		packet[34] |= (hopping_frequency_no&0x0F)<<4;
		packet[36] |= (hopping_frequency_no&0xF0);		// last byte is ending with F on the dumps so let's see
		hopping_frequency_no &= 0x1F;
	}
	#if 0
		debug("ch=%02X P=",rf_ch_num);
		for(uint8_t i=0; i<37; i++)
			debug("%02X ", packet[i]);
		debugln("");
	#endif
	A7105_WriteData(37, rf_ch_num);
}
#endif //MULTI_AIR

static void __attribute__((unused)) KYOSHO_hype_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		if(packet_sent==0)
		{//build the packet and send it
			packet[0] = rx_tx_addr[1];
			packet[1] = rx_tx_addr[3];
			//RF table
			for(uint8_t i=0; i<15;i++)
				packet[i+2]=hopping_frequency[i];
			A7105_WriteData(17, 0x01);
			packet_sent++;
			packet_period=1421;
			#if 0
				debug("ch=01 P=");
				for(uint8_t i=0; i<17; i++)
					debug("%02X ", packet[i]);
				debugln("");
			#endif
		}
		else
			A7105_Strobe(A7105_TX);	//only send
	}
	else
	{
		//original TX is only refreshing the packet every 20ms and keep repeating the same packet in between (STROBE_TX) 
		//build packet=6 channels with order AETR
		for(uint8_t i=0;i<6;i++)
			packet[i] = convert_channel_8b(CH_AETR[i]);
		//set RF channel
		rf_ch_num=hopping_frequency[hopping_frequency_no];
		hopping_frequency_no++;
		if(hopping_frequency_no>14)
			hopping_frequency_no = 0;
		//send it
		A7105_WriteData(6, rf_ch_num);
		packet_period=931;	//packet period fluctuates a lot on the original TX from one packet to the other but stable if looking over a period of 40ms
		#if 0
			debug("ch=%02X P=",rf_ch_num);
			for(uint8_t i=0; i<6; i++)
				debug("%02X ", packet[i]);
			debugln("");
		#endif
	}
}

uint16_t KYOSHO_callback()
{
	#ifndef FORCE_KYOSHO_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter--;
		if (bind_counter==0)
		{
			BIND_DONE;
			if(sub_protocol==KYOSHO_HYPE)
			{
				A7105_WriteID(MProtocol_id);
				A7105_WriteReg(A7105_03_FIFOI,0x05);
			}
		}
	}
	else
	{
		if(hopping_frequency_no==0)
			A7105_SetPower();
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(packet_period);
		#endif
	}
	if(sub_protocol==KYOSHO_HYPE)
		KYOSHO_hype_send_packet();
	else //FHSS && SYNCRO
	#ifndef MULTI_AIR
		KYOSHO_send_packet();
	#else
		SUB_PROTO_INVALID;
	#endif
	return packet_period;
}

void KYOSHO_init()
{
	A7105_Init();

	// compute channels from ID
	calc_fh_channels(sub_protocol==KYOSHO_HYPE?15:32);
	hopping_frequency_no=0;

	#ifdef KYOSHO_FORCE_ID_FHSS
		if(sub_protocol==KYOSHO_FHSS)
		{
			memcpy(rx_tx_addr,"\x3A\x39\x37\x00",4);
			memcpy(hopping_frequency,"\x29\x4C\x67\x92\x31\x1C\x77\x18\x23\x6E\x81\x5C\x8F\x5A\x51\x94\x7A\x12\x45\x6C\x7F\x1E\x0D\x88\x63\x8C\x4F\x37\x26\x61\x2C\x8A",32);
		}
	#endif
	#ifdef KYOSHO_FORCE_ID_SYNCRO
		if(sub_protocol==KYOSHO_FHSS)
		{
			memcpy(rx_tx_addr,"\x00\xC2\x24\x00",4);
			memcpy(hopping_frequency,"\x73\x12\x7D\x88\x63\x4A\x8D\x60\x57\x16\x5D\x8B\x25\x53\x6E\x3C\x41\x70\x20\x83\x2A\x19\x94\x2F\x91\x4C\x47\x36\x78\x10\x5A\x31",32);
		}
	#endif
	if(sub_protocol==KYOSHO_HYPE)
	{
		MProtocol_id &= 0x00FF00FF;
		rx_tx_addr[0] = 0xAF - (rx_tx_addr[1]&0x0F);
		rx_tx_addr[2] = 0xFF -  rx_tx_addr[3];
		MProtocol_id |= (rx_tx_addr[0]<<24) + (rx_tx_addr[2]<<8);
		#ifdef KYOSHO_FORCE_ID_HYPE
			MProtocol_id=0xAF90738C;
			set_rx_tx_addr(MProtocol_id);
			memcpy(hopping_frequency,"\x27\x1B\x63\x75\x03\x39\x57\x69\x87\x0F\x7B\x3F\x33\x51\x6F",15);
		#endif
		if(IS_BIND_IN_PROGRESS)
			A7105_WriteID(0xAF00FF00);
		else
		{
			A7105_WriteID(MProtocol_id);
			A7105_WriteReg(A7105_03_FIFOI,0x05);
		}
	}

	if(IS_BIND_IN_PROGRESS)
		bind_counter = KYOSHO_BIND_COUNT;

	packet_sent=0;
	packet_period=3852;		//FHSS
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/LOLI_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(LOLI_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define LOLI_BIND_CHANNEL	33
#define LOLI_PACKET_SIZE	11
#define LOLI_NUM_CHANNELS	5

static void __attribute__((unused)) LOLI_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t*)"LOVE!", 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t*)"LOVE!", 5);
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, LOLI_PACKET_SIZE);	// RX FIFO size
	NRF24L01_SetBitrate(NRF24L01_BR_250K);             	// 250Kbps
}

// flags going to packet[1] for packet type 0xa2 (Rx config)
#define LOLI_FLAG_PWM7   0x02
#define LOLI_FLAG_PWM2   0x04
#define LOLI_FLAG_PWM1   0x08
#define LOLI_FLAG_SBUS   0x40
#define LOLI_FLAG_PPM    0x80

// flags going to packet[2] for packet type 0xa2 (Rx config)
#define LOLI_FLAG_SW8    0x01
#define LOLI_FLAG_SW7    0x02
#define LOLI_FLAG_SW6    0x04
#define LOLI_FLAG_SW5    0x08
#define LOLI_FLAG_SW4    0x10
#define LOLI_FLAG_SW3    0x20
#define LOLI_FLAG_SW2    0x40
#define LOLI_FLAG_SW1    0x80

#ifdef LOLI_NRF24L01_INO
	uint8_t LOLI_P1, LOLI_P2;
#endif

static void __attribute__((unused)) LOLI_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0xa0;
		memcpy(&packet[1], hopping_frequency, LOLI_NUM_CHANNELS);
		memcpy(&packet[6], rx_tx_addr, 5);
		rf_ch_num = LOLI_BIND_CHANNEL;
	}
	else
	{
		//Check RX config
		uint8_t P1=0;
		uint8_t P2=0;
		//ch1: PWM/PPM
		if(Channel_data[CH1+8] > CHANNEL_MAX_COMMAND)
			P1|=LOLI_FLAG_PWM1;
		else if(Channel_data[CH1+8] > CHANNEL_SWITCH)
			P1|=LOLI_FLAG_PPM;
		//ch2: PWM
		if(Channel_data[CH2+8] > CHANNEL_MAX_COMMAND)
			P1|=LOLI_FLAG_PWM2;
		//ch5: SBUS
		if(Channel_data[CH5+8] > CHANNEL_SWITCH)
			P1|=LOLI_FLAG_SBUS;
		//ch7: PWM
		if(Channel_data[CH7+8] > CHANNEL_MAX_COMMAND)
			P1|=LOLI_FLAG_PWM7;

		//switches
		for(uint8_t i=0;i<8;i++)
			if(Channel_data[i+8]<CHANNEL_MIN_COMMAND)
				P2 |= 1 << (7-i);

		if(LOLI_P1!=P1 || LOLI_P2!=P2)
			flags=10;
		if(flags)
		{// Send RX config since P1 or P2 have changed
			LOLI_P1=P1;LOLI_P2=P2;
			packet[0] = 0xa2;
			packet[1] = LOLI_P1;	// CH1:LOLI_FLAG_PPM || LOLI_FLAG_PWM1, CH2:LOLI_FLAG_PWM2, CH5:LOLI_FLAG_SBUS, CH7:LOLI_FLAG_PWM7
			packet[2] = LOLI_P2;	// CHx switch bit(8-x)=1
			flags--;
		}
		else
		{// Normal packet
			#ifdef FAILSAFE_ENABLE
				packet[0] = IS_FAILSAFE_VALUES_on ? 0xa0 : 0xa1;
			#else
				packet[0] = 0xa1;
			#endif

			//Build channels
			uint8_t ch=0, offset=1;
			uint16_t val;
			for(uint8_t i=0;i<2;i++)
			{
				val = convert_channel_10b(ch++, IS_FAILSAFE_VALUES_on);
				packet[offset++] = val >> 2;
				packet[offset  ] = val << 6;
				val = convert_channel_10b(ch++, IS_FAILSAFE_VALUES_on);
				packet[offset++]|= val >> 4;
				packet[offset  ] = val << 4;
				val = convert_channel_10b(ch++, IS_FAILSAFE_VALUES_on);
				packet[offset++]|= val >> 6;
				packet[offset  ] = val << 2;
				val = convert_channel_10b(ch++, IS_FAILSAFE_VALUES_on);
				packet[offset++]|= val >> 8;
				packet[offset++] = val & 0xff;
			}
			FAILSAFE_VALUES_off;	// Failsafe values are sent if they were available
		}

		if (++hopping_frequency_no > LOLI_NUM_CHANNELS-1)
			hopping_frequency_no = 0;
		rf_ch_num = hopping_frequency[hopping_frequency_no];
	}
	
	#if 0
		debug("P(%02X):",rf_ch_num);
		for(uint8_t i=0; i<LOLI_PACKET_SIZE; i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
		
	//Send packet
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch_num);
	NRF24L01_SetPower();
	NRF24L01_SetTxRxMode(TXRX_OFF);
	NRF24L01_SetTxRxMode(TX_EN);
	NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x0a);  // 8bit CRC, TX
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, LOLI_PACKET_SIZE);
}

enum{
	LOLI_BIND1,
	LOLI_BIND2,
	LOLI_BIND3,
	LOLI_PREP_DATA,
	LOLI_DATA1,
	LOLI_DATA2,
	LOLI_SET_RX_CONFIG,
	LOLI_SET_FAILSAFE
};

#define LOLI_WRITE_TIME 1000

uint16_t LOLI_callback()
{
	switch (phase)
	{
		case LOLI_BIND1:
			if(bind_counter)
				if(--bind_counter==0)
				{
					phase=LOLI_PREP_DATA;
					break;
				}
			// send bind packet
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_SetTxRxMode(TX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x0a);  // 8bit CRC, TX
			LOLI_send_packet();
			phase++;
			return 2000;
		case LOLI_BIND2:
			// switch to RX mode
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_FlushRx();
			NRF24L01_SetTxRxMode(RX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x3b);  // 8bit CRC, RX
			phase++;
			packet_count = 0;
			return 2000;
		case LOLI_BIND3:
			// got bind response ?
			if (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{
				NRF24L01_ReadPayload(packet, LOLI_PACKET_SIZE);
				if (packet[0] == 'O' && packet[1] == 'K')
				{
					debugln("Bind OK");
					phase++;	// LOLI_PREP_DATA
					break;
				}
			}
			packet_count++;
			if (packet_count > 50)
				phase = LOLI_BIND1;
			return 1000;

		case LOLI_PREP_DATA:
			BIND_DONE;
			NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, 5);
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);
			NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
			NRF24L01_FlushRx();
			packet_count = 0;
			//defaut RX config with servo outputs
			LOLI_P1=0;LOLI_P2=0;flags=10;
			phase++;

		case LOLI_DATA1:
			#ifdef LOLI_HUB_TELEMETRY
				// Check telemetry
				if (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
				{  // RX fifo data ready
					NRF24L01_ReadPayload(packet, LOLI_PACKET_SIZE);
					#if 0
						debug("T:");
						for(uint8_t i=0; i<LOLI_PACKET_SIZE; i++)
							debug(" %02X",packet[i]);
						debugln("");
					#endif
					RX_RSSI = packet[0]<<1;
					uint16_t val=((packet[1] << 8) | packet[2])/10;
					if(val > 255) val=255;
					v_lipo1 = val;
					val=((packet[3] << 8) | packet[4])/10;
					if(val > 255) val=255;
					v_lipo2 = val;
					telemetry_link = 1;
					telemetry_counter++;			// TX LQI counter
					if(telemetry_lost)
					{
						telemetry_lost = 0;
						packet_count = 100;
						telemetry_counter = 100;
					}
				}
				//LQI
				packet_count++;
				if(packet_count>=100)
				{
					packet_count=0;
					TX_LQI=telemetry_counter;
					if(telemetry_counter==0)
						telemetry_lost = 1;
					telemetry_counter = 0;
				}
			#endif
			
			// Send data packet
			LOLI_send_packet();
			
	#ifdef LOLI_HUB_TELEMETRY
			phase ++;
			return LOLI_WRITE_TIME;
		case LOLI_DATA2:
			// Wait for packet to be sent
			while( (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_TX_DS)) == 0);
			// Switch to RX mode
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_FlushRx();
			NRF24L01_SetTxRxMode(RX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x3b);  // 8bit CRC, RX
			phase = LOLI_DATA1;
			return 20000 - LOLI_WRITE_TIME;
	#else
			break;
	#endif
	}
	return 20000;
}

void LOLI_init()
{
	rx_tx_addr[1] %= 0x30;
	calc_fh_channels(LOLI_NUM_CHANNELS);
	for (uint8_t i=0; i < LOLI_NUM_CHANNELS; i++)
		if (hopping_frequency[i] == LOLI_BIND_CHANNEL)
			hopping_frequency[i]++;

	if (IS_BIND_IN_PROGRESS)
	{
		bind_counter=250;
		phase = LOLI_BIND1;
	}
	else
		phase = LOLI_PREP_DATA;

	LOLI_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Losi_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(LOSI_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define LOSI_FORCE_ID

/* Using DSM.ino data codes since they are the same
const uint8_t LOSI_data_code[][8] = {
	//(Freq-1)%5=0
	{ 0x83, 0xF7, 0xA8, 0x2D, 0x7A, 0x44, 0x64, 0xD3 },
	{ 0x3F, 0x2C, 0x4E, 0xAA, 0x71, 0x48, 0x7A, 0xC9 },
	{ 0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82 },
	{ 0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB },
	{ 0x24, 0xF5, 0xDD, 0xF8, 0x7A, 0x77, 0x74, 0xE7 },
	{ 0x3D, 0x70, 0x7C, 0x94, 0xDC, 0x84, 0xAD, 0x95 },
	{ 0x1E, 0x6A, 0xF0, 0x37, 0x52, 0x7B, 0x11, 0xD4 },
	{ 0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF },
	//(Freq-1)%5=1
	{ 0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97 },
	{ 0x8E, 0x4A, 0xD0, 0xA9, 0xA7, 0xFF, 0x20, 0xCA },
	{ 0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE },
	{ 0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD },
	{ 0x50, 0x14, 0x33, 0xDE, 0xF1, 0x78, 0x95, 0xAD },
	{ 0x0C, 0x3C, 0xFA, 0xF9, 0xF0, 0xF2, 0x10, 0xC9 },
	{ 0xF4, 0xDA, 0x06, 0xDB, 0xBF, 0x4E, 0x6F, 0xB3 },
	{ 0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0 },
	//(Freq-1)%5=2
	{ 0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E },
	{ 0x80, 0x69, 0x26, 0x80, 0x08, 0xF8, 0x49, 0xE7 },
	{ 0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1 },
	{ 0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4 },
	{ 0x42, 0xAE, 0x9C, 0x1C, 0xDA, 0x67, 0x05, 0xF6 },
	{ 0x9B, 0x75, 0xF7, 0xE0, 0x14, 0x8D, 0xB5, 0x80 },
	{ 0xBF, 0x54, 0x98, 0xB9, 0xB7, 0x30, 0x5A, 0x88 },
	{ 0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88 },
	//(Freq-1)%5=3
	{ 0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93 },
	{ 0xDC, 0x68, 0x08, 0x99, 0x97, 0xAE, 0xAF, 0x8C },
	{ 0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA },
	{ 0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC },
	{ 0x5C, 0xD5, 0x9C, 0xB8, 0x46, 0x9C, 0x7D, 0x84 },
	{ 0xF1, 0xC6, 0xFE, 0x5C, 0x9D, 0xA5, 0x4F, 0xB7 },
	{ 0x58, 0xB5, 0xB3, 0xDD, 0x0E, 0x28, 0xF1, 0xB0 },
	{ 0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1 },
	//(Freq-1)%5=4
	{ 0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8 },
	{ 0x88, 0x17, 0x13, 0x3B, 0x2D, 0xBF, 0x06, 0xD6 },
	{ 0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9 },
	{ 0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4 },
	{ 0x8C, 0xFA, 0x47, 0x9B, 0x83, 0xA5, 0x66, 0xD0 },
	{ 0x07, 0xBD, 0x9F, 0x26, 0xC8, 0x31, 0x0F, 0xB8 },
	{ 0xEF, 0x03, 0x95, 0x89, 0xB4, 0x71, 0x61, 0x9D },
	{ 0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1 },
	//Bind
	{ 0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86 }
};*/

static uint16_t __attribute__((unused)) LOSI_check(uint16_t val)
{
	const uint8_t PROGMEM tab[] = { 0xF1, 0xDA, 0xB6, 0xC8 };
	uint8_t res = crc8, tmp;
	uint16_t calc = val>>2; 								// don't care about the 2 first bits
	for(uint8_t i=0; i<5; i++)
	{
		tmp=pgm_read_byte_near(&tab[i&0x03]);
		if(calc&0x0001)
			res ^= tmp>>4;
		calc >>= 1;
		if(calc&0x0001)
			res ^= tmp;
		calc >>= 1;
	}
	return val ^ (res<<12);
}

static void __attribute__((unused)) LOSI_send_packet()
{
	memcpy(packet, rx_tx_addr, 4);
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(&packet[4], rx_tx_addr, 4);
		crc = 0x0170;
		for(uint8_t i=0; i < 8; i++)
			crc += packet[i];
		packet[8] = crc >> 8;
		packet[9] = crc;
	}
	else
	{
		for(uint8_t i=0; i<3; i++)
		{
			uint16_t val = LOSI_check(Channel_data[i]<<1);
			packet[4+i*2] = val >> 8;
			packet[5+i*2] = val;
		}
	}

	CYRF_SetPower(0x38);
	CYRF_WriteDataPacketLen(packet, 0x0A);
	#if 0
		for(uint8_t i=0; i < 0x0A; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) LOSI_cyrf_init()
{
	/* Initialise CYRF chip */
	CYRF_WriteRegister(CYRF_28_CLK_EN, 0x02);
	CYRF_WriteRegister(CYRF_32_AUTO_CAL_TIME, 0x3C);
	CYRF_WriteRegister(CYRF_35_AUTOCAL_OFFSET, 0x14);
	CYRF_WriteRegister(CYRF_06_RX_CFG, 0x48);
	CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB, 0x55);
	CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB, 0x05);
	//CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);
	CYRF_SetPower(0x38);									// 64 SDR mode -> 8 bytes data code
	CYRF_WriteRegister(CYRF_12_DATA64_THOLD, 0x0A);
	CYRF_WriteRegister(CYRF_39_ANALOG_CTRL, 0x01);
	CYRF_WritePreamble(0x333304);
	//CYRF_WriteRegister(CYRF_27_CLK_OVERRIDE, 0x00);
	CYRF_WriteRegister(CYRF_10_FRAMING_CFG, 0x4A);
	CYRF_WriteRegister(CYRF_1F_TX_OVERRIDE, 0x04);			// No CRC
	//CYRF_WriteRegister(CYRF_1E_RX_OVERRIDE, 0x14);
	//CYRF_WriteRegister(CYRF_14_EOP_CTRL, 0x02);
	uint8_t code[16];
	DSM_read_code(code,0,8);								// Load bind data code by default
	CYRF_ConfigDataCode(code);
}

uint16_t LOSI_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if(bind_counter==0)
		{
			BIND_DONE;
			// Load normal data code
			uint8_t code[16];
			DSM_read_code(code,hopping_frequency[0] % 5,(rx_tx_addr[0] + rx_tx_addr[1] + rx_tx_addr[2]) % 8);
			CYRF_ConfigDataCode(code);
			packet_period = 19738;
		}
	}
	LOSI_send_packet();
	return packet_period;
}

void LOSI_init()
{
	LOSI_cyrf_init();

	CYRF_FindBestChannels(hopping_frequency, 1, 0, 0x07, 0x4F, FIND_CHANNEL_ODD);	// 0x07 and 0x4F are unknown limits, this routine resets the CRC Seed to 0

	crc8 = 0;
	crc8 = (uint16_t)LOSI_check(((rx_tx_addr[2]&0x0F) << 8) + rx_tx_addr[3]) >> 12;

	#ifdef LOSI_FORCE_ID
		/*	
		rx_tx_addr[0] = 0x47;
		rx_tx_addr[1] = 0x52;
		rx_tx_addr[2] = 0xAE;
		rx_tx_addr[3] = 0xAA;
		crc8 = 0x0B;
		num_ch = 0x07;
		//Data codes for hopping_frequency[0] % 5
		//{ 0x40, 0xBA, 0x97, 0xD5, 0x86, 0x4F, 0xCC, 0xD1, 0xD7, 0xA1, 0x54, 0xB1, 0x5E, 0x89, 0xAE, 0x86 },
		//{ 0x62, 0xF5, 0x2B, 0xAA, 0xFC, 0x33, 0xBF, 0xAF, 0x40, 0x56, 0x32, 0xD9, 0x0F, 0xD9, 0x5D, 0x97 },
		//{ 0x9E, 0x08, 0xD1, 0xAE, 0x59, 0x5E, 0xE8, 0xF0, 0xC0, 0x90, 0x8F, 0xBB, 0x7C, 0x8E, 0x2B, 0x8E },
		//{ 0x35, 0xD1, 0xFC, 0x97, 0x23, 0xD4, 0xC9, 0x88, 0xE1, 0xD6, 0x31, 0x26, 0x5F, 0xBD, 0x40, 0x93 },
		//{ 0x5F, 0x30, 0x3B, 0x56, 0x96, 0x45, 0xF4, 0xA1, 0x03, 0xBC, 0x6E, 0x8A, 0xEF, 0xBD, 0xFE, 0xF8 }
		*/
		rx_tx_addr[0] = 0x56;
		rx_tx_addr[1] = 0x52;
		rx_tx_addr[2] = 0x22;
		rx_tx_addr[3] = 0x8A;
		crc8 = 0x0F;
		num_ch = 0x02;
		//Data codes for hopping_frequency[0] % 5
		//{ 0xF1, 0x94, 0x30, 0x21, 0xA1, 0x1C, 0x88, 0xA9, 0xD0, 0xD2, 0x8E, 0xBC, 0x82, 0x2F, 0xE3, 0xB4 },
		//{ 0x17, 0xFF, 0x9E, 0x21, 0x36, 0x90, 0xC7, 0x82, 0xBC, 0x5D, 0x9A, 0x5B, 0xEE, 0x7F, 0x42, 0xEB },
		//{ 0x4C, 0x97, 0x9D, 0xBF, 0xB8, 0x3D, 0xB5, 0xBE, 0x0C, 0x5D, 0x24, 0x30, 0x9F, 0xCA, 0x6D, 0xBD },
		//{ 0x7D, 0x2D, 0x49, 0x54, 0xD0, 0x80, 0x40, 0xC1, 0xB6, 0xF2, 0xE6, 0x1B, 0x80, 0x5A, 0x36, 0xB4 },
		//{ 0xC3, 0x0E, 0x01, 0x16, 0x0E, 0x32, 0x06, 0xBA, 0xE0, 0x83, 0x01, 0xFA, 0xAB, 0x3E, 0x8F, 0xAC }
		
		// Note: crc8=00..0F and num_ch=00..07
		// num_ch = (rx_tx_addr[0] + rx_tx_addr[1] + rx_tx_addr[2]) % 8;
		// crc8 = (uint16_t)LOSI_check(((rx_tx_addr[2]&0x0F) << 8) + rx_tx_addr[3]) >> 12;
	#endif

	CYRF_ConfigRFChannel(hopping_frequency[0]);

	bind_counter = IS_BIND_IN_PROGRESS?300:1;
	packet_period = 8763;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MJXQ_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with MJX WLH08, X600, X800, H26D, Eachine E010
// Last sync with hexfet new_protocols/mjxq_nrf24l01.c dated 2016-01-17

#if defined(MJXQ_CCNRF_INO)

#include "iface_xn297.h"

#define MJXQ_BIND_COUNT		150
#define MJXQ_PACKET_PERIOD	4000  // Timeout for callback in uSec
#define MJXQ_INITIAL_WAIT	500
#define MJXQ_PACKET_SIZE	16
#define MJXQ_RF_NUM_CHANNELS	4
#define MJXQ_ADDRESS_LENGTH	5

// haven't figured out txid<-->rf channel mapping for MJX models
const uint8_t PROGMEM MJXQ_map_txid[][3] = {
				{0xF8, 0x4F, 0x1C},
				{0xC8, 0x6E, 0x02},
				{0x48, 0x6A, 0x40}	};
const uint8_t PROGMEM MJXQ_map_rfchan[][4] = {
				{0x0A, 0x46, 0x3A, 0x42},
				{0x0A, 0x3C, 0x36, 0x3F},
				{0x0A, 0x43, 0x36, 0x3F}	};

const uint8_t PROGMEM E010_map_txid[][2] = {
					{0x4F, 0x1C},
					{0x90, 0x1C},
					{0x24, 0x36},
					{0x7A, 0x40},
					{0x61, 0x31},
					{0x5D, 0x37},
					{0xFD, 0x4F},
					{0x86, 0x3C},
					{0x41, 0x22},
					{0xEE, 0xB3},
					{0x9A, 0xB2},
					{0xC0, 0x44},
					{0x2A, 0xFE},
					{0xD7, 0x6E},
					{0x3C, 0xCD}, // for this ID rx_tx_addr[2]=0x01
					{0xF5, 0x2B} // for this ID rx_tx_addr[2]=0x02
					};
const uint8_t PROGMEM E010_map_rfchan[][2] = {
					{0x3A, 0x35},
					{0x2E, 0x36},
					{0x32, 0x3E},
					{0x2E, 0x3C},
					{0x2F, 0x3B},
					{0x33, 0x3B},
					{0x33, 0x3B},
					{0x34, 0x3E},
					{0x34, 0x2F},
					{0x39, 0x3E},
					{0x2E, 0x38},
					{0x2E, 0x36},
					{0x2E, 0x38},
					{0x3A, 0x41},
					{0x32, 0x3E},
					{0x33, 0x3F}
					};

#define MJXQ_PAN_TILT_COUNT	16   // for H26D - match stock tx timing
#define MJXQ_PAN_DOWN		0x08
#define MJXQ_PAN_UP			0x04
#define MJXQ_TILT_DOWN		0x20
#define MJXQ_TILT_UP		0x10

static uint8_t __attribute__((unused)) MJXQ_pan_tilt_value()
{
// CH12_SW	PAN			// H26D
// CH13_SW	TILT
	uint8_t	pan = 0;
	packet_count++;
	if(packet_count & MJXQ_PAN_TILT_COUNT)
	{
		if(CH12_SW)
			pan=MJXQ_PAN_UP;
		if(Channel_data[CH12]<CHANNEL_MIN_COMMAND)
			pan=MJXQ_PAN_DOWN;
		if(CH13_SW)
			pan+=MJXQ_TILT_UP;
		if(Channel_data[CH13]<CHANNEL_MIN_COMMAND)
			pan+=MJXQ_TILT_DOWN;
	}
	return pan;
}

#define MJXQ_CHAN2TRIM(X) (((X) & 0x80 ? (X) : 0x7f - (X)) >> 1)
static void __attribute__((unused)) MJXQ_send_packet(uint8_t bind)
{
	//RF freq
	hopping_frequency_no++;
	XN297_Hopping(hopping_frequency_no / 2);
	hopping_frequency_no %= 2 * MJXQ_RF_NUM_CHANNELS;	// channels repeated

	//Build packet
	packet[0] = convert_channel_8b(THROTTLE);
	packet[1] = convert_channel_s8b(RUDDER);
	packet[4] = 0x40;							// rudder does not work well with dyntrim
	packet[2] = 0x80 ^ convert_channel_s8b(ELEVATOR);
	packet[5] = (CH9_SW || CH14_SW) ? 0x40 : MJXQ_CHAN2TRIM(packet[2]);	// trim elevator
	packet[3] = convert_channel_s8b(AILERON);
	packet[6] = (CH9_SW || CH14_SW) ? 0x40 : MJXQ_CHAN2TRIM(packet[3]);	// trim aileron
	packet[7] = rx_tx_addr[0];
	packet[8] = rx_tx_addr[1];
	packet[9] = rx_tx_addr[2];

	packet[10] = 0x00;							// overwritten below for feature bits
	packet[11] = 0x00;							// overwritten below for X600
	packet[12] = 0x00;
	packet[13] = 0x00;

	packet[14] = 0xC0;							// bind value

// CH5_SW	FLIP
// CH6_SW	LED / ARM	// H26WH - TDR Phoenix mini
// CH7_SW	PICTURE
// CH8_SW	VIDEO
// CH9_SW	HEADLESS
// CH10_SW	RTH
// CH11_SW	AUTOFLIP	// X800, X600
// CH12_SW	PAN
// CH13_SW	TILT
// CH14_SW	XTRM		// Dyntrim, don't use if high.
	switch(sub_protocol)
	{
		case H26WH:
		case H26D:
			packet[10]=MJXQ_pan_tilt_value();
			// fall through on purpose - no break
		case WLH08:
		case E010:
		case PHOENIX:
			packet[10] += GET_FLAG(CH10_SW, 0x02)	//RTH
						| GET_FLAG(CH9_SW, 0x01);	//HEADLESS
			if (!bind)
			{
				packet[14] = 0x04
						| GET_FLAG(CH5_SW, 0x01)	//FLIP
						| GET_FLAG(CH7_SW, 0x08)	//PICTURE
						| GET_FLAG(CH8_SW, 0x10)	//VIDEO
						| GET_FLAG(!CH6_SW, 0x20);	// LED or air/ground mode
				if(sub_protocol==PHOENIX)
				{
					packet[10] |=0x20						//High rate
							   | GET_FLAG(CH6_SW, 0x80);	// arm
					packet[14] &= ~0x24;					// unset air/ground & arm flags
				}
				if(sub_protocol==H26WH)
				{
					packet[10] |=0x40;					//High rate
					packet[14] &= ~0x24;				// unset air/ground & arm flags
					packet[14] |= GET_FLAG(CH6_SW, 0x02);	// arm
				}
			}
			break;
		case X600:
			packet[10] = GET_FLAG(!CH6_SW, 0x02);	//LED
			packet[11] = GET_FLAG(CH10_SW, 0x01);	//RTH
			if (!bind)
			{
				packet[14] = 0x02						// always high rates by bit2 = 1
						| GET_FLAG(CH5_SW, 0x04)	//FLIP
						| GET_FLAG(CH11_SW, 0x10)	//AUTOFLIP
						| GET_FLAG(CH9_SW, 0x20);	//HEADLESS
			}
			break;
		case X800:
		default:
			packet[10] = 0x10
					| GET_FLAG(!CH6_SW, 0x02)	//LED
					| GET_FLAG(CH11_SW, 0x01);	//AUTOFLIP
			if (!bind)
			{
				packet[14] = 0x02						// always high rates by bit2 = 1
						| GET_FLAG(CH5_SW, 0x04)	//FLIP
						| GET_FLAG(CH7_SW, 0x08)	//PICTURE
						| GET_FLAG(CH8_SW, 0x10);	//VIDEO
			}
			break;
	}

	uint8_t sum = packet[0];
	for (uint8_t i=1; i < MJXQ_PACKET_SIZE-1; i++) sum += packet[i];
	packet[15] = sum;

	// Send
	XN297_SetTxRxMode(TX_EN);
	XN297_SetPower();
#ifdef NRF24L01_INSTALLED
	if (sub_protocol == H26D || sub_protocol == H26WH)
	{
		//NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no / 2]);
		//NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
		//NRF24L01_FlushTx();
		//NRF24L01_SetTxRxMode(TX_EN);
		//NRF24L01_SetPower();
		NRF24L01_WritePayload(packet, MJXQ_PACKET_SIZE);
	}
	else
#endif
	{//E010, PHOENIX, WLH08, X600, X800
		XN297_SetFreqOffset();
		XN297_WritePayload(packet, MJXQ_PACKET_SIZE);
	}
}

static void __attribute__((unused)) MJXQ_RF_init()
{
	uint8_t addr[MJXQ_ADDRESS_LENGTH];
	memcpy(addr, "\x6d\x6a\x77\x77\x77", MJXQ_ADDRESS_LENGTH);
	if (sub_protocol == WLH08)
		memcpy(hopping_frequency, "\x12\x22\x32\x42", MJXQ_RF_NUM_CHANNELS);
	else
		if (sub_protocol == H26D || sub_protocol == H26WH || sub_protocol == E010 || sub_protocol == PHOENIX)
			memcpy(hopping_frequency, "\x2e\x36\x3e\x46", MJXQ_RF_NUM_CHANNELS);
		else
		{
			memcpy(hopping_frequency, "\x0a\x35\x42\x3d", MJXQ_RF_NUM_CHANNELS);
			memcpy(addr, "\x6d\x6a\x73\x73\x73", MJXQ_ADDRESS_LENGTH);
		}
	if (sub_protocol == E010 || sub_protocol == PHOENIX)
	{
		XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
		XN297_SetTXAddr(addr, MJXQ_ADDRESS_LENGTH);
		XN297_HoppingCalib(MJXQ_RF_NUM_CHANNELS);
	}
	else
	{
		XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);	// this will select the nrf and initialize it, therefore both H26 sub protocols can use common instructions
#ifdef NRF24L01_INSTALLED
		if (sub_protocol == H26D || sub_protocol == H26WH)
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, addr, MJXQ_ADDRESS_LENGTH);
		else
#endif
			XN297_SetTXAddr(addr, MJXQ_ADDRESS_LENGTH);
		//NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0,		MJXQ_PACKET_SIZE);	// no RX???
	}
}

static void __attribute__((unused)) MJXQ_init2()
{
	switch(sub_protocol)
	{
		case H26D:
			memcpy(hopping_frequency, "\x32\x3e\x42\x4e", MJXQ_RF_NUM_CHANNELS);
			break;
		case H26WH:
			memcpy(hopping_frequency, "\x37\x32\x47\x42", MJXQ_RF_NUM_CHANNELS);
			break;
		case E010:
		case PHOENIX:
			for(uint8_t i=0;i<2;i++)
			{
				hopping_frequency[i]=pgm_read_byte_near( &E010_map_rfchan[rx_tx_addr[3]&0x0F][i] );
				hopping_frequency[i+2]=hopping_frequency[i]+0x10;
			}
			XN297_HoppingCalib(MJXQ_RF_NUM_CHANNELS);
			break;
		case WLH08:
			// do nothing
			break;
		default:
			for(uint8_t i=0;i<MJXQ_RF_NUM_CHANNELS;i++)
				hopping_frequency[i]=pgm_read_byte_near( &MJXQ_map_rfchan[rx_tx_addr[3]%3][i] );
			break;
	}
}

static void __attribute__((unused)) MJXQ_initialize_txid()
{
	switch(sub_protocol)
	{
		case H26WH:
			memcpy(rx_tx_addr, "\xa4\x03\x00", 3); 
			break;
		case E010:
		case PHOENIX:
			for(uint8_t i=0;i<2;i++)
				rx_tx_addr[i]=pgm_read_byte_near( &E010_map_txid[rx_tx_addr[3]&0x0F][i] );
			if((rx_tx_addr[3]&0x0E) == 0x0E)
				rx_tx_addr[2]=(rx_tx_addr[3]&0x01)+1;
			else
				rx_tx_addr[2]=0;
			break;
		case WLH08:
			rx_tx_addr[0]&=0xF8;
			rx_tx_addr[2]=rx_tx_addr[3];	// Make use of RX_Num
			break;
		default:
			for(uint8_t i=0;i<3;i++)
				rx_tx_addr[i]=pgm_read_byte_near( &MJXQ_map_txid[rx_tx_addr[3]%3][i] );
			break;
	}
}

uint16_t MJXQ_callback()
{
	if(IS_BIND_DONE)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(MJXQ_PACKET_PERIOD);
		#endif
		MJXQ_send_packet(0);
	}
	else
	{
		if (bind_counter == 0)
		{
			MJXQ_init2();
			BIND_DONE;
		}
		else
		{
			bind_counter--;
			MJXQ_send_packet(1);
		}
	}

    return MJXQ_PACKET_PERIOD;
}

void MJXQ_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
	bind_counter = MJXQ_BIND_COUNT;
    MJXQ_initialize_txid();
    MJXQ_RF_init();
	packet_count=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MLINK_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(MLINK_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define MLINK_FORCE_ID
#define MLINK_BIND_COUNT	696	// around 20s
#define MLINK_NUM_FREQ		78
#define MLINK_BIND_CHANNEL	0x01
#define MLINK_PACKET_SIZE	8

enum {
	MLINK_BIND_TX=0,
	MLINK_BIND_PREP_RX,
	MLINK_BIND_RX,
	MLINK_PREP_DATA,
	MLINK_SEND1,
	MLINK_SEND2,
	MLINK_SEND3,
	MLINK_CHECK3,
	MLINK_RX,
	MLINK_BUILD4,
};

uint8_t MLINK_Data_Code[16], MLINK_CRC_Init, MLINK_Unk_6_2;

const uint8_t PROGMEM MLINK_init_vals[][2] = {
	//Init from dump
	{ CYRF_01_TX_LENGTH,	0x08 },	// Length of packet
	{ CYRF_02_TX_CTRL,		0x40 },	// Clear TX Buffer
	{ CYRF_03_TX_CFG,		0x3C }, //0x3E in normal mode, 0x3C in bind mode: SDR 64 chip codes (=8 bytes data code used)
	{ CYRF_05_RX_CTRL,		0x00 },
	{ CYRF_06_RX_CFG,		0x93 },	// AGC enabled, overwrite enable, valid flag enable
	{ CYRF_0B_PWR_CTRL,		0x00 },
	//{ CYRF_0C_XTAL_CTRL,	0x00 },	// Set to GPIO on reset
	//{ CYRF_0D_IO_CFG,		0x00 },	// Set to GPIO on reset
	//{ CYRF_0E_GPIO_CTRL,	0x00 }, // Set by the CYRF_SetTxRxMode function
	{ CYRF_0F_XACT_CFG,		0x04 },	// end state idle
	{ CYRF_10_FRAMING_CFG,	0x00 },	// SOP disabled
	{ CYRF_11_DATA32_THOLD,	0x05 }, // not used???
	{ CYRF_12_DATA64_THOLD,	0x0F }, // 64 Chip Data PN Code Correlator Threshold
	{ CYRF_14_EOP_CTRL,		0x05 }, // 5 consecutive noncorrelations symbol for EOP
	{ CYRF_15_CRC_SEED_LSB,	0x00 }, // not used???
	{ CYRF_16_CRC_SEED_MSB,	0x00 }, // not used???
	{ CYRF_1B_TX_OFFSET_LSB,0x00 },
	{ CYRF_1C_TX_OFFSET_MSB,0x00 },
	{ CYRF_1D_MODE_OVERRIDE,0x00 },
	{ CYRF_1E_RX_OVERRIDE,	0x14 },	// RX CRC16 is disabled and Force Receive Data Rate
	{ CYRF_1F_TX_OVERRIDE,	0x04 }, // TX CRC16 is disabled
	{ CYRF_26_XTAL_CFG,		0x08 },
	{ CYRF_29_RX_ABORT,		0x00 },
	{ CYRF_32_AUTO_CAL_TIME,0x3C },
	{ CYRF_35_AUTOCAL_OFFSET,0x14 },
	{ CYRF_39_ANALOG_CTRL,	0x03 },	// Receive invert and all slow
};

static void __attribute__((unused)) MLINK_cyrf_config()
{
	for(uint8_t i = 0; i < sizeof(MLINK_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&MLINK_init_vals[i][0]), pgm_read_byte_near(&MLINK_init_vals[i][1]));
	CYRF_WritePreamble(0x333304);
	CYRF_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) MLINK_send_bind_packet()
{
	uint8_t p_c=packet_count>>1;
	
	memset(packet, p_c<0x16?0x00:0xFF, MLINK_PACKET_SIZE-1);
	packet[0]=0x0F;	// bind
	packet[1]=p_c;
	switch(p_c)
	{
		case 0x00:
			packet[2]=0x40;			//unknown but seems constant
			packet[4]=0x01;			//unknown but seems constant
			packet[5]=0x03;			//unknown but seems constant
			packet[6]=0xE3;			//unknown but seems constant
			break;
		case 0x05:
			packet[6]=MLINK_CRC_Init;	//CRC init value
			break;
		case 0x06:
			packet[2]=MLINK_Unk_6_2;	//unknown and different
			//Start of hopping frequencies
			for(uint8_t i=0;i<4;i++)
				packet[i+3]=hopping_frequency[i];
			break;
		case 0x15:
			packet[6]=0x51;			//unknown but seems constant
			break;
		case 0x16:
			packet[2]=0x51;			//unknown but seems constant
			packet[3]=0xEC;			//unknown but seems constant
			packet[4]=0x05;			//unknown but seems constant
			break;
		case 0x1A:
			packet[1]=0xFF;
			memset(&packet[2],0x00,5);
			break;
	}
	if(p_c>=0x01 && p_c<=0x04)
	{//DATA_CODE
		uint8_t p_c_5=(p_c-1)*5;
		for(uint8_t i=0;i<5;i++)
			if(i+p_c_5<16)
				packet[i+2]=MLINK_Data_Code[i+p_c_5];
	}
	else
		if(p_c>=0x07 && p_c<=0x15)
		{//Hopping frequencies
			uint8_t p_c_5=5*(p_c-6)-1;
			for(uint8_t i=0;i<5;i++)
				if(i+p_c_5<MLINK_NUM_FREQ)
					packet[i+2]=hopping_frequency[i+p_c_5];
		}
		else
			if(p_c>0x19)
			{
				packet[1]=0xFF;
				memset(&packet[2], 0x00, MLINK_PACKET_SIZE-3);
			}

	//Calculate CRC
	crc8=0xFF;	// Init = 0xFF
	for(uint8_t i=0;i<MLINK_PACKET_SIZE-1;i++)
		crc8_update(bit_reverse(packet[i]));
	packet[7] = bit_reverse(crc8);			// CRC reflected out

	//Debug
	#if 0
		debug("P(%02d):",p_c);
		for(uint8_t i=0;i<8;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif

	//Send packet
	CYRF_WriteDataPacketLen(packet, MLINK_PACKET_SIZE);
}

static void __attribute__((unused)) MLINK_send_data_packet()
{
	static uint8_t tog=0;
	uint8_t start;
	
#ifdef FAILSAFE_ENABLE
	static uint8_t fs=0;
	if(IS_FAILSAFE_VALUES_on && phase==MLINK_SEND1)
	{
		fs=10;	// Original radio is sending 70 packets
		FAILSAFE_VALUES_off;
	}
	if(fs)
	{// Failsafe packets
		switch(phase)
		{
			case MLINK_SEND2:
				packet[0]=0x06;
				start=17;
				break;
			case MLINK_SEND3:
				packet[0]=0x84;
				start=5;
				fs--;
				break;
			default: //MLINK_SEND1:
				packet[0]=0x05;
				start=11;
				break;
		}
		//Pack 6 channels per packet
		for(uint8_t i=0;i<6;i++)
		{
			uint8_t val=start<16 ? convert_channel_16b_nolimit(start,426 >> 4,3448 >> 4,true) : 0x00;
			start--;	// switch to next channel
			packet[i+1]=val;
		}
	}
	else
#endif
	{// Normal packets
		if(hopping_frequency_no==0)
			tog=1;
		//Channels to be sent
		if(phase==MLINK_SEND1 || ((hopping_frequency_no%5==0) && (phase==MLINK_SEND2)))
		{
			if((hopping_frequency_no&1)==0)
				packet[0] = 0x09;	//10,8,6
			else
				packet[0] = 0x01;	//11,9,7
		}
		else
			if(phase==MLINK_SEND2)
			{
				if(tog)
					packet[0] = 0x02;	//x,15,13
				else
					packet[0] = 0x0A;	//x,14,12
				tog^=1;
			}
			else
			{//phase==MLINK_SEND3
				if((hopping_frequency_no&1)==0)
					packet[0] = 0x88;	//4,2,0
				else
					packet[0] = 0x80;	//5,3,1
			}

		//Start channel
		start=4+6*(packet[0]&3);
		if((packet[0]&0x08)==0)
			start++;
		
		//Channels 426..1937..3448
		for(uint8_t i=0;i<3;i++)
		{
			uint16_t val=start<16 ? convert_channel_16b_nolimit(start,426,3448,false) : 0x0000;
			start-=2;	// switch to next channel
			packet[i*2+1]=val>>8;
			packet[i*2+2]=val;
		}
	}

	//Calculate CRC
	crc8=bit_reverse(hopping_frequency_no + MLINK_CRC_Init);	// Init = relected freq index + offset
	for(uint8_t i=0;i<MLINK_PACKET_SIZE-1;i++)
		crc8_update(bit_reverse(packet[i]));
	packet[7] = bit_reverse(crc8);			// CRC reflected out

	//Send
	CYRF_WriteDataPacketLen(packet, MLINK_PACKET_SIZE);

	//Debug
	#if 0
		debug("P(%02d):",hopping_frequency_no);
		for(uint8_t i=0;i<8;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
}

#ifdef MLINK_HUB_TELEMETRY
	static void __attribute__((unused)) MLINK_Send_Telemetry()
	{ // not sure how MLINK telemetry works, the 2 RXs I have are sending something completly different...
		telemetry_counter += 2;				// TX LQI counter
		telemetry_link = 1;

		if(packet_in[0]==0x13)
		{ // RX-9-DR : 13 1A C8 00 01 64 00
			uint8_t id;
			for(uint8_t i=1; i<5; i+=3)
			{//2 sensors per packet
				id=0x00;
				switch(packet_in[i]&0x0F)
				{
					case 1: //voltage
						if((packet_in[i]&0xF0) == 0x00)
							v_lipo1 = packet_in[i+1];		// Rx_Batt*20
						else
							v_lipo2 = packet_in[i+1];
						break;
					case 2: //current
						id = 0x28;
						break;
					case 3: //vario
						id = 0x30;
						break;
					case 5: //rpm
						id = 0x03;
						break;
					case 6: //temp
						id = 0x02;
						break;
					case 10: //lqi
						RX_RSSI=RX_LQI=packet_in[i+1]>>1;
						break;
				}
				#if defined HUB_TELEMETRY
					if(id)
					{
						uint16_t val=((packet_in[i+2]&0x80)<<8)|((packet_in[i+2]&0x7F)<<7)|(packet_in[i+1]>>1);	//remove the alarm LSB bit, move the sign bit to MSB
						frsky_send_user_frame(id, val, val>>8);
					}
				#endif
			}
		}
		else
			if(packet_in[0]==0x03)
			{ // RX-5 :    03 15 23 00 00 01 02
				//Incoming packet values
				RX_RSSI = packet_in[2]<<1;	// Looks to be the RX RSSI value
				RX_LQI  = packet_in[5];		// Looks to be connection lost
			}
			else
				RX_RSSI = TX_LQI;

		// Read TX RSSI
		TX_RSSI = CYRF_ReadRegister(CYRF_13_RSSI)&0x1F;

		if(telemetry_lost)
		{
			telemetry_lost = 0;
			packet_count = 50;
			telemetry_counter = 100;
		}
	}
#endif

#ifdef MLINK_FW_TELEMETRY
	static void __attribute__((unused)) MLINK_Send_Telemetry()
	{
		telemetry_counter += 2;				// TX LQI counter
		telemetry_link = 4;

		// Read TX RSSI
		TX_RSSI = CYRF_ReadRegister(CYRF_13_RSSI)&0x1F;

		if(telemetry_lost)
		{
			telemetry_lost = 0;
			packet_count = 50;
			telemetry_counter = 100;
		}
	}
#endif

uint16_t MLINK_callback()
{
	uint8_t status;
	uint16_t start;

	switch(phase)
	{
		case MLINK_BIND_RX:
			//debugln("RX");
			status=CYRF_ReadRegister(CYRF_05_RX_CTRL);
			if( (status&0x80) == 0 )
			{//Packet received
				len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				debugln("L=%02X",len)
				if( len==8 )
				{
					CYRF_ReadDataPacketLen(packet, len*2);
					debug("RX=");
					for(uint8_t i=0;i<8;i++)
						debug(" %02X",packet[i*2]);
					debugln("");
					//Check CRC
					crc8=0xFF;	// Init = 0xFF
					for(uint8_t i=0;i<MLINK_PACKET_SIZE-1;i++)
						crc8_update(bit_reverse(packet[i<<1]));
					if(packet[14] == bit_reverse(crc8))
					{// CRC is ok
						debugln("CRC ok");
						if(packet[0]==0x7F)
							packet_count=3;					// Start sending bind payload
						else if(packet_count > 0x19*2)
						{
							if(packet[0] == 0x8F)
								packet_count++;
							else if(packet[0] == 0x9F)
								packet_count=0x80;			// End bind
							else
								packet_count=0;				// Restart bind...
						}
					}
				}
			}
			else
				packet_count=0;
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Enable RX abort
			CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);		// Force end state
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Disable RX abort
			phase=MLINK_BIND_TX;							// Retry sending bind packet
			CYRF_SetTxRxMode(TX_EN);						// Transmit mode
			if(packet_count)
				return 18136;
		case MLINK_BIND_TX:
			if(--bind_counter==0 || packet_count>=0x1B*2)
			{ // Switch to normal mode
				BIND_DONE;
				phase=MLINK_PREP_DATA;
				return 22720;
			}
			MLINK_send_bind_packet();
			if(packet_count == 0 || packet_count > 0x19*2)
			{
				phase++;		// MLINK_BIND_PREP_RX
				return 4700;	// Original is 4900
			}
			packet_count++;
			if(packet_count&1)
				return 6000;
			return 22720;
		case MLINK_BIND_PREP_RX:
			start=micros();
			while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 200)	// Wait max 200s for TX to finish
				if((CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80) == 0x00)
					break;										// Packet transmission complete
			CYRF_SetTxRxMode(RX_EN);							// Receive mode
			CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x82);			// Prepare to receive
			phase++;	//MLINK_BIND_RX
			if(packet_count > 0x19*2)
				return 28712;									// Give more time to the RX to confirm that the bind is ok...
			return 28712-4700;


		case MLINK_PREP_DATA:
			CYRF_ConfigDataCode(MLINK_Data_Code);
			MLINK_CRC_Init += 0xED;
			hopping_frequency_no = 0x00;
			CYRF_ConfigRFChannel(hopping_frequency[hopping_frequency_no]);
			CYRF_SetPower(0x38);
			#if defined(MLINK_HUB_TELEMETRY) || defined(MLINK_FW_TELEMETRY)
				packet_count = 0;
				telemetry_lost = 1;
			#endif
			phase++;


		case MLINK_SEND1:
			MLINK_send_data_packet();
			phase++;
			return 4880+1111;
		case MLINK_SEND2:
			MLINK_send_data_packet();
			phase++;
			if(hopping_frequency_no%5==0)
				return 4617+1017;
			return 4617+1422;
		case MLINK_SEND3:
			MLINK_send_data_packet();
			phase++;
			return 4611;
		case MLINK_CHECK3:
			//Switch to next channel
			hopping_frequency_no++;
			if(hopping_frequency_no>=MLINK_NUM_FREQ)
				hopping_frequency_no=0;
			CYRF_ConfigRFChannel(hopping_frequency[hopping_frequency_no]);
			
			//Receive telemetry
			if(hopping_frequency_no%5==0)
			{//Receive telemetry
				CYRF_SetTxRxMode(RX_EN);							// Receive mode
				CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x82);			// Prepare to receive
				phase++;	//MLINK_RX
				return 8038+2434+410-1000;
			}
			else
				CYRF_SetPower(0x38);
			phase=MLINK_SEND1;
			return 4470;
		case MLINK_RX:
			#if defined(MLINK_HUB_TELEMETRY) || defined(MLINK_FW_TELEMETRY)
				//TX LQI calculation
				packet_count++;
				if(packet_count>=50)
				{
					packet_count=0;
					TX_LQI=telemetry_counter;
					if(telemetry_counter==0)
						telemetry_lost = 1;
					telemetry_counter = 0;
				}
			#endif
			status=CYRF_ReadRegister(CYRF_05_RX_CTRL);
			debug("T(%02X):",status);
			if( (status&0x80) == 0 )
			{//Packet received
				len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				debug("(%X)",len)
				if( len && len <= MLINK_PACKET_SIZE )
				{
					CYRF_ReadDataPacketLen(packet_in, len*2);
					#if defined(MLINK_HUB_TELEMETRY) || defined(MLINK_FW_TELEMETRY)
						if(len==MLINK_PACKET_SIZE)
						{
							for(uint8_t i=0;i<8;i++)
							//Check CRC
							crc8=bit_reverse(MLINK_CRC_Init);
							for(uint8_t i=0;i<MLINK_PACKET_SIZE-1;i++)
							{
								packet_in[i]=packet_in[i<<1];
								crc8_update(bit_reverse(packet_in[i]));
								debug(" %02X",packet_in[i]);
							}
							if(packet_in[14] == bit_reverse(crc8))	// Packet CRC is ok
								MLINK_Send_Telemetry();
							else
								debug(" NOK");
						}
					#endif
				}
			}
			debugln("");
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Enable RX abort
			CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);		// Force end state
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Disable RX abort
			CYRF_SetTxRxMode(TX_EN);						// Transmit mode
			phase=MLINK_SEND2;
			return 1000;
	}
	return 1000;
}

static void __attribute__((unused)) MLINK_shuffle_freqs(uint32_t seed, uint8_t *hop)
{
	randomSeed(seed);
	
	for(uint8_t i=0; i < MLINK_NUM_FREQ/2; i++)
	{
		uint8_t r   = random(0xfefefefe) % (MLINK_NUM_FREQ/2);
		uint8_t tmp = hop[r];
		hop[r] = hop[i];
		hop[i] = tmp;
	}
}

void MLINK_init()
{ 
	MLINK_cyrf_config();

	//Init ID and RF freqs
	for(uint8_t i=0; i < MLINK_NUM_FREQ/2; i++)
	{
		hopping_frequency[i                 ] = (i<<1) + 3;
		hopping_frequency[i+MLINK_NUM_FREQ/2] = (i<<1) + 3;
	}
	// part1
	memcpy(MLINK_Data_Code  ,rx_tx_addr,4);
	MLINK_shuffle_freqs(MProtocol_id, hopping_frequency);

	// part2
	MProtocol_id ^= 0x6FBE3201;
	set_rx_tx_addr(MProtocol_id);
	memcpy(MLINK_Data_Code+4,rx_tx_addr,4);
	MLINK_shuffle_freqs(MProtocol_id, &hopping_frequency[MLINK_NUM_FREQ/2]);
	
	// part3
	MLINK_CRC_Init = rx_tx_addr[3];		//value sent during bind then used to init the CRC
	MLINK_Unk_6_2  = 0x3A;		//unknown value sent during bind but doesn't seem to matter
	
	#ifdef MLINK_FORCE_ID
		if(RX_num)
		{
			//Cockpit SX
			memcpy(MLINK_Data_Code,"\x4C\x97\x9D\xBF\xB8\x3D\xB5\xBE",8);
			memcpy(hopping_frequency,"\x0D\x41\x09\x43\x17\x2D\x05\x31\x13\x3B\x1B\x3D\x0B\x41\x11\x45\x09\x2B\x17\x4D\x19\x3F\x03\x3F\x0F\x37\x1F\x47\x1B\x49\x07\x35\x27\x2F\x15\x33\x23\x39\x1F\x33\x19\x45\x0D\x2D\x11\x35\x0B\x47\x25\x3D\x21\x37\x1D\x3B\x05\x2F\x21\x39\x23\x4B\x03\x31\x25\x29\x07\x4F\x1D\x4B\x15\x4D\x13\x4F\x0F\x49\x29\x2B\x27\x43",MLINK_NUM_FREQ);
			MLINK_Unk_6_2  = 0x3A;		//unknown value sent during bind but doesn't seem to matter
			MLINK_CRC_Init = 0x07;		//value sent during bind then used to init the CRC
		}
		else
		{
			//HFM3
			memcpy(MLINK_Data_Code,"\xC0\x90\x8F\xBB\x7C\x8E\x2B\x8E",8);
			memcpy(hopping_frequency,"\x05\x41\x27\x4B\x17\x33\x11\x39\x0F\x3F\x05\x2F\x13\x2D\x25\x31\x1F\x2D\x25\x35\x03\x41\x1B\x43\x09\x3D\x1F\x29\x1D\x35\x0D\x3B\x19\x49\x23\x3B\x17\x47\x1D\x2B\x13\x37\x0B\x31\x23\x33\x29\x3F\x07\x37\x07\x43\x11\x2B\x1B\x39\x0B\x4B\x03\x4F\x21\x47\x0F\x4D\x15\x45\x21\x4F\x09\x3D\x19\x2F\x15\x45\x0D\x49\x27\x4D",MLINK_NUM_FREQ);
			MLINK_Unk_6_2  = 0x02;		//unknown value but doesn't seem to matter
			MLINK_CRC_Init = 0x3E;		//value sent during bind then used to init the CRC
		}
		//Other TX
		//MLINK_Unk_6_2  = 0x7e;		//unknown value but doesn't seem to matter
		//MLINK_CRC_Init = 0xA2;		//value sent during bind then used to init the CRC
	#endif

	for(uint8_t i=0;i<8;i++)
		MLINK_Data_Code[i+8]=MLINK_Data_Code[7-i];

	debug("ID:")
	for(uint8_t i=0;i<16;i++)
		debug(" %02X", MLINK_Data_Code[i]);
	debugln("");

	debugln("CRC init: %02X", MLINK_CRC_Init)

	debug("RF:")
	for(uint8_t i=0;i<MLINK_NUM_FREQ;i++)
		debug(" %02X", hopping_frequency[i]);
	debugln("");
	
	if(IS_BIND_IN_PROGRESS)
	{
		packet_count = 0;
		bind_counter = MLINK_BIND_COUNT;
		CYRF_ConfigDataCode((uint8_t*)"\x6F\xBE\x32\x01\xDB\xF1\x2B\x01\xE3\x5C\xFA\x02\x97\x93\xF9\x02"); //Bind data code
		CYRF_ConfigRFChannel(MLINK_BIND_CHANNEL);
		phase = MLINK_BIND_TX;
	}
	else
		phase = MLINK_PREP_DATA;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MT99xx_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with MT99xx, Eachine H7, Yi Zhan i6S, LS114/124, QF009 Su35
// Last sync with Goebish mt99xx_nrf24l01.c dated 2016-01-29

#if defined(MT99XX_CCNRF_INO)

#include "iface_xn297.h"

#define MT99XX_BIND_COUNT			928
#define MT99XX_PACKET_PERIOD_FY805	2460
#define MT99XX_PACKET_PERIOD_MT		2625
#define MT99XX_PACKET_PERIOD_YZ		3125
#define MT99XX_PACKET_PERIOD_A180	3400	// timing changes between the packets 2 x 27220 then 1x 26080, it seems that it is only on the first RF channel which jitters by 1.14ms but hard to pinpoint with XN297dump
#define MT99XX_PACKET_PERIOD_DRAGON	1038	// there is a pause of 2x1038 between two packets, no idea why and how since it is not even stable on a same dump...
#define MT99XX_PACKET_PERIOD_DRAGON_TELEM	10265	// long pause to receive the telemetry packets, 3 are sent by the RX one after the other
#define MT99XX_PACKET_PERIOD_F949G	3450
#define MT99XX_PACKET_PERIOD_PA18	1338
#define MT99XX_INITIAL_WAIT			500
#define MT99XX_PACKET_SIZE			9

//#define FORCE_A180_ID
//#define FORCE_DRAGON_ID
//#define FORCE_F949G_ID
#define FORCE_PA18_ID1
//#define FORCE_PA18_ID2

enum {
    MT99XX_DATA,
    MT99XX_RX,
    MT99XX_CHECK,
};

enum{
    // flags going to packet[6] (MT99xx, H7)
    FLAG_MT_RATE1   = 0x01, // (H7 & A180 high rate)
    FLAG_MT_RATE2   = 0x02, // (MT9916 only)
    FLAG_MT_VIDEO   = 0x10,
    FLAG_MT_SNAPSHOT= 0x20,
    FLAG_MT_FLIP    = 0x80,
};

enum{
    // flags going to packet[6] (LS)
    FLAG_LS_INVERT  = 0x01,
    FLAG_LS_RATE    = 0x02,
    FLAG_LS_HEADLESS= 0x10,
    FLAG_LS_SNAPSHOT= 0x20,
    FLAG_LS_VIDEO   = 0x40,
    FLAG_LS_FLIP    = 0x80,
};

enum{
    // flags going to packet[7] (FY805)
    FLAG_FY805_HEADLESS= 0x10,
};

enum{
    // flags going to packet[6] (A180)
    FLAG_A180_3D6G	= 0x01,
    FLAG_A180_RATE	= 0x02,
};

enum{
    // flags going to packet[6] (DRAGON)
    FLAG_DRAGON_RATE	= 0x01,
    FLAG_DRAGON_RTH		= 0x80,
    FLAG_DRAGON_UNK		= 0x04,
};

enum{
    // flags going to packet[6] (F949G)
    FLAG_F949G_LIGHT	= 0x01,
	FLAG_F949G_RATES	= 0x02,
    FLAG_F949G_3D6G		= 0x20,
    FLAG_BF109_RATES	= 0x01,	// short press right
    FLAG_BF109_LIGHT	= 0x02,	// short press left
    FLAG_BF109_UNK1		= 0x08,	// long press right
    FLAG_BF109_UNK2		= 0x10,	// long press left
};
enum{
    // flags going to packet[6] (PA18)
	FLAG_PA18_RTH		= 0x08,
	FLAG_PA18_FLIP		= 0x80,
};

enum{
    // flags going to packet[6] (QF009 Su35)
    FLAG_SU35_6G     = 0x00,
    FLAG_SU35_3D     = 0x40, 
    FLAG_SU35_HIRATE = 0x01,
    FLAG_SU35_LED    = 0x02,
    FLAG_SU35_FLASH  = 0x04,
    FLAG_SU35_INVERT = 0x08,   
};

const uint8_t h7_mys_byte[] = {
	0x01, 0x11, 0x02, 0x12, 0x03, 0x13, 0x04, 0x14, 
	0x05, 0x15, 0x06, 0x16, 0x07, 0x17, 0x00, 0x10
};

const uint8_t ls_mys_byte[] = {
	0x05, 0x15, 0x25, 0x06, 0x16, 0x26,
	0x07, 0x17, 0x27, 0x00, 0x10, 0x20,
	0x01, 0x11, 0x21, 0x02, 0x12, 0x22,
	0x03, 0x13, 0x23, 0x04, 0x14, 0x24
};

const uint8_t yz_p4_seq[] = {0xa0, 0x20, 0x60};

#ifdef MT99XX_HUB_TELEMETRY
	const uint8_t DRAGON_seq[] = {0x20, 0x60, 0x20, 0x80};
#endif

static void __attribute__((unused)) MT99XX_send_packet()
{
	static uint8_t seq_num=0;

	//Set RF freq
	if(sub_protocol == LS)
		XN297_RFChannel(0x2D); 			// LS always transmits on the same channel
	else
		if(sub_protocol==FY805)
			XN297_RFChannel(0x4B);		// FY805 always transmits on the same channel
		else // MT99 & H7 & YZ & A180 & DRAGON & F949G & PA18
			XN297_Hopping(hopping_frequency_no);

	if(IS_BIND_IN_PROGRESS)
	{
		//Bind packet
		packet[0] = 0x20;
		switch(sub_protocol)
		{
			case YZ:
				packet[1] = 0x15;
				packet[2] = 0x05;
				packet[3] = 0x06;
				break;
			case LS:
				packet[1] = 0x14;
				packet[2] = 0x05;
				packet[3] = 0x11;
				break;
			case FY805:
				packet[1] = 0x15;
				packet[2] = 0x12;
				packet[3] = 0x17;
				break;
			default:	// MT99 & H7 & A180 & DRAGON & F949G & PA18
				packet[1] = 0x14;
				packet[2] = 0x03;
				packet[3] = 0x25;
				break;
		}
		packet[4] = rx_tx_addr[0];
		packet[5] = rx_tx_addr[1];
		packet[6] = rx_tx_addr[2];
		if(sub_protocol == PA18+8)
		{
			packet[7] = num_ch;											// checksum offset
			packet[8] = 0x55;											// fixed
		}
		else
		{ // all others
			packet[7] = crc8;											// checksum offset
			if(sub_protocol != F949G)
				packet[8] = 0xAA;										// fixed
			else
				packet[8] = 0x00;
		}
	}
	else
	{
		if(sub_protocol != YZ)
		{ // MT99XX & H7 & LS & FY805 & A180 & DRAGON & F949G & PA18
			packet[0] = convert_channel_16b_limit(THROTTLE,0xE1,0x00);	// throttle
			packet[1] = convert_channel_16b_limit(RUDDER  ,0x00,0xE1);	// rudder
			packet[2] = convert_channel_16b_limit(AILERON ,0xE1,0x00);	// aileron
			packet[3] = convert_channel_16b_limit(ELEVATOR,0x00,0xE1);	// elevator
			packet[4] = (convert_channel_8b(CH10) ^ 0xFF) >> 2; 		// aileron trim  (3F..20..00)
			packet[5] =  convert_channel_8b(CH11)         >> 2;			// elevator trim (00..20..3F)
			packet[6] = GET_FLAG( CH5_SW, FLAG_MT_FLIP );
			if(sub_protocol != PA18+8)
				packet[7] = h7_mys_byte[hopping_frequency_no];			// next rf channel index ?
			else
				packet[7] = (packet[7]&0xBF)|0x20;
			switch(sub_protocol)
			{
				case MT99:
					packet[6] |= 0x40 | FLAG_MT_RATE2					// max rate on MT99xx
					  | GET_FLAG( CH7_SW, FLAG_MT_SNAPSHOT )
					  | GET_FLAG( CH8_SW, FLAG_MT_VIDEO );
					break;
				case H7:
					packet[6] |= FLAG_MT_RATE1; 						// max rate on H7
					break;
				case LS:
					packet[6] |= FLAG_LS_RATE							// max rate
						| GET_FLAG( CH6_SW, FLAG_LS_INVERT )			// invert
						| GET_FLAG( CH7_SW, FLAG_LS_SNAPSHOT )			// snapshot
						| GET_FLAG( CH8_SW, FLAG_LS_VIDEO )				// video
						| GET_FLAG( CH9_SW, FLAG_LS_HEADLESS );			// Headless
					packet[7] = ls_mys_byte[seq_num++];
					if(seq_num >= sizeof(ls_mys_byte))
						seq_num=0;
					break;
				case FY805:
					packet[6]=0x20;
					//Rate 0x01?
					//Flip ?
					packet[7]=0x01
						|GET_FLAG( CH5_SW, FLAG_MT_FLIP )
						|GET_FLAG( CH9_SW, FLAG_FY805_HEADLESS );		//HEADLESS
					crc8=0;
					break;
				case A180:
					packet[6] = GET_FLAG( !CH6_SW,FLAG_A180_RATE)		// 0x02, A180=RATE,  F949S=LED
							   |GET_FLAG( CH5_SW, FLAG_A180_3D6G )		// 0x01, A180=3D_6G, F949S=RATE
							   |GET_FLAG( CH7_SW, 0x20 );				// 0x20, F949S=3D_6G
					packet[7] = 0x00;
					break;
				case DRAGON:
					if(CH5_SW)											// Advanced mode
						packet[5] |= 0x80;
					else
						if(Channel_data[CH5] > CHANNEL_MIN_COMMAND)		// Beginner mode
							packet[5] |= 0x40;
					packet[6] = FLAG_DRAGON_RATE
						| GET_FLAG( CH6_SW, FLAG_DRAGON_RTH );
					
					#ifdef MT99XX_HUB_TELEMETRY
						//Telemetry
						if(hopping_frequency_no == 0)
						{
							seq_num++;
							seq_num &= 0x03;
							packet_count++;
							if(packet_count > 11)
								packet_count = 0;
						}
						if(packet_count > 10)							// Telemetry packet request every 10 or 11 packets
						{
							packet[6] |= 0x04;							// Request telemetry flag
							phase = MT99XX_RX;
						}
						packet[7] = DRAGON_seq[seq_num];				// seq: 20 80 20 60 20 80 20 60... 80 changes to 80+batt from telem
						if(seq_num==3)
							packet[7] |= v_lipo1;
					#else
						packet[7] = 0x20;
					#endif
					break;
				case F949G:
					packet[6] = GET_FLAG( CH5_SW, FLAG_F949G_3D6G )
							  | GET_FLAG( CH6_SW, FLAG_F949G_LIGHT )	//FLAG_BF109_RATES
							  | GET_FLAG(!CH7_SW, FLAG_F949G_RATES )	//FLAG_BF109_LIGHT
							  | GET_FLAG( CH8_SW, FLAG_BF109_UNK1 )		//BF109 long press right, temporary flag
							  | GET_FLAG( CH9_SW, FLAG_BF109_UNK2 );	//BF109 long press left, temporary flag
					packet[7] = 0x00;
					break;
				case PA18+8:
					if(Channel_data[CH5] > CHANNEL_MAX_COMMAND)			// Expert mode
						packet[5] = 0xA0;
					else
						if(Channel_data[CH5] > CHANNEL_MIN_COMMAND)		// Intermediate mode
							packet[5] = 0x60;
					packet[6] = GET_FLAG( CH6_SW, FLAG_PA18_FLIP )		// Flip
							  | GET_FLAG( CH7_SW, FLAG_PA18_RTH );		// RTH
					if(hopping_frequency_no == 0)
						packet[7] ^= 0x40;
					break;
				case SU35+8:
					packet[6] = FLAG_SU35_6G
						| GET_FLAG( CH5_SW, FLAG_SU35_3D )
						| GET_FLAG( !CH6_SW, FLAG_SU35_LED )
						| GET_FLAG( CH7_SW, FLAG_SU35_FLASH )
						| GET_FLAG( CH8_SW, FLAG_SU35_INVERT )
						| GET_FLAG( CH9_SW, FLAG_SU35_HIRATE );
					break; 
			}
			uint8_t result=crc8;
			for(uint8_t i=0; i<8; i++)
				result += packet[i];
			if(sub_protocol == PA18+8)
				result += num_ch;
			packet[8] = result;
		}
		else
		{ // YZ
			packet[0] = convert_channel_16b_limit(THROTTLE,0x00,0x64);		// throttle
			packet[1] = convert_channel_16b_limit(RUDDER  ,0x64,0x00);		// rudder
			packet[2] = convert_channel_16b_limit(ELEVATOR,0x00,0x64);		// elevator
			packet[3] = convert_channel_16b_limit(AILERON ,0x64,0x00);		// aileron
			if(packet_count++ >= 23)
			{
				seq_num ++;
				if(seq_num > 2)
					seq_num = 0;
				packet_count=0;
			}
			packet[4] = yz_p4_seq[seq_num];
			packet[5] = 0x02 // expert ? (0=unarmed, 1=normal)
						| GET_FLAG(CH8_SW, 0x10)							//VIDEO
						| GET_FLAG(CH5_SW, 0x80)							//FLIP
						| GET_FLAG(CH9_SW, 0x04)							//HEADLESS
						| GET_FLAG(CH7_SW, 0x20);							//SNAPSHOT
			packet[6] =   GET_FLAG(CH6_SW, 0x80);							//LED
			packet[7] = packet[0];            
			for(uint8_t idx = 1; idx < MT99XX_PACKET_SIZE-2; idx++)
				packet[7] += packet[idx];
			packet[8] = 0xff;
		}
	}

	//Hopp
	hopping_frequency_no++;
	if(sub_protocol == YZ || sub_protocol == A180 || sub_protocol == DRAGON || sub_protocol == F949G || sub_protocol == PA18+8)
		hopping_frequency_no++; // skip every other channel
	if(hopping_frequency_no > 15)
		hopping_frequency_no = 0;

	// Send
	XN297_SetPower();
	XN297_SetFreqOffset();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, MT99XX_PACKET_SIZE);
	
	#if 1
		for(uint8_t i=0; i<MT99XX_PACKET_SIZE; i++)
			debug(" %02X",packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) MT99XX_RF_init()
{
    if(sub_protocol == YZ)
		XN297_Configure(XN297_CRCEN, XN297_UNSCRAMBLED, XN297_250K);
	else if(sub_protocol == F949G)
		XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	else
		XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
    XN297_SetTXAddr((uint8_t *)"\xCC\xCC\xCC\xCC\xCC", 5);
	XN297_HoppingCalib(16);
	#ifdef MT99XX_HUB_TELEMETRY
		XN297_SetRXAddr(rx_tx_addr, MT99XX_PACKET_SIZE);
	#endif

}

static void __attribute__((unused)) MT99XX_initialize_txid()
{
	num_ch = rx_tx_addr[1];			// PA18
	rx_tx_addr[1] = rx_tx_addr[3];	// RX_Num
	switch(sub_protocol)
	{
		case YZ:
			rx_tx_addr[0] = 0x53;	// test (SB id)
			rx_tx_addr[1] = 0x00;
			rx_tx_addr[2] = 0x00;
			break;
		case FY805:
			rx_tx_addr[0] = 0x81;	// test (SB id)
			rx_tx_addr[1] = 0x0F;
			rx_tx_addr[2] = 0x00;
			break;
		case LS:
			rx_tx_addr[0] = 0xCC;
			break;
	#ifdef FORCE_A180_ID
		case A180:
			rx_tx_addr[0] = 0x84;	// MikeHRC ID
			rx_tx_addr[1] = 0x62;
			rx_tx_addr[2] = 0x4A;
			//crc8 = 0x30
			//channel_offset  = 0x03;
			break;
	#endif
	#ifdef FORCE_DRAGON_ID
		case DRAGON:
			rx_tx_addr[0] = 0x6C;	// Laurie ID
			rx_tx_addr[1] = 0x00;
			rx_tx_addr[2] = 0x22;
			//crc8 = 0x8E
			//channel_offset  = 0x06
			break;
	#endif
	#ifdef FORCE_F949G_ID
		case F949G:
			rx_tx_addr[0] = 0x7E;	// LilTeo14 ID
			rx_tx_addr[1] = 0x2F;
			rx_tx_addr[2] = 0x29;
			//crc8 = 0xD6
			//channel_offset  = 0x03
			break;
	#endif
	#ifdef FORCE_PA18_ID1
		case PA18+8:
			rx_tx_addr[0] = 0xC9;	// zebble ID
			rx_tx_addr[1] = 0x02;
			rx_tx_addr[2] = 0x13;
			num_ch = 0x89;			// additional crc init. How is this calculated? or could it be random?
			//crc8 = 0xDE
			//channel_offset  = 0x03
			//1Mb C=5 S=Y A= C9 02 13 CC CC P(9)= E1 70 70 70 20 20 00 20 1A -> 0x91 + 0x89 => 0x1A
			//        S=Y A= C9 02 13 CC CC P(9)= E1 70 70 70 20 A0 00 20 9A -> 0x11 + 0x89 => 0x9A
			//bind    S=Y A= CC CC CC CC CC P(9)= 20 14 03 25 C9 02 13 89 55
			break;
	#endif
	#ifdef FORCE_PA18_ID2
		case PA18+8:
			rx_tx_addr[0] = 0x0E;
			rx_tx_addr[1] = 0x05;
			rx_tx_addr[2] = 0x13;
			num_ch = 0xD1;			// additional crc init. How is this calculated? or could it be random?
			//crc8 = 0x28
			//channel_offset  = 0x00
			//1Mb C=2 S=Y A= 0E 05 13 CC CC P(9)= E1 70 70 70 20 60 00 60 E2 -> 0x11 + 0xD1 => 0xE2
			//bind    S=Y A= CC CC CC CC CC P(9)= 20 14 03 25 0E 05 13 D1 55
			break;
	#endif
		default: //MT99 & H7 & A180 & DRAGON & F949G & PA18
			rx_tx_addr[2] = 0x00;
			if(sub_protocol == PA18+8)
				rx_tx_addr[2] = 0x13;
			break;
	}
	
	rx_tx_addr[3] = 0xCC;
	rx_tx_addr[4] = 0xCC;

	crc8 = rx_tx_addr[0] + rx_tx_addr[1] + rx_tx_addr[2];

	//memcpy(hopping_frequency,"\x02\x48\x0C\x3e\x16\x34\x20\x2A\x2A\x20\x34\x16\x3e\x0c\x48\x02",16);
	for(uint8_t i=0; i<8; i++)
	{
		hopping_frequency[(i<<1)  ]=0x02 + (10*i);
		hopping_frequency[(i<<1)+1]=0x48 - (10*i);
	}
	hopping_frequency_no=0;
}

uint16_t MT99XX_callback()
{
	switch(phase)
	{
		case MT99XX_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(packet_period);
			#endif
			if(bind_counter)
			{
				bind_counter--;
				if (bind_counter == 0)
				{
					// set tx address for data packets
					XN297_SetTXAddr(rx_tx_addr, 5);
					// set rf channels
					uint8_t channel_offset = ((crc8>>4) + (crc8 & 0x0f)) % 8;
					for(uint8_t i=0;i<16;i++)
						hopping_frequency[i] += channel_offset;
					XN297_HoppingCalib(16);
					BIND_DONE;
				}
			}
			MT99XX_send_packet();
			break;
		#ifdef MT99XX_HUB_TELEMETRY
		case MT99XX_RX:
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase++;
			return MT99XX_PACKET_PERIOD_DRAGON_TELEM - MT99XX_PACKET_PERIOD_DRAGON - 500;
		case MT99XX_CHECK:
			//Check telem
			if(XN297_IsRX())
			{
				//debug("RX");
				if(XN297_ReadPayload(packet_in, MT99XX_PACKET_SIZE))
				{
					// C=48 S=Y A= 6C 00 22 CC CC P(9)= 6C 00 22 27 00 00 00 00 60
					// C=48 S=Y A= 6C 00 22 CC CC P(9)= 6C 00 22 28 00 00 00 00 61
					// C=18 S=Y A= 6C 00 22 CC CC P(9)= 6C 00 22 24 00 00 00 00 5D
					// 6C 00 22 = TX address, 27/28/24=vbatt, check = sum(P[0..7]) + AB
					// D2 EE 00 25 00 00 00 00 90 -> check also + AB
					//for(uint8_t i=0; i<MT99XX_PACKET_SIZE; i++)
					//	debug(" %02X",packet_in[i]);
					uint8_t check=0xAB;
					for(uint8_t i=0; i<8; i++)
						check += packet_in[i];
					if(packet_in[8] == check && packet_in[0] == rx_tx_addr[0] && packet_in[1] == rx_tx_addr[1] && packet_in[2] == rx_tx_addr[2])
					{ // checksum and address are ok
					//	debug(" OK");
						v_lipo1 = packet_in[3] & 0x7F;	// Batt
						v_lipo2 = packet_in[3] & 0x80;	// Low batt flag
						RX_RSSI=100;
						telemetry_link = 1;
					}
				}
				//debugln("");
			}
			//Switch to TX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(TX_EN);
			phase=MT99XX_DATA;
			return 500;
		#endif
	}
	return packet_period;
}

void MT99XX_init(void)
{
	if(protocol == PROTO_MT99XX2)
		sub_protocol|=0x08;		// Increase the number of sub_protocols for MT99XX

    bind_counter = MT99XX_BIND_COUNT;
	if(IS_BIND_DONE)
	{		
		if(sub_protocol != A180 && sub_protocol != DRAGON && sub_protocol != F949G && sub_protocol != PA18+8 && sub_protocol != SU35+8)
			BIND_IN_PROGRESS;	// autobind protocol
		else
		    bind_counter = 1;
	}

	MT99XX_initialize_txid();
	MT99XX_RF_init();

	switch(sub_protocol)
	{
		case YZ:
			packet_period = MT99XX_PACKET_PERIOD_YZ;
			break;
		case FY805:
			packet_period = MT99XX_PACKET_PERIOD_FY805;
			break;
		case F949G:
		case A180:
			packet_period = MT99XX_PACKET_PERIOD_A180;
			break;
		case PA18+8:
			packet_period = MT99XX_PACKET_PERIOD_PA18;
			break;
		default:
			packet_period = MT99XX_PACKET_PERIOD_MT;
			break;
	}

	packet_count=0;
	phase=MT99XX_DATA;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/MouldKg_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(MOULDKG_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_MOULDKG_ORIGINAL_ID

#define MOULDKG_PACKET_PERIOD		5000
#define MOULDKG_BIND_PACKET_PERIOD	12000
#define MOULDKG_TX_BIND_CHANNEL		11
#define MOULDKG_RX_BIND_CHANNEL		76
#define MOULDKG_PAYLOAD_SIZE_DIGIT	5
#define MOULDKG_PAYLOAD_SIZE_ANALOG	10
#define MOULDKG_BIND_PAYLOAD_SIZE	7
#define MOULDKG_BIND_COUNT			300
#define MOULDKG_RF_NUM_CHANNELS		4

enum {
	MOULDKG_BINDTX=0,
	MOULDKG_BINDRX,
	MOULDKG_PREP_DATA,
	MOULDKG_PREP_DATA1,
	MOULDKG_DATA,
};

uint8_t MOULDKG_RX_id[4*3];

static void __attribute__((unused)) MOULDKG_send_packet()
{
	uint8_t len = MOULDKG_BIND_PAYLOAD_SIZE;
	memcpy(&packet[1],rx_tx_addr,3);
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0xC0;
		memset(&packet[4], 0x00, 3);
	}
	else
	{
		uint8_t n = num_ch<<2;
		if(sub_protocol == MOULDKG_ANALOG4 || sub_protocol == MOULDKG_ANALOG6 )
		{
			packet[0] = 0x36;
			const uint8_t ch[]={ 1,0,2,3,5,4 };
			if(sub_protocol == MOULDKG_ANALOG6)
				n += num_ch<<1;
			for(uint8_t i=0;i<6;i++)
			{
				if( (i > 3 && sub_protocol == MOULDKG_ANALOG4) || i + n > 15)
					packet[i+4] = 0x80;							//Centered channel
				else
					packet[i+4] = convert_channel_8b(ch[i]+n);
			}
			len = MOULDKG_PAYLOAD_SIZE_ANALOG;
		}
		else
		{//DIGIT
			len = MOULDKG_PAYLOAD_SIZE_DIGIT;
			uint8_t val=0;
			if(packet_count&1)
			{
				packet[0] = 0x31;
				//Button B
				if(Channel_data[CH2+n]>CHANNEL_MAX_COMMAND) val |= 0x40;
				else if(Channel_data[CH2+n]<CHANNEL_MIN_COMMAND) val |= 0x80;
				//Button C
				if(Channel_data[CH3+n]>CHANNEL_MAX_COMMAND) val |= 0x10;
				else if(Channel_data[CH3+n]<CHANNEL_MIN_COMMAND) val |= 0x20;
			}
			else
			{
				packet[0] = 0x30;
				val = 0x60;
				//	| GET_FLAG(CH5_SW, 0x80)	// Button E
				//	| GET_FLAG(CH6_SW, 0x10);	// Button F
			}
			//Button A
			if(Channel_data[CH1+n]>CHANNEL_MAX_COMMAND) val |= 0x01;
			else if(Channel_data[CH1+n]<CHANNEL_MIN_COMMAND) val |= 0x02;
			//Button D
			if(Channel_data[CH4+n]>CHANNEL_MAX_COMMAND) val |= 0x04;
			else if(Channel_data[CH4+n]<CHANNEL_MIN_COMMAND) val |= 0x08;
			packet[4]= val;
		}
	}

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, len);
	#if 0
		for(uint8_t i=0; i < len; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) MOULDKG_initialize_txid()
{
	//rx_tx_addr[0] = rx_tx_addr[3];	// Use RX_num;

	#ifdef FORCE_MOULDKG_ORIGINAL_ID
		rx_tx_addr[0]=0x57;
		rx_tx_addr[1]=0x1B;
		rx_tx_addr[2]=0xF8;
	#endif
}

static void __attribute__((unused)) MOULDKG_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"KDH", 3);
	XN297_SetRXAddr((uint8_t*)"KDH", MOULDKG_BIND_PAYLOAD_SIZE);
}

uint16_t MOULDKG_callback()
{
	uint8_t rf,n;
	uint16_t addr;
	switch(phase)
	{
		case MOULDKG_BINDTX:
			if(XN297_IsRX())
			{
				//Example:	TX: C=11 S=Y A= 4B 44 48 P(7)= C0 37 02 4F 00 00 00
				//			RX: C=76 S=Y A= 4B 44 48 P(7)= 5A 37 02 4F 03 0D 8E
				// 03 0D 8E => RF channels 0F,1C,39,3C
				XN297_ReadPayload(packet_in, MOULDKG_BIND_PAYLOAD_SIZE);
				for(uint8_t i=0; i < MOULDKG_BIND_PAYLOAD_SIZE; i++)
					debug("%02X ", packet_in[i]);
				debugln();
				//Not sure if I should test packet_in[0]
				if(memcmp(&packet_in[1],&packet[1],3)==0)
				{//TX ID match
					if(option == 0)
					{
						memcpy(MOULDKG_RX_id,&packet_in[4],3);
						phase = MOULDKG_PREP_DATA1;
					}
					else
					{// Store RX ID
						addr=MOULDKG_EEPROM_OFFSET+RX_num*3;
						for(uint8_t i=0;i<3;i++)
							eeprom_write_byte((EE_ADDR)(addr+i),packet_in[4+i]);
						phase = MOULDKG_PREP_DATA;
					}
					break;
				}
			}
			XN297_RFChannel(MOULDKG_TX_BIND_CHANNEL);	// Set TX bind channel
			XN297_SetTxRxMode(TXRX_OFF);
			MOULDKG_send_packet();
			phase++;
			return 600;
		case MOULDKG_BINDRX:
			//Wait for the packet transmission to finish
			while(XN297_IsPacketSent()==false);
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_RFChannel(MOULDKG_RX_BIND_CHANNEL);	// Set RX bind channel
			XN297_SetTxRxMode(RX_EN);
			phase = MOULDKG_BINDTX;
			return MOULDKG_BIND_PACKET_PERIOD-600;
		case MOULDKG_PREP_DATA:
			addr=MOULDKG_EEPROM_OFFSET+RX_num*3;
			debug("RXID: ");
			for(uint8_t i=0;i<3*4;i++)
			{ // load 4 consecutive RX IDs
				MOULDKG_RX_id[i]=eeprom_read_byte((EE_ADDR)(addr+i));
				debug(" %02X",MOULDKG_RX_id[i]);
			}
			debugln("");
		case MOULDKG_PREP_DATA1:
			//Switch to normal mode
			BIND_DONE;
			XN297_SetTxRxMode(TXRX_OFF);
			phase = MOULDKG_DATA;
			break;
		case MOULDKG_DATA:
			#ifdef MULTI_SYNC
				if(num_ch==0)
					telemetry_set_input_sync(MOULDKG_PACKET_PERIOD);
			#endif
			if(option == 0) option++;
			if(num_ch<option)
			{
				//Set RX ID address
				n = num_ch*3;
				XN297_SetTXAddr(&MOULDKG_RX_id[n], 3);
				//Set frequency based on current RX ID and packet number
				rf = 0x0C;
				if(packet_count & 0x04)
				{
					n++;
					rf += 0x20;
				}
				if(packet_count & 0x02)
					rf += 0x10 + (MOULDKG_RX_id[n] >> 4);
				else
					rf += MOULDKG_RX_id[n] & 0x0F;
				XN297_RFChannel(rf);
				#if 1
					debugln("num_ch=%d,packet_count=%d,rf=%02X,ID=%02X %02X %02X",num_ch,packet_count,rf,MOULDKG_RX_id[num_ch*3],MOULDKG_RX_id[num_ch*3+1],MOULDKG_RX_id[num_ch*3+2]);
				#endif
				MOULDKG_send_packet();
				if(num_ch==0)
					packet_count++;
			}
			num_ch++;
			num_ch &= 0x03;
			break;
	}
	return MOULDKG_PACKET_PERIOD/4;
}

void MOULDKG_init()
{
	if(option == 0)
		BIND_IN_PROGRESS;
	MOULDKG_initialize_txid();
	MOULDKG_RF_init();
	bind_counter = MOULDKG_BIND_COUNT;
	if(IS_BIND_IN_PROGRESS)
		phase = MOULDKG_BINDTX;
	else
		phase = MOULDKG_PREP_DATA;
	packet_count = 0;
	num_ch = 0;
}

#endif

// Analog
// Bind TX: C=11 S=Y A= 4B 44 48 P(7)= C0 46 01 00 00 00 00
// Bind RX: 5A 46 01 00 63 82 4E
// Norm: C=15 S=Y A= 63 82 4E P(10)= 36 46 01 00 80 80 80 80 00 00
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Config.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(MULTI_CONFIG_INO)

#ifdef CYRF6936_INSTALLED
#include "iface_cyrf6936.h"
#endif

void CONFIG_write_GID(uint32_t id)
{
	for(uint8_t i=0;i<4;i++)
		eeprom_write_byte((EE_ADDR)EEPROM_ID_OFFSET+i,id >> (i*8));
	//eeprom_write_byte((EE_ADDR)(EEPROM_ID_OFFSET+10),0xf0);
}

void CONFIG_write_CID(uint8_t *data)
{
	for(uint8_t i=0;i<6;i++)
		eeprom_write_byte((EE_ADDR)EEPROM_CID_OFFSET+i, data[i]);
	//eeprom_write_byte((EE_ADDR)EEPROM_CID_INIT_OFFSET, 0xf0);
}
uint16_t CONFIG_callback()
{
	static uint8_t line=0, page=0;
	uint32_t id=0;
	// [0] = page<<4|line number
	// [1..6] = max 6 bytes
	if(CONFIG_SerialRX)
	{
		debug("config");
		for(uint8_t i=0; i<7; i++)
			debug("%02X ",CONFIG_SerialRX_val[i]);
		debugln("");
		CONFIG_SerialRX = false;
		switch(CONFIG_SerialRX_val[0]&0x0F)
		{
			//case 0:
				// Page change
			//	break;
			case 1:
				for(uint8_t i=0; i<4; i++)
				{
					id <<= 8;
					id |= CONFIG_SerialRX_val[i+1];
				}
				debugln("Update ID to %lx", id);
				CONFIG_write_GID(id);
				break;
			case 2:
				if(CONFIG_SerialRX_val[1]==0xAA)
				{
					#define STM32_UUID ((uint32_t *)0x1FFFF7E8)
					id = STM32_UUID[0] ^ STM32_UUID[1] ^ STM32_UUID[2];
					debugln("Reset GID to %lx", id);
					CONFIG_write_GID(id);
				}
				break;
#ifdef CYRF6936_INSTALLED
			case 4:
				debug("Update CID to ");
				for(uint8_t i=0; i<6; i++)
					debug("%02X ",CONFIG_SerialRX_val[i+1]);
				debugln("");
				CONFIG_write_CID(&CONFIG_SerialRX_val[1]);
			case 5:
				if(CONFIG_SerialRX_val[1]==0xAA)
				{
					uint8_t data[6];
					CYRF_WriteRegister(CYRF_25_MFG_ID, 0xFF);	/* Fuses power on */
					CYRF_ReadRegisterMulti(CYRF_25_MFG_ID, data, 6);
					CYRF_WriteRegister(CYRF_25_MFG_ID, 0x00);	/* Fuses power off */
					debug("Reset CID to ");
					for(uint8_t i=0; i<6; i++)
						debug("%02X ",data[i]);
					debugln("");
					CONFIG_write_CID(data);
				}
				break;
#endif
			case 7:
				if(CONFIG_SerialRX_val[1]==0xAA)
				{
					debugln("Format EE");
					#if defined(STM32_BOARD)
						EEPROM.format();
					#else
						for (uint16_t i = 0; i < 512; i++)
    						eeprom_write_byte((EE_ADDR)i, 0xFF);
					#endif
				}
				break;
		}
	}

	if(	telemetry_link )
		return 10000;
	// [0] = page<<4|line number
	// line=0: VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION, VERSION_PATCH_LEVEL, Channel order:RUDDER<<6|THROTTLE<<4|ELEVATOR<<2|AILERON
	// [1..21] = max 20 characters, any displayable chars followed by:
	//    0x00    : end of line
	//    0x80+len:  selectable text to follow
	//    0x90+len:  selectable text to follow with "Are you sure?"
	//    0xA0+len:  not editable dec value
	//    0xB0+len:  editable dec value
	//    0xC0+len:  not editable hex value
	//    0xD0+len:  editable hex value
	memset(&packet_in[1],0,20);
	do
	{
		packet_in[0] = (page<<4) | line;
		switch(line)
		{
			case 0:
				packet_in[1]=VERSION_MAJOR;
				packet_in[2]=VERSION_MINOR;
				packet_in[3]=VERSION_REVISION;
				packet_in[4]=VERSION_PATCH_LEVEL;
				packet_in[5]=RUDDER<<6|THROTTLE<<4|ELEVATOR<<2|AILERON;
				break;
			case 1:
				//Global ID
				#ifndef FORCE_GLOBAL_ID
					memcpy(&packet_in[1],"Global ID",9);
					packet_in[10] = 0xD0 + 4;
				#else
					memcpy(&packet_in[1],"Fixed ID ",9);
					packet_in[10] = 0xC0 + 4;
				#endif
				MProtocol_id_master = random_id(EEPROM_ID_OFFSET,false);
				set_rx_tx_addr(MProtocol_id_master);
				for(uint8_t i=0; i<4; i++)
					packet_in[11+i]=rx_tx_addr[i];
				break;
			#if defined(STM32_BOARD) && not defined(FORCE_GLOBAL_ID)
			case 2:
				//Reset global ID
				packet_in[1] = 0x90+9;
				memcpy(&packet_in[2],"Reset GID",9);
				break;
			#endif
#ifdef CYRF6936_INSTALLED
			case 4:
				//Cyrf ID
				#ifndef FORCE_CYRF_ID
					memcpy(&packet_in[1],"Cyrf ID",7);
					packet_in[8] = 0xD0 + 6;
					CYRF_GetMfgData(&packet_in[9]);
				#else
					memcpy(&packet_in[1],"Fixed CID",9);
					packet_in[10] = 0xC0 + 6;
					CYRF_GetMfgData(&packet_in[11]);
				#endif
				break;
			#ifndef FORCE_CYRF_ID
			case 5:
				//Reset Cyrf ID
				packet_in[1] = 0x90+9;
				memcpy(&packet_in[2],"Reset CID",9);
				break;
			#endif
#endif
			case 7:
				packet_in[1] = 0x90+13;
				memcpy(&packet_in[2],"Format EEPROM",13);
				break;
		}
		line++;
		line %= 8;
	}
	while(packet_in[1]==0);	// next line if empty
	telemetry_link = 1;
	return 10000;
}

void CONFIG_init()
{
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Multi_Protos.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

const char STR_FLYSKY[]		="FlySky";
const char STR_HUBSAN[]		="Hubsan";
const char STR_FRSKYD[]		="FrSky D";
const char STR_HISKY[]		="Hisky";
const char STR_V2X2[]		="V2x2";
const char STR_DSM[]		="DSM";
const char STR_DSM_RX[]		="DSM_RX";
const char STR_DEVO[]		="Devo";
const char STR_YD717[]		="YD717";
const char STR_KN[]			="KN";
const char STR_SYMAX[]		="SymaX";
const char STR_SLT[]		="SLT";
const char STR_CX10[]		="CX10";
const char STR_CG023[]		="CG023";
const char STR_BAYANG[]		="Bayang";
const char STR_FRSKYL[]		="FrSky L";
const char STR_FRSKYX[]		="FrSky X";
const char STR_FRSKYX2[]	="FrSkyX2";
const char STR_ESKY[]		="ESky";
const char STR_MT99XX[]		="MT99XX";
const char STR_MT99XX2[]	="MT99XX2";
const char STR_MJXQ[]		="MJXq";
const char STR_SHENQI[]		="Shenqi";
const char STR_SHENQI2[]	="Shenqi2";
const char STR_FY326[]		="FY326";
const char STR_FUTABA[]		="Futaba";
const char STR_J6PRO[]		="J6 Pro";
const char STR_JJRC345[]	="JJRC345";
const char STR_JOYSWAY[]	="JOYSWAY";
const char STR_FQ777[]		="FQ777";
const char STR_ASSAN[]		="Assan";
const char STR_FRSKYV[]		="FrSky V";
const char STR_HONTAI[]		="Hontai";
const char STR_AFHDS2A[]	="FlSky2A";
const char STR_Q2X2[]		="Q2x2";
const char STR_WK2x01[]		="Walkera";
const char STR_Q303[]		="Q303";
const char STR_Q90C[]		="Q90C";
const char STR_GW008[]		="GW008";
const char STR_DM002[]		="DM002";
const char STR_CABELL[]		="Cabell";
const char STR_ESKY150[]	="Esky150";
const char STR_ESKY150V2[]	="EskyV2";
const char STR_H36[]		="H36";
const char STR_H8_3D[]		="H8 3D";
const char STR_CORONA[]		="Corona";
const char STR_CFLIE[]		="CFlie";
const char STR_HITEC[]		="Hitec";
const char STR_WFLY[]		="WFLY";
const char STR_WFLY2[]		="WFLY2";
const char STR_BUGS[]		="Bugs";
const char STR_BUGSMINI[]	="BugMini";
const char STR_TRAXXAS[]	="Traxxas";
const char STR_NCC1701[]	="NCC1701";
const char STR_E01X[]		="E01X";
const char STR_V911S[]		="V911S";
const char STR_GD00X[]		="GD00x";
const char STR_V761[]		="V761";
const char STR_KF606[]		="KF606";
const char STR_REDPINE[]	="Redpine";
const char STR_POTENSIC[]	="Potensi";
const char STR_ZSX[]		="ZSX";
const char STR_HEIGHT[]		="Height";
const char STR_SCANNER[]	="Scanner";
const char STR_FRSKY_RX[]	="FrSkyRX";
const char STR_AFHDS2A_RX[]	="FS2A_RX";
const char STR_HOTT[]		="HoTT";
const char STR_FX[]			="FX";
const char STR_BAYANG_RX[]	="BayanRX";
const char STR_PELIKAN[]	="Pelikan";
const char STR_XK[]			="XK";
const char STR_XK2[]		="XK2";
const char STR_XN297DUMP[]	="XN297DP";
const char STR_FRSKYR9[]	="FrSkyR9";
const char STR_PROPEL[]		="Propel";
const char STR_SKYARTEC[]	="Skyartc";
const char STR_KYOSHO[]		="Kyosho";
const char STR_KYOSHO2[]	="Kyosho2";
const char STR_RLINK[]		="RadLink";
const char STR_REALACC[]	="Realacc";
const char STR_OMP[]		="OMP";
const char STR_MLINK[]		="M-Link";
const char STR_TEST[]		="Test";
const char STR_NANORF[]		="NanoRF";
const char STR_E016HV2[]    ="E016Hv2";
const char STR_E010R5[]     ="E010r5";
const char STR_LOLI[]       ="LOLI";
const char STR_E129[]       ="E129";
const char STR_E016H[]      ="E016H";
const char STR_IKEAANSLUTA[]="Ansluta";
const char STR_CONFIG[]     ="Config";
const char STR_LOSI[]       ="Losi";
const char STR_MOULDKG[]    ="MouldKg";
const char STR_XERALL[]     ="Xerall";
const char STR_SCORPIO[]    ="Scorpio";
const char STR_BLUEFLY[]    ="BlueFly";
const char STR_BUMBLEB[]    ="BumbleB";
const char STR_SGF22[]      ="SGF22";
const char STR_EAZYRC[]     ="EazyRC";
const char STR_KYOSHO3[]    ="Kyosho3";
const char STR_YUXIANG[]    ="YuXiang";
const char STR_UDIRC[]      ="UDIRC";
const char STR_JIABAILE[]   ="JIABAILE";
const char STR_KAMTOM[]     ="KAMTOM";
const char STR_WL91X[]      ="WL91x";
const char STR_WPL[]        ="WPL";
const char STR_ARES[]       ="Ares";

const char STR_SUBTYPE_FLYSKY[] =     "\x04""Std\0""V9x9""V6x6""V912""CX20";
const char STR_SUBTYPE_HUBSAN[] =     "\x04""H107""H301""H501";
const char STR_SUBTYPE_FRSKYD[] =     "\x06""D8\0   ""Cloned";
#ifndef MULTI_EU
	const char STR_SUBTYPE_FRSKYX[] =     "\x07""D16\0   ""D16 8ch""LBT(EU)""LBT 8ch""Cloned\0""Clo 8ch";
#else
	const char STR_SUBTYPE_FRSKYX[] =     "\x07""--->\0  ""--->\0  ""LBT(EU)""LBT 8ch""Cloned\0""Clo 8ch";
#endif
const char STR_SUBTYPE_HISKY[] =      "\x05""Std\0 ""HK310";
const char STR_SUBTYPE_V2X2[] =       "\x06""Std\0  ""JXD506""MR101\0";
#ifndef MULTI_EU
	const char STR_SUBTYPE_DSM[] =        "\x04""2 1F""2 2F""X 1F""X 2F""Auto""R 1F""2SFC";
#else
	const char STR_SUBTYPE_DSM[] =        "\x04""--->""--->""X 1F""X 2F""Auto""R 1F""----";
#endif
const char STR_SUBTYPE_DEVO[] =       "\x04""8ch\0""10ch""12ch""6ch\0""7ch\0";
const char STR_SUBTYPE_YD717[] =      "\x07""Std\0   ""SkyWlkr""Syma X4""XINXUN\0""NIHUI\0 ";
const char STR_SUBTYPE_KN[] =         "\x06""WLtoys""FeiLun";
const char STR_SUBTYPE_SYMAX[] =      "\x03""Std""X5C";
const char STR_SUBTYPE_SLT[] =        "\x07""V1_6ch\0""V2_8ch\0""Q100\0  ""Q200\0  ""MR100\0 ""V1_4ch\0""RF_SIM\0""SLT6_Tx";
const char STR_SUBTYPE_CX10[] =       "\x07""Green\0 ""Blue\0  ""DM007\0 ""-\0     ""JC3015a""JC3015b""MK33041";
const char STR_SUBTYPE_CG023[] =      "\x05""Std\0 ""YD829";
const char STR_SUBTYPE_BAYANG[] =     "\x07""Std\0   ""H8S3D\0 ""X16 AH\0""IRDrone""DHD D4\0""QX100\0 ";
const char STR_SUBTYPE_MT99[] =       "\x06""MT99\0 ""H7\0   ""YZ\0   ""LS\0   ""FY805\0""A180\0 ""Dragon""F949G\0";
const char STR_SUBTYPE_MT992[] =      "\x04""PA18""SU35";
const char STR_SUBTYPE_MJXQ[] =       "\x07""WLH08\0 ""X600\0  ""X800\0  ""H26D\0  ""E010\0  ""H26WH\0 ""Phoenix";
const char STR_SUBTYPE_FY326[] =      "\x05""Std\0 ""FY319";
const char STR_SUBTYPE_HONTAI[] =     "\x06""Std\0  ""JJRCX1""X5C1\0 ""FQ_951""XKK170";
const char STR_SUBTYPE_AFHDS2A[] =    "\x08""PWM,IBUS""PPM,IBUS""PWM,SBUS""PPM,SBUS""Gyro_Off""Gyro_On\0""G_On_Rev";
const char STR_SUBTYPE_Q2X2[] =       "\x04""Q222""Q242""Q282";
const char STR_SUBTYPE_WK2x01[] =     "\x06""WK2801""WK2401""W6_5_1""W6_6_1""W6_HeL""W6_HeI";
const char STR_SUBTYPE_Q303[] =       "\x06""Std\0  ""CX35\0 ""CX10D\0""CX10WD";
const char STR_SUBTYPE_CABELL[] =     "\x07""V3\0    ""V3 Telm""-\0     ""-\0     ""-\0     ""-\0     ""F-Safe\0""Unbind\0";
const char STR_SUBTYPE_H83D[] =       "\x07""Std\0   ""H20H\0  ""H20Mini""H30Mini";
const char STR_SUBTYPE_CORONA[] =     "\x05""V1\0  ""V2\0  ""FD V3";
const char STR_SUBTYPE_HITEC[] =      "\x07""Optima\0""Opt Hub""Minima\0";
const char STR_SUBTYPE_BUGS_MINI[] =  "\x06""Std\0  ""Bugs3H";
const char STR_SUBTYPE_TRAXXAS[] =    "\x03""TQ2""TQ1";
const char STR_SUBTYPE_E01X[] =       "\x05""E012\0""E015\0";
const char STR_SUBTYPE_GD00X[] =      "\x05""GD_V1""GD_V2";
const char STR_SUBTYPE_REDPINE[] =    "\x04""Fast""Slow";
const char STR_SUBTYPE_POTENSIC[] =   "\x03""A20";
const char STR_SUBTYPE_ZSX[] =        "\x07""280JJRC";
const char STR_SUBTYPE_HEIGHT[] =     "\x03""5ch""8ch";
const char STR_SUBTYPE_XN297DUMP[] =  "\x07""250Kbps""1Mbps\0 ""2Mbps\0 ""Auto\0  ""NRF\0   ""CC2500\0""XN297\0 ";
const char STR_SUBTYPE_ESKY150[] =    "\x03""4ch""7ch";
const char STR_SUBTYPE_ESKY150V2[] =  "\x05""150V2";
const char STR_SUBTYPE_V911S[] =      "\x05""V911S""E119\0";
const char STR_SUBTYPE_XK[] =         "\x04""X450""X420""Cars";
const char STR_SUBTYPE_XK2[] =        "\x03""X4\0""P10";
const char STR_SUBTYPE_FRSKYR9[] =    "\x07""915MHz\0""868MHz\0""915 8ch""868 8ch""FCC\0   ""--\0    ""FCC 8ch""-- 8ch\0";
const char STR_SUBTYPE_ESKY[] =       "\x03""Std""ET4";
const char STR_SUBTYPE_PROPEL[] =     "\x04""74-Z";
const char STR_SUBTYPE_FRSKYL[] =     "\x08""LR12\0   ""LR12 6ch";
const char STR_SUBTYPE_WFLY[] =       "\x05""WFR0x";
const char STR_SUBTYPE_WFLY2[] =      "\x05""RF20x";
const char STR_SUBTYPE_HOTT[] =       "\x07""Sync\0  ""No_Sync";
const char STR_SUBTYPE_PELIKAN[] =    "\x05""Pro\0 ""Lite\0""SCX24";
const char STR_SUBTYPE_V761[] =       "\x05""3ch\0 ""4ch\0 ""TOPRC";
const char STR_SUBTYPE_RLINK[] =      "\x07""Surface""Air\0   ""DumboRC""RC4G\0  ";
const char STR_SUBTYPE_KYOSHO[] =     "\x04""FHSS""Hype";
const char STR_SUBTYPE_KYOSHO2[] =    "\x05""KT-17";
const char STR_SUBTYPE_KYOSHO3[] =    "\x03""ASF";
const char STR_SUBTYPE_FUTABA[] =     "\x05""SFHSS";
const char STR_SUBTYPE_JJRC345[] =    "\x08""JJRC345\0""SkyTmblr";
const char STR_SUBTYPE_MOULDKG[] =    "\x05""A4444""D4444""A664\0";
const char STR_SUBTYPE_KF606[] =      "\x06""KF606\0""MIG320""ZCZ50\0";
const char STR_SUBTYPE_E129[] =       "\x04""E129""C186";
const char STR_SUBTYPE_FX[] =         "\x05""816\0 ""620\0 ""9630\0""Q560\0""QF012";
const char STR_SUBTYPE_SGF22[] =      "\x04""F22\0""F22S""J20\0""CX10";
const char STR_SUBTYPE_JIABAILE[] =   "\x04""Std\0""Gyro";
const char STR_SUBTYPE_ARES[] =      "\x05""6HPA\0";
#define NO_SUBTYPE		nullptr

#ifdef SEND_CPPM
	const char STR_SUB_FRSKY_RX[] =   "\x07""Multi\0 ""CloneTX""EraseTX""CPPM\0  ";
	const char STR_SUB_DSM_RX[] =   "\x07""Multi\0 ""CloneTX""EraseTX""CPPM\0  ";
	#define FRCPPM   4
	#define DSMCPPM   4
	const char STR_CPPM[] =           "\x05""Multi""CPPM\0";
	#define NBR_CPPM 2
#else
	const char STR_SUB_FRSKY_RX[] =   "\x07""Multi\0 ""CloneTX""EraseTX";
	const char STR_SUB_DSM_RX[] =   "\x07""Multi\0 ""CloneTX""EraseTX";
	#define FRCPPM   3
	#define DSMCPPM   3
	#define STR_CPPM NO_SUBTYPE
	#define NBR_CPPM 0
#endif

enum
{
	OPTION_NONE,
	OPTION_OPTION,
	OPTION_RFTUNE,
	OPTION_VIDFREQ,
	OPTION_FIXEDID,
	OPTION_TELEM,
	OPTION_SRVFREQ,
	OPTION_MAXTHR,
	OPTION_RFCHAN,
	OPTION_RFPOWER,
	OPTION_WBUS,
};

const mm_protocol_definition multi_protocols[] = {
// Protocol number, Protocol String, Sub_protocol strings, Number of sub_protocols, Option type, Failsafe, ChMap, RF switch, Init, Callback
	#if defined(MULTI_CONFIG_INO)
		{PROTO_CONFIG,     STR_CONFIG,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, 0,         CONFIG_init,     CONFIG_callback     },
	#endif
	#if defined(ARES_CC2500_INO)
		{PROTO_ARES,       STR_ARES,      STR_SUBTYPE_ARES,      1, OPTION_RFTUNE,  0, 0, SW_CC2500, ARES_init,       ARES_callback       },
	#endif
	#if defined(ASSAN_NRF24L01_INO)
		{PROTO_ASSAN,      STR_ASSAN,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    ASSAN_init,      ASSAN_callback      },
	#endif
	#if defined(BAYANG_NRF24L01_INO)
		{PROTO_BAYANG,     STR_BAYANG,    STR_SUBTYPE_BAYANG,    6, OPTION_TELEM,   0, 0, SW_NRF,    BAYANG_init,     BAYANG_callback     },
	#endif
	#if defined(BAYANG_RX_NRF24L01_INO)
		{PROTO_BAYANG_RX,  STR_BAYANG_RX, STR_CPPM,       NBR_CPPM, OPTION_NONE,    0, 0, SW_NRF,    BAYANG_RX_init,  BAYANG_RX_callback  },	
	#endif
	#if defined(BLUEFLY_CCNRF_INO)
		{PROTO_BLUEFLY,    STR_BLUEFLY,   NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_NRF,    BLUEFLY_init,    BLUEFLY_callback    },
	#endif
	#if defined(BUMBLEB_CCNRF_INO)
		{PROTO_BUMBLEB,    STR_BUMBLEB,   NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_NRF,    BUMBLEB_init,    BUMBLEB_callback    },
	#endif
	#if defined(BUGS_A7105_INO)
		{PROTO_BUGS,       STR_BUGS,      NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_A7105,  BUGS_init,       BUGS_callback       },
	#endif
	#if defined(BUGSMINI_NRF24L01_INO)
		{PROTO_BUGSMINI,   STR_BUGSMINI,  STR_SUBTYPE_BUGS_MINI, 2, OPTION_NONE,    0, 0, SW_NRF,    BUGSMINI_init,   BUGSMINI_callback   },
	#endif
	#if defined(CABELL_NRF24L01_INO)                           
		{PROTO_CABELL,     STR_CABELL,    STR_SUBTYPE_CABELL,    8, OPTION_OPTION,  0, 0, SW_NRF,    CABELL_init,     CABELL_callback     },
	#endif
	#if defined(CFLIE_NRF24L01_INO)
		{PROTO_CFLIE,      STR_CFLIE,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    CFLIE_init,      CFLIE_callback      }, // review protocol
	#endif
	#if defined(CG023_NRF24L01_INO)
		{PROTO_CG023,      STR_CG023,     STR_SUBTYPE_CG023,     2, OPTION_NONE,    0, 0, SW_NRF,    CG023_init,      CG023_callback      },
	#endif
	#if defined(CORONA_CC2500_INO)
		{PROTO_CORONA,     STR_CORONA,    STR_SUBTYPE_CORONA,    3, OPTION_RFTUNE,  0, 0, SW_CC2500, CORONA_init,     CORONA_callback     },
	#endif
	#if defined(CX10_NRF24L01_INO)
		{PROTO_CX10,       STR_CX10,      STR_SUBTYPE_CX10,      7, OPTION_NONE,    0, 0, SW_NRF,    CX10_init,       CX10_callback       },
	#endif
	#if defined(DEVO_CYRF6936_INO)
		{PROTO_DEVO,       STR_DEVO,      STR_SUBTYPE_DEVO,      5, OPTION_FIXEDID, 1, 1, SW_CYRF,   DEVO_init,       DEVO_callback       },
	#endif
	#if defined(DM002_NRF24L01_INO)
		{PROTO_DM002,      STR_DM002,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    DM002_init,      DM002_callback      },
	#endif
	#if defined(DSM_CYRF6936_INO)
		{PROTO_DSM,        STR_DSM,       STR_SUBTYPE_DSM,       7, OPTION_MAXTHR,  0, 1, SW_CYRF,   DSM_init,        DSM_callback        },
	#endif
	#if defined(DSM_RX_CYRF6936_INO)
		{PROTO_DSM_RX,     STR_DSM_RX,    STR_SUB_DSM_RX,  DSMCPPM, OPTION_NONE,    0, 1, SW_CYRF,   DSM_RX_init,     DSM_RX_callback     },
	#endif
	#if defined(E010R5_CYRF6936_INO)
		{PROTO_E010R5,     STR_E010R5,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_CYRF,   E010R5_init,     E010R5_callback     },
	#endif
	#if defined(E016H_NRF24L01_INO)
		{PROTO_E016H,      STR_E016H,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    E016H_init,      E016H_callback      },
	#endif
	#if defined(E016HV2_CC2500_INO)
		{PROTO_E016HV2,    STR_E016HV2,   NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_CC2500, E016HV2_init,    E016HV2_callback    },
	#endif
	#if defined(E01X_CYRF6936_INO)
		{PROTO_E01X,       STR_E01X,      STR_SUBTYPE_E01X,      2, OPTION_NONE,    0, 0, SW_CYRF,   E01X_init,       E01X_callback       },
	#endif
	#if defined(E129_CYRF6936_INO)
		{PROTO_E129,       STR_E129,      STR_SUBTYPE_E129,      2, OPTION_NONE,    0, 0, SW_CYRF,   E129_init,       E129_callback       },
	#endif
	#if defined(EAZYRC_NRF24L01_INO)
		{PROTO_EAZYRC,     STR_EAZYRC,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    EAZYRC_init,     EAZYRC_callback     },
	#endif
	#if defined(ESKY_NRF24L01_INO)
		{PROTO_ESKY,       STR_ESKY,      STR_SUBTYPE_ESKY,      2, OPTION_NONE,    0, 1, SW_NRF,    ESKY_init,       ESKY_callback       },
	#endif
	#if defined(ESKY150_NRF24L01_INO)
		{PROTO_ESKY150,    STR_ESKY150,   STR_SUBTYPE_ESKY150,   2, OPTION_NONE,    0, 0, SW_NRF,    ESKY150_init,    ESKY150_callback    },
	#endif
	#if defined(ESKY150V2_CC2500_INO)
		{PROTO_ESKY150V2,  STR_ESKY150V2, STR_SUBTYPE_ESKY150V2, 1, OPTION_RFTUNE,  0, 1, SW_CC2500, ESKY150V2_init,  ESKY150V2_callback  },
	#endif
	#if defined(FLYSKY_A7105_INO)
		{PROTO_FLYSKY,     STR_FLYSKY,    STR_SUBTYPE_FLYSKY,    5, OPTION_NONE,    0, 1, SW_A7105,  FLYSKY_init,     FLYSKY_callback     },
	#endif
	#if defined(AFHDS2A_A7105_INO)
		{PROTO_AFHDS2A,    STR_AFHDS2A,   STR_SUBTYPE_AFHDS2A,   7, OPTION_SRVFREQ, 1, 1, SW_A7105,  AFHDS2A_init,    AFHDS2A_callback    },
	#endif
	#if defined(AFHDS2A_RX_A7105_INO)
		{PROTO_AFHDS2A_RX, STR_AFHDS2A_RX,STR_CPPM,       NBR_CPPM, OPTION_NONE,    0, 0, SW_A7105,  AFHDS2A_RX_init, AFHDS2A_RX_callback },
	#endif
	#if defined(FQ777_NRF24L01_INO)
		{PROTO_FQ777,      STR_FQ777,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    FQ777_init,      FQ777_callback      },
	#endif
//OpenTX 2.3.x issue: DO NOT CHANGE ORDER below
	#if defined(FRSKY_RX_CC2500_INO)
		{PROTO_FRSKY_RX,   STR_FRSKY_RX,  STR_SUB_FRSKY_RX, FRCPPM, OPTION_RFTUNE,  0, 0, SW_CC2500, FRSKY_RX_init,   FRSKY_RX_callback   },
	#endif
	#if defined(FRSKYD_CC2500_INO)
		{PROTO_FRSKYD,     STR_FRSKYD,    STR_SUBTYPE_FRSKYD,    2, OPTION_RFTUNE,  0, 0, SW_CC2500, FRSKYD_init,     FRSKYD_callback     },
	#endif
	#if defined(FRSKYV_CC2500_INO)
		{PROTO_FRSKYV,      STR_FRSKYV,   NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_CC2500, FRSKYV_init,     FRSKYV_callback     },
	#endif
	#if defined(FRSKYX_CC2500_INO)
		{PROTO_FRSKYX,     STR_FRSKYX,    STR_SUBTYPE_FRSKYX,    6, OPTION_RFTUNE,  1, 0, SW_CC2500, FRSKYX_init,     FRSKYX_callback     },
		{PROTO_FRSKYX2,    STR_FRSKYX2,   STR_SUBTYPE_FRSKYX,    6, OPTION_RFTUNE,  1, 0, SW_CC2500, FRSKYX_init,     FRSKYX_callback     },
	#endif
//OpenTX 2.3.x issue: DO NOT CHANGE ORDER above
	#if defined(FRSKYL_CC2500_INO)
		{PROTO_FRSKYL,     STR_FRSKYL,    STR_SUBTYPE_FRSKYL,    2, OPTION_RFTUNE,  0, 0, SW_CC2500, FRSKYL_init,     FRSKYL_callback     },
	#endif
	#if defined(FRSKYR9_SX1276_INO)
		#if MULTI_5IN1_INTERNAL == T18
		{PROTO_FRSKY_R9,   STR_FRSKYR9,   STR_SUBTYPE_FRSKYR9,   8, OPTION_NONE,    1, 0, 0,         FRSKYR9_init,    FRSKYR9_callback    },
		#else	// DIY & T-Lite
		{PROTO_FRSKY_R9,   STR_FRSKYR9,   STR_SUBTYPE_FRSKYR9,   8, OPTION_RFPOWER, 1, 0, 0,         FRSKYR9_init,    FRSKYR9_callback    },
		#endif
	#endif
	#if defined(FUTABA_CC2500_INO)
		{PROTO_FUTABA,     STR_FUTABA,    STR_SUBTYPE_FUTABA,    1, OPTION_RFTUNE,  1, 1, SW_CC2500, SFHSS_init,      SFHSS_callback      },
	#endif
	#if defined(FX_NRF24L01_INO)
		{PROTO_FX,         STR_FX,        STR_SUBTYPE_FX,        5, OPTION_NONE,    0, 0, SW_NRF,    FX_init,         FX_callback         },
	#endif
	#if defined(FY326_NRF24L01_INO)
		{PROTO_FY326,      STR_FY326,     STR_SUBTYPE_FY326,     2, OPTION_NONE,    0, 0, SW_NRF,    FY326_init,      FY326_callback      },
	#endif
	#if defined(GD00X_CCNRF_INO)
		{PROTO_GD00X,      STR_GD00X,     STR_SUBTYPE_GD00X,     2, OPTION_RFTUNE,  0, 0, SW_NRF,    GD00X_init,      GD00X_callback      },
	#endif
	#if defined(GW008_NRF24L01_INO)
		{PROTO_GW008,      STR_GW008,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    GW008_init,      GW008_callback      },
	#endif
	#if defined(H36_NRF24L01_INO)
		{PROTO_H36,        STR_H36,       NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    H36_init,        H36_callback        },
	#endif
	#if defined(H8_3D_NRF24L01_INO)
		{PROTO_H8_3D,      STR_H8_3D,     STR_SUBTYPE_H83D,      4, OPTION_NONE,    0, 0, SW_NRF,    H8_3D_init,      H8_3D_callback      },
	#endif
	#if defined(HEIGHT_A7105_INO)
		{PROTO_HEIGHT,     STR_HEIGHT,    STR_SUBTYPE_HEIGHT,    2, OPTION_NONE,    0, 0, SW_A7105,  HEIGHT_init,     HEIGHT_callback     },
	#endif
	#if defined(HISKY_NRF24L01_INO)
		{PROTO_HISKY,      STR_HISKY,     STR_SUBTYPE_HISKY,     2, OPTION_NONE,    1, 1, SW_NRF,    HISKY_init,      HISKY_callback      },
	#endif
	#if defined(HITEC_CC2500_INO)
		{PROTO_HITEC,      STR_HITEC,     STR_SUBTYPE_HITEC,     3, OPTION_RFTUNE,  0, 0, SW_CC2500, HITEC_init,      HITEC_callback      },
	#endif
	#if defined(HONTAI_NRF24L01_INO)
		{PROTO_HONTAI,     STR_HONTAI,    STR_SUBTYPE_HONTAI,    5, OPTION_NONE,    0, 0, SW_NRF,    HONTAI_init,     HONTAI_callback     },
	#endif
	#if defined(HOTT_CC2500_INO)
		{PROTO_HOTT,       STR_HOTT,      STR_SUBTYPE_HOTT,      2, OPTION_RFTUNE,  1, 0, SW_CC2500, HOTT_init,       HOTT_callback       },
	#endif
	#if defined(HUBSAN_A7105_INO)
		{PROTO_HUBSAN,     STR_HUBSAN,    STR_SUBTYPE_HUBSAN,    3, OPTION_VIDFREQ, 0, 0, SW_A7105,  HUBSAN_init,     HUBSAN_callback     },
	#endif
	#if defined(IKEAANSLUTA_CC2500_INO)
		{PROTO_IKEAANSLUTA,STR_IKEAANSLUTA,NO_SUBTYPE,           0, OPTION_OPTION,  0, 0, SW_CC2500, IKEAANSLUTA_init,IKEAANSLUTA_callback },
	#endif
	#if defined(J6PRO_CYRF6936_INO)
		{PROTO_J6PRO,      STR_J6PRO,     NO_SUBTYPE,            0, OPTION_NONE,    0, 1, SW_CYRF,   J6PRO_init,      J6PRO_callback      },
	#endif
	#if defined(JIABAILE_NRF24L01_INO)
		{PROTO_JIABAILE,   STR_JIABAILE,  STR_SUBTYPE_JIABAILE,  2, OPTION_NONE,    0, 0, SW_NRF,    JIABAILE_init,   JIABAILE_callback   },
	#endif
	#if defined(JJRC345_NRF24L01_INO)
		{PROTO_JJRC345,    STR_JJRC345,   STR_SUBTYPE_JJRC345,   2, OPTION_NONE,    0, 0, SW_NRF,    JJRC345_init,    JJRC345_callback    },
	#endif
	#if defined(JOYSWAY_A7105_INO)
		{PROTO_JOYSWAY,    STR_JOYSWAY,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_A7105,  JOYSWAY_init,    JOYSWAY_callback    },
	#endif
	#if defined(KAMTOM_NRF24L01_INO)
		{PROTO_KAMTOM,     STR_KAMTOM,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    KAMTOM_init,     KAMTOM_callback     },
	#endif
	#if defined(KF606_CCNRF_INO)
		{PROTO_KF606,      STR_KF606,     STR_SUBTYPE_KF606,     3, OPTION_RFTUNE,  0, 0, SW_NRF,    KF606_init,      KF606_callback      },
	#endif
	#if defined(KN_NRF24L01_INO)
		{PROTO_KN,         STR_KN,        STR_SUBTYPE_KN,        2, OPTION_NONE,    0, 0, SW_NRF,    KN_init,         KN_callback         },
	#endif
	#if defined(KYOSHO_A7105_INO)
		{PROTO_KYOSHO,     STR_KYOSHO,    STR_SUBTYPE_KYOSHO,    2, OPTION_NONE,    0, 1, SW_A7105,  KYOSHO_init,     KYOSHO_callback     },
	#endif
	#if defined(KYOSHO2_NRF24L01_INO)
		{PROTO_KYOSHO2,    STR_KYOSHO2,   STR_SUBTYPE_KYOSHO2,   1, OPTION_NONE,    0, 0, SW_NRF,    KYOSHO2_init,    KYOSHO2_callback    },
	#endif
	#if defined(KYOSHO3_CYRF6936_INO)
		{PROTO_KYOSHO3,    STR_KYOSHO3,   STR_SUBTYPE_KYOSHO3,   1, OPTION_NONE,    0, 0, SW_CYRF,   KYOSHO3_init,    KYOSHO3_callback    },
	#endif
	#if defined(LOLI_NRF24L01_INO)
		{PROTO_LOLI,       STR_LOLI,      NO_SUBTYPE,            0, OPTION_NONE,    1, 0, SW_NRF,    LOLI_init,       LOLI_callback       },
	#endif
	#if defined(LOSI_CYRF6936_INO)
		{PROTO_LOSI,       STR_LOSI,      NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_CYRF,   LOSI_init,       LOSI_callback       },
	#endif
	#if defined(MJXQ_CCNRF_INO)
		{PROTO_MJXQ,       STR_MJXQ,      STR_SUBTYPE_MJXQ,      7, OPTION_NONE,    0, 0, SW_NRF,    MJXQ_init,       MJXQ_callback       },
	#endif
	#if defined(MLINK_CYRF6936_INO)
		{PROTO_MLINK,      STR_MLINK,     NO_SUBTYPE,            0, OPTION_NONE,    1, 0, SW_CYRF,   MLINK_init,      MLINK_callback      },
	#endif
	#if defined(MOULDKG_NRF24L01_INO)
		{PROTO_MOULDKG,    STR_MOULDKG,   STR_SUBTYPE_MOULDKG,   3, OPTION_OPTION,  0, 0, SW_NRF,    MOULDKG_init,    MOULDKG_callback    },
	#endif
	#if defined(MT99XX_CCNRF_INO)
		{PROTO_MT99XX,     STR_MT99XX,    STR_SUBTYPE_MT99,      8, OPTION_NONE,    0, 0, SW_NRF,    MT99XX_init,     MT99XX_callback     },
	#endif
	#if defined(MT99XX_CCNRF_INO)
		{PROTO_MT99XX2,    STR_MT99XX2,   STR_SUBTYPE_MT992,     2, OPTION_NONE,    0, 0, SW_NRF,    MT99XX_init,     MT99XX_callback     },
	#endif
	#if defined(NCC1701_NRF24L01_INO)
		{PROTO_NCC1701,    STR_NCC1701,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    NCC_init,        NCC_callback        },
	#endif
	#if defined(OMP_CCNRF_INO)
		{PROTO_OMP,        STR_OMP,       NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    OMP_init,        OMP_callback        },
	#endif
	#if defined(PELIKAN_A7105_INO)
		{PROTO_PELIKAN,    STR_PELIKAN,   STR_SUBTYPE_PELIKAN,   3, OPTION_NONE,    0, 1, SW_A7105,  PELIKAN_init,    PELIKAN_callback    },
	#endif
	#if defined(POTENSIC_NRF24L01_INO)
		{PROTO_POTENSIC,   STR_POTENSIC,  STR_SUBTYPE_POTENSIC,  1, OPTION_NONE,    0, 0, SW_NRF,    POTENSIC_init,   POTENSIC_callback   },
	#endif
	#if defined(PROPEL_NRF24L01_INO)
		{PROTO_PROPEL,     STR_PROPEL,    STR_SUBTYPE_PROPEL,    1, OPTION_NONE,    0, 0, SW_NRF,    PROPEL_init,     PROPEL_callback     },
	#endif
	#if defined(CX10_NRF24L01_INO)
		{PROTO_Q2X2,       STR_Q2X2,      STR_SUBTYPE_Q2X2,      3, OPTION_NONE,    0, 0, SW_NRF,    CX10_init,       CX10_callback       },
	#endif
	#if defined(Q303_CCNRF_INO)
		{PROTO_Q303,       STR_Q303,      STR_SUBTYPE_Q303,      4, OPTION_NONE,    0, 0, SW_NRF,    Q303_init,       Q303_callback       },
	#endif
	#if defined(Q90C_CCNRF_INO)
		{PROTO_Q90C,       STR_Q90C,      NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_NRF,    Q90C_init,       Q90C_callback       },
	#endif
	#if defined(RLINK_CC2500_INO)
		{PROTO_RLINK,      STR_RLINK,     STR_SUBTYPE_RLINK,     4, OPTION_RFTUNE,  0, 0, SW_CC2500, RLINK_init,      RLINK_callback      },
	#endif
	#if defined(REALACC_NRF24L01_INO)
		{PROTO_REALACC,    STR_REALACC,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    REALACC_init,    REALACC_callback    },
	#endif
	#if defined(REDPINE_CC2500_INO)
		{PROTO_REDPINE,    STR_REDPINE,   STR_SUBTYPE_REDPINE,   2, OPTION_RFTUNE,  0, 0, SW_CC2500, REDPINE_init,    REDPINE_callback    },
	#endif
	#if defined(SCANNER_CC2500_INO)
		{PROTO_SCANNER,    STR_SCANNER,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_CC2500, SCANNER_init,    SCANNER_callback    },
	#endif
	#if defined(SCORPIO_CYRF6936_INO)
		{PROTO_SCORPIO,    STR_SCORPIO,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_CYRF,   SCORPIO_init,    SCORPIO_callback    },
	#endif
	#if defined(SGF22_NRF24L01_INO)
		{PROTO_SGF22,      STR_SGF22,     STR_SUBTYPE_SGF22,     4, OPTION_NONE,    0, 0, SW_NRF,    SGF22_init,      SGF22_callback      },
	#endif
	#if defined(SHENQI_NRF24L01_INO)
		{PROTO_SHENQI,     STR_SHENQI,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    SHENQI_init,     SHENQI_callback     },
	#endif
	#if defined(SHENQI2_NRF24L01_INO)
		{PROTO_SHENQI2,    STR_SHENQI2,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    SHENQI2_init,     SHENQI2_callback   },
	#endif
	#if defined(SKYARTEC_CC2500_INO)
		{PROTO_SKYARTEC,   STR_SKYARTEC,  NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 1, SW_CC2500, SKYARTEC_init,   SKYARTEC_callback   },
	#endif
	#if defined(SLT_CCNRF_INO)
		{PROTO_SLT,        STR_SLT,       STR_SUBTYPE_SLT,       8, OPTION_RFTUNE,  0, 1, SW_NRF,    SLT_init,        SLT_callback        },
	#endif
	#if defined(SYMAX_NRF24L01_INO)
		{PROTO_SYMAX,      STR_SYMAX,     STR_SUBTYPE_SYMAX,     2, OPTION_NONE,    0, 0, SW_NRF,    SYMAX_init,      SYMAX_callback      },
	#endif
	#if defined(TRAXXAS_CYRF6936_INO)
		{PROTO_TRAXXAS,    STR_TRAXXAS,   STR_SUBTYPE_TRAXXAS,   2, OPTION_NONE,    0, 0, SW_CYRF,   TRAXXAS_init,    TRAXXAS_callback    },
	#endif
	#if defined(UDIRC_CCNRF_INO)
		{PROTO_UDIRC,      STR_UDIRC,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    UDIRC_init,      UDIRC_callback      },
	#endif
	#if defined(V2X2_NRF24L01_INO)
		{PROTO_V2X2,       STR_V2X2,      STR_SUBTYPE_V2X2,      3, OPTION_NONE,    0, 0, SW_NRF,    V2X2_init,       V2X2_callback       },
	#endif
	#if defined(V761_NRF24L01_INO)
		{PROTO_V761,       STR_V761,      STR_SUBTYPE_V761,      3, OPTION_NONE,    0, 0, SW_NRF,    V761_init,       V761_callback       },
	#endif
	#if defined(V911S_CCNRF_INO)
		{PROTO_V911S,      STR_V911S,     STR_SUBTYPE_V911S,     2, OPTION_RFTUNE,  0, 0, SW_NRF,    V911S_init,      V911S_callback      },
	#endif
	#if defined(WFLY_CYRF6936_INO)
		{PROTO_WFLY,       STR_WFLY,      STR_SUBTYPE_WFLY,      1, OPTION_NONE,    1, 0, SW_CYRF,   WFLY_init,       WFLY_callback       },
	#endif
	#if defined(WFLY2_A7105_INO)
		{PROTO_WFLY2,      STR_WFLY2,     STR_SUBTYPE_WFLY2,     1, OPTION_OPTION,  1, 0, SW_A7105,  WFLY2_init,      WFLY2_callback      },
//		{PROTO_WFLY2,      STR_WFLY2,     STR_SUBTYPE_WFLY2,     1, OPTION_WBUS,    1, 0, SW_A7105,  WFLY2_init,      WFLY2_callback      },// crash OpenTX...
	#endif
	#if defined(WK2x01_CYRF6936_INO)
		{PROTO_WK2x01,     STR_WK2x01,    STR_SUBTYPE_WK2x01,    6, OPTION_NONE,    1, 1, SW_CYRF,   WK_init,         WK_callback         },
	#endif
	#if defined(WL91X_CCNRF_INO)
		{PROTO_WL91X,      STR_WL91X,     NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    WL91X_init,      WL91X_callback      },
	#endif
	#if defined(WPL_NRF24L01_INO)
		{PROTO_WPL,        STR_WPL,       NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    WPL_init,        WPL_callback        },
	#endif
	#if defined(XERALL_NRF24L01_INO)
		{PROTO_XERALL,     STR_XERALL,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    XERALL_init,     XERALL_callback     },	
	#endif
	#if defined(XK_CCNRF_INO)
		{PROTO_XK,         STR_XK,        STR_SUBTYPE_XK,        3, OPTION_RFTUNE,  0, 0, SW_NRF,    XK_init,         XK_callback         },	
	#endif
	#if defined(XK2_CCNRF_INO)
		{PROTO_XK2,        STR_XK2,       STR_SUBTYPE_XK2,       2, OPTION_RFTUNE,  0, 0, SW_NRF,    XK2_init,        XK2_callback        },	
	#endif
	#if defined(XN297DUMP_NRF24L01_INO)
		{PROTO_XN297DUMP,  STR_XN297DUMP, STR_SUBTYPE_XN297DUMP, 7, OPTION_RFCHAN,  0, 0, SW_NRF,    XN297Dump_init,  XN297Dump_callback  },
	#endif
	#if defined(YD717_NRF24L01_INO)
		{PROTO_YD717,      STR_YD717,     STR_SUBTYPE_YD717,     5, OPTION_NONE,    0, 0, SW_NRF,    YD717_init,      YD717_callback      },
	#endif
	#if defined(YUXIANG_NRF24L01_INO)
		{PROTO_YUXIANG,    STR_YUXIANG,   NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    YUXIANG_init,    YUXIANG_callback    },
	#endif
	#if defined(ZSX_NRF24L01_INO)
		{PROTO_ZSX,        STR_ZSX,       STR_SUBTYPE_ZSX,       1, OPTION_NONE,    0, 0, SW_NRF,    ZSX_init,        ZSX_callback        },
	#endif
	#if defined(TEST_CC2500_INO)
		{PROTO_TEST,       STR_TEST,      NO_SUBTYPE,            0, OPTION_RFTUNE,  0, 0, SW_NRF,    TEST_init,       TEST_callback       },
	#endif
	#if defined(NANORF_NRF24L01_INO)
		{PROTO_NANORF,     STR_NANORF,    NO_SUBTYPE,            0, OPTION_NONE,    0, 0, SW_NRF,    NANORF_init,     NANORF_callback     },
	#endif
		{0xFF,             nullptr,       nullptr,               0, 0,              0, 0, 0,         nullptr,         nullptr             }
};

#ifdef MULTI_TELEMETRY
uint16_t PROTOLIST_callback()
{
	if(option != prev_option)
	{//Only send once
		/* Type 0x11 Protocol list export via telemetry. Used by the protocol PROTO_PROTOLIST=0, the list entry is given by the Option field.
		   length: variable
		   data[0]     = protocol number, 0xFF is an invalid list entry (Option value too large), Option == 0xFF -> number of protocols in the list
		   data[1..n]  = protocol name null terminated
		   data[n+1]   = flags
						 flags>>4 Option text number to be displayed (check multi status for description)
						 flags&0x01 failsafe supported
						 flags&0x02 Channel Map Disabled supported
		   data[n+2]   = number of sub protocols
		   data[n+3]   = sub protocols text length, only sent if nbr_sub != 0
		   data[n+4..] = sub protocol names, only sent if nbr_sub != 0
		*/
		prev_option = option;

		if(option >= (sizeof(multi_protocols)/sizeof(mm_protocol_definition)) - 1)
		{//option is above the end of the list
			//Header
			multi_send_header(MULTI_TELEMETRY_PROTO, 1);
			if(option == 0xFF)
				Serial_write((sizeof(multi_protocols)/sizeof(mm_protocol_definition)) - 1);	//Nbr proto
			else
				Serial_write(0xFF);															//Error
		}
		else
		{//valid option value
			uint8_t proto_len = strlen(multi_protocols[option].ProtoString) + 1;
			uint8_t nbr_sub = multi_protocols[option].nbrSubProto;
			uint8_t sub_len = 0;
			if(nbr_sub)
				sub_len = multi_protocols[option].SubProtoString[0];
			
			//Header
			multi_send_header(MULTI_TELEMETRY_PROTO, 1 + proto_len + 1 + 1 + (nbr_sub?1:0) + (nbr_sub * sub_len));
			//Protocol number
			Serial_write(multi_protocols[option].protocol);
			//Protocol name
			for(uint8_t i=0;i<proto_len;i++)
			{
				Serial_write(multi_protocols[option].ProtoString[i]);
				//debug("%c",multi_protocols[option].ProtoString[i]);
			}
			//Flags
			uint8_t flags=0;
			#ifdef FAILSAFE_ENABLE
				if(multi_protocols[option].failSafe)
					flags |= 0x01;		//Failsafe supported
			#endif
			if(multi_protocols[option].chMap)
				flags |= 0x02;			//Disable_ch_mapping supported
			Serial_write( flags | (multi_protocols[option].optionType<<4));	// flags && option type
			//debug(" Flag=%02X",flags | (multi_protocols[option].optionType<<4));
			//Number of sub protocols
			Serial_write(nbr_sub);
			//debug(" NSub=%02X ",nbr_sub);
			if(nbr_sub !=0 )
			{//Sub protocols length and texts
				for(uint8_t i=0;i<=nbr_sub*sub_len;i++)
				{
					Serial_write(multi_protocols[option].SubProtoString[i]);
					//debug("%c",multi_protocols[option].SubProtoString[i]);
				}
			}
			//debugln("");
		}
	}
	return 1000;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NCC1701_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(NCC1701_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define NCC_WRITE_WAIT      2000
#define NCC_PACKET_INTERVAL 10333
#define NCC_TX_PACKET_LEN	16
#define NCC_RX_PACKET_LEN	13

enum {
	NCC_BIND_TX1=0,
	NCC_BIND_RX1,
	NCC_BIND_TX2,
	NCC_BIND_RX2,
	NCC_TX3,
	NCC_RX3,
};

static void __attribute__((unused)) NCC_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t*)"\xE7\xE7\xC7\xD7\x67",5);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t*)"\xE7\xE7\xC7\xD7\x67",5);
	
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, NCC_RX_PACKET_LEN);			// Enable rx pipe 0
	NRF24L01_SetBitrate(NRF24L01_BR_250K);								// NRF24L01_BR_1M, NRF24L01_BR_2M, NRF24L01_BR_250K
	NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)		// switch to TX mode and disable CRC
										| (1 << NRF24L01_00_CRCO)
										| (1 << NRF24L01_00_PWR_UP)
										| (0 << NRF24L01_00_PRIM_RX));
}

const uint8_t NCC_xor[]={0x80, 0x44, 0x64, 0x75, 0x6C, 0x71, 0x2A, 0x36, 0x7C, 0xF1, 0x6E, 0x52, 0x09, 0x9D};
static void __attribute__((unused)) NCC_Crypt_Packet()
{
	crc=0;
	for(uint8_t i=0; i< NCC_TX_PACKET_LEN-2; i++)
	{
		packet[i]^=NCC_xor[i];
		crc16_update(packet[i], 8);
	}
	crc^=0x60DE;
	packet[NCC_TX_PACKET_LEN-2]=crc>>8;
	packet[NCC_TX_PACKET_LEN-1]=crc;
}
static boolean __attribute__((unused)) NCC_Decrypt_Packet()
{
	crc=0;
	debug("RX: ");
	for(uint8_t i=0; i< NCC_RX_PACKET_LEN-2; i++)
	{
		crc16_update( packet[i], 8);
		packet[i]^=NCC_xor[i];
		debug("%02X ",packet[i]);
	}
	crc^=0xA950;
	if( (crc>>8)==packet[NCC_RX_PACKET_LEN-2] && (crc&0xFF)==packet[NCC_RX_PACKET_LEN-1] )
	{// CRC match
		debugln("OK");
		return true;
	}
	debugln("NOK");
	return false;
}

static void __attribute__((unused)) NCC_Write_Packet()
{
	packet[0]=0xAA;
	packet[1]=rx_tx_addr[0];
	packet[2]=rx_tx_addr[1];
	packet[3]=rx_id[0];
	packet[4]=rx_id[1];
	packet[5]=convert_channel_8b(THROTTLE)>>2;	// 00-3D
	packet[6]=convert_channel_8b(ELEVATOR);		// original: 61-80-9F but works with 00-80-FF
	packet[7]=convert_channel_8b(AILERON );		// original: 61-80-9F but works with 00-80-FF
	packet[8]=convert_channel_8b(RUDDER  );		// original: 61-80-9F but works with 00-80-FF
	packet[9]=rx_id[2];
	packet[10]=rx_id[3];
	packet[11]=rx_id[4];
	packet[12]=GET_FLAG(CH5_SW, 0x02);			// Warp:0x00 -> 0x02
	packet[13]=packet[5]+packet[6]+packet[7]+packet[8]+packet[12];
	if(phase==NCC_BIND_TX1)
	{
		packet[0]=0xBB;
		packet[5]=0x01;
		packet[6]=rx_tx_addr[2];
		memset((void *)(packet+7),0x55,7);
		hopping_frequency_no^=1;
	}
	else
	{
		hopping_frequency_no++;
		if(hopping_frequency_no>2) hopping_frequency_no=0;
	}
	// change frequency
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);
	// switch to TX mode and disable CRC
	NRF24L01_SetTxRxMode(TXRX_OFF);
	NRF24L01_SetTxRxMode(TX_EN);
	NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)
										| (1 << NRF24L01_00_CRCO)
										| (1 << NRF24L01_00_PWR_UP)
										| (0 << NRF24L01_00_PRIM_RX));
	// clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_FlushTx();
	// send packet
	NCC_Crypt_Packet();
	NRF24L01_WritePayload(packet,NCC_TX_PACKET_LEN);
	NRF24L01_SetPower();
}

uint16_t NCC_callback()
{
	switch(phase)
	{
		case NCC_BIND_TX1:
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ // RX fifo data ready
				NRF24L01_ReadPayload(packet, NCC_RX_PACKET_LEN);
				if(NCC_Decrypt_Packet() && packet[1]==rx_tx_addr[0] && packet[2]==rx_tx_addr[1])

				{
					rx_id[0]=packet[3];
					rx_id[1]=packet[4];
					NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
					phase=NCC_BIND_TX2;
					return NCC_PACKET_INTERVAL;
				}
			}
			NCC_Write_Packet();
			phase = NCC_BIND_RX1;
			return NCC_WRITE_WAIT;
		case NCC_BIND_RX1:
			// switch to RX mode and disable CRC
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_SetTxRxMode(RX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
			NRF24L01_FlushRx();
			phase = NCC_BIND_TX1;
			return NCC_PACKET_INTERVAL - NCC_WRITE_WAIT;
		case NCC_BIND_TX2:
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ // RX fifo data ready
				NRF24L01_ReadPayload(packet, NCC_RX_PACKET_LEN);
				if(NCC_Decrypt_Packet() && packet[1]==rx_tx_addr[0] && packet[2]==rx_tx_addr[1] && packet[3]==rx_id[0] && packet[4]==rx_id[1])
				{
					rx_id[2]=packet[8];
					rx_id[3]=packet[9];
					rx_id[4]=packet[10];
					NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
					BIND_DONE;
					phase=NCC_TX3;
					return NCC_PACKET_INTERVAL;
				}
			}
			NCC_Write_Packet();
			phase = NCC_BIND_RX2;
			return NCC_WRITE_WAIT;
		case NCC_BIND_RX2:
			// switch to RX mode and disable CRC
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_SetTxRxMode(RX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
			NRF24L01_FlushRx();
			phase = NCC_BIND_TX2;
			return NCC_PACKET_INTERVAL - NCC_WRITE_WAIT;
		case NCC_TX3:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(NCC_PACKET_INTERVAL);
			#endif
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ // RX fifo data ready
				NRF24L01_ReadPayload(packet, NCC_RX_PACKET_LEN);
				if(NCC_Decrypt_Packet() && packet[1]==rx_tx_addr[0] && packet[2]==rx_tx_addr[1] && packet[3]==rx_id[0] && packet[4]==rx_id[1])
				{
					//Telemetry
					//packet[5] and packet[7] roll angle
					//packet[6] crash detect: 0x00 no crash, 0x02 crash
					#ifdef NCC1701_HUB_TELEMETRY
						v_lipo1 = packet[6]?0xFF:0x00;	// Crash indication
						v_lipo2 = 0x00;
						RX_RSSI = 0x7F;					// Dummy RSSI
						TX_RSSI = 0x7F;					// Dummy RSSI
						telemetry_link=1;
					#endif
				}
			}
			NCC_Write_Packet();
			phase = NCC_RX3;
			return NCC_WRITE_WAIT;
		case NCC_RX3:
			// switch to RX mode and disable CRC
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_SetTxRxMode(RX_EN);
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
			NRF24L01_FlushRx();
			phase = NCC_TX3;
			return NCC_PACKET_INTERVAL - NCC_WRITE_WAIT;
	}
	return 0;
}

const uint8_t PROGMEM NCC_TX_DATA[][6]= {
	{ 0x6D, 0x97, 0x04, 0x48, 0x43, 0x26 }, 
	{ 0x35, 0x4B, 0x80, 0x44, 0x4C, 0x0B },
	{ 0x50, 0xE2, 0x32, 0x2D, 0x4B, 0x0A },
	{ 0xBF, 0x34, 0xF3, 0x45, 0x4D, 0x0D },
	{ 0xDD, 0x7D, 0x5A, 0x46, 0x28, 0x23 },
	{ 0xED, 0x19, 0x06, 0x2C, 0x4A, 0x09 },
	{ 0xE9, 0xA8, 0x91, 0x2B, 0x49, 0x07 },
	{ 0x66, 0x17, 0x7D, 0x48, 0x43, 0x26 },
	{ 0xC2, 0x93, 0x55, 0x44, 0x4C, 0x0B },
};

void NCC_init(void)
{
	BIND_IN_PROGRESS;	// autobind protocol
	
	// Load TX data
	uint8_t rand=rx_tx_addr[3]%9;
	for(uint8_t i=0; i<3; i++)
	{
		rx_tx_addr[i]=pgm_read_byte_near(&NCC_TX_DATA[rand][i]);
		hopping_frequency[i]=pgm_read_byte_near(&NCC_TX_DATA[rand][i+3]);
	}

	// RX data is acquired during bind
	rx_id[0]=0x00;
	rx_id[1]=0x00;
	rx_id[2]=0x20;
	rx_id[3]=0x20;
	rx_id[4]=0x20;

	hopping_frequency[4]=0x08;	// bind channel 1
	hopping_frequency[5]=0x2A;	// bind channel 2
	hopping_frequency_no=4;		// start with bind
	NCC_RF_init();
	phase=NCC_BIND_TX1;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF24l01_SPI.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */


#ifdef NRF24L01_INSTALLED
#include "iface_nrf24l01.h"
#include "iface_xn297.h"

//---------------------------
// NRF24L01+ SPI Specific Functions
//---------------------------

uint8_t rf_setup;

void NRF24L01_Initialize()
{
    rf_setup = 0x09;
	prev_power = 0x00;	// Make sure prev_power is inline with current power

	//Load most likely default NRF config
	NRF24L01_FlushTx();
	NRF24L01_FlushRx();
	NRF24L01_WriteReg(NRF24L01_01_EN_AA,		0x00);	// No Auto Acknowldgement on all data pipes
	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR,	0x01); 	// Enable data pipe 0 only
	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW,		0x03);	// 5 bytes rx/tx address
	NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR,	0x00); 	// no retransmits
	NRF24L01_SetBitrate(NRF24L01_BR_1M);             	// 1Mbps
	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x00);       	// Disable dynamic payload length on all pipes
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x01);     	// Set feature bits off and enable the command NRF24L01_B0_TX_PYLD_NOACK
	NRF24L01_SetPower();
	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}  

void NRF24L01_WriteReg(uint8_t reg, uint8_t data)
{
	NRF_CSN_off;
	SPI_Write(W_REGISTER | (REGISTER_MASK & reg));
	SPI_Write(data);
	NRF_CSN_on;
}

void NRF24L01_WriteRegisterMulti(uint8_t reg, uint8_t * data, uint8_t length)
{
	NRF_CSN_off;

	SPI_Write(W_REGISTER | ( REGISTER_MASK & reg));
	for (uint8_t i = 0; i < length; i++)
		SPI_Write(data[i]);
	NRF_CSN_on;
}

void NRF24L01_WritePayload(uint8_t * data, uint8_t length)
{
	NRF_CSN_off;
	SPI_Write(W_TX_PAYLOAD);
	for (uint8_t i = 0; i < length; i++)
		SPI_Write(data[i]);
	NRF_CSN_on;
}

uint8_t NRF24L01_ReadReg(uint8_t reg)
{
	NRF_CSN_off;
	SPI_Write(R_REGISTER | (REGISTER_MASK & reg));
	uint8_t data = SPI_Read();
	NRF_CSN_on;
	return data;
}

/*static void NRF24L01_ReadRegisterMulti(uint8_t reg, uint8_t * data, uint8_t length)
{
	NRF_CSN_off;
	SPI_Write(R_REGISTER | (REGISTER_MASK & reg));
	for(uint8_t i = 0; i < length; i++)
		data[i] = SPI_Read();
	NRF_CSN_on;
}
*/

static void NRF24L01_ReadPayload(uint8_t * data, uint8_t length)
{
	NRF_CSN_off;
	SPI_Write(R_RX_PAYLOAD);
	for(uint8_t i = 0; i < length; i++)
		data[i] = SPI_Read();
	NRF_CSN_on; 
}

static void  NRF24L01_Strobe(uint8_t state)
{
	NRF_CSN_off;
	SPI_Write(state);
	NRF_CSN_on;
}

void NRF24L01_FlushTx()
{
	NRF24L01_Strobe(FLUSH_TX);
}

void NRF24L01_FlushRx()
{
	NRF24L01_Strobe(FLUSH_RX);
}

static uint8_t __attribute__((unused)) NRF24L01_GetStatus()
{
	return SPI_Read();
}

static uint8_t NRF24L01_GetDynamicPayloadSize()
{
	NRF_CSN_off;
    SPI_Write(R_RX_PL_WID);
    uint8_t len = SPI_Read();
	NRF_CSN_on; 
    return len;
}

/*void NRF24L01_Activate(uint8_t code)
{
	NRF_CSN_off;
	SPI_Write(ACTIVATE);
	SPI_Write(code);
	NRF_CSN_on;
}*/

void NRF24L01_SetBitrate(uint8_t bitrate)
{
    // Note that bitrate 250kbps (and bit RF_DR_LOW) is valid only
    // for nRF24L01+. There is no way to programmatically tell it from
    // older version, nRF24L01, but the older is practically phased out
    // by Nordic, so we assume that we deal with modern version.

    // Bit 0 goes to RF_DR_HIGH, bit 1 - to RF_DR_LOW
    rf_setup = (rf_setup & 0xD7) | ((bitrate & 0x02) << 4) | ((bitrate & 0x01) << 3);
    prev_power=(rf_setup>>1)&0x03;	// Make sure prev_power is inline with current power
	NRF24L01_WriteReg(NRF24L01_06_RF_SETUP, rf_setup);
}

/*
	static void NRF24L01_SetPower_Value(uint8_t power)
{
    uint8_t nrf_power = 0;
    switch(power) {
        case TXPOWER_100uW: nrf_power = 0; break;
        case TXPOWER_300uW: nrf_power = 0; break;
        case TXPOWER_1mW:   nrf_power = 0; break;
        case TXPOWER_3mW:   nrf_power = 1; break;
        case TXPOWER_10mW:  nrf_power = 1; break;
        case TXPOWER_30mW:  nrf_power = 2; break;
        case TXPOWER_100mW: nrf_power = 3; break;
        case TXPOWER_150mW: nrf_power = 3; break;
        default:            nrf_power = 0; break;
    };
    // Power is in range 0..3 for nRF24L01
    rf_setup = (rf_setup & 0xF9) | ((nrf_power & 0x03) << 1);
    NRF24L01_WriteReg(NRF24L01_06_RF_SETUP, rf_setup);
}
*/
void NRF24L01_SetPower()
{
	uint8_t power=NRF_BIND_POWER;
	if(IS_BIND_DONE)
		#ifdef NRF24L01_ENABLE_LOW_POWER
			power=IS_POWER_FLAG_on?NRF_HIGH_POWER:NRF_LOW_POWER;
		#else
			power=NRF_HIGH_POWER;
		#endif
	if(IS_RANGE_FLAG_on)
		power=NRF_POWER_0;
	if(prev_power != power)
	{
		rf_setup = (rf_setup & 0xF8) | (power << 1);
		if(power==3)
			rf_setup |= 0x01;	// Si24r01 full power, unused bit for NRF
		NRF24L01_WriteReg(NRF24L01_06_RF_SETUP, rf_setup);
		prev_power=power;
	}
}

void NRF24L01_SetTxRxMode(enum TXRX_State mode)
{
	NRF24L01_WriteReg(NRF24L01_07_STATUS, (1 << NRF24L01_07_RX_DR)    //reset the flag(s)
										| (1 << NRF24L01_07_TX_DS)
										| (1 << NRF24L01_07_MAX_RT));
	if(mode == TX_EN) {
		NRF_CE_off;
		NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_EN_CRC)   // switch to TX mode
											| (1 << NRF24L01_00_CRCO)
											| (1 << NRF24L01_00_PWR_UP));
		delayMicroseconds(130);
		NRF_CE_on;
	}
	else
		if (mode == RX_EN)
		{
			NRF_CE_off;
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_EN_CRC)   // switch to RX mode
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
			delayMicroseconds(130);
			NRF_CE_on;
		}
		else
		{
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_EN_CRC)); //PowerDown
			NRF_CE_off;
		}
}

void NRF24L01_Reset()
{
	NRF24L01_FlushTx();
    NRF24L01_FlushRx();
    NRF24L01_Strobe(0xff);			// NOP
    NRF24L01_ReadReg(NRF24L01_07_STATUS);
    NRF24L01_SetTxRxMode(TXRX_OFF);
	delayMicroseconds(100);
}

uint8_t NRF24L01_packet_ack()
{
    switch (NRF24L01_ReadReg(NRF24L01_07_STATUS) & (_BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)))
	{
		case _BV(NRF24L01_07_TX_DS):
			return PKT_ACKED;
		case _BV(NRF24L01_07_MAX_RT):
			return PKT_TIMEOUT;
    }
	return PKT_PENDING;
}

///////////////
// LT8900 emulation layer
uint8_t LT8900_buffer[64];
uint8_t LT8900_buffer_start;
uint16_t LT8900_buffer_overhead_bits;
uint8_t LT8900_addr[8];
uint8_t LT8900_addr_size;
uint8_t LT8900_Preamble_Len;
uint8_t LT8900_Tailer_Len;
uint8_t LT8900_CRC_Initial_Data;
uint8_t LT8900_Flags;
#define LT8900_CRC_ON 6
#define LT8900_SCRAMBLE_ON 5
#define LT8900_PACKET_LENGTH_EN 4
#define LT8900_DATA_PACKET_TYPE_1 3
#define LT8900_DATA_PACKET_TYPE_0 2
#define LT8900_FEC_TYPE_1 1
#define LT8900_FEC_TYPE_0 0

void LT8900_Config(uint8_t preamble_len, uint8_t trailer_len, uint8_t flags, uint8_t crc_init)
{
	//Preamble 1 to 8 bytes
	LT8900_Preamble_Len=preamble_len;
	//Trailer 4 to 18 bits
	LT8900_Tailer_Len=trailer_len;
	//Flags
	// CRC_ON: 1 on, 0 off
	// SCRAMBLE_ON: 1 on, 0 off
	// PACKET_LENGTH_EN: 1 1st byte of payload is payload size
	// DATA_PACKET_TYPE: 00 NRZ, 01 Manchester, 10 8bit/10bit line code, 11 interleave data type
	// FEC_TYPE: 00 No FEC, 01 FEC13, 10 FEC23, 11 reserved
	LT8900_Flags=flags;
	//CRC init constant
	LT8900_CRC_Initial_Data=crc_init;
}

void LT8900_SetChannel(uint8_t channel)
{
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, channel +2);	//NRF24L01 is 2400+channel but LT8900 is 2402+channel
}

void LT8900_SetTxRxMode(enum TXRX_State mode)
{
	if(mode == TX_EN)
	{
		//Switch to TX
		NRF24L01_SetTxRxMode(TXRX_OFF);
		NRF24L01_SetTxRxMode(TX_EN);
		//Disable CRC
		NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_PWR_UP));
	}
	else
		if (mode == RX_EN)
		{
			NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x01);		// Enable data pipe 0 only
			NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, 32);
			//Switch to RX
			NRF24L01_SetTxRxMode(TXRX_OFF);
			NRF24L01_FlushRx();
			NRF24L01_SetTxRxMode(RX_EN);
			// Disable CRC
			NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_PWR_UP) | (1 << NRF24L01_00_PRIM_RX) );
		}
		else
			NRF24L01_SetTxRxMode(TXRX_OFF);
}

void LT8900_BuildOverhead()
{
	uint8_t pos;

	//Build overhead
	//preamble
	memset(LT8900_buffer,LT8900_addr[0]&0x01?0xAA:0x55,LT8900_Preamble_Len-1);
	pos=LT8900_Preamble_Len-1;
	//address
	for(uint8_t i=0;i<LT8900_addr_size;i++)
	{
		LT8900_buffer[pos]=bit_reverse(LT8900_addr[i]);
		pos++;
	}
	//trailer
	memset(LT8900_buffer+pos,(LT8900_buffer[pos-1]&0x01)==0?0xAA:0x55,3);
	LT8900_buffer_overhead_bits=pos*8+LT8900_Tailer_Len;
	//nrf address length max is 5
	pos+=LT8900_Tailer_Len/8;
	LT8900_buffer_start=pos>5?5:pos;
}

void LT8900_SetAddress(uint8_t *address,uint8_t addr_size)
{
	uint8_t addr[5];
	
	//Address size (SyncWord) 2 to 8 bytes, 16/32/48/64 bits
	LT8900_addr_size=addr_size;
	for (uint8_t i = 0; i < addr_size; i++)
		LT8900_addr[i] = address[addr_size-1-i];

	//Build overhead
	LT8900_BuildOverhead();

	//Set NRF RX&TX address based on overhead content
	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, LT8900_buffer_start-2);
	for(uint8_t i=0;i<LT8900_buffer_start;i++)	// reverse bytes order
		addr[i]=LT8900_buffer[LT8900_buffer_start-i-1];
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0,	addr,LT8900_buffer_start);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,	addr,LT8900_buffer_start);
}

uint8_t LT8900_ReadPayload(uint8_t* msg, uint8_t len)
{
	uint8_t i,pos=0,shift,end,buffer[32];
	unsigned int a;
	crc=LT8900_CRC_Initial_Data;
	pos=LT8900_buffer_overhead_bits/8-LT8900_buffer_start;
	end=pos+len+(LT8900_Flags&_BV(LT8900_PACKET_LENGTH_EN)?1:0)+(LT8900_Flags&_BV(LT8900_CRC_ON)?2:0);
	//Read payload
	NRF24L01_ReadPayload(buffer,end+1);
	//Check address + trail
	for(i=0;i<pos;i++)
		if(LT8900_buffer[LT8900_buffer_start+i]!=buffer[i])
			return 0; // wrong address...
	//Shift buffer to remove trail bits
	shift=LT8900_buffer_overhead_bits&0x7;
	for(i=pos;i<end;i++)
	{
		a=(buffer[i]<<8)+buffer[i+1];
		a<<=shift;
		buffer[i]=(a>>8)&0xFF;
	}
	//Check len
	if(LT8900_Flags&_BV(LT8900_PACKET_LENGTH_EN))
	{
		crc16_update(buffer[pos],8);
		if(bit_reverse(len)!=buffer[pos++])
			return 0; // wrong len...
	}
	//Decode message 
	for(i=0;i<len;i++)
	{
		crc16_update(buffer[pos],8);
		msg[i]=bit_reverse(buffer[pos++]);
	}
	//Check CRC
	if(LT8900_Flags&_BV(LT8900_CRC_ON))
	{
		if(buffer[pos++]!=((crc>>8)&0xFF)) return 0;	// wrong CRC...
		if(buffer[pos]!=(crc&0xFF)) return 0;			// wrong CRC...
	}
	//Everything ok
	return 1;
}

void LT8900_WritePayload(uint8_t* msg, uint8_t len)
{
	unsigned int a,mask;
	uint8_t i, pos=0,tmp, buffer[64], pos_final,shift;
	crc=LT8900_CRC_Initial_Data;
	//Add packet len
	if(LT8900_Flags&_BV(LT8900_PACKET_LENGTH_EN))
	{
		tmp=bit_reverse(len);
		buffer[pos++]=tmp;
		crc16_update(tmp,8);
	}
	//Add payload
	for(i=0;i<len;i++)
	{
		tmp=bit_reverse(msg[i]);
		buffer[pos++]=tmp;
		crc16_update(tmp,8);
	}
	//Add CRC
	if(LT8900_Flags&_BV(LT8900_CRC_ON))
	{
		buffer[pos++]=crc>>8;
		buffer[pos++]=crc;
	}
	//Shift everything to fit behind the trailer (4 to 18 bits)
	shift=LT8900_buffer_overhead_bits&0x7;
	pos_final=LT8900_buffer_overhead_bits/8;
	mask=~(0xFF<<(8-shift));
	LT8900_buffer[pos_final+pos]=0xFF;
	for(i=pos-1;i!=0xFF;i--)
	{
		a=buffer[i]<<(8-shift);
		LT8900_buffer[pos_final+i]=(LT8900_buffer[pos_final+i]&mask>>8)|a>>8;
		LT8900_buffer[pos_final+i+1]=(LT8900_buffer[pos_final+i+1]&mask)|a;
	}
	if(shift)
		pos++;
	//Send everything
	NRF24L01_WritePayload(LT8900_buffer+LT8900_buffer_start,pos_final+pos-LT8900_buffer_start);
}
// End of LT8900 emulation
#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NRF250K_EMU.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(CC2500_INSTALLED) || defined(NRF24L01_INSTALLED)

#include "iface_nrf250k.h"

#if defined(CC2500_INSTALLED) && defined(NRF24L01_INSTALLED)
	extern bool xn297_rf;
#endif

uint8_t cc2500_nrf_tx_addr[5], cc2500_nrf_addr_len;

static void __attribute__((unused)) NRF250K_SetTXAddr(uint8_t* addr, uint8_t len)
{
	if (len > 5) len = 5;
	if (len < 3) len = 3;
	#if defined(CC2500_INSTALLED) && defined(NRF24L01_INSTALLED)
		cc2500_nrf_addr_len = len;
		memcpy(cc2500_nrf_tx_addr, addr, len);
		if(xn297_rf == XN297_NRF)
		{
			NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, len-2);
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, addr, len);
		}
	#elif defined(CC2500_INSTALLED)
		cc2500_nrf_addr_len = len;
		memcpy(cc2500_nrf_tx_addr, addr, len);
	#elif defined(NRF24L01_INSTALLED)
		NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, len-2);
		NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, addr, len);
	#endif
}

static void __attribute__((unused)) NRF250K_WritePayload(uint8_t* msg, uint8_t len)
{
	#if defined(NRF24L01_INSTALLED)
		#if defined(CC2500_INSTALLED)
			if(xn297_rf == XN297_NRF)
		#endif
		{
			if(len<=32)
			{
				NRF24L01_FlushTx();
				NRF24L01_WriteReg(NRF24L01_07_STATUS, _BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_RX_DR) | _BV(NRF24L01_07_MAX_RT));
				NRF24L01_WritePayload(msg, len);
			}
			#if defined(CC2500_INSTALLED)
				return;
			#endif
		}
	#endif
	#if defined(CC2500_INSTALLED)
		#if defined(ESKY150V2_CC2500_INO)
			uint8_t buf[158];
		#else
			uint8_t buf[35];
		#endif
		uint8_t last = 0;
		uint8_t i;

		//nrf preamble
		if(cc2500_nrf_tx_addr[cc2500_nrf_addr_len - 1] & 0x80)
			buf[0]=0xAA;
		else
			buf[0]=0x55;
		last++;
		// address
		for (i = 0; i < cc2500_nrf_addr_len; ++i)
			buf[last++] = cc2500_nrf_tx_addr[cc2500_nrf_addr_len - i - 1];
		// payload
		for (i = 0; i < len; ++i)
			buf[last++] = msg[i];

		// crc
		crc = 0xffff;
		for (uint8_t i = 1; i < last; ++i)
			crc16_update( buf[i], 8);
		buf[last++] = crc >> 8;
		buf[last++] = crc & 0xff;
		buf[last++] = 0;

		//for(uint8_t i=0;i<last;i++)
		//	debug("%02X ",buf[i]);
		//debugln("");
		// stop TX/RX
		CC2500_Strobe(CC2500_SIDLE);
		// flush tx FIFO
		CC2500_Strobe(CC2500_SFTX);
		// packet length
		CC2500_WriteReg(CC2500_3F_TXFIFO, last);
		// transmit nrf packet
		uint8_t *buff=buf;
		uint8_t status;
		if(last>63)
		{
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, buff, 63);
			CC2500_Strobe(CC2500_STX);
			last-=63;
			buff+=63;
			while(last)
			{//Loop until all the data is sent
				do
				{// Wait for the FIFO to become available
					status=CC2500_ReadReg(CC2500_3A_TXBYTES | CC2500_READ_BURST);
				}
				while((status&0x7F)>31 && (status&0x80)==0);
				if(last>31)
				{//Send 31 bytes
					CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, buff, 31);
					last-=31;
					buff+=31;
				}
				else
				{//Send last bytes
					CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, buff, last);
					last=0;
				}
			}
		}
		else
		{//Send packet
			CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, buff, last);
			CC2500_Strobe(CC2500_STX);
		}
	#endif
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/NanoRF_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(NANORF_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define NANORF_PACKET_PERIOD		40000
#define NANORF_INITIAL_WAIT			500
#define NANORF_RF_CHANNEL			40
#define NANORF_PAYLOADSIZE			7

static void __attribute__((unused)) NANORF_send_packet()
{
	packet[0] = convert_channel_8b(AILERON);
	packet[1] = convert_channel_8b(ELEVATOR);
	packet[2] = convert_channel_8b(THROTTLE);
	packet[3] = convert_channel_8b(RUDDER);
	packet[4] = convert_channel_8b(CH5);
	packet[5] = convert_channel_8b(CH6);
	packet[6] = 0;
	for (uint8_t i=0; i < NANORF_PAYLOADSIZE-1; i++)
		packet[6] += packet[i];
	packet[6] += 0x55;

	// clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, NANORF_PAYLOADSIZE);

}

static void __attribute__((unused)) NANORF_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR , (uint8_t *)"Nano1",5);
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, NANORF_RF_CHANNEL);
}

uint16_t NANORF_callback()
{
	NANORF_send_packet();
	return NANORF_PACKET_PERIOD;
}

void NANORF_init()
{	
	BIND_DONE;
	NANORF_RF_init();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/OMP_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(OMP_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_OMP_ORIGINAL_ID
//#define OMP_TELEM_DEBUG

#define OMP_INITIAL_WAIT	500
#define OMP_PACKET_PERIOD	5000
#define OMP_RF_BIND_CHANNEL	35
#define OMP_RF_NUM_CHANNELS	8
#define OMP_PAYLOAD_SIZE	16
#define OMP_BIND_COUNT		600	//3sec

static void __attribute__((unused)) OMP_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(packet,"BND",3);
		memcpy(&packet[3],rx_tx_addr,5);
		memcpy(&packet[8],hopping_frequency,8);
	}
	else
	{
		memset(packet,0x00,OMP_PAYLOAD_SIZE);

#ifdef OMP_HUB_TELEMETRY
		//RX telem request every 7*5=35ms
		packet_sent++;
		packet_sent %= OMP_RF_NUM_CHANNELS-1;			// Change telem RX channels every time
		if(packet_sent==0)
			packet[0] |= 0x40;							// |0x40 to request RX telemetry
#endif
		
		//hopping frequency
		packet[0 ] |= hopping_frequency_no;
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no &= OMP_RF_NUM_CHANNELS-1;	// 8 RF channels

		//flags
		packet[1 ] = 0x08								//unknown
				   | GET_FLAG(CH5_SW, 0x20);			// HOLD

		packet[2 ] = 0x40;								//unknown
		
		if(Channel_data[CH6] > CHANNEL_MAX_COMMAND)
			packet[2 ] |= 0x20;							// IDLE2
		else if(Channel_data[CH6] > CHANNEL_MIN_COMMAND)
			packet[1 ] |= 0x40;							// IDLE1

		if(Channel_data[CH7] > CHANNEL_MAX_COMMAND)
			packet[2 ] |= 0x08;							// 3D
		else if(Channel_data[CH7] > CHANNEL_MIN_COMMAND)
			packet[2 ] |= 0x04;							// ATTITUDE

		//trims??
		//packet[3..6]

		//channels TAER packed 11bits
		uint16_t channel=convert_channel_16b_limit(THROTTLE,0,2047);
		packet[7 ]  = channel;
		packet[8 ]  = channel>>8;
		channel=convert_channel_16b_limit(AILERON,2047,0);
		packet[8 ] |= channel<<3;
		packet[9 ]  = channel>>5;
		channel=convert_channel_16b_limit(ELEVATOR,0,2047);
		packet[9] |= channel<<6;
		packet[10]  = channel>>2;
		packet[11]  = channel>>10;
		channel=convert_channel_16b_limit(RUDDER,2047,0);
		packet[11] |= channel<<1;
		packet[12]  = channel>>7;

		//unknown
		//packet[13..15]
		packet[15] = 0x04;
	}

	XN297_SetPower();									// Set tx_power
	XN297_SetFreqOffset();								// Set frequency offset
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, OMP_PAYLOAD_SIZE, packet_sent!=0);
}

static void __attribute__((unused)) OMP_RF_init()
{
	//Config CC2500
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	XN297_SetTXAddr((uint8_t*)"FLPBD", 5);
	XN297_HoppingCalib(OMP_RF_NUM_CHANNELS);	// Calibrate all channels
	XN297_RFChannel(OMP_RF_BIND_CHANNEL);		// Set bind channel

#ifdef OMP_HUB_TELEMETRY
	XN297_SetRXAddr(rx_tx_addr, OMP_PAYLOAD_SIZE);
#endif
}

static void __attribute__((unused)) OMP_initialize_txid()
{
	calc_fh_channels(OMP_RF_NUM_CHANNELS);
	#ifdef FORCE_OMP_ORIGINAL_ID
		rx_tx_addr[0]=0x4E;
		rx_tx_addr[1]=0x72;
		rx_tx_addr[2]=0x8E;
		rx_tx_addr[3]=0x70;
		rx_tx_addr[4]=0x62;
		for(uint8_t i=0; i<OMP_RF_NUM_CHANNELS;i++)
			hopping_frequency[i]=(i+3)*5;
	#endif
}

#ifdef OMP_HUB_TELEMETRY
	static void __attribute__((unused)) OMP_Send_Telemetry(uint8_t v)
	{
		v_lipo1=v;
		telemetry_counter++;	//LQI
		telemetry_link=1;
		if(telemetry_lost)
		{
			telemetry_lost = 0;
			packet_count = 100;
			telemetry_counter = 100;
		}
	}
#endif

enum {
	OMP_BIND		= 0x00,
	OMP_PREPDATA	= 0x01,
	OMP_DATA		= 0x02,
	OMP_RX			= 0x03,
};

#define OMP_WRITE_TIME 850

uint16_t OMP_callback()
{
	bool rx;
	
	switch(phase)
	{
		case OMP_BIND:
			if(--bind_counter==0)
				phase++;						// OMP_PREPDATA
			OMP_send_packet();
			return OMP_PACKET_PERIOD;
		case OMP_PREPDATA:
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);
			phase++;							// OMP_DATA
		case OMP_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(OMP_PACKET_PERIOD);
			#endif
			#ifdef OMP_HUB_TELEMETRY
				rx = XN297_IsRX();				// Needed for the NRF24L01 since otherwise the bit gets cleared
			#endif
			OMP_send_packet();
			#ifdef OMP_HUB_TELEMETRY
				if(packet_sent == 0)
				{
					phase++;					// OMP_RX
					return OMP_WRITE_TIME;
				}
				else if(packet_sent == 1)
				{
					if( rx )
					{ // a packet has been received
						#ifdef OMP_TELEM_DEBUG
							debug("RX :");
						#endif
						if(XN297_ReadEnhancedPayload(packet_in, OMP_PAYLOAD_SIZE) == OMP_PAYLOAD_SIZE)
						{ // packet with good CRC and length
							#ifdef OMP_TELEM_DEBUG
								debug("OK :");
								for(uint8_t i=0;i<OMP_PAYLOAD_SIZE;i++)
									debug(" %02X",packet_in[i]);
							#endif
							// packet_in = 01 00 98 2C 03 19 19 F0 49 02 00 00 00 00 00 00
							// all bytes are fixed and unknown except 2 and 3 which represent the battery voltage: packet_in[3]*256+packet_in[2]=lipo voltage*100 in V
							uint16_t v=((packet_in[3]<<8)+packet_in[2]-400)/50;
							if(v>255) v=255;
							v_lipo2=v;
							OMP_Send_Telemetry(v);
						}
						else
						{ // As soon as the motor spins the telem packets are becoming really bad and the CRC throws most of them in error as it should but...
							#ifdef OMP_TELEM_DEBUG
								debug("NOK:");
								for(uint8_t i=0;i<OMP_PAYLOAD_SIZE;i++)
										debug(" %02X",packet_in[i]);
							#endif
							if(packet_in[0]==0x01 && packet_in[1]==0x00)
							{// the start of the packet looks ok...
								uint16_t v=((packet_in[3]<<8)+packet_in[2]-400)/50;
								if(v<260 && v>180)
								{ //voltage is less than 13V and more than 9V (3V/element)
									if(v>255) v=255;
									uint16_t v1=v-v_lipo2;
									if(v1&0x8000) v1=-v1;
									if(v1<20) // the batt voltage is within 1V from a good reading...
									{
										OMP_Send_Telemetry(v);	// ok to send
										#ifdef OMP_TELEM_DEBUG
											debug(" OK");
										#endif
									}
								}
							}
							else
								telemetry_counter++;	//LQI
						}
						#ifdef OMP_TELEM_DEBUG
							debugln("");
						#endif
					}
					XN297_SetTxRxMode(TXRX_OFF);
					packet_count++;
					if(packet_count>=100)
					{//LQI calculation
						packet_count=0;
						TX_LQI=telemetry_counter;
						RX_RSSI=telemetry_counter;
						if(telemetry_counter==0)
							telemetry_lost = 1;
						telemetry_counter = 0;
					}
				}
			#endif
			return OMP_PACKET_PERIOD;
	#ifdef OMP_HUB_TELEMETRY
		case OMP_RX:
			{
				uint16_t start=(uint16_t)micros();
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
				{
					if(XN297_IsPacketSent())
						break;
				}
			}
			XN297_SetTxRxMode(RX_EN);
			phase = OMP_DATA;
			return OMP_PACKET_PERIOD-OMP_WRITE_TIME;
	#endif
	}
	return OMP_PACKET_PERIOD;
}

void OMP_init()
{
	OMP_initialize_txid();
	OMP_RF_init();
	hopping_frequency_no = 0;
	packet_sent = 0;
	#ifdef OMP_HUB_TELEMETRY
		packet_count = 0;
		telemetry_lost = 1;
	#endif
	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter = OMP_BIND_COUNT;
		phase = OMP_BIND;
	}
	else
		phase = OMP_PREPDATA;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/POTENSIC_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
  */

#if defined(POTENSIC_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_POTENSIC_ORIGINAL_ID

#define POTENSIC_PACKET_PERIOD		4100 // Timeout for callback in uSec
#define POTENSIC_INITIAL_WAIT		500
#define POTENSIC_PACKET_SIZE		10
#define POTENSIC_BIND_COUNT			400
#define POTENSIC_RF_NUM_CHANNELS	4

static void __attribute__((unused)) POTENSIC_set_checksum()
{
	uint8_t checksum = packet[1];
	for(uint8_t i=2; i<POTENSIC_PACKET_SIZE-2; i++)
		checksum += packet[i];
	packet[8] |= checksum & 0x0f;
}

static void __attribute__((unused)) POTENSIC_send_packet()
{
	packet[8]=0;
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x61;
		memcpy(&packet[1],rx_tx_addr,5);
		packet[6] = 0x20;
		packet[7] = 0xC0;
	}
	else
	{ 
		packet[0] = 0x64;
		// Deadband is needed on throttle to emulate the spring to neutral otherwise the quad behaves weirdly, 160 gives +-20%
		packet[1] = convert_channel_8b_limit_deadband(THROTTLE,0x00,0x19,0x32,160)<<1;	// Throttle 00..19..32 *2
		uint8_t elevator=convert_channel_8b(ELEVATOR)>>3;			
		packet[2] = ((255-convert_channel_8b(RUDDER))&0xF8)|(elevator>>2);
		packet[3] = (elevator<<6)|(((255-convert_channel_8b(AILERON))>>2)&0xFE);
		packet[4] = 0x20;	// Trim
		packet[5] = 0x20	// Trim
					| GET_FLAG(CH7_SW, 0x80);			// High: +100%
		packet[6] = 0x20;	// Trim
		packet[7] = 0x40								// Low: -100%
					| GET_FLAG((Channel_data[CH7] > CHANNEL_MIN_COMMAND && !CH7_SW), 0x80)	// Medium: 0%
					| GET_FLAG((CH5_SW||CH6_SW), 0x02)	// Momentary Take off/Landing + Emergency
					| GET_FLAG(CH8_SW, 0x04);			// Headless: -100%=off,+100%=on
		packet[8] = GET_FLAG(CH6_SW, 0x80);				// Emergency
	}
	POTENSIC_set_checksum();
	packet[9] = hopping_frequency_no;
	
	//RF channel
	XN297_Hopping(hopping_frequency_no&0x03);
	hopping_frequency_no++;

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, POTENSIC_PACKET_SIZE);
}

static void __attribute__((unused)) POTENSIC_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);

	if(IS_BIND_IN_PROGRESS)
		XN297_SetTXAddr((uint8_t*)"\x01\x01\x01\x01\x06", 5);	// Bind address
	else
		XN297_SetTXAddr(rx_tx_addr,5);							// Normal address
}

static void __attribute__((unused)) POTENSIC_initialize_txid()
{
	#ifdef FORCE_POTENSIC_ORIGINAL_ID
		memcpy(rx_tx_addr,(uint8_t *)"\xF6\xE0\x20\x00\x0E",5);
	#endif
	memcpy(hopping_frequency,(uint8_t *)"\x32\x3E\x3A\x36",POTENSIC_RF_NUM_CHANNELS); //50, 62, 58, 54
}

uint16_t POTENSIC_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(POTENSIC_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr,5);
		}
	POTENSIC_send_packet();
	return POTENSIC_PACKET_PERIOD;
}

void POTENSIC_init(void)
{
	bind_counter = POTENSIC_BIND_COUNT;
	POTENSIC_initialize_txid();
	POTENSIC_RF_init();
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Pelikan_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with CADET PRO V4 TX

#if defined(PELIKAN_A7105_INO)

#include "iface_a7105.h"

//#define PELIKAN_FORCE_ID
//#define PELIKAN_LITE_FORCE_ID
#define PELIKAN_LITE_FORCE_HOP				// hop sequence creation is unknown
//#define PELIKAN_SCX24_FORCE_ID
//#define PELIKAN_SCX24_FORCE_HOP				// hop sequence creation is unknown

#define PELIKAN_BIND_COUNT		400			// 3sec
#define PELIKAN_BIND_RF			0x3C
#define PELIKAN_NUM_RF_CHAN 	0x1D
#define PELIKAN_PACKET_PERIOD	7980
#define PELIKAN_LITE_PACKET_PERIOD 18000
#define PELIKAN_SCX24_PACKET_PERIOD 15069
#define PELIKAN_SCX_HOP_LIMIT 90

static void __attribute__((unused)) pelikan_build_packet()
{
	static boolean upper=false;
	uint8_t sum;
	uint16_t channel;

	#ifndef MULTI_AIR
	if(sub_protocol == PELIKAN_SCX24)
		packet[0] = 0x11;
	else //PELIKAN_PRO & PELIKAN_LITE
	#endif
		packet[0] = 0x15;
    if(IS_BIND_IN_PROGRESS)
	{
		packet[2] = rx_tx_addr[0];
		packet[3] = rx_tx_addr[1];
		packet[4] = rx_tx_addr[2];
		packet[5] = rx_tx_addr[3];

		#ifndef MULTI_AIR
		if(sub_protocol == PELIKAN_SCX24)
		{
			packet[1] = 0x65;				//??
			packet[6] = 0x55;				//??
			packet[7] = 0xAA;				//??
		}
		else
		#endif
		{//PELIKAN_PRO & PELIKAN_LITE
			packet[1] = 0x04;				//version??
			if(sub_protocol==PELIKAN_PRO)
				packet[6] = 0x05;			//sub version??
			else //PELIKAN_LITE
				packet[6] = 0x03;			//sub version??
			packet[7] = 0x00;				//??
		}
		packet[8] = 0x55;					//??
		packet_length = 10;
	}
	else
	{
		//ID
		packet[1]  = rx_tx_addr[0];
		#ifndef MULTI_AIR
		if(sub_protocol == PELIKAN_SCX24)
		{
			//ID
			packet[4]  = rx_tx_addr[1];
			//Channels
			channel = Channel_data[0];		//STEERING: 1B1..23B..2C5 ???
			packet[2]  = channel >> 9;
			packet[3]  = channel >> 1;
			channel = Channel_data[1];		//THROTTLE: 0DB..1FF..30E
			packet[5]  = channel >> 9;
			packet[6]  = channel >> 1;
			channel = Channel_data[2];		//CH3: 055..3AA
			packet[7]  = channel >> 9;
			packet[8]  = channel >> 1;
			//Hopping counters
			if(++packet_count>2)
			{
				packet_count=0;
				if(++hopping_frequency_no>=PELIKAN_NUM_RF_CHAN)
					hopping_frequency_no=0;
			}
			//Length
			packet_length = 14;
		}
		else
		#endif
		{//PELIKAN_PRO & PELIKAN_LITE
			//ID
			packet[7]  = rx_tx_addr[1];
			//Channels
			uint8_t offset=upper?4:0;
			channel=convert_channel_16b_nolimit(CH_AETR[offset++], 153, 871,false);
			uint8_t top=(channel>>2) & 0xC0;
			packet[2]  = channel;
			channel=convert_channel_16b_nolimit(CH_AETR[offset++], 153, 871,false);
			top|=(channel>>4) & 0x30;
			packet[3]  = channel;
			channel=convert_channel_16b_nolimit(CH_AETR[offset++], 153, 871,false);
			top|=(channel>>6) & 0x0C;
			packet[4]  = channel;
			channel=convert_channel_16b_nolimit(CH_AETR[offset], 153, 871,false);
			top|=(channel>>8) & 0x03;
			packet[5]  = channel;
			packet[6]  = top;
			//Check
			sum=0x00;
			for(uint8_t i=0;i<8;i++)
				sum+=packet[i];
			packet[8]=sum;
			//Low/Up channel flag
			packet[9]=upper?0xAA:0x00;
			upper=!upper;
			//Hopping counters
			if(sub_protocol==PELIKAN_LITE || ++packet_count>4)
			{
				packet_count=0;
				if(++hopping_frequency_no>=PELIKAN_NUM_RF_CHAN)
					hopping_frequency_no=0;
			}
			//Length
			packet_length = 15;
		}
		//Hopping
		packet[packet_length-5] = hopping_frequency_no;
		packet[packet_length-4] = packet_count;
		//ID
		packet[packet_length-3] = rx_tx_addr[2];
		packet[packet_length-2] = rx_tx_addr[3];
	}

	//Check
	sum=0x00;
	for(uint8_t i=0; i<packet_length-1 ;i++)
		sum+=packet[i];
	packet[packet_length-1] = sum;

	//Send
	#ifdef DEBUG_SERIAL
		debug("C: %02X P(%d):",IS_BIND_IN_PROGRESS?PELIKAN_BIND_RF:hopping_frequency[hopping_frequency_no],packet_length);
		for(uint8_t i=0;i<packet_length;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
	A7105_WriteData(packet_length, IS_BIND_IN_PROGRESS?PELIKAN_BIND_RF:hopping_frequency[hopping_frequency_no]);
	A7105_SetPower();
}

uint16_t PELIKAN_callback()
{
	#ifdef MULTI_AIR
		if(sub_protocol == PELIKAN_SCX24)
		{
			SUB_PROTO_INVALID;
			return 10000;
		}
	#endif
	if(phase==0)
	{
		#ifndef FORCE_PELIKAN_TUNING
			A7105_AdjustLOBaseFreq(1);
		#endif
		if(IS_BIND_IN_PROGRESS)
		{
			bind_counter--;
			if (bind_counter==0)
			{
				BIND_DONE;
				A7105_Strobe(A7105_STANDBY);
				if(sub_protocol==PELIKAN_PRO)
					A7105_WriteReg(A7105_03_FIFOI,0x28); //????
				else if(sub_protocol==PELIKAN_LITE)
					A7105_WriteID(MProtocol_id);
				#ifndef MULTI_AIR
				else // PELIKAN_SCX24
					A7105_WriteReg(A7105_03_FIFOI,0x0D);
				#endif
			}
		}
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(packet_period);
		#endif
		pelikan_build_packet();
		if(IS_BIND_IN_PROGRESS || sub_protocol != PELIKAN_LITE)
			return packet_period;
		//PELIKAN_LITE
		phase++;
		return 942;
	}
	//PELIKAN_LITE
	A7105_Strobe(A7105_TX);
	phase++;
	if(phase==1)
		return 942;
	phase=0;
	return PELIKAN_LITE_PACKET_PERIOD-942-942;
}

static uint8_t pelikan_firstCh(uint8_t u, uint8_t l)
{
	int16_t i;
	i = u * 10 + l - 23;
	do
	{
		if (i > 24)
			i -= 24;
		if (i <= 0)
			return 10;
		else if ((i > 0) && (i < 13))
			return 10 + 12 + (i * 4);
		else if ((i > 12) && (i < 24))
			return 10 - 2 + ((i - 12) * 4);
	}
	while (i > 24);
	return 0;
}

static uint8_t pelikan_firstCh_scx(uint8_t i, uint8_t j)
{
	uint8_t ch;
	switch (j) {
		case 0:
			ch = 30;
			break;
		case 1:
		case 2:
			ch = (i * 4) + 42;
			break;
		case 3:
			ch = (i * 2) + 36;
			break;
		case 4:
			ch = (i * 8) + 54;
			break;
		case 5:
			ch = 30;
			break;
	}

	if (ch > PELIKAN_SCX_HOP_LIMIT)
	{
		do
		{
			ch -= 62;
		} while (ch > PELIKAN_SCX_HOP_LIMIT);
	}

	switch (ch) {
		case 48:
			if (j == 3)
				ch += 18;
			else if (j == 4)
				ch += 20;
			else
				ch += 40;
			break;
		case 40:
			if (j == 4)
				ch += 18;
			break;
		case 52:
			if (j < 3)
				ch -= 20;
			else if (j == 4)
				ch -= 10;
			break;
		case 66:
			if  (j < 3)
				ch += 18;
			else if (j == 4)
				ch -= 22;
			break;
		case 72:
			if (j < 3)
				ch -= 10;
			else if (j ==3)
				ch -= 20;
			else if (j == 4)
				ch -= 36;
			break;
		case 74:
			if (j == 4)
				ch -= 20;
			break;
		case 86:
			if (j == 4)
				ch -= 48;
			break;
	}

	return ch;
}

static uint8_t pelikan_adjust_value(uint8_t value, uint8_t addition, uint8_t limit)
{
	uint8_t i;
	do
	{
		i = 0;
		if (value > limit) {
			value -= 62;
			i++;
		}
		if (value == 24) {
			value += addition;
			i++;
		}
		if (value == 48) {
			value += addition;
			i++;
		}
		if (value == 72) {
			value += addition;
			i++;
		}
	}
	while (i > 0);

	return value;
}

static uint8_t pelikan_add(uint8_t pfrq,uint8_t a, uint8_t limit)
{
	uint8_t nfrq;
	nfrq = pfrq + a;

	nfrq = pelikan_adjust_value(nfrq, a, limit);
	
	return nfrq;
}

static void __attribute__((unused)) pelikan_init_hop()
{
	#define PELIKAN_HOP_LIMIT 70
	rx_tx_addr[0] = 0;
	rx_tx_addr[1]+= RX_num;
	uint8_t high = (rx_tx_addr[1]>>4) % 3;	// 0..2
	uint8_t low = rx_tx_addr[1] & 0x0F;
	if(high==2)
		low %= 0x04;	// 0..3
	else if(high)
		low %= 0x0E;	// 0..D
	else
		low %= 0x0F;	// 0..E
	rx_tx_addr[1] = (high<<4) + low;
	uint8_t addition = (20 * high)+ (2 * low) + 8;

	uint8_t first_channel = pelikan_firstCh(high, low);
	first_channel = pelikan_adjust_value(first_channel, addition, PELIKAN_HOP_LIMIT);
	hopping_frequency[0] = first_channel;
	debug("%02X", first_channel);
	for (uint8_t i = 1; i < PELIKAN_NUM_RF_CHAN; i++)
	{
		hopping_frequency[i] = pelikan_add(hopping_frequency[i-1], addition, PELIKAN_HOP_LIMIT);
		debug(" %02X", hopping_frequency[i]);
	}
	debugln("");
}

#ifndef MULTI_AIR

const uint8_t PROGMEM scx_ch_map[4][PELIKAN_NUM_RF_CHAN] = 
	{
		{0,1,2,26,27,28,23,24,25,20,21,22,17,18,19,14,15,16,11,12,13,8,9,10,5,6,7,4,3},
		{0,1,2,28,25,26,27,24,21,22,23,20,17,18,19,16,13,14,15,12,9,10,11,8,5,6,7,3,4},
		{0,1,27,28,25,26,23,24,21,22,19,20,17,18,15,16,13,14,11,12,9,10,7,8,5,6,3,4,2},
		{0,1,28,1,4,2,23,26,22,24,27,25,17,20,16,18,21,19,11,14,10,12,15,13,27,8,6,7,9}
	};

static void pelikan_shuffle(uint8_t j)
{
	uint8_t temp[PELIKAN_NUM_RF_CHAN];
	for (uint8_t i = 0; i < PELIKAN_NUM_RF_CHAN; i++)
		temp[i] = hopping_frequency[pgm_read_byte_near(&scx_ch_map[j-1][i])];

	for (uint8_t i = 0; i < PELIKAN_NUM_RF_CHAN; i++)
		hopping_frequency[i] = temp[i];
}

static void __attribute__((unused)) pelikan_init_hop_scx()
{
	rx_tx_addr[0] = 0x10;
	rx_tx_addr[1] = (rx_tx_addr[1] + RX_num) % 192;
	debugln("TX[0]: %02X TX[1]: %02X", rx_tx_addr[0], rx_tx_addr[1]);
	
	uint8_t high = (rx_tx_addr[1]>>4);
	uint8_t low = rx_tx_addr[1] & 0x0F;
	int16_t i = (high * 10) + low - 23;
	uint8_t j = 0;

	if (i > 0)
		j = 1;
	
	if (i > 24)
	{
		do
		{
			i -= 24;
			j++;
		} while (i > 24);
	}

	debugln("H: %02X L: %02X I: %02X J: %02X", high, low, i, j);

	uint8_t first_channel;
	uint8_t last_channel;
	uint8_t addition;

	first_channel = pelikan_firstCh_scx(i, j);

	if (j == 0)
		last_channel = 42 - (high * 10) - low;
	else
		last_channel = 42 - i + 1;

	if (last_channel == 24)
		last_channel += 9;
	
	if (last_channel == 36)
		last_channel -= 10;

	if (j == 0)
		addition = (2 * i) + 54;
	else if (j == 5)
		addition = (2 * i) + 6;
	else
		addition = 56 - (2 * i);

	hopping_frequency[0] = first_channel;
	for (uint8_t i = 1; i < PELIKAN_NUM_RF_CHAN; i++)
	{
		hopping_frequency[i] = pelikan_add(hopping_frequency[i-1], addition, PELIKAN_SCX_HOP_LIMIT);
	}

	if (j > 0 && j < 5)
		pelikan_shuffle(j);

	if (j == 2)
	{
		hopping_frequency[PELIKAN_NUM_RF_CHAN - 2] = last_channel;
	} else if (j == 4)
	{
		uint8_t t = (2 * i) + 36;
		if (t == 48)
			t += 18;
		if (t == 72)
			t -= 20;

		hopping_frequency[1] = t;
		hopping_frequency[PELIKAN_NUM_RF_CHAN - 5] = last_channel;
	}	
	else
	{
		hopping_frequency[PELIKAN_NUM_RF_CHAN - 1] = last_channel;
	}

	#ifdef DEBUG_SERIAL
		for (uint8_t i = 0; i < PELIKAN_NUM_RF_CHAN; i++)
			debug("%02X ", hopping_frequency[i]);
		debugln("");
	#endif
}

#ifdef PELIKAN_SCX24_FORCE_HOP
const uint8_t PROGMEM pelikan_scx24_hopp[][PELIKAN_NUM_RF_CHAN] = {
/*TX1*/	{ 0x1E,0x32,0x46,0x5A,0x44,0x58,0x2E,0x42,0x56,0x2C,0x40,0x54,0x2A,0x3E,0x52,0x28,0x3C,0x50,0x26,0x3A,0x4E,0x24,0x38,0x4C,0x22,0x36,0x4A,0x20,0x1A },
/*TX2*/	{ 0x2C,0x44,0x1E,0x52,0x56,0x22,0x3A,0x3E,0x34,0x4C,0x26,0x5A,0x50,0x2A,0x42,0x38,0x2E,0x46,0x20,0x54,0x4A,0x24,0x3C,0x32,0x28,0x40,0x58,0x1B,0x4E },
/*TX3*/	{ 0x3C,0x4C,0x1E,0x4A,0x5A,0x2C,0x58,0x2A,0x3A,0x56,0x28,0x38,0x26,0x36,0x46,0x34,0x44,0x54,0x42,0x52,0x24,0x50,0x22,0x32,0x4E,0x20,0x40,0x3E,0x17 },
/*TX4*/	{ 0x46,0x32,0x1E,0x58,0x44,0x5A,0x56,0x42,0x2E,0x54,0x40,0x2C,0x52,0x3E,0x2A,0x50,0x3C,0x28,0x4E,0x3A,0x26,0x4C,0x38,0x24,0x4A,0x36,0x22,0x20,0x1A }
};
#endif //PELIKAN_SCX24_FORCE_HOP

#endif //MULTI_AIR

#ifdef PELIKAN_FORCE_ID
const uint8_t PROGMEM pelikan_hopp[][PELIKAN_NUM_RF_CHAN] = {
	{ 0x5A,0x46,0x32,0x6E,0x6C,0x58,0x44,0x42,0x40,0x6A,0x56,0x54,0x52,0x3E,0x68,0x66,0x64,0x50,0x3C,0x3A,0x38,0x62,0x4E,0x4C,0x5E,0x4A,0x36,0x5C,0x34 }
};
#endif

#ifdef PELIKAN_LITE_FORCE_HOP
const uint8_t PROGMEM pelikan_lite_hopp[][PELIKAN_NUM_RF_CHAN] = {
	{ 0x46,0x2A,0x3E,0x5A,0x5C,0x24,0x4E,0x32,0x54,0x26,0x2C,0x34,0x56,0x1E,0x3A,0x3C,0x50,0x4A,0x2E,0x42,0x20,0x52,0x28,0x22,0x44,0x58,0x36,0x38,0x4C }
};
#endif

void PELIKAN_init()
{
	A7105_Init();
	if(IS_BIND_IN_PROGRESS || sub_protocol==PELIKAN_LITE)
		A7105_WriteReg(A7105_03_FIFOI,0x10);

	bind_counter = PELIKAN_BIND_COUNT;

	if(sub_protocol==PELIKAN_PRO)
	{
		pelikan_init_hop();
		//ID from dump
		#if defined(PELIKAN_FORCE_ID)
			rx_tx_addr[0]=0x0D;		// hopping freq
			rx_tx_addr[1]=0xF4;		// hopping freq
			rx_tx_addr[2]=0x50;		// ID
			rx_tx_addr[3]=0x18;		// ID
			// Fill frequency table
			for(uint8_t i=0;i<PELIKAN_NUM_RF_CHAN;i++)
				hopping_frequency[i]=pgm_read_byte_near(&pelikan_hopp[0][i]);
		#endif
		packet_period = PELIKAN_PACKET_PERIOD;
	}
	else
	{
		bind_counter >>= 1;
		if(sub_protocol==PELIKAN_LITE)
		{
			#if defined(PELIKAN_LITE_FORCE_HOP)
				// Hop frequency table
				rx_tx_addr[0]=0x04;		// hopping freq
				rx_tx_addr[1]=0x63;		// hopping freq
				for(uint8_t i=0;i<PELIKAN_NUM_RF_CHAN;i++)
					hopping_frequency[i]=pgm_read_byte_near(&pelikan_lite_hopp[0][i]);
			#endif
			#if defined(PELIKAN_LITE_FORCE_ID)
				// ID
				rx_tx_addr[2]=0x60;
				rx_tx_addr[3]=0x18;
			#endif
			MProtocol_id = ((uint32_t)rx_tx_addr[0]<<24)|((uint32_t)rx_tx_addr[1]<<16)|((uint32_t)rx_tx_addr[2]<<8)|(rx_tx_addr[3]);
			if(IS_BIND_DONE)
				A7105_WriteID(MProtocol_id);
			packet_period = PELIKAN_LITE_PACKET_PERIOD;
		}
		#ifndef MULTI_AIR
		else// if(sub_protocol==PELIKAN_SCX24)
		{
			pelikan_init_hop_scx();
			#if defined(PELIKAN_SCX24_FORCE_HOP)
				// Hop frequency table
				uint8_t num=rx_tx_addr[3] & 0x03;
				switch(num)
				{
					case 1:
						rx_tx_addr[0]=0x10;		// hopping freq TX2
						rx_tx_addr[1]=0x63;		// hopping freq TX2
						break;
					case 2:
						rx_tx_addr[0]=0x81;		// hopping freq TX3
						rx_tx_addr[1]=0x63;		// hopping freq TX3
						break;
					case 3:
						rx_tx_addr[0]=0x36;		// hopping freq TX4
						rx_tx_addr[1]=0x5C;		// hopping freq TX4
						break;
					default:
						rx_tx_addr[0]=0x12;		// hopping freq TX1
						rx_tx_addr[1]=0x46;		// hopping freq TX1
						break;
				}
				for(uint8_t i=0;i<PELIKAN_NUM_RF_CHAN;i++)
					hopping_frequency[i]=pgm_read_byte_near(&pelikan_scx24_hopp[num][i]);
			#endif
			#if defined(PELIKAN_SCX24_FORCE_ID)
				// ID
				rx_tx_addr[2]=0x80;			// TX1
				rx_tx_addr[3]=0x19;			// TX1
				rx_tx_addr[2]=0x80;			// TX2
				rx_tx_addr[3]=0x22;			// TX2
				rx_tx_addr[2]=0x30;			// TX3
				rx_tx_addr[3]=0x18;			// TX3
				rx_tx_addr[2]=0x30;			// TX4
				rx_tx_addr[3]=0x17;			// TX4
			#endif
			A7105_WriteReg(A7105_0E_DATA_RATE,0x03);
			if(IS_BIND_DONE)
				A7105_WriteReg(A7105_03_FIFOI,0x0D);
			packet_period = PELIKAN_SCX24_PACKET_PERIOD;
		}
		#endif //MULTI_AIR
	}

	hopping_frequency_no = PELIKAN_NUM_RF_CHAN;
	packet_count = 5;
	phase = 0;
	bind_counter = PELIKAN_BIND_COUNT;
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Propel_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with PROPEL 74-Z Speeder Bike.

#if defined(PROPEL_NRF24L01_INO)

#include "iface_nrf24l01.h"

//#define PROPEL_FORCE_ID

#define PROPEL_INITIAL_WAIT		500
#define PROPEL_PACKET_PERIOD	10000
#define PROPEL_BIND_RF_CHANNEL	0x23
#define PROPEL_PAYLOAD_SIZE		16
#define PROPEL_SEARCH_PERIOD	50	//*10ms
#define PROPEL_BIND_PERIOD		1500
#define PROPEL_PACKET_SIZE		14
#define PROPEL_RF_NUM_CHANNELS	4
#define PROPEL_ADDRESS_LENGTH	5
#define PROPEL_DEFAULT_PERIOD	20

enum {
	PROPEL_BIND1 = 0,
	PROPEL_BIND2,
	PROPEL_BIND3,
	PROPEL_DATA1,
};

static uint16_t __attribute__((unused)) PROPEL_checksum()
{
	typedef union {
		struct {
			uint8_t h:1;
			uint8_t g:1;
			uint8_t f:1;
			uint8_t e:1;
			uint8_t d:1;
			uint8_t c:1;
			uint8_t b:1;
			uint8_t a:1;
		} bits;
		uint8_t byte:8;
	} byte_bits_t;

    uint8_t sum = packet[0];
    for (uint8_t i = 1; i < PROPEL_PACKET_SIZE - 2; i++)
        sum += packet[i];

    byte_bits_t in  = { .byte = sum };
    byte_bits_t out = { .byte = sum };
	out.byte ^= 0x0a;
    out.bits.d = !(in.bits.d ^ in.bits.h);
    out.bits.c = (!in.bits.c && !in.bits.d &&  in.bits.g)
              ||  (in.bits.c && !in.bits.d && !in.bits.g)
              || (!in.bits.c &&  in.bits.g && !in.bits.h)
              ||  (in.bits.c && !in.bits.g && !in.bits.h)
              ||  (in.bits.c &&  in.bits.d &&  in.bits.g &&  in.bits.h)
              || (!in.bits.c &&  in.bits.d && !in.bits.g &&  in.bits.h);
    out.bits.b = (!in.bits.b && !in.bits.c && !in.bits.d)
              ||  (in.bits.b &&  in.bits.c &&  in.bits.g)
              || (!in.bits.b && !in.bits.c && !in.bits.g)
              || (!in.bits.b && !in.bits.d && !in.bits.g)
              || (!in.bits.b && !in.bits.c && !in.bits.h)
              || (!in.bits.b && !in.bits.g && !in.bits.h)
              ||  (in.bits.b &&  in.bits.c &&  in.bits.d &&  in.bits.h)
              ||  (in.bits.b &&  in.bits.d &&  in.bits.g &&  in.bits.h);
    out.bits.a =  (in.bits.a && !in.bits.b)
              ||  (in.bits.a && !in.bits.c && !in.bits.d)
              ||  (in.bits.a && !in.bits.c && !in.bits.g)
              ||  (in.bits.a && !in.bits.d && !in.bits.g)
              ||  (in.bits.a && !in.bits.c && !in.bits.h)
              ||  (in.bits.a && !in.bits.g && !in.bits.h)
              || (!in.bits.a &&  in.bits.b &&  in.bits.c &&  in.bits.g)
              || (!in.bits.a &&  in.bits.b &&  in.bits.c &&  in.bits.d &&  in.bits.h)
              || (!in.bits.a &&  in.bits.b &&  in.bits.d &&  in.bits.g &&  in.bits.h);

    return (sum << 8) | (out.byte & 0xff);
}

static void __attribute__((unused)) PROPEL_bind_packet(bool valid_rx_id)
{
	memset(packet, 0, PROPEL_PACKET_SIZE);

	packet[0] = 0xD0;
	memcpy(&packet[1], rx_tx_addr, 4);  // only 4 bytes sent of 5-byte address
	if (valid_rx_id) memcpy(&packet[5], rx_id, 4);
	packet[9] = rf_ch_num;				// hopping table to be used when switching to normal mode
	packet[11] = 0x05;					// unknown, 0x01 on TX2??

	uint16_t check = PROPEL_checksum();
	packet[12] = check >> 8;
	packet[13] = check & 0xff;

	NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_RX_DR) | _BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));
	NRF24L01_FlushTx();
	NRF24L01_FlushRx();
	NRF24L01_WritePayload(packet, PROPEL_PACKET_SIZE);
}

static void __attribute__((unused)) PROPEL_data_packet()
{
	memset(packet, 0, PROPEL_PACKET_SIZE);

	packet[0] = 0xC0;
	packet[1] = convert_channel_16b_limit(THROTTLE, 0x2f, 0xcf);
	packet[2] = convert_channel_16b_limit(RUDDER  , 0xcf, 0x2f);
	packet[3] = convert_channel_16b_limit(ELEVATOR, 0x2f, 0xcf);
	packet[4] = convert_channel_16b_limit(AILERON , 0xcf, 0x2f);
	packet[5] = 0x40;							//might be trims but unsused
	packet[6] = 0x40;							//might be trims but unsused
	packet[7] = 0x40;							//might be trims but unsused
	packet[8] = 0x40;							//might be trims but unsused
	if (bind_phase)
	{//need to send a couple of default packets after bind
		bind_phase--;
		packet[10] = 0x80;	// LEDs
	}
	else
	{
		packet[9] = 0x02    					// Always fast speed, slow=0x00, medium=0x01, fast=0x02, 0x03=flight training mode
					| GET_FLAG( CH14_SW, 0x03)	// Flight training mode
					| GET_FLAG( CH10_SW, 0x04)	// Calibrate
					| GET_FLAG( CH12_SW, 0x08)	// Take off
					| GET_FLAG( CH8_SW,  0x10)	// Fire
					| GET_FLAG( CH11_SW, 0x20)	// Altitude hold=0x20
					| GET_FLAG( CH6_SW,  0x40)	// Roll CW
					| GET_FLAG( CH7_SW,  0x80);	// Roll CCW
		packet[10] =  GET_FLAG( CH13_SW, 0x20)	// Land
					| GET_FLAG( CH9_SW,  0x40)	// Weapon system activted=0x40
					| GET_FLAG(!CH5_SW,  0x80);	// LEDs
	}
	packet[11] = 5;								// unknown, 0x01 on TX2??

	uint16_t check = PROPEL_checksum();
	packet[12] = check >> 8;
	packet[13] = check & 0xff;

	NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no++]);
	hopping_frequency_no &= 0x03;
	NRF24L01_SetPower();
	NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_RX_DR) | _BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));
	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, PROPEL_PACKET_SIZE);
}

static void __attribute__((unused)) PROPEL_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x7f);
	NRF24L01_WriteReg(NRF24L01_01_EN_AA, 0x3f);			// AA on all pipes
	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x3f);		// Enable all pipes
	NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0x36);	// retransmit 1ms, 6 times
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t *)"\x99\x77\x55\x33\x11", PROPEL_ADDRESS_LENGTH);	//Bind address
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t *)"\x99\x77\x55\x33\x11", PROPEL_ADDRESS_LENGTH);	//Bind address
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, PROPEL_BIND_RF_CHANNEL);
	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3f);			// Enable dynamic payload length
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x07);		// Enable all features

	NRF24L01_SetTxRxMode(TX_EN);						// Clear data ready, data sent, retransmit and enable CRC 16bits, ready for TX
}

const uint8_t PROGMEM PROPEL_hopping []= { 0x47,0x36,0x27,0x44,0x33,0x0D,0x3C,0x2E,0x1B,0x39,0x2A,0x18 };
static void __attribute__((unused)) PROPEL_initialize_txid()
{
	//address last byte
	rx_tx_addr[4]=0x11;
	
	//random hopping channel table
	rf_ch_num=random(0xfefefefe)&0x03;
	for(uint8_t i=0; i<3; i++)
		hopping_frequency[i]=pgm_read_byte_near( &PROPEL_hopping[i + 3*rf_ch_num] );
	hopping_frequency[3]=0x23;

#ifdef PROPEL_FORCE_ID
	if(RX_num&1)
		memcpy(rx_tx_addr, (uint8_t *)"\x73\xd3\x31\x30\x11", PROPEL_ADDRESS_LENGTH);	//TX1: 73 d3 31 30 11
	else
		memcpy(rx_tx_addr, (uint8_t *)"\x94\xc5\x31\x30\x11", PROPEL_ADDRESS_LENGTH);	//TX2: 94 c5 31 30 11
	rf_ch_num = 0x03; //TX1
	memcpy(hopping_frequency,(uint8_t *)"\x39\x2A\x18\x23",PROPEL_RF_NUM_CHANNELS);		//TX1: 57,42,24,35
	rf_ch_num = 0x00; //TX2
	memcpy(hopping_frequency,(uint8_t *)"\x47\x36\x27\x23",PROPEL_RF_NUM_CHANNELS); 	//TX2: 71,54,39,35
	rf_ch_num = 0x01; // Manual search
	memcpy(hopping_frequency,(uint8_t *)"\x44\x33\x0D\x23",PROPEL_RF_NUM_CHANNELS); 	//Manual: 68,51,13,35
	rf_ch_num = 0x02; // Manual search
	memcpy(hopping_frequency,(uint8_t *)"\x3C\x2E\x1B\x23",PROPEL_RF_NUM_CHANNELS); 	//Manual: 60,46,27,35
#endif
}

uint16_t PROPEL_callback()
{
	uint8_t status;

	switch (phase)
	{
		case PROPEL_BIND1:
			PROPEL_bind_packet(false);		//rx_id unknown
			phase++;						//BIND2
			return PROPEL_BIND_PERIOD;

		case PROPEL_BIND2:
			status=NRF24L01_ReadReg(NRF24L01_07_STATUS);
			if (status & _BV(NRF24L01_07_MAX_RT))
			{// Max retry (6) reached
				phase = PROPEL_BIND1;
				return PROPEL_BIND_PERIOD;
			}
			if (!(_BV(NRF24L01_07_RX_DR) & status))
				return PROPEL_BIND_PERIOD;		// nothing received
			// received frame, got rx_id, save it
			NRF24L01_ReadPayload(packet_in, PROPEL_PACKET_SIZE);
			memcpy(rx_id, &packet_in[1], 4);
			PROPEL_bind_packet(true);		//send bind packet with rx_id
			phase++;						//BIND3
			break;

		case PROPEL_BIND3:
			if (_BV(NRF24L01_07_RX_DR) & NRF24L01_ReadReg(NRF24L01_07_STATUS))
			{
				NRF24L01_ReadPayload(packet_in, PROPEL_PACKET_SIZE);
				if (packet_in[0] == 0xa3 && memcmp(&packet_in[1],rx_id,4)==0)
				{//confirmation from the model
					phase++;				//PROPEL_DATA1
					bind_phase=PROPEL_DEFAULT_PERIOD;
					packet_count=0;
					BIND_DONE;
					break;
				}
			}
			NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, PROPEL_ADDRESS_LENGTH);
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, PROPEL_ADDRESS_LENGTH);
			PROPEL_bind_packet(true);		//send bind packet with rx_id
			break;

		case PROPEL_DATA1:
			#ifdef PROPEL_HUB_TELEMETRY
				if (_BV(NRF24L01_07_RX_DR) & NRF24L01_ReadReg(NRF24L01_07_STATUS))
				{// data received from the model
					NRF24L01_ReadPayload(packet_in, PROPEL_PACKET_SIZE);
					#if 1
						for(uint8_t i=0; i<PROPEL_PACKET_SIZE; i++)
							debug("%02X ",packet_in[i]);
						debugln("");
					#endif
					if (packet_in[0] == 0xa3 && memcmp(&packet_in[1],rx_id,3)==0)
					{
						telemetry_counter++;	//LQI
						v_lipo1=packet_in[5];	//number of life left?
						v_lipo2=packet_in[4];	//bit mask: 0x80=flying, 0x08=taking off, 0x04=landing, 0x00=landed/crashed
						if(telemetry_lost==0)
							telemetry_link=1;
					}
				}
				packet_count++;
				if(packet_count>=100)
				{//LQI calculation
					packet_count=0;
					TX_LQI=telemetry_counter;
					RX_RSSI=telemetry_counter;
					telemetry_counter = 0;
					telemetry_lost=0;
				}
			#endif
			PROPEL_data_packet();
			break;
	}
	return PROPEL_PACKET_PERIOD;
}

void PROPEL_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	PROPEL_initialize_txid();
	PROPEL_RF_init();
	hopping_frequency_no = 0;
	phase=PROPEL_BIND1;
}

#endif
// equations for checksum check byte from truth table
// (1)  z =  a && !b
//       ||  a && !c && !d
//       ||  a && !c && !g
//       ||  a && !d && !g
//       ||  a && !c && !h
//       ||  a && !g && !h
//       || !a &&  b &&  c &&  g
//       || !a &&  b &&  c &&  d &&  h
//       || !a &&  b &&  d &&  g &&  h;
//
// (2)  y = !b && !c && !d
//       ||  b &&  c &&  g
//       || !b && !c && !g
//       || !b && !d && !g
//       || !b && !c && !h
//       || !b && !g && !h
//       ||  b &&  c &&  d &&  h
//       ||  b &&  d &&  g &&  h;
//
// (3)  x = !c && !d &&  g
//       ||  c && !d && !g
//       || !c &&  g && !h
//       ||  c && !g && !h
//       ||  c &&  d &&  g &&  h
//       || !c &&  d && !g &&  h;
//
// (4)  w =  d &&  h
//       || !d && !h;
//
// (5)  v = !e;
//
// (6)  u =  f;
//
// (7)  t = !g;
//
// (8)  s =  h;
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q303_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(Q303_CCNRF_INO)

#include "iface_xn297.h"

#define Q303_BIND_COUNT			1500
#define Q303_INITIAL_WAIT		500
#define Q303_RF_BIND_CHANNEL	0x02

#define Q303_BTN_TAKEOFF	1
#define Q303_BTN_DESCEND	2
#define Q303_BTN_SNAPSHOT	4
#define Q303_BTN_VIDEO		8
#define Q303_BTN_RTH		16
#define Q303_BTN_VTX		32

static uint8_t __attribute__((unused)) cx10wd_getButtons()
{
	#define CX10WD_FLAG_LAND	0x20
	#define CX10D_FLAG_LAND		0x80
	#define CX10WD_FLAG_TAKEOFF	0x40

	static uint8_t BTN_state;
	static uint8_t command;

	// startup
	if(packet_count < 50)
	{
		BTN_state = 0;
		command = 0;
		packet_count++;
	}
	// auto land
	else if((Channel_data[CH5]<CHANNEL_MIN_COMMAND) && !(BTN_state & Q303_BTN_DESCEND))
	{
		BTN_state |= Q303_BTN_DESCEND;
		BTN_state &= ~Q303_BTN_TAKEOFF;
		switch(sub_protocol)
		{
			case CX10WD:
				command ^= CX10WD_FLAG_LAND;
				break;
			case CX10D:
				command ^= CX10D_FLAG_LAND;
				break;
		}
	}
	// auto take off
	else if(CH5_SW && !(BTN_state & Q303_BTN_TAKEOFF))
	{
		BTN_state |= Q303_BTN_TAKEOFF;
		BTN_state &= ~Q303_BTN_DESCEND;
		command ^= CX10WD_FLAG_TAKEOFF;
	}

	return command;
}

static uint8_t __attribute__((unused))  cx35_lastButton()
{
	#define CX35_CMD_RATE		0x09
	#define CX35_CMD_TAKEOFF	0x0e
	#define CX35_CMD_DESCEND	0x0f
	#define CX35_CMD_SNAPSHOT	0x0b
	#define CX35_CMD_VIDEO		0x0c
	#define CX35_CMD_RTH		0x11
	#define CX35_CMD_VTX		0x10
	
	static uint8_t BTN_state;
	static uint8_t command;
	// simulate 2 keypress on rate button just after bind
	if(packet_count < 50)
	{
		BTN_state = 0;
		packet_count++;
		command = 0x00; // startup
	}
	else if(packet_count < 150)
	{
		packet_count++;
		command = CX35_CMD_RATE; // 1st keypress
	}
	else if(packet_count < 250)
	{
		packet_count++;
		command |= 0x20; // 2nd keypress
	}
	// descend
	else if(!(GET_FLAG(CH5_SW, 1)) && !(BTN_state & Q303_BTN_DESCEND))
	{
		BTN_state |= Q303_BTN_DESCEND;
		BTN_state &= ~Q303_BTN_TAKEOFF;
		command = CX35_CMD_DESCEND;
	}
	// take off
	else if(GET_FLAG(CH5_SW,1) && !(BTN_state & Q303_BTN_TAKEOFF))
	{
		BTN_state |= Q303_BTN_TAKEOFF;
		BTN_state &= ~Q303_BTN_DESCEND;
		command = CX35_CMD_TAKEOFF;
	}
	// RTH
	else if(GET_FLAG(CH10_SW,1) && !(BTN_state & Q303_BTN_RTH))
	{
		BTN_state |= Q303_BTN_RTH;
		if(command == CX35_CMD_RTH)
			command |= 0x20;
		else
			command = CX35_CMD_RTH;
	}
	else if(!(GET_FLAG(CH10_SW,1)) && (BTN_state & Q303_BTN_RTH))
	{
		BTN_state &= ~Q303_BTN_RTH;
		if(command == CX35_CMD_RTH)
			command |= 0x20;
		else
			command = CX35_CMD_RTH;
	}
	// video
	else if(GET_FLAG(CH8_SW,1) && !(BTN_state & Q303_BTN_VIDEO))
	{
		BTN_state |= Q303_BTN_VIDEO;
		if(command == CX35_CMD_VIDEO)
			command |= 0x20;
		else
			command = CX35_CMD_VIDEO;
	}
	else if(!(GET_FLAG(CH8_SW,1)) && (BTN_state & Q303_BTN_VIDEO))
	{
		BTN_state &= ~Q303_BTN_VIDEO;
		if(command == CX35_CMD_VIDEO)
			command |= 0x20;
		else
			command = CX35_CMD_VIDEO;
	}
	// snapshot
	else if(GET_FLAG(CH7_SW,1) && !(BTN_state & Q303_BTN_SNAPSHOT))
	{
		BTN_state |= Q303_BTN_SNAPSHOT;
		if(command == CX35_CMD_SNAPSHOT)
			command |= 0x20;
		else
			command = CX35_CMD_SNAPSHOT;
	}
	// vtx channel
	else if(GET_FLAG(CH6_SW,1) && !(BTN_state & Q303_BTN_VTX))
	{
		BTN_state |= Q303_BTN_VTX;
		if(command == CX35_CMD_VTX)
			command |= 0x20;
		else
			command = CX35_CMD_VTX;
	}

	if(!(GET_FLAG(CH7_SW,1)))
		BTN_state &= ~Q303_BTN_SNAPSHOT;
	if(!(GET_FLAG(CH6_SW,1)))
		BTN_state &= ~Q303_BTN_VTX;

	return command;
}

static void __attribute__((unused)) Q303_send_packet()
{
	uint16_t aileron, elevator, throttle, rudder, slider;
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0xaa;
		memcpy(&packet[1], rx_tx_addr + 1, 4);
		memset(&packet[5], 0, packet_length-5);
	}
	else
	{
		//RF freq
		XN297_Hopping(hopping_frequency_no++);
		hopping_frequency_no %= rf_ch_num;

		//Build packet
		packet[0] = 0x55;
		// sticks
		switch(sub_protocol)
		{
			case Q303:
			case CX35:
				aileron  = convert_channel_16b_limit(AILERON,  0, 1000);
				elevator = convert_channel_16b_limit(ELEVATOR, 1000, 0);
				throttle = convert_channel_16b_limit(THROTTLE, 0, 1000);
				rudder   = convert_channel_16b_limit(RUDDER,   1000, 0);
				if(sub_protocol == CX35)
					aileron = 1000 - aileron;
				packet[1] = aileron >> 2;			// 8 bits
				packet[2] = (aileron & 0x03) << 6	// 2 bits
							| (elevator >> 4);		// 6 bits
				packet[3] = (elevator & 0x0f) << 4	// 4 bits
							| (throttle >> 6);		// 4 bits
				packet[4] = (throttle & 0x3f) << 2	// 6 bits 
							| (rudder >> 8);		// 2 bits
				packet[5] = rudder & 0xff;			// 8 bits
				break;
			case CX10D:
			case CX10WD:
				aileron  = convert_channel_16b_limit(AILERON,  2000, 1000);
				elevator = convert_channel_16b_limit(ELEVATOR, 2000, 1000);
				throttle = convert_channel_16b_limit(THROTTLE, 1000, 2000);
				rudder   = convert_channel_16b_limit(RUDDER,   1000, 2000);
				packet[1] = aileron & 0xff;
				packet[2] = aileron >> 8;
				packet[3] = elevator & 0xff;
				packet[4] = elevator >> 8;
				packet[5] = throttle & 0xff;
				packet[6] = throttle >> 8;
				packet[7] = rudder & 0xff;
				packet[8] = rudder >> 8;
				break;
		}

		// buttons
		switch(sub_protocol)
		{
			case Q303:
				packet[6] = 0x10;					// trim(s) ?
				packet[7] = 0x10;					// trim(s) ?
				packet[8] = 0x03					// high rate (0-3)
					| GET_FLAG(CH5_SW,   0x40)
					| GET_FLAG(CH10_SW,	 0x80);
				packet[9] = 0x40					// always set
					| GET_FLAG(CH9_SW,0x08)
					| GET_FLAG(CH6_SW,	0x80)
					| GET_FLAG(CH7_SW,0x10)
					| GET_FLAG(CH8_SW,   0x01);
				if(Channel_data[CH11] < CHANNEL_MIN_COMMAND)
					packet[9] |= 0x04;				// gimbal down
				else if(CH11_SW)
						packet[9] |= 0x20;			// gimbal up
				break;

			case CX35:
				slider = convert_channel_16b_limit(CH11, 731, 342);
				packet[6] = slider >> 2;
				packet[7] = ((slider & 3) << 6)
					| 0x3e;							// ?? 6 bit left (always 111110 ?)
				packet[8] = 0x80;					// always set
				packet[9] = cx35_lastButton();
				break;

			case CX10D:
				packet[8] |= GET_FLAG(CH6_SW, 0x10);
				packet[9] = 0x02; // rate (0-2)
				packet[10]= cx10wd_getButtons();	// auto land / take off management
				break;

			case CX10WD:
				packet[8] |= GET_FLAG(CH6_SW, 0x10);
				packet[9]  = 0x02  // rate (0-2)
						| cx10wd_getButtons();		// auto land / take off management
				packet[10] = 0x00;
				break;
		}
	}

	// Send
	XN297_SetPower();
	XN297_SetFreqOffset();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, packet_length);
}

static void __attribute__((unused)) Q303_RF_init()
{
	const uint8_t bind_address[] = {0xcc,0xcc,0xcc,0xcc,0xcc};

	if(sub_protocol==Q303)
	{
		XN297_Configure(XN297_CRCEN, XN297_UNSCRAMBLED, XN297_250K);
		XN297_HoppingCalib(rf_ch_num);
	}
	else
		XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);

	XN297_SetTXAddr(bind_address, 5);
	XN297_RFChannel(Q303_RF_BIND_CHANNEL);
}

static void __attribute__((unused)) Q303_initialize_txid()
{
	uint8_t i,offset;

	rx_tx_addr[0] = 0x55;

	switch(sub_protocol)
	{
		case Q303:
		case CX10WD:
			offset = rx_tx_addr[1] & 3;
			for(i=0; i<4; i++)
				hopping_frequency[i] = 0x46 + i*2 + offset;
			break;
		case CX35:
		case CX10D:
			// not thoroughly figured out rx_tx_addr/channels mapping yet
			// for now 5 msb of rx_tx_addr[1] must be cleared
			rx_tx_addr[1] &= 7;
			offset = 6+(rx_tx_addr[1]*3);
			hopping_frequency[0] = 0x14; // works only if rx_tx_addr[1] < 8
			for(i=1; i<16; i++)
			{
				hopping_frequency[i] = hopping_frequency[i-1] + offset;
				if(hopping_frequency[i] > 0x41)
					hopping_frequency[i] -= 0x33;
				if(hopping_frequency[i] < 0x14)
					hopping_frequency[i] += offset;
			}
			// CX35 tx uses only 4 of those channels (#0,3,6,9)
			if(sub_protocol == CX35)
				for(i=0; i<4; i++)
					hopping_frequency[i] = hopping_frequency[i*3];
			break;
	}
}

uint16_t Q303_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			XN297_SetTXAddr(rx_tx_addr, 5);
			packet_count = 0;
			BIND_DONE;
		}
	}
	Q303_send_packet();
	return packet_period;
}

void Q303_init()
{
	Q303_initialize_txid();
	Q303_RF_init();
	bind_counter = Q303_BIND_COUNT;
	switch(sub_protocol)
	{
		case Q303:
			packet_period = 1500;
			packet_length = 10;
			rf_ch_num = 4;
			break;
		case CX35:
			packet_period = 3000;
			packet_length = 10;
			rf_ch_num = 4;
			break;
		case CX10D:
			packet_period = 3000;
			packet_length = 11;
			rf_ch_num = 16;
			break;
		case CX10WD:
			packet_period = 3000;
			packet_length = 11;
			rf_ch_num = 4;
		break;
	}
	hopping_frequency_no = 0;
	BIND_IN_PROGRESS;	// autobind protocol
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Q90C_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with Q90C quad.

#if defined(Q90C_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_Q90C_ORIGINAL_ID

#define Q90C_BIND_COUNT			250
#define Q90C_PACKET_PERIOD		7336 // 6200 on saimat's TX...
#define Q90C_INITIAL_WAIT		500
#define Q90C_PACKET_SIZE		12
#define Q90C_RF_BIND_CHANNEL	0x33
#define Q90C_RF_NUM_CHANNELS	3
#define Q90C_ADDRESS_LENGTH		5

bool Q90C_VTX;

int16_t Q90C_channel(uint8_t num, int16_t in_min,int16_t in_max, int16_t out_min,int16_t out_max)
{
	int32_t val=Channel_data[num];
	if(val<in_min) val=in_min;
	else if(val>in_max) val=in_max;
	val=(val-in_min)*(out_max-out_min)/(in_max-in_min)+out_min;
	return (uint16_t)val;
}

static void __attribute__((unused)) Q90C_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(packet, rx_tx_addr, 4);
		memcpy(&packet[4], hopping_frequency, 3);
		//packet[7]  = 0x1e;	// 2e on Saimat 1???
		packet[10] = 0x4B;
		packet[11] = 0x4E;
	}
	else
	{
		XN297_Hopping(hopping_frequency_no++);				// RF Freq
		hopping_frequency_no %= Q90C_RF_NUM_CHANNELS;
		packet[0]= convert_channel_8b(THROTTLE);			// 0..255
		// A,E,R have weird scaling, 0x00-0xff range (unsigned) but center isn't 7f or 80
		// rudder ff-7a-00
		if (Channel_data[RUDDER] <= CHANNEL_MID)
			packet[1] = Q90C_channel(RUDDER,   CHANNEL_MIN_100, CHANNEL_MID, 0xff, 0x7a );
		else
			packet[1] = Q90C_channel(RUDDER,   CHANNEL_MID, CHANNEL_MAX_100, 0x7a, 0x00 );
		// elevator 00-88-ff
		if (Channel_data[ELEVATOR] <= CHANNEL_MID)
			packet[2] = Q90C_channel(ELEVATOR, CHANNEL_MIN_100, CHANNEL_MID, 0x00, 0x88);
		else
			packet[2] = Q90C_channel(ELEVATOR, CHANNEL_MID, CHANNEL_MAX_100, 0x88, 0xff);
		// aileron ff-88-00
		if (Channel_data[AILERON] <= CHANNEL_MID)
			packet[3] = Q90C_channel(AILERON,  CHANNEL_MIN_100, CHANNEL_MID, 0xff, 0x88);
		else
			packet[3] = Q90C_channel(AILERON,  CHANNEL_MID, CHANNEL_MAX_100, 0x88, 0x00);
		// required to "arm" (low throttle + aileron to the right)
		if (packet[0] < 5 && packet[3] < 25) {
			packet[1] = 0x7a;
			packet[2] = 0x88;
		}
		packet[4] = 0x1e;									// T trim 00-1e-3c
		packet[5] = 0x1e;									// R trim 3c-1e-00
		packet[6] = 0x1e;									// E trim 00-1e-3c
		//packet[7] = 0x1e;									// A trim 00-1e-3c
		packet[8] |= 0x02;									// Rudder rate 0=min,1,2=max
		if(state!=Channel_data[CH5])
		{
			state=Channel_data[CH5];
			if(state<CHANNEL_MIN_COMMAND)
				packet[8] ^= 0x04;							// Angle
			else if(state>CHANNEL_MAX_COMMAND)
				packet[8] ^= 0x10;							// Acro
			else
				packet[8] ^= 0x08;							// Horizon
		}
		if(!Q90C_VTX && CH6_SW)
			packet[8] ^= 0x20;								// VTX+
		Q90C_VTX=CH6_SW;

		debugln("8=%02X",packet[8]);
		packet[10] = packet_count++;
	}
	packet[7]  = 0x1e;	// bind 1e or 2e, normal: A trim 00-1e-3c

	// checksum
	if(IS_BIND_DONE)
	{
	    uint8_t sum=0;
		for (uint8_t i = 0; i < Q90C_PACKET_SIZE - 1; i++)
			sum += packet[i];
		packet[11] = sum ^ crc8;
	}

	// Send
	XN297_SetFreqOffset();									// Set frequency offset
	XN297_SetPower();										// Set tx_power
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, Q90C_PACKET_SIZE, 0);
}

static void __attribute__((unused)) Q90C_initialize_txid()
{
	calc_fh_channels(Q90C_RF_NUM_CHANNELS);
	rx_tx_addr[4]=0x4B;
	#ifdef FORCE_Q90C_ORIGINAL_ID
		//24 03 01 82 18 26 37 1E 00 00 4B 4E
		memcpy(rx_tx_addr, (uint8_t*)"\x24\x03\x01\x82\x4B", Q90C_ADDRESS_LENGTH);	//Goebish
		memcpy(hopping_frequency, (uint8_t*)"\x18\x26\x37", Q90C_RF_NUM_CHANNELS);
		//4C 0A 02 01 17 24 36 2E 00 00 4B 4E 
		memcpy(rx_tx_addr, (uint8_t*)"\x4C\x0A\x02\x01\x4B", Q90C_ADDRESS_LENGTH);	//Saimat 1
		memcpy(hopping_frequency, (uint8_t*)"\x17\x24\x36", Q90C_RF_NUM_CHANNELS);
		//34 13 02 01 18 26 37 1E 00 00 4B 4E 
		memcpy(rx_tx_addr, (uint8_t*)"\x34\x13\x02\x01\x4B", Q90C_ADDRESS_LENGTH);	//Saimat 2
		memcpy(hopping_frequency, (uint8_t*)"\x18\x26\x37", Q90C_RF_NUM_CHANNELS);
	#endif
	crc8=rx_tx_addr[0]^rx_tx_addr[1]^rx_tx_addr[2]^rx_tx_addr[3];
}

static void __attribute__((unused)) Q90C_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	if(IS_BIND_IN_PROGRESS)
		XN297_SetTXAddr((uint8_t*)"\x4F\x43\x54\x81\x81", Q90C_ADDRESS_LENGTH);
	else
		XN297_SetTXAddr(rx_tx_addr, Q90C_ADDRESS_LENGTH);
	XN297_HoppingCalib(Q90C_RF_NUM_CHANNELS);				// Calibrate all channels
	XN297_RFChannel(Q90C_RF_BIND_CHANNEL);					// Set bind channel
}

uint16_t Q90C_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(Q90C_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, Q90C_ADDRESS_LENGTH);
		}
	Q90C_send_packet();
	return Q90C_PACKET_PERIOD;
}

void Q90C_init()
{
	Q90C_initialize_txid();
	Q90C_RF_init();
	hopping_frequency_no = 0;
	packet_count = 0;
	bind_counter=Q90C_BIND_COUNT;

	//features
	state=Channel_data[CH5];
	Q90C_VTX=CH6_SW;
	packet[8]  = 0x00;
	packet[9]  = 0x00;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/REALACC_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with Realacc R11

#if defined(REALACC_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_REALACC_ORIGINAL_ID

#define REALACC_INITIAL_WAIT		500
#define REALACC_PACKET_PERIOD		2268
#define REALACC_BIND_RF_CHANNEL		80
#define REALACC_BIND_PAYLOAD_SIZE	10
#define REALACC_PAYLOAD_SIZE		13
#define REALACC_BIND_COUNT			50
#define REALACC_RF_NUM_CHANNELS		5

static void __attribute__((unused)) REALACC_send_packet()
{
	packet[ 0]= 0xDC;							// DC/D6/DE
	packet[ 1]= convert_channel_8b(AILERON);	// 00..80..FF
	packet[ 2]= convert_channel_8b(ELEVATOR);	// 00..80..FF
	packet[ 3]= convert_channel_8b(THROTTLE);	// 00..FF
	packet[ 4]= convert_channel_8b(RUDDER);		// 00..80..FF
	packet[ 5]= 0x20; 							// Trim
	packet[ 6]= 0x20; 							// Trim
	packet[ 7]= 0x20; 							// Trim
	packet[ 8]= 0x20; 							// Trim
	packet[ 9]= 0x88;							// Change at each power up: C5 A2 77 F0 84 58, fixed for the E017 = 88
	packet[10]= 0x04 							// Flag1: R11=04, E017=0C
		| 0x02									//   Rate1=0, Rate2=1, Rate3=2
		| GET_FLAG(CH8_SW, 0x20);				//   Headless
	packet[11]= 0x00 							// Flag2
		| GET_FLAG(CH7_SW, 0x01)				//   Calib
		| GET_FLAG(CH9_SW, 0x20)				//   Return
		| GET_FLAG(CH10_SW,0x80);				//   Throttle cut
	packet[12]= 0x00 							// Flag3
		| GET_FLAG(CH5_SW, 0x01)				//   Flip
		| GET_FLAG(CH11_SW,0x02)				//   Rotating
		| GET_FLAG(CH6_SW, 0x80);				//   Light

	XN297_Hopping(hopping_frequency_no);
	hopping_frequency_no++;
	hopping_frequency_no %= REALACC_RF_NUM_CHANNELS;
	XN297_WriteEnhancedPayload(packet, REALACC_PAYLOAD_SIZE,0);
}

static void __attribute__((unused)) REALACC_send_bind_packet()
{
	packet[0] = 0xB1;							// B0/B1
	memcpy(&packet[1],rx_tx_addr,4);			// Address
	memcpy(&packet[5],hopping_frequency,5);		// RF frequencies

	XN297_WriteEnhancedPayload(packet, REALACC_BIND_PAYLOAD_SIZE,1);
}

static void __attribute__((unused)) REALACC_initialize_txid()
{
	rx_tx_addr[3] &= 0x3F;
	calc_fh_channels(REALACC_RF_NUM_CHANNELS);
	#ifdef FORCE_REALACC_ORIGINAL_ID
		if(RX_num==0)
		{//TX1
			rx_tx_addr[0]=0x99;
			rx_tx_addr[1]=0x06;
			rx_tx_addr[2]=0x00;
			rx_tx_addr[3]=0x00;	// 00..3F:OK, 40..:NOK
			hopping_frequency[0]=0x55;
			hopping_frequency[1]=0x59;
			hopping_frequency[2]=0x5A;
			hopping_frequency[3]=0x5A;
			hopping_frequency[4]=0x62;
		}
		else
		{//TX2
			rx_tx_addr[0]=0x4F;
			rx_tx_addr[1]=0xB9;
			rx_tx_addr[2]=0xA1;
			rx_tx_addr[3]=0x17;
			hopping_frequency[0]=0x45;
			hopping_frequency[1]=0x38;
			hopping_frequency[2]=0x3C;
			hopping_frequency[3]=0x41;
			hopping_frequency[4]=0x3F;
		}
	#endif
	#if 0
		debug("ID: %02X %02X %02X %02X, C: ",rx_tx_addr[0],rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3]);
		for(uint8_t i=0; i<REALACC_RF_NUM_CHANNELS; i++)
			debug(" %02X",hopping_frequency[i]);
		debugln("");
	#endif

}

static void __attribute__((unused)) REALACC_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"MAIN", 4);
	XN297_RFChannel(REALACC_BIND_RF_CHANNEL);	// Set bind channel
}

uint16_t REALACC_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(REALACC_PACKET_PERIOD);
	#endif
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	if(IS_BIND_IN_PROGRESS)
	{
		REALACC_send_bind_packet();
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 4);
		}
	}
	else
		REALACC_send_packet();
	return REALACC_PACKET_PERIOD;
}

void REALACC_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	REALACC_initialize_txid();
	REALACC_RF_init();
	bind_counter=REALACC_BIND_COUNT;
	hopping_frequency_no=0;
}

#endif

// XN297 speed 1Mb, scrambled, enhanced
// Bind
//   Address = 4D 41 49 4E = 'MAIN'
//   Channel = 80 (most likely from dump)
//   TX1
//   ---
//     P(10) = B1 99 06 00 00 55 59 5A 5A 62
//     Bx indicates bind packet, why x=1?
//     99 06 00 00 = ID = address of normal packets
//     55 59 5A 5A 62 = 85, 89, 90, 90, 98 = RF channels to be used (kind of match previous dumps)
//   TX2
//   ---
//     P(10) = B0 4F B9 A1 17 45 38 3C 41 3F
//     Bx indicates bind packet, why x=0?
//     4F B9 A1 17 = ID = address of normal packets
//     45 38 3C 41 3F  = 69, 56, 60, 65, 63 = RF channels to be used
// Normal
//   TX1
//   ---
//     Address = 99 06 00 00
//     Channels = 84, 89, 90, 90, 98 (guess from bind)
//     P(13)= DC 80 80 32 80 20 20 20 20 58 04 00 00
//     Dx = normal packet, why C ?
//     80 80 32 80 : AETR 00..80..FF
//     20 20 20 20 : Trims
//     58 : changing every time the TX restart
//     04 : |0x20=headless, |0x01=rate2, |0x02=rate3
//     00 : |0x01=calib, |0x20=return, |0x80=unknown
//     00 : |0x80=light, |0x01=flip
//   TX2
//   ---
//     Address = 4F B9 A1 17
//     P(13)= D6/DE 80 80 80 80 20 20 20 20 88 0C 00 00
//     Dx = normal packet, why 6/E ?
//     80 80 32 80 : AETR 00..80..FF
//     20 20 20 20 : Trims
//     88 : not changing unknown
//     0C : |0x20=headless, |0x01=rate2, |0x02=rate3
//     00 : |0x01=calib, |0x20=return, |0x80=unknown
//     00 : |0x80=light, |0x01=flip, |0x02=Rotating

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/RF2500_EMU.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifdef CYRF6936_INSTALLED
#include "iface_rf2500.h"

#define RF2500_ADDR_LENGTH 4

uint8_t RF2500_payload_length, RF2500_tx_addr[RF2500_ADDR_LENGTH], RF2500_buf[100];
bool RF2500_scramble_enabled;

static void __attribute__((unused)) RF2500_Init(uint8_t payload_length, bool scramble)
{
	CYRF_GFSK1M_Init( RF2500_ADDR_LENGTH + 2 + (payload_length+2)*4, 2 );		// full payload length with CRC + address + 5 + FEC

	RF2500_payload_length=payload_length;
	RF2500_scramble_enabled=scramble;
}

static void __attribute__((unused)) RF2500_SetTXAddr(const uint8_t* addr)
{
	memcpy(RF2500_tx_addr, addr, RF2500_ADDR_LENGTH);
}

static void __attribute__((unused)) RF2500_BuildPayload(uint8_t* buffer)
{
	const uint8_t RF2500_scramble[] = { 0xD0, 0x9E, 0x53, 0x33, 0xD8, 0xBA, 0x98, 0x08, 0x24, 0xCB, 0x3B, 0xFC, 0x71, 0xA3, 0xF4, 0x55, 0x68, 0x4F, 0xA9 }; //0x4F: unsure
	uint16_t RF2500_crc_xorout_scramble;
	if(RF2500_payload_length == 16)
		RF2500_crc_xorout_scramble = 0xAEE4;
	else //19
		RF2500_crc_xorout_scramble = 0xE7C5;

	#if 0
		for(uint8_t i=0; i<RF2500_payload_length; i++)
			debug("%02X ", buffer[i]);
	#endif
	//Scramble the incoming buffer
	if(RF2500_scramble_enabled)
		for(uint8_t i=0; i<RF2500_payload_length; i++)
			buffer[i] ^= RF2500_scramble[i];

	//Add CRC to the buffer
	crc=0x0000;
	for(uint8_t i=0;i<RF2500_payload_length;i++)
		crc16_update(bit_reverse(buffer[i]),8);
	buffer[RF2500_payload_length  ] = bit_reverse(crc>>8);
	buffer[RF2500_payload_length+1] = bit_reverse(crc);

	#if 0
		debugln("C:%02X %02X",buffer[RF2500_payload_length  ], buffer[RF2500_payload_length+1]);
	#endif

	if(RF2500_scramble_enabled)
	{
		buffer[RF2500_payload_length  ] ^= RF2500_crc_xorout_scramble>>8;
		buffer[RF2500_payload_length+1] ^= RF2500_crc_xorout_scramble;
	}

	#if 0
		debug("B:");
		for(uint8_t i=0; i<RF2500_payload_length+2; i++)
			debug(" %02X",buffer[i]);
		debugln("");
	#endif

	memcpy(RF2500_buf,RF2500_tx_addr,RF2500_ADDR_LENGTH);		// Address
	
	uint8_t pos = RF2500_ADDR_LENGTH;

	RF2500_buf[pos++]=0xC3;RF2500_buf[pos++]=0xC3;				// 5 FEC encoded
	memset(&RF2500_buf[pos],0x00,(RF2500_payload_length+2)*4);	// + CRC) * 4 FEC bytes per byte
	
	//FEC encode
	for(uint8_t i=0; i<RF2500_payload_length+2; i++)			// Include CRC
	{
		for(uint8_t j=0;j<8;j++)
		{
			uint8_t offset=pos + (i<<2) + (j>>1);
			RF2500_buf[offset] <<= 4;
			if( (buffer[i]>>j) & 0x01 )
				RF2500_buf[offset] |= 0x0C;
			else
				RF2500_buf[offset] |= 0x03;
		}
	}

	#if 0
		debug("E:");
		for(uint8_t i=0; i<RF2500_ADDR_LENGTH+2+(RF2500_payload_length+2)*4; i++)
			debug(" %02X",RF2500_buf[i]);
		debugln("");
	#endif

	//CYRF wants LSB first
	for(uint8_t i=0; i<RF2500_ADDR_LENGTH+2+(RF2500_payload_length+2)*4; i++)
		RF2500_buf[i]=bit_reverse(RF2500_buf[i]);
}

static void __attribute__((unused)) RF2500_SendPayload()
{
	CYRF_GFSK1M_SendPayload(RF2500_buf, RF2500_ADDR_LENGTH + 2 + (RF2500_payload_length+2)*4 );
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/RadioLink_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Radiolink surface protocol. TXs: RC4GS,RC6GS. Compatible RXs:R7FG(Std),R6FG,R6F,R8EF,R8FM,R8F,R4FGM 

#if defined(RLINK_CC2500_INO)

#include "iface_cc2500.h"

//#define RLINK_DEBUG
//#define RLINK_DEBUG_TELEM

//#define RLINK_FORCE_ID
//#define RLINK_RC4G_FORCE_ID

#define RLINK_TX_PACKET_LEN	33
#define RLINK_RX_PACKET_LEN	15
#define RLINK_TX_ID_LEN		4
#define RLINK_HOP			16

enum {
	RLINK_DATA	= 0x00,
	RLINK_RX1	= 0x01,
	RLINK_RX2	= 0x02,
};

uint32_t RLINK_rand1;
uint32_t RLINK_rand2;

static uint32_t __attribute__((unused)) RLINK_prng_next(uint32_t r)
{
	return 0xA5E2A705 * r + 0x754DB79B;
}

static void __attribute__((unused)) RLINK_init_random(uint32_t id)
{
	uint32_t result = id;

	RLINK_rand2 = result;
	for (uint8_t i=0; i<31; i++)
		result = RLINK_prng_next(result);
	RLINK_rand1 = result;
}

static uint8_t __attribute__((unused)) RLINK_next_random_swap()
{
	uint8_t result = (RLINK_rand2 >> 16) + RLINK_rand2 + (RLINK_rand1 >> 16) + RLINK_rand1;

	RLINK_rand2 = RLINK_prng_next(RLINK_rand2);
	RLINK_rand1 = RLINK_prng_next(RLINK_rand1);

	return result & 0x0F;
}

static uint32_t __attribute__((unused)) RLINK_compute_start_id(uint32_t id)
{
	return id * 0xF65EF9F9u + 0x2EDDF6CAu;
}

static void __attribute__((unused)) RLINK_shuffle_freqs(uint32_t seed)
{
	RLINK_init_random(seed);

	for(uint8_t i=0; i<RLINK_HOP; i++)
	{
		uint8_t r   = RLINK_next_random_swap();
		uint8_t tmp = hopping_frequency[r];
		hopping_frequency[r] = hopping_frequency[i];
		hopping_frequency[i] = tmp;
	}
}

static void __attribute__((unused)) RLINK_hop()
{
	uint8_t inc=3*(rx_tx_addr[0]&3);
	
	// init hop table
	for(uint8_t i=0; i<RLINK_HOP; i++)
		hopping_frequency[i] = (12*i) + inc;

	// shuffle
	RLINK_shuffle_freqs(RLINK_compute_start_id(rx_tx_addr[0] + (rx_tx_addr[1] << 8)));
	RLINK_shuffle_freqs(RLINK_compute_start_id(rx_tx_addr[2] + (rx_tx_addr[3] << 8)));

	// replace one of the channel randomely
	rf_ch_num=random(0xfefefefe)%0x11;		// 0x00..0x10
	if(inc==9) inc=6;						// frequency exception
	hopping_frequency[rf_ch_num]=12*16+inc;
}

static void __attribute__((unused)) RLINK_TXID_init()
{
	#ifdef RLINK_RC4G_FORCE_ID
		//TODO: test any ID
		if(sub_protocol==RLINK_RC4G)
		{
			rx_tx_addr[1]=0x77;
			rx_tx_addr[2]=0x00;
			rx_tx_addr[3]=0x00;
		}
	#endif
	#ifdef RLINK_FORCE_ID
		if(sub_protocol==RLINK_SURFACE)
			memcpy(rx_tx_addr,"\x3A\x99\x22\x3A",RLINK_TX_ID_LEN);	//surface RC6GS
		else
			memcpy(rx_tx_addr,"\xFC\x11\x0D\x20",RLINK_TX_ID_LEN);	//air T8FB
	#endif
	// channels order depend on ID
	if(sub_protocol!=RLINK_RC4G)
		RLINK_hop();
	else
	{//RLINK_RC4G
		// Find 2 unused channels
		//  first  channel is a multiple of 3 between 00 and 5D
		//  second channel is a multiple of 3 between 63 and BD
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_17_MCSM1,0x3C);
		CC2500_Strobe(CC2500_SFRX);
		CC2500_SetTxRxMode(RX_EN);
		CC2500_Strobe(CC2500_SRX);
		delayMilliseconds(1);						//wait for RX mode
		uint16_t val;
		uint8_t val_low = 0xFF;
		hopping_frequency[0] = 0x00;
		hopping_frequency[1] = 0x63;
		for(uint8_t ch=0; ch<=0xBD; ch+=3)
		{
			if(ch==0x63)
				val_low	= 0xFF;						//init for second block
			if(ch==0x60)
				continue;							//skip channel
			CC2500_WriteReg(CC2500_0A_CHANNR, ch);	//switch channel
			delayMicroseconds(370);					//wait to read
			val = 0;
			for(uint8_t i=0;i<16;i++)
				val += CC2500_ReadReg(CC2500_34_RSSI | CC2500_READ_BURST);
			val >>= 4;
			debug("C:%02X RSSI:%02X",ch,val);
			if(val_low > val)
			{
				debug(" OK");
				val_low = val;
				hopping_frequency[ch<0x63?0:1]=ch;	//save best channel
			}
			debugln("");
		}
		CC2500_WriteReg(CC2500_17_MCSM1,0x30);
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_SetTxRxMode(TX_EN);
		#ifdef RLINK_RC4G_FORCE_ID
			hopping_frequency[0] = 0x03;
			hopping_frequency[1] = 0x6F;
		#endif
	}

 	#ifdef RLINK_DEBUG
		debug("ID:");
		for(uint8_t i=0;i<RLINK_TX_ID_LEN;i++)
			debug(" 0x%02X",rx_tx_addr[i]);
		debugln("");
		debug("Hop(%d):", rf_ch_num);
		for(uint8_t i=0;i<RLINK_HOP;i++)
			debug(" 0x%02X",hopping_frequency[i]);
		debugln("");
	#endif
 }

const PROGMEM uint8_t RLINK_init_values[] = {
  /* 00 */ 0x5B, 0x06, 0x5C, 0x07, 0xAB, 0xCD, 0x40, 0x04,
  /* 08 */ 0x45, 0x00, 0x00, 0x06, 0x00, 0x5C, 0x62, 0x76,
  /* 10 */ 0x7A, 0x7F, 0x13, 0x23, 0xF8, 0x44, 0x07, 0x30,
  /* 18 */ 0x18, 0x16, 0x6C, 0x43, 0x40, 0x91, 0x87, 0x6B,
  /* 20 */ 0xF8, 0x56, 0x10, 0xA9, 0x0A, 0x00, 0x11
};

static void __attribute__((unused)) RLINK_rf_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 0; i < 39; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&RLINK_init_values[i]));

	if(sub_protocol==RLINK_DUMBORC)
	{
		CC2500_WriteReg(4, 0xBA);
		CC2500_WriteReg(5, 0xDC);
	}
	else if(sub_protocol==RLINK_RC4G)
		CC2500_WriteReg(5, 0xA5);
		
	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	
	CC2500_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) RLINK_send_packet()
{
	static uint32_t pseudo=0;
	uint32_t bits = 0;
	uint8_t bitsavailable = 0;
	uint8_t idx = 6;

	CC2500_Strobe(CC2500_SIDLE);

	// packet length
	packet[0] = RLINK_TX_PACKET_LEN;
	// header
	if(packet_count>3)
		packet[1] = 0x02;					// 0x02 telemetry request flag
	else
		packet[1] = 0x00;					// no telemetry

	switch(sub_protocol)
	{
		case RLINK_SURFACE:
			packet[1] |= 0x01;
			//radiolink additionnal ID which is working only on a small set of RXs
			//if(RX_num) packet[1] |= ((RX_num+2)<<4)+4;	// RX number limited to 10 values, 0 is a wildcard
			break;
		case RLINK_AIR:
			packet[1] |= 0x21;					//air 0x21 on dump but it looks to support telemetry at least RSSI
			break;
		case RLINK_DUMBORC:
			packet[1] |= 0x01;					//always 0x00 on dump but does appear to support telemtry on newer transmitters
			break;
	}
	
	// ID
	memcpy(&packet[2],rx_tx_addr,RLINK_TX_ID_LEN);

	// pack 16 channels on 11 bits values between 170 and 1876, 1023 middle. The last 8 channels are failsafe values associated to the first 8 values.
	for (uint8_t i = 0; i < 16; i++)
	{
		uint32_t val = convert_channel_16b_nolimit(i,170,1876,false);		// allow extended limits
		if (val & 0x8000)
			val = 0;
		else if (val > 2047)
			val=2047;

		bits |= val << bitsavailable;
		bitsavailable += 11;
		while (bitsavailable >= 8) {
			packet[idx++] = bits & 0xff;
			bits >>= 8;
			bitsavailable -= 8;
		}
	}
	
	// hop
	pseudo=((pseudo * 0xAA) + 0x03) % 0x7673;	// calc next pseudo random value
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[pseudo & 0x0F]);
	packet[28]= pseudo;
	packet[29]= pseudo >> 8;
	packet[30]= 0x00;						// unknown
	packet[31]= 0x00;						// unknown
	packet[32]= rf_ch_num;					// index of value changed in the RF table
	
	// check
	uint8_t sum=0;
	for(uint8_t i=1;i<33;i++)
		sum+=packet[i];
	packet[33]=sum;

	// send packet
	CC2500_WriteData(packet, RLINK_TX_PACKET_LEN+1);
	
	// packets type
	packet_count++;
	if(packet_count>5) packet_count=0;

	#ifdef RLINK_DEBUG
		debugln("C= 0x%02X",hopping_frequency[pseudo & 0x0F]);
		debug("P=");
		for(uint8_t i=1;i<RLINK_TX_PACKET_LEN+1;i++)
			debug(" 0x%02X",packet[i]);
		debugln("");
	#endif
}

#ifndef MULTI_AIR
static void __attribute__((unused)) RLINK_RC4G_send_packet()
{
	uint32_t val;
	//hop
	CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[packet_count>>1]);
	#ifdef RLINK_DEBUG
		debug("C= 0x%02X ",hopping_frequency[packet_count>>1]);
	#endif
	// packet length
	packet[0] = 0x0F;
	//address
	memcpy(&packet[1], &rx_tx_addr[1], 3);
	//channels
	for(uint8_t i=0;i<2;i++)
	{
		val = Channel_data[2*i  ] +400 -24;
		packet[4+i*2] = val;
		packet[8+i  ] = val>>8;
		val = Channel_data[2*i+1] +400 -24;
		packet[5+i*2] = val;
		packet[8+i  ] |= (val>>4) & 0xF0;
	}
	//special channel which is linked to gyro on the orginal TX but allocating it on CH5 here
	packet[10] = convert_channel_16b_limit(CH5,0,100);
	//failsafe
	for(uint8_t i=0;i<4;i++)
		packet[11+i] = convert_channel_16b_limit(CH6+i,0,200);
	//next hop
	packet_count++;
	packet_count &= 0x03;
	packet[15] = hopping_frequency[packet_count>>1];
	// send packet
	CC2500_WriteData(packet, 16);

	#ifdef RLINK_DEBUG
		debug("P=");
		for(uint8_t i=1;i<16;i++)
			debug(" 0x%02X",packet[i]);
		debugln("");
	#endif
}
#endif

#define RLINK_TIMING_PROTO	20000-100		// -100 for compatibility with R8EF
#define RLINK_TIMING_RFSEND	10500
#define RLINK_TIMING_CHECK	2000
#define RLINK_RC4G_TIMING_PROTO 14460
uint16_t RLINK_callback()
{
	if(sub_protocol == RLINK_RC4G)
	{
		#ifndef MULTI_AIR
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(RLINK_RC4G_TIMING_PROTO);
			#endif
			CC2500_SetPower();
			CC2500_SetFreqOffset();
			RLINK_RC4G_send_packet();
		#else
			SUB_PROTO_INVALID;
		#endif
		return RLINK_RC4G_TIMING_PROTO;
	}
	switch(phase)
	{
		case RLINK_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(RLINK_TIMING_PROTO);
			#endif
			CC2500_SetPower();
			CC2500_SetFreqOffset();
			RLINK_send_packet();
#if not defined RLINK_HUB_TELEMETRY
			return RLINK_TIMING_PROTO;
#else
			if(!(packet[1]&0x02))
				return RLINK_TIMING_PROTO;					//Normal packet
															//Telemetry packet
			phase++;										// RX1
			return RLINK_TIMING_RFSEND;
		case RLINK_RX1:
			CC2500_Strobe(CC2500_SIDLE);
			CC2500_Strobe(CC2500_SFRX);
			CC2500_SetTxRxMode(RX_EN);
			CC2500_Strobe(CC2500_SRX);
			phase++;										// RX2
			return RLINK_TIMING_PROTO-RLINK_TIMING_RFSEND-RLINK_TIMING_CHECK;
		case RLINK_RX2:
			len = CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F;	
			if (len == RLINK_RX_PACKET_LEN + 1 + 2)			//Telemetry frame is 15 bytes + 1 byte for length + 2 bytes for RSSI&LQI&CRC
			{
				#ifdef RLINK_DEBUG_TELEM
					debug("Telem:");
				#endif
				CC2500_ReadData(packet_in, len);
				if(packet_in[0]==RLINK_RX_PACKET_LEN && (packet_in[len-1] & 0x80) && memcmp(&packet[2],rx_tx_addr,RLINK_TX_ID_LEN)==0 && (packet_in[6]==packet[1] || sub_protocol == RLINK_DUMBORC))
				{//Correct telemetry received: length, CRC, ID and type
				 //packet_in[6] is 0x00 on almost all DumboRC RX so assume it is always valid
					#ifdef RLINK_DEBUG_TELEM
						for(uint8_t i=0;i<len;i++)
							debug(" %02X",packet_in[i]);
					#endif
					TX_RSSI = packet_in[len-2];
					if(TX_RSSI >=128)
						TX_RSSI -= 128;
					else
						TX_RSSI += 128;
					RX_RSSI=packet_in[7]&0x7F;				//Should be packet_in[7]-256 but since it's an uint8_t...
					v_lipo1=packet_in[8]<<1;				//RX Batt
					v_lipo2=packet_in[9];					//Batt
					telemetry_link=1;						//Send telemetry out
					pps_counter++;
					packet_count=0;
				}
				#ifdef RLINK_DEBUG_TELEM
					debugln("");
				#endif
			}
			if (millis() - pps_timer >= 2000)
			{//1 telemetry packet every 100ms
				pps_timer = millis();
				if(pps_counter<20)
					pps_counter*=5;
				else
					pps_counter=100;
				debugln("%d pps", pps_counter);
				TX_LQI = pps_counter;						//0..100%
				pps_counter = 0;
			}
			CC2500_SetTxRxMode(TX_EN);
			phase=RLINK_DATA;								// DATA
			return RLINK_TIMING_CHECK;
#endif
	}
	return 0;
}

void RLINK_init()
{
	BIND_DONE;	// Not a TX bind protocol
	RLINK_TXID_init();
	RLINK_rf_init();
	packet_count = 0;
	phase = RLINK_DATA;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Redpine_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(REDPINE_CC2500_INO)

#include "iface_cc2500.h"

#define REDPINE_LOOPTIME_FAST 20	//2.0ms
#define REDPINE_LOOPTIME_SLOW 20  	//20ms

#define REDPINE_BIND 2000
#define REDPINE_PACKET_SIZE 11
#define REDPINE_FEC false  // from cc2500 datasheet: The convolutional coder is a rate 1/2 code with a constraint length of m=4
#define REDPINE_NUM_HOPS 50

static void REDPINE_set_channel(uint8_t ch)
{
    CC2500_Strobe(CC2500_SIDLE);
    CC2500_WriteReg(CC2500_25_FSCAL1, calData[ch]);
    CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[ch]);
}

static void REDPINE_build_bind_packet()
{
    memset(&packet[0], 0, REDPINE_PACKET_SIZE);

    packet[0] = REDPINE_PACKET_SIZE - 1;
    packet[1] = 0x03;
    packet[2] = 0x01;
    packet[3] = rx_tx_addr[2];
    packet[4] = rx_tx_addr[3];	// Use RX_Num
    uint16_t idx = ((REDPINE_BIND - bind_counter) % 10) * 5;
    packet[5] = idx;
    packet[6] = hopping_frequency[idx++];
    packet[7] = hopping_frequency[idx++];
    packet[8] = hopping_frequency[idx++];
    packet[9] = hopping_frequency[idx++];
    packet[10] = hopping_frequency[idx++];
    // packet[11] = 0x02;
    // packet[12] = RXNUM;
}

static uint16_t Redpine_Scale(uint8_t chan)
{
    uint16_t chan_val=Channel_data[chan];	// -125%..+125% <=> 0..2047
	if (chan_val > 2046)   chan_val = 2046;
    else if (chan_val < 10) chan_val = 10;
    return chan_val;
}


static void REDPINE_data_frame() {
    uint16_t chan[4];

    memset(&packet[0], 0, REDPINE_PACKET_SIZE);

    packet[0] = REDPINE_PACKET_SIZE - 1;
    packet[1] = rx_tx_addr[2];
    packet[2] = rx_tx_addr[3];	// Use RX_Num

    chan[0] = Redpine_Scale(0);
    chan[1] = Redpine_Scale(1);
    chan[2] = Redpine_Scale(2);
    chan[3] = Redpine_Scale(3);

    packet[3] = chan[0];
    packet[4] = (((chan[0] >> 8) & 0x07) | (chan[1] << 4)) | GET_FLAG(CH5_SW, 0x08);
    packet[5] = ((chan[1] >> 4) & 0x7F) | GET_FLAG(CH6_SW, 0x80);
    packet[6] = chan[2];
    packet[7] = (((chan[2] >> 8) & 0x07) | (chan[3] << 4))  | GET_FLAG(CH7_SW, 0x08);
    packet[8] = ((chan[3] >> 4) & 0x7F) | GET_FLAG(CH8_SW, 0x80);
    packet[9] = GET_FLAG(CH9_SW, 0x01)
            | GET_FLAG(CH10_SW, 0x02)
            | GET_FLAG(CH11_SW, 0x04)
            | GET_FLAG(CH12_SW, 0x08)
            | GET_FLAG(CH13_SW, 0x10)
            | GET_FLAG(CH14_SW, 0x20)
            | GET_FLAG(CH15_SW, 0x40)
            | GET_FLAG(CH16_SW, 0x80);

    if (sub_protocol==0)
        packet[10] = REDPINE_LOOPTIME_FAST;
    else
        packet[10] = REDPINE_LOOPTIME_SLOW;
}

uint16_t REDPINE_callback()
{
	CC2500_SetFreqOffset();
	if(IS_BIND_IN_PROGRESS)
	{
        if (state == REDPINE_BIND) {
    		REDPINE_RF_init(0);
        }
		REDPINE_set_channel(49);
        CC2500_SetTxRxMode(TX_EN);
		CC2500_SetPower();
		CC2500_Strobe(CC2500_SFRX);
		REDPINE_build_bind_packet();
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteData(packet, REDPINE_PACKET_SIZE);
		if(--bind_counter==0)
		{
			BIND_DONE;
			REDPINE_RF_init(sub_protocol);
		}
		return 4000;
	}
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(packet_period);
	#endif
	CC2500_SetTxRxMode(TX_EN);
	REDPINE_set_channel(hopping_frequency_no);
	CC2500_SetPower();
	CC2500_Strobe(CC2500_SFRX);
	REDPINE_data_frame();
	CC2500_Strobe(CC2500_SIDLE);
	hopping_frequency_no = (hopping_frequency_no + 1) % 49;
	CC2500_WriteData(packet, REDPINE_PACKET_SIZE);
	return packet_period;
}

// register, fast 250k, slow
static const uint8_t REDPINE_init_data[][3] = {
    {CC2500_00_IOCFG2,    0x06, 0x06},
    {CC2500_02_IOCFG0,    0x06, 0x06},
    {CC2500_03_FIFOTHR,   0x07, 0x07},
    {CC2500_07_PKTCTRL1,  0x04, 0x04},
    {CC2500_08_PKTCTRL0,  0x05, 0x05},
    {CC2500_09_ADDR,      0x00, 0x00},
    {CC2500_0B_FSCTRL1,   0x0A, 0x06},
    {CC2500_0C_FSCTRL0,   0x00, 0x00},
    {CC2500_0D_FREQ2,     0x5D, 0x5D},
    {CC2500_0E_FREQ1,     0x93, 0x93},
    {CC2500_0F_FREQ0,     0xB1, 0xB1},
    {CC2500_10_MDMCFG4,   0x2D, 0x78},
    {CC2500_11_MDMCFG3,   0x3B, 0x93},
    {CC2500_12_MDMCFG2,   0x73, 0x03},
    {CC2500_13_MDMCFG1,   0x23, 0x22},
    {CC2500_14_MDMCFG0,   0x56, 0xF8},  // Chan space
    {CC2500_15_DEVIATN,   0x00, 0x44},
    {CC2500_17_MCSM1,     0x0c, 0x0c},
    {CC2500_18_MCSM0,     0x18, 0x18},
    {CC2500_19_FOCCFG,    0x1D, 0x16},
    {CC2500_1A_BSCFG,     0x1C, 0x6c},
    {CC2500_1B_AGCCTRL2,  0xC7, 0x43},
    {CC2500_1C_AGCCTRL1,  0x00, 0x40},
    {CC2500_1D_AGCCTRL0,  0xB0, 0x91},
    {CC2500_21_FREND1,    0xB6, 0x56},
    {CC2500_22_FREND0,    0x10, 0x10},
    {CC2500_23_FSCAL3,    0xEA, 0xA9},
    {CC2500_24_FSCAL2,    0x0A, 0x0A},
    {CC2500_25_FSCAL1,    0x00, 0x00},
    {CC2500_26_FSCAL0,    0x11, 0x11},
    {CC2500_29_FSTEST,    0x59, 0x59},
    {CC2500_2C_TEST2,     0x88, 0x88},
    {CC2500_2D_TEST1,     0x31, 0x31},
    {CC2500_2E_TEST0,     0x0B, 0x0B},
	{CC2500_3E_PATABLE,   0xff, 0xff}
};

static void REDPINE_RF_init(uint8_t format)
{
	CC2500_Reset();

	CC2500_WriteReg(CC2500_06_PKTLEN, REDPINE_PACKET_SIZE);

	for (uint8_t i=0; i < ((sizeof(REDPINE_init_data)) / (sizeof(REDPINE_init_data[0]))); i++) {
		CC2500_WriteReg(REDPINE_init_data[i][0], REDPINE_init_data[i][format+1]);
	}

	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);
	CC2500_Strobe(CC2500_SIDLE);

	// calibrate hop channels
	for (uint8_t c = 0; c < REDPINE_NUM_HOPS; c++)
	{
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, hopping_frequency[c]);
		CC2500_Strobe(CC2500_SCAL);
		delayMicroseconds(900);
		calData[c] = CC2500_ReadReg(CC2500_25_FSCAL1);
	}
}

void REDPINE_init()
{
	hopping_frequency_no = 0;
	// Used from kn_nrf24l01.c : kn_calculate_freqency_hopping_channels
	uint32_t idx = 0;
	uint32_t rnd = MProtocol_id;
	#define REDPINE_MAX_RF_CHANNEL 255
	while (idx < REDPINE_NUM_HOPS-1)
	{
		uint32_t i;
		rnd = rnd * 0x0019660D + 0x3C6EF35F;  // Randomization
		// Drop least-significant byte for better randomization. Start from 1
		uint8_t next_ch = (rnd >> 8) % REDPINE_MAX_RF_CHANNEL + 1;
		// Check that it's not duplicate nor adjacent nor channel 0 or 1
		for (i = 0; i < idx; i++)
		{
			uint8_t ch = hopping_frequency[i];
            if ((ch <= next_ch + 1) && (ch >= next_ch - 1) && (ch >= 1)) {
                break;
            }
		}
		if (i != idx)
			continue;
		hopping_frequency[idx++] = next_ch;
	}
	hopping_frequency[49] = 0;  // Last channel is the bind channel at hop 0

	if (sub_protocol==0)
		packet_period = REDPINE_LOOPTIME_FAST*100;
	else
		packet_period = REDPINE_LOOPTIME_SLOW*1000;

	bind_counter=REDPINE_BIND;
	REDPINE_RF_init(sub_protocol);
	CC2500_SetTxRxMode(TX_EN);  // enable PA
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SGF22_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with SGF22, ParkTen F22S, KF700 J20

#if defined(SGF22_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_SGF22_ORIGINAL_ID
#define FORCE_SGF22_CX10_ORIGINAL_ID

#define SGF22_PACKET_PERIOD				11950 //10240
#define SGF22_PAYLOAD_SIZE				12
#define SGF22_BIND_COUNT				50
#define SGF22_RF_NUM_CHANNELS			4
#define SGF22_BIND_RF_CHANNEL			78
#define SGF22_F22S_BIND_RF_CHANNEL		10
#define SGF22_J20_BIND_RF_CHANNEL  		28
#define SGF22_CX10_BIND_RF_CHANNEL		48

//packet[8]
#define SGF22_FLAG_3D					0x00
#define SGF22_FLAG_LIGHT				0x04
#define SGF22_FLAG_ROLL					0x08
#define SGF22_FLAG_VIDEO				0x10
#define SGF22_FLAG_6G					0x40
#define SGF22_FLAG_VERTICAL				0xC0

#define SGF22_J20_FLAG_HORIZONTAL		0x80
//#define SGF22_J20_FLAG_SPEED			0x01	// Up/Down trim, not implemented

#define SGF22_FX922_FLAG_BALANCEHIGH	0x01
#define SGF22_FX922_FLAG_BALANCE		0x02


//packet[9]
#define SGF22_FLAG_TRIMRESET			0x04
#define SGF22_FLAG_PHOTO				0x40	// #define SGF22_J20_FLAG_INVERT  0x40
#define SGF22_J20_FLAG_FIXHEIGHT		0x80

#define SGF22_WRITE_TIME				1000

enum {
	SGF22_DATA1,
	SGF22_DATA2,
	SGF22_DATA3,
	SGF22_RX,
};

static void __attribute__((unused)) SGF22_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		packet[ 0] = 0x5B;
		packet[ 8] = 0x00;								// ??? do they have to be 0 for bind to succeed ?
		packet[ 9] = 0x00;								// ??? do they have to be 0 for bind to succeed ?
		packet[10] = 0xAA;
		packet[11] = 0x55;
	}
	else
	{
		//hop
		XN297_Hopping(packet_sent & 0x03);				// ??? from the dumps I can't really say how hop and seq are sync, there could be an offset (0,1,2,3)...
		//sequence from 02 to 7A by increments of 4, sometimes with a flag 0x80 from 82 to FA, I can't tell from the dumps when the switch happens
		if( (packet_sent & 0x03) == 0x02)
			packet_count = packet_sent;
		packet_sent++;
		if(packet_sent > 0x7B)
			packet_sent = 0;
		//packet
		packet[0] = 0x1B;
		if (sub_protocol != SGF22_CX10)
		{//SGF22_F22,SGF22_F22S,SGF22_J20
			packet[8] = SGF22_FLAG_3D           			// CH5 -100%, F22 & F22S - 3D mode, J20 - Gyro off  
				| GET_FLAG(CH6_SW, SGF22_FLAG_ROLL)			// roll
				| GET_FLAG(CH7_SW, SGF22_FLAG_LIGHT)		// push up throttle trim for light in the stock TX
				| GET_FLAG(CH9_SW, SGF22_FLAG_VIDEO)		// push down throttle trim for video in the stock TX
				| GET_FLAG(CH11_SW, SGF22_FX922_FLAG_BALANCE)
				| GET_FLAG(CH12_SW, SGF22_FX922_FLAG_BALANCEHIGH);
			if(Channel_data[CH5] > CHANNEL_MAX_COMMAND)
				packet[8] |= SGF22_FLAG_VERTICAL;     		// CH5 100%,  vertical mode (torque)    
			else if(Channel_data[CH5] > CHANNEL_MIN_COMMAND )
			packet[8] |= ( sub_protocol == SGF22_J20 ? SGF22_J20_FLAG_HORIZONTAL : SGF22_FLAG_6G );     // CH5 0%, F22 & F22S - 6G mode, J20 - Horizontal mode
		}
		else //SGF22_CX10 114548
		{
			if(CH6_SW)
				flags = 0x06;								// high rate
			else
				if(Channel_data[CH6] < CHANNEL_MIN_COMMAND)
					flags = 0x04;							// low rate
				else
					flags = 0x05;							// mid rate
			packet[8] = flags
				| GET_FLAG(CH5_SW, 0x08);					// flip
		}
		packet[9] = GET_FLAG(CH8_SW, SGF22_FLAG_PHOTO)		// F22: photo, press in throttle trim in the stock TX, J20: invert flight
			| GET_FLAG(CH10_SW, ( sub_protocol == SGF22_J20 ? SGF22_J20_FLAG_FIXHEIGHT : SGF22_FLAG_TRIMRESET )) ;   // F22: Both sticks down inwards in the stock TX, J20: Altitude hold
		packet[10] = 0x42;									// no fine tune
		packet[11] = 0x10;									// no fine tune
	}
	if(sub_protocol == SGF22_F22S)
		packet[0] += 6;
	else if (sub_protocol == SGF22_J20)
    		packet[0] += 3; 
	else if (sub_protocol == SGF22_CX10)
    		packet[0] += 0x6A; 
	packet[1] = packet_count;								// sequence
	packet[2] = rx_tx_addr[2];
	packet[3] = rx_tx_addr[3];
	packet[4] = convert_channel_8b(THROTTLE);
	packet[5] = convert_channel_8b(RUDDER);
	packet[6] = convert_channel_8b(ELEVATOR);
	packet[7] = convert_channel_8b(AILERON);

	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	if (sub_protocol != SGF22_CX10)
		XN297_WriteEnhancedPayload(packet, SGF22_PAYLOAD_SIZE,0);
	else
		XN297_WritePayload(packet, SGF22_PAYLOAD_SIZE);
	#if 0
		debug_time("");
		for(uint8_t i=0; i<SGF22_PAYLOAD_SIZE; i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
}

static void __attribute__((unused)) SGF22_initialize_txid()
{
	uint16_t val = ( rx_tx_addr[2] << 8 ) | rx_tx_addr[3];
	if ( rx_tx_addr[2] > ( 0xFF - rx_tx_addr[3]) )
		val--;
	val %= 5;

	const uint8_t hop[5][4] =
	{ { 0x0C, 0x2A, 0x1B, 0x39 },
	  { 0x0F, 0x2D, 0x1E, 0x3D },
	  { 0x12, 0x31, 0x21, 0x41 },
	  { 0x15, 0x34, 0x24, 0x44 },
	  { 0x18, 0x37, 0x27, 0x47 } };
	memcpy(hopping_frequency, &hop[val], SGF22_RF_NUM_CHANNELS);

	/*//Same code size...
	hopping_frequency[0] = 0x0C + 3 * val;
	hopping_frequency[1] = hopping_frequency[0] + 0x1E;
	if(val > 1) hopping_frequency[1]++;
	hopping_frequency[2] = hopping_frequency[0] + 0x0F;
	hopping_frequency[3] = hopping_frequency[1] + 0x0F;
	if(val    ) hopping_frequency[3]++;*/
	
	#ifdef FORCE_SGF22_ORIGINAL_ID
		rx_tx_addr[2] = 0x1F;	// TX2:27 TX3:2B
		rx_tx_addr[3] = 0x61;	// TX2:51 TX3:0C
		memcpy(hopping_frequency,"\x15\x34\x24\x44", SGF22_RF_NUM_CHANNELS);    //Original dump=>21=0x15,52=0x34,36=0x24,68=0x44
	#endif
	#ifdef FORCE_SGF22_CX10_ORIGINAL_ID
		if(sub_protocol == SGF22_CX10)
		{
			if(rx_tx_addr[3] & 1)
			{
				rx_tx_addr[2] = 0x4C;
				rx_tx_addr[3] = 0xD7;
				memcpy(hopping_frequency, "\x37\x42\x47\x3c", SGF22_RF_NUM_CHANNELS);
			}
			else
			{
				rx_tx_addr[2] = 0x50;
				rx_tx_addr[3] = 0xE1;
				memcpy(hopping_frequency, "\x3b\x4b\x46\x41", SGF22_RF_NUM_CHANNELS);
			}
		}
	#endif
	#if 0
		debug("ID: %02X %02X, C: ",rx_tx_addr[2],rx_tx_addr[3]);
		for(uint8_t i=0; i<SGF22_RF_NUM_CHANNELS; i++)
			debug(" %02X",hopping_frequency[i]);
		debugln("");
	#endif
}

static void __attribute__((unused)) SGF22_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"\xC7\x95\x3C\xBB\xA5", 5);
	#ifdef SGF22_HUB_TELEMETRY
		XN297_SetRXAddr((uint8_t*)"\xC7\x95\x3C\xBB\xA5", SGF22_PAYLOAD_SIZE);
	#endif

	const uint8_t bind_chan[] = {SGF22_BIND_RF_CHANNEL, SGF22_F22S_BIND_RF_CHANNEL, SGF22_J20_BIND_RF_CHANNEL, SGF22_CX10_BIND_RF_CHANNEL};
	XN297_RFChannel(bind_chan[sub_protocol]);	// Set bind channel
}

uint16_t SGF22_callback()
{
	#ifdef SGF22_HUB_TELEMETRY
		bool rx = false;
		static uint8_t telem_count = 0;
	#endif

	switch(phase)
	{
		case SGF22_DATA1:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(SGF22_PACKET_PERIOD);
			#endif
	#ifdef SGF22_HUB_TELEMETRY
			rx = XN297_IsRX();
			XN297_SetTxRxMode(TXRX_OFF);
	#endif
			SGF22_send_packet();
			if(IS_BIND_IN_PROGRESS)
			{
				if(--bind_counter==0)
					BIND_DONE;
			}
	#ifdef SGF22_HUB_TELEMETRY
			if(rx)
			{
				uint8_t p_len = XN297_ReadEnhancedPayload(packet_in, SGF22_PAYLOAD_SIZE);
				if(p_len == 3 && packet_in[0] == rx_tx_addr[2] && packet_in[1] == rx_tx_addr[3])
				{//packets: 00 0B 00 -> 00 0B 01
					telemetry_link = 1;
					v_lipo1 = packet_in[2] ? 0 : 255;	//2.9V for 1S, 7.0V for 2S
					telemetry_lost = 0;
					telem_count = 0;
				}
				#if 0
					debug("L %d ",p_len);
					debug("RX");
					for(uint8_t i=0; i<SGF22_PAYLOAD_SIZE; i++)
						debug(" %02X",packet_in[i]);
					debugln("");
				#endif
			}
			if(telem_count > 4*63)				// Around 3.5sec with no telemetry
				telemetry_lost = 1;
			else
			{
				telem_count++;
				if(!telemetry_lost && (telem_count & 0x3F) == 0)
				{// Should have received a telem packet but... Send telem to the radio to keep it alive
					telemetry_link = 1;
					#if 0
						debugln("Miss");
					#endif
				}
			}

	#endif
			phase++;
			break;
		case SGF22_DATA2:
		case SGF22_DATA3:
			//send 3 times in total the same packet
			XN297_ReSendPayload();
			phase++;
			break;
		default: //SGF22_RX
	#ifdef SGF22_HUB_TELEMETRY
			/*{ // Wait for packet to be sent before switching to receive mode
				uint16_t start=(uint16_t)micros(), count=0;
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
				{
					if(XN297_IsPacketSent())
						break;
					count++;
				}
				debugln("%d",count);
			}*/
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
	#endif
			phase = SGF22_DATA1;
			return SGF22_PACKET_PERIOD - 3*1550;
	}
	return 1550;
}

void SGF22_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	SGF22_initialize_txid();
	SGF22_RF_init();
	bind_counter=SGF22_BIND_COUNT;
	packet_sent = packet_count = 0x26;	// TX2:26 TX3:26
	phase = SGF22_DATA1;
	#ifdef SGF22_HUB_TELEMETRY
		RX_RSSI = 100;		// Dummy value
		telemetry_lost = 1;
	#endif
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SHENQI2_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
#if defined(SHENQI2_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_SHENQI2_ORIGINAL_ID

#define SHENQI2_PAYLOAD_SIZE		8
#define SHENQI2_RF_NUM_CHANNELS		16
#define SHENQI2_BIND_COUNT			2000
#define SHENQI2_WRITE_TIME			650
#define SHENQI2_BIND_CHANNEL		44
#define SHENQI2_PACKET_PERIOD		8210


enum {
	SHENQI2_BIND = 0,
	SHENQI2_BIND_RX,
	SHENQI2_DATA,
};

static void __attribute__((unused)) SHENQI2_send_packet()
{
	if(bind_counter)
	{
		bind_counter--;
		if(!bind_counter)
			BIND_DONE;
	}

	memset(packet, 0x00, SHENQI2_PAYLOAD_SIZE);

	packet_count &= 0x0F;
	packet[0] = packet_count;
	
	memcpy(&packet[1],rx_tx_addr,5);

	if(IS_BIND_DONE)
	{//Normal
		uint8_t val = convert_channel_8b(CH2);
		if(val < 0x70)
			val = 0x30;
		else if(val < 0x80)
			val = 0x00;
		else
		{
			val &= 0x7F;
			val >>= 2;
		}
		if(Channel_data[CH1] > 1024+50)
			val |= 0x40;
		else if(Channel_data[CH1] < 1024-50)
			val |= 0x80;
		packet[6] = val;
		//packet[7] = 0x00;		// ??
	}
	else
		packet[0] |= 0x30;

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, SHENQI2_PAYLOAD_SIZE, false);
	#ifdef DEBUG_SERIAL
		for(uint8_t i=0; i < SHENQI2_PAYLOAD_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) SHENQI2_initialize_txid()
{
	#ifdef FORCE_SHENQI2_ORIGINAL_ID
		//TXID
		rx_tx_addr[0] = 0x51;
		rx_tx_addr[1] = 0x70;
		rx_tx_addr[2] = 0x02;
		//RXID
		rx_tx_addr[3] = 0x46;
		rx_tx_addr[4] = 0xBE;
	#endif
	rx_tx_addr[3] = 0x00;
	rx_tx_addr[4] = 0x00;
	//Freq
	memcpy(hopping_frequency,(uint8_t*)"\x05\x09\x0E\x0F\x17\x1C\x21\x27\x2A\x2C\x33\x39\x3D\x42\x48\x4C",16);
}

static void __attribute__((unused)) SHENQI2_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	//Address
	XN297_SetTXAddr((uint8_t*)"\x74\xD1\x3A\xF5\x6C", 5);
	XN297_SetRXAddr((uint8_t*)"\x74\xD1\x3A\xF5\x6C", SHENQI2_PAYLOAD_SIZE);
	XN297_RFChannel(SHENQI2_BIND_CHANNEL);
}

uint16_t SHENQI2_callback()
{
	static bool rx=false;
	
	switch(phase)
	{
		case SHENQI2_BIND:
			rx = XN297_IsRX();
			XN297_SetTxRxMode(TXRX_OFF);
			SHENQI2_send_packet();
			packet_count++;
			if(rx)
			{
				uint8_t val=XN297_ReadEnhancedPayload(packet_in, SHENQI2_PAYLOAD_SIZE);
				if(val == SHENQI2_PAYLOAD_SIZE)
				{
					if(memcmp(rx_tx_addr, packet_in, 3) == 0)
					{//Good packet with our TXID
						BIND_DONE;
						rx_tx_addr[3] = packet_in[3];
						rx_tx_addr[4] = packet_in[4];
						packet_count = 0;
						phase = SHENQI2_DATA;
					}
					#ifdef DEBUG_SERIAL
						for(uint8_t i=0; i < SHENQI2_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
						debugln();
					#endif
				}
			}
			phase++;
			return SHENQI2_WRITE_TIME;
		case SHENQI2_BIND_RX:
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = SHENQI2_BIND;
			return SHENQI2_PACKET_PERIOD - SHENQI2_WRITE_TIME;
		default: //SHENQI2_DATA
			//Since I don't know the order of the channels, I'm hopping on all the channels quickly
			//Refresh rate from the motorcycle perspective is 32ms instead of 8ms...
			XN297_Hopping(hopping_frequency_no);
			hopping_frequency_no++;
			hopping_frequency_no &= 0x0F;
			SHENQI2_send_packet();
			if(hopping_frequency_no%4 == 0)
				packet_count++;
			return SHENQI2_PACKET_PERIOD/4;
	}
	return 0;
}

void SHENQI2_init()
{
	BIND_IN_PROGRESS;
	SHENQI2_initialize_txid();
	SHENQI2_RF_init();

	bind_counter = SHENQI2_BIND_COUNT;
	phase = SHENQI2_BIND;
	hopping_frequency_no = 0;
}

#endif
/*
XN297 1Mb Enhanced,Acked,Scrambled

Bind
---
RX on channel: 44, Time:  2890us P: 34 51 70 02 00 00 00 00
RX on channel: 44, Time:  1780us P: 34 51 70 02 00 00 00 00
RX on channel: 44, Time:  1773us P: 34 51 70 02 00 00 00 00
RX on channel: 44, Time:  1772us P: 34 51 70 02 00 00 00 00
RX on channel: 44, Time:  2889us P: 35 51 70 02 00 00 00 00
RX on channel: 44, Time:  1769us P: 35 51 70 02 00 00 00 00
RX on channel: 44, Time:  1774us P: 35 51 70 02 00 00 00 00
RX on channel: 44, Time:  1771us P: 35 51 70 02 00 00 00 00
RX on channel: 44, Time:  2894us P: 36 51 70 02 00 00 00 00

A= 74 D1 3A F5 6C
RF:44
Timing: 1772s between the same 4 packets, 2892s to the next packet, 8208s between 2 packets
Request ack, if no ack repeat the packet 4 times

P[0] = counter 00..0F | 30 bind
P[1] = TXID[0]
P[2] = TXID[1]
P[3] = TXID[2]
P[4] = RXID[0]
P[5] = RXID[1]
P[6] = TH 00..1F, Break 30, 40 ST_right, 80 ST_left
P[7] = 00?

Answer from motorcycle:
P: 51 70 02 46 BE 00 00 00
P[0] = TXID[0]
P[1] = TXID[1]
P[2] = TXID[2]
P[3] = RXID[0]
P[4] = RXID[1]
P[5] = 00
P[6] = 00
P[7] = 00

Normal packets
---
A= 74 D1 3A F5 6C
RF:5,9,14,15,23,28,33,39,42,44,51,57,61,66,72,76
RF:\x05\x09\x0E\x0F\x17\x1C\x21\x27\x2A\x2C\x33\x39\x3D\x42\x48\x4C
- order of the channels is unknown and vary over time
- send 16 times on each channel and switch (counter 00..0F)
Timing:1772s between the same 4 packets, 2892s to the next packet, 8208s between 2 packets
Timing:8208 between packets if acked
P: 00 51 70 02 46 BE 00 00
P[0] = counter 00..0F
P[1] = TXID[0]
P[2] = TXID[1]
P[3] = TXID[2]
P[4] = RXID[0]
P[5] = RXID[1]
P[6] = TH 00..1F, Break 30, 40 ST_right, 80 ST_left
P[7] = 00?
*/
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SHENQI_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(SHENQI_NRF24L01_INO)

#include "iface_nrf24l01.h"

const uint8_t PROGMEM SHENQI_Freq[] = {
			50,50,20,60,30,40,
			10,30,40,20,60,10,
			50,20,50,40,10,60,
			30,30,60,10,40,50,
			20,10,60,20,50,30,
			40,40,30,50,20,60,
			10,10,20,30,40,50,
			60,60,50,40,30,20,
			10,60,10,50,30,40,
			20,10,40,30,60,20 };

void SHENQI_RF_init()
{
    NRF24L01_Initialize();

	LT8900_Config(4, 8, _BV(LT8900_CRC_ON)|_BV(LT8900_PACKET_LENGTH_EN), 0xAA);
	LT8900_SetChannel(2);
	LT8900_SetAddress((uint8_t *)"\x9A\x9A\x9A\x9A",4);
	LT8900_SetTxRxMode(RX_EN);
}

void SHENQI_send_packet()
{
	packet[0]=0x00;
	if(packet_count==0)
	{
		uint8_t bind_addr[4];
		bind_addr[0]=rx_tx_addr[0];
		bind_addr[1]=rx_tx_addr[1];
		bind_addr[2]=0x9A;
		bind_addr[3]=0x9A;
		LT8900_SetAddress(bind_addr,4);
		LT8900_SetChannel(2);
		packet[1]=rx_tx_addr[2];
		packet[2]=rx_tx_addr[3];
		packet_period=2508;
	}
	else
	{
		#ifdef MULTI_SYNC
			if(packet_count==1)
				telemetry_set_input_sync(3000+2508+6*1750);
		#endif
		LT8900_SetAddress(rx_tx_addr,4);
		packet[1]=255-convert_channel_8b(RUDDER);
		packet[2]=255-convert_channel_16b_limit(THROTTLE,0x60,0xA0);
		uint8_t freq=pgm_read_byte_near(&SHENQI_Freq[hopping_frequency_no])+(rx_tx_addr[2]&0x0F);
		LT8900_SetChannel(freq);
		hopping_frequency_no++;
		if(hopping_frequency_no==60)
			hopping_frequency_no=0;
		packet_period=1750;
	}
	// Send packet + 1 retransmit - not sure why but needed (not present on original TX...)
	LT8900_WritePayload(packet,3);
	while(NRF24L01_packet_ack()!=PKT_ACKED);
	LT8900_WritePayload(packet,3);
	
	packet_count++;
	if(packet_count==7)
	{
		packet_count=0;
		packet_period=3000;
	}
	// Set power
	NRF24L01_SetPower();
}

uint16_t SHENQI_callback()
{
	if(IS_BIND_DONE)
	{
		SHENQI_send_packet();
	}
	else
	{
		if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
		{
			if(LT8900_ReadPayload(packet, 3))
			{
				BIND_DONE;
				rx_tx_addr[0]=packet[1];
				rx_tx_addr[1]=packet[2];
				LT8900_SetTxRxMode(TX_EN);
				packet_period=14000;
			}
			NRF24L01_FlushRx();
		}
	}
    return packet_period;
}

void SHENQI_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	SHENQI_RF_init();
	hopping_frequency_no = 0;
	packet_count=0;
	packet_period=500;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SLT_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with deviation main github branch

#if defined(SLT_CCNRF_INO)

#include "iface_nrf250k.h"

//#define SLT_Q200_FORCE_ID
//#define SLT_V1_4_FORCE_ID

// For code readability
#define SLT_PAYLOADSIZE_V1		7
#define SLT_PAYLOADSIZE_V1_4	5
#define SLT_PAYLOADSIZE_V2		11
#define SLT_PAYLOADSIZE_Q100	19
#define SLT_NFREQCHANNELS		15
#define SLT_TXID_SIZE			4
#define SLT_BIND_CHANNEL		0x50
#define SLT6_CH_MIN				182		// 10-bit AETR minimum (captures: 180-185, symmetric around 512)
#define SLT6_CH_MAX				842		// 10-bit AETR maximum (captures: 829-843, symmetric around 512)
#define SLT6_SW_THRESHOLD		273		// ~33% of half-range (820/3) for 3-position switch zones

enum{
	// flags going to packet[6] (Q200)
	FLAG_Q200_FMODE	= 0x20,
	FLAG_Q200_VIDON	= 0x10,
	FLAG_Q200_FLIP	= 0x08,
	FLAG_Q200_VIDOFF= 0x04,
};

enum{
	// flags going to packet[6] (MR100 & Q100)
	FLAG_MR100_FMODE	= 0x20,
	FLAG_MR100_FLIP		= 0x04,
	FLAG_MR100_VIDEO	= 0x02,
	FLAG_MR100_PICTURE	= 0x01,
};

enum {
	SLT_BUILD=0,
	SLT_DATA,
	SLT_LAST_DATA,
	SLT_BIND1,
	SLT_BIND2,
};

// SLT6 sub-cycle states: 3 sub-cycles per triple, each with 2 copies
enum {
	SLT6_BUILD_A=0,		// Build packet, configure for 7B sub-cycle
	SLT6_DATA_A1,		// Send 7B copy 1
	SLT6_DATA_A2,		// Send 7B copy 2, configure for 6B sub-cycle
	SLT6_DATA_B1,		// Send 6B copy 1
	SLT6_DATA_B2,		// Send 6B copy 2, configure for 5B sub-cycle
	SLT6_DATA_C1,		// Send 5B copy 1
	SLT6_DATA_C2,		// Send 5B copy 2
	SLT6_BIND,			// Send bind packet
};

// SLT6 address XOR values for the 3 sub-cycles
#define SLT6_ADDR_XOR_A		0x00	// 7B sub-cycle: base address
#define SLT6_ADDR_XOR_B		0x06	// 6B sub-cycle: byte[0] XOR 0x06
#define SLT6_ADDR_XOR_C		0x09	// 5B sub-cycle: byte[0] XOR 0x09

// SLT6 timing (from capture 12b, in microseconds)
#define SLT6_TIMING_SUBCYCLE	5994	// ~6000us between sub-cycle starts
#define SLT6_TIMING_PAIR		1633	// ~1633us between the two copies within a sub-cycle
#define SLT6_TIMING_BUILD		1000	// Build+config time at start of each triple
#define SLT6_TIMING_TRIPLE		(3 * SLT6_TIMING_SUBCYCLE)	// ~18ms triple period

static void __attribute__((unused)) SLT_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K, option == 0);	// SLT: option==0 uses NRF24L01, option!=0 uses CC2500 with freq tuning
	NRF250K_SetTXAddr(rx_tx_addr, SLT_TXID_SIZE);
}

static void __attribute__((unused)) SLT_set_freq(void)
{
	// Frequency hopping sequence generation
	for (uint8_t i = 0; i < SLT_TXID_SIZE; ++i)
	{
		uint8_t next_i = (i+1) % SLT_TXID_SIZE; // is & 3 better than % 4 ?
		uint8_t base = i < 2 ? 0x03 : 0x10;
		hopping_frequency[i*4 + 0]  = (rx_tx_addr[i] & 0x3f) + base;
		hopping_frequency[i*4 + 1]  = (rx_tx_addr[i] >> 2) + base;
		hopping_frequency[i*4 + 2]  = (rx_tx_addr[i] >> 4) + (rx_tx_addr[next_i] & 0x03)*0x10 + base;
		hopping_frequency[i*4 + 3]  = (rx_tx_addr[i] >> 6) + (rx_tx_addr[next_i] & 0x0f)*0x04 + base;
	}

	// Unique freq
	uint8_t max_freq = 0x50;	//V1, V2, and MR100
	if(sub_protocol == Q200)
		max_freq=45;
	for (uint8_t i = 0; i < SLT_NFREQCHANNELS; ++i)
	{
		if(sub_protocol == Q200 && hopping_frequency[i] >= max_freq)
			hopping_frequency[i] = hopping_frequency[i] - max_freq + 0x03;
		uint8_t done = 0;
		while (!done)
		{
			done = 1;
			for (uint8_t j = 0; j < i; ++j)
				if (hopping_frequency[i] == hopping_frequency[j])
				{
					done = 0;
					hopping_frequency[i] += 7;
					if (hopping_frequency[i] >= max_freq)
						hopping_frequency[i] = hopping_frequency[i] - max_freq + 0x03;
				}
		}
	}
	#ifdef DEBUG_SERIAL
		debug("CH:");
		for (uint8_t i = 0; i < SLT_NFREQCHANNELS; ++i)
			debug(" %02X(%d)", hopping_frequency[i], hopping_frequency[i]);
		debugln();
	#endif
	
	//Bind channel
	hopping_frequency[SLT_NFREQCHANNELS] = SLT_BIND_CHANNEL;
	
	//Calib all channels
	NRF250K_HoppingCalib(SLT_NFREQCHANNELS+1);
}

static void __attribute__((unused)) SLT_wait_radio()
{
	if (packet_sent)
		while (!NRF250K_IsPacketSent());
	packet_sent = 0;
}

static void __attribute__((unused)) SLT_send_packet(uint8_t len)
{
	SLT_wait_radio();
	NRF250K_WritePayload(packet, len);
	packet_sent = 1;
}

static void __attribute__((unused)) SLT_build_packet()
{
	static uint8_t calib_counter=0;
	
	// Set radio channel - once per packet batch
	NRF250K_SetFreqOffset();	// Set frequency offset
	NRF250K_Hopping(hopping_frequency_no);
	if (++hopping_frequency_no >= SLT_NFREQCHANNELS)
		hopping_frequency_no = 0;

	// aileron, elevator, throttle, rudder, gear, pitch
	uint8_t e = 0; // byte where extension 2 bits for every 10-bit channel are packed
	for (uint8_t i = 0; i < 4; ++i)
	{
		uint16_t v = convert_channel_10b(sub_protocol != SLT_V1_4 ? CH_AETR[i] : i, false);
		if(sub_protocol>SLT_V2 && (i==CH2 || i==CH3) && sub_protocol != SLT_V1_4 && sub_protocol != RF_SIM)
			v=1023-v;	// reverse throttle and elevator channels for Q100/Q200/MR100 protocols
		packet[i] = v;
		e = (e >> 2) | (uint8_t) ((v >> 2) & 0xC0);
	}
	// Extra bits for AETR
	packet[4] = e;

	//->V1_4CH stops here

	// 8-bit channels
	packet[5] = convert_channel_8b(CH5);
	packet[6] = convert_channel_8b(CH6);

	//->V1 stops here

	if(sub_protocol == Q200)
		packet[6] =  GET_FLAG(CH9_SW , FLAG_Q200_FMODE)
					|GET_FLAG(CH10_SW, FLAG_Q200_FLIP)
					|GET_FLAG(CH11_SW, FLAG_Q200_VIDON)
					|GET_FLAG(CH12_SW, FLAG_Q200_VIDOFF);
	else if(sub_protocol == MR100 || sub_protocol == Q100)
		packet[6] =  GET_FLAG(CH9_SW , FLAG_MR100_FMODE)
					|GET_FLAG(CH10_SW, FLAG_MR100_FLIP)
					|GET_FLAG(CH11_SW, FLAG_MR100_VIDEO)	// Does not exist on the Q100 but...
					|GET_FLAG(CH12_SW, FLAG_MR100_PICTURE);	// Does not exist on the Q100 but...
	packet[7] = convert_channel_8b(CH7);
	packet[8] = convert_channel_8b(CH8);
	if(sub_protocol == RF_SIM)
	{
		packet[9]  = convert_channel_8b(CH9);
		packet[10] = convert_channel_8b(CH10);
	}
	else
	{
		packet[9]  = 0xAA;		//normal mode for Q100/Q200, unknown for V2/MR100
		packet[10] = 0x00;		//normal mode for Q100/Q200, unknown for V2/MR100
	}
	if((sub_protocol == Q100 || sub_protocol == Q200) && CH13_SW)
	{//Calibrate
		packet[9] = 0x77;			//enter calibration
		if(calib_counter >= 20 && calib_counter <= 25)	// 7 packets for Q100 / 3 packets for Q200
			packet[10] = 0x20;	//launch calibration
		calib_counter++;
		if(calib_counter > 250) calib_counter = 250;
	}
	else
		calib_counter = 0;

	// Q100 uses 19-byte packets: bytes[11..18] are zero-padded
	if(sub_protocol == Q100)
		for(uint8_t i = 11; i < SLT_PAYLOADSIZE_Q100; i++)
			packet[i] = 0x00;
}

// SLT6: build 7-byte data packet from current channel values
static void __attribute__((unused)) SLT6_build_packet()
{
	// aileron, elevator, throttle, rudder (10-bit, limited range)
	uint8_t e = 0;
	for (uint8_t i = 0; i < 4; ++i)
	{
		uint16_t v = convert_channel_16b_limit(CH_AETR[i], SLT6_CH_MIN, SLT6_CH_MAX);
		packet[i] = v;
		e = (e >> 2) | (uint8_t) ((v >> 2) & 0xC0);
	}
	packet[4] = e;

	// Flight mode: 3 positions at ~33% each
	if(Channel_data[CH5] > CHANNEL_MID + SLT6_SW_THRESHOLD)
		packet[5] = 0xD0;
	else if(Channel_data[CH5] < CHANNEL_MID - SLT6_SW_THRESHOLD)
		packet[5] = 0x30;
	else
		packet[5] = 0x80;

	// Panic: only active when CH6 is below -33%, center and up = no panic
	if(Channel_data[CH6] < CHANNEL_MID - SLT6_SW_THRESHOLD)
		packet[6] = 0x30;
	else
		packet[6] = 0xD0;
}

// SLT6: configure radio for a sub-cycle (set address and channel)
static void __attribute__((unused)) SLT6_configure_radio(uint8_t addr_xor, uint8_t hop_offset)
{
	SLT_wait_radio();
	// Set TX address with XOR on byte[0]
	uint8_t addr[SLT_TXID_SIZE];
	memcpy(addr, rx_tx_addr, SLT_TXID_SIZE);
	addr[0] ^= addr_xor;
	NRF250K_SetTXAddr(addr, SLT_TXID_SIZE);
	// Set RF channel
	NRF250K_Hopping((hopping_frequency_no + hop_offset) % SLT_NFREQCHANNELS);
}

static void __attribute__((unused)) SLT_send_bind_packet()
{
	SLT_wait_radio();
	if(phase == SLT_BIND2 || phase == SLT6_BIND)
		NRF250K_Hopping(SLT_NFREQCHANNELS);	//Bind channel for BIND2 and SLT6 BIND
	BIND_IN_PROGRESS;					//Limit TX power to bind level
	NRF250K_SetPower();
	BIND_DONE;
	NRF250K_SetTXAddr((uint8_t *)"\x7E\xB8\x63\xA9", SLT_TXID_SIZE);
	memcpy((void*)packet, (void*)rx_tx_addr, SLT_TXID_SIZE);
	if(phase == SLT_BIND2 || phase == SLT6_BIND)
		SLT_send_packet(SLT_TXID_SIZE);
	else // SLT_BIND1
		SLT_send_packet(packet_length);
}

#define SLT_FRAME_PERIOD		18000
#define SLT_TIMING_BUILD		1000
#define SLT_V1_TIMING_PACKET	1600
#define SLT_V1_4_TIMING_PACKET	1643
#define SLT_V2_TIMING_PACKET	2042
#define SLT_Q100_TIMING_PACKET	1897
#define SLT_MR100_TIMING_PACKET	2007
#define SLT_V1_TIMING_BIND2		1000
#define SLT_V2_TIMING_BIND1		6507
#define SLT_V2_TIMING_BIND2		2112
#define SLT_Q100_TIMING_BIND1	3652
#define SLT_Q100_TIMING_BIND2	1217
#define SLT_MR100_TIMING_BIND2	1008

// SLT6 callback: triple-address state machine
// Each triple: 3 sub-cycles (7B, 6B, 5B), each sent twice, with different addresses and channels
static uint16_t __attribute__((unused)) SLT6_callback()
{
	switch (phase)
	{
		case SLT6_BUILD_A:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(SLT6_TIMING_TRIPLE);
			#endif
			SLT6_build_packet();
			NRF250K_SetPower();
			SLT6_configure_radio(SLT6_ADDR_XOR_A, 0);	// 7B sub-cycle: base address, hop+0
			phase = SLT6_DATA_A1;
			return SLT6_TIMING_BUILD;
		case SLT6_DATA_A1:
			SLT_send_packet(7);
			phase = SLT6_DATA_A2;
			return SLT6_TIMING_PAIR;					// 1633us between copies
		case SLT6_DATA_A2:
			SLT_send_packet(7);
			SLT6_configure_radio(SLT6_ADDR_XOR_B, 3);	// 6B sub-cycle: XOR 0x06 address, hop+3
			phase = SLT6_DATA_B1;
			return SLT6_TIMING_SUBCYCLE - SLT6_TIMING_PAIR;	// 4361us to next sub-cycle TX
		case SLT6_DATA_B1:
			SLT_send_packet(6);
			phase = SLT6_DATA_B2;
			return SLT6_TIMING_PAIR;
		case SLT6_DATA_B2:
			SLT_send_packet(6);
			SLT6_configure_radio(SLT6_ADDR_XOR_C, 6);	// 5B sub-cycle: XOR 0x09 address, hop+6
			phase = SLT6_DATA_C1;
			return SLT6_TIMING_SUBCYCLE - SLT6_TIMING_PAIR;	// 4361us
		case SLT6_DATA_C1:
			SLT_send_packet(5);
			phase = SLT6_DATA_C2;
			return SLT6_TIMING_PAIR;
		case SLT6_DATA_C2:
			SLT_send_packet(5);
			// Advance hopping for next triple
			if (++hopping_frequency_no >= SLT_NFREQCHANNELS)
				hopping_frequency_no = 0;
			if (++packet_count >= 100)
			{// Send bind packet periodically
				packet_count = 0;
				phase = SLT6_BIND;
				return SLT_V1_TIMING_BIND2;
			}
			phase = SLT6_BUILD_A;
			return SLT6_TIMING_SUBCYCLE - SLT6_TIMING_PAIR - SLT6_TIMING_BUILD;	// Gap before next build
		case SLT6_BIND:
			SLT_send_bind_packet();
			phase = SLT6_BUILD_A;
			return SLT6_TIMING_SUBCYCLE - SLT6_TIMING_PAIR - SLT6_TIMING_BUILD;
	}
	return SLT6_TIMING_TRIPLE;
}

uint16_t SLT_callback()
{
	// SLT6 has its own state machine
	if(sub_protocol == SLT6_Tx)
		return SLT6_callback();

	switch (phase)
	{
		case SLT_BUILD:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(packet_period);
			#endif
			SLT_build_packet();
			NRF250K_SetPower();					//Change power level
			NRF250K_SetTXAddr(rx_tx_addr, SLT_TXID_SIZE);
			bind_phase = 0;						//Reset data packet counter
			phase = SLT_DATA;
			if(sub_protocol == MR100)
				return 0;						//MR100: no build delay
			return SLT_TIMING_BUILD;
		case SLT_DATA:
			SLT_send_packet(packet_length);
			bind_phase++;
			if(bind_phase >= rf_ch_num)
			{// Last data packet of the frame
				phase = SLT_LAST_DATA;
			}
			if(sub_protocol == SLT_V1 || sub_protocol == SLT_V2 || sub_protocol == RF_SIM)
				return SLT_V1_TIMING_PACKET;
			if(sub_protocol == SLT_V1_4)
				return SLT_V1_4_TIMING_PACKET;
			if(sub_protocol == Q100)
				return SLT_Q100_TIMING_PACKET;
			if(sub_protocol == MR100)
				return SLT_MR100_TIMING_PACKET;
			//Q200
			return SLT_V2_TIMING_PACKET;
		case SLT_LAST_DATA:
			SLT_send_packet(packet_length);
			if (++packet_count >= num_ch)
			{// Send bind packet
				packet_count = 0;
				if(sub_protocol == SLT_V1 || sub_protocol == SLT_V1_4 || sub_protocol == SLT_V2 || sub_protocol == RF_SIM)
				{
					phase = SLT_BIND2;
					return SLT_V1_TIMING_BIND2;
				}
				if(sub_protocol == MR100)
				{// MR100: only BIND2 (no BIND1)
					phase = SLT_BIND2;
					return SLT_MR100_TIMING_BIND2;
				}
				if(sub_protocol == Q100)
				{// Q100: BIND1+BIND2
					phase = SLT_BIND1;
					return SLT_Q100_TIMING_BIND1;
				}
				//Q200
				phase = SLT_BIND1;
				return SLT_V2_TIMING_BIND1;
			}
			else
			{// Continue to send normal packets
				phase = SLT_BUILD;
				if(sub_protocol == SLT_V1 || sub_protocol == SLT_V2 || sub_protocol == RF_SIM)
					return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - SLT_V1_TIMING_PACKET;
				if(sub_protocol == SLT_V1_4)
					return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - SLT_V1_4_TIMING_PACKET;
				if(sub_protocol == Q100)
					return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - 6*SLT_Q100_TIMING_PACKET;
				if(sub_protocol == MR100)
					return SLT_FRAME_PERIOD - 8*SLT_MR100_TIMING_PACKET;
				//Q200
				return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - 2*SLT_V2_TIMING_PACKET;
			}
		case SLT_BIND1:
			SLT_send_bind_packet();
			phase = SLT_BIND2;
			if(sub_protocol == Q100)
				return SLT_Q100_TIMING_BIND2;
			return SLT_V2_TIMING_BIND2;
		case SLT_BIND2:
			SLT_send_bind_packet();
			phase = SLT_BUILD;
			if(sub_protocol == SLT_V1 || sub_protocol == SLT_V2 || sub_protocol == RF_SIM)
				return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - SLT_V1_TIMING_PACKET - SLT_V1_TIMING_BIND2;
			if(sub_protocol == SLT_V1_4)
				return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - SLT_V1_4_TIMING_PACKET - SLT_V1_TIMING_BIND2;
			if(sub_protocol == Q100)
				return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - 6*SLT_Q100_TIMING_PACKET - SLT_Q100_TIMING_BIND1 - SLT_Q100_TIMING_BIND2;
			if(sub_protocol == MR100)
				return SLT_FRAME_PERIOD - 8*SLT_MR100_TIMING_PACKET - SLT_MR100_TIMING_BIND2;
			//Q200
			return SLT_FRAME_PERIOD - SLT_TIMING_BUILD - 2*SLT_V2_TIMING_PACKET - SLT_V2_TIMING_BIND1 - SLT_V2_TIMING_BIND2;
	}
	return 19000;
}

void SLT_init()
{
	BIND_DONE;	// Not a TX bind protocol
	packet_count = 0;
	packet_sent = 0;
	hopping_frequency_no = 0;

	if(sub_protocol == SLT6_Tx)
	{
		hopping_frequency_no = 1;	// SLT6 starts hopping at index 1 (verified from captures)
		// packet_length not used for SLT6 (lengths vary per sub-cycle)
		#ifdef MULTI_SYNC
			packet_period = SLT6_TIMING_TRIPLE;
		#endif
	}
	else if(sub_protocol == SLT_V1)
	{
		packet_length = SLT_PAYLOADSIZE_V1;
		rf_ch_num = 1;									//2 packets per frame
		num_ch = 88;									//Bind every 88 frames
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
	}
	else if(sub_protocol == SLT_V1_4)
	{
		packet_length = SLT_PAYLOADSIZE_V1_4;
		rf_ch_num = 1;									//2 packets per frame
		num_ch = 88;									//Bind every 88 frames
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
		 //Force high part of the ID otherwise the RF frequencies do not match, only tested the 2 last bytes...
		rx_tx_addr[0]=0xF4;
		rx_tx_addr[1]=0x71;
		#ifdef SLT_V1_4_FORCE_ID	// ID taken from TX dumps
			memcpy(rx_tx_addr,"\xF4\x71\x8D\x01",SLT_TXID_SIZE);
		#endif
	}
	else if(sub_protocol == Q100)
	{
		packet_length = SLT_PAYLOADSIZE_Q100;
		rf_ch_num = 6;									//7 packets per frame
		num_ch = 50;									//Bind every 50 frames
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
	}
	else if(sub_protocol == MR100)
	{
		packet_length = SLT_PAYLOADSIZE_V2;
		rf_ch_num = 8;									//9 packets per frame
		num_ch = 83;									//Bind every ~83 frames
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
	}
	else if(sub_protocol == SLT_V2 || sub_protocol == RF_SIM)
	{
		packet_length = SLT_PAYLOADSIZE_V2;
		rf_ch_num = 1;									//2 packets per frame (same as V1)
		num_ch = 88;									//Bind every 88 frames (same as V1)
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
	}
	else //Q200
	{
		packet_length = SLT_PAYLOADSIZE_V2;
		rf_ch_num = 2;									//3 packets per frame
		num_ch = 50;									//Bind every 50 frames
		#ifdef MULTI_SYNC
			packet_period = SLT_FRAME_PERIOD;
		#endif
	}

	if(sub_protocol == Q200 || sub_protocol == Q100)
	{ //Q200/Q100: Force high part of the ID otherwise it won't bind
		rx_tx_addr[0]=0x01;
		rx_tx_addr[1]=0x02;
		#ifdef SLT_Q200_FORCE_ID	// ID taken from TX dumps
			rx_tx_addr[0]=0x01;rx_tx_addr[1]=0x02;rx_tx_addr[2]=0x6A;rx_tx_addr[3]=0x31;
		/*	rx_tx_addr[0]=0x01;rx_tx_addr[1]=0x02;rx_tx_addr[2]=0x0B;rx_tx_addr[3]=0x57;*/
		#endif
	}

	SLT_RF_init();
	SLT_set_freq();

	if(sub_protocol == SLT6_Tx)
		phase = SLT6_BUILD_A;
	else
		phase = SLT_BUILD;
}

#endif
//SLT v1_4ch timing
//268363 + 1643 / 15 = 18000

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SPI.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
/********************/
/**  SPI routines  **/
/********************/
#ifdef STM32_BOARD

#ifdef DEBUG_SERIAL
//	#define DEBUG_SPI
#endif

SPIClass SPI_2(2); 								//Create an instance of the SPI Class called SPI_2 that uses the 2nd SPI Port

void initSPI2()
{
	//SPI_DISABLE();
	SPI_2.end();
	SPI2_BASE->CR1 &= ~SPI_CR1_DFF_8_BIT;		//8 bits format, this bit should be written only when SPI is disabled (SPE = ?0?) for correct operation.
	SPI_2.begin();								//Initialize the SPI_2 port.

	SPI2_BASE->CR1 &= ~SPI_CR1_LSBFIRST;		// Set the SPI_2 bit order MSB first
	SPI2_BASE->CR1 &= ~(SPI_CR1_CPOL|SPI_CR1_CPHA);	// Set the SPI_2 data mode 0: Clock idles low, data captured on rising edge (first transition)
	SPI2_BASE->CR1 &= ~(SPI_CR1_BR);
	SPI2_BASE->CR1 |= SPI_CR1_BR_PCLK_DIV_8;	// Set the speed (36 / 8 = 4.5 MHz SPI_2 speed) SPI_CR1_BR_PCLK_DIV_8
}
	
void SPI_Write(uint8_t command)
{//working OK	
	SPI2_BASE->DR = command;					//Write the first data item to be transmitted into the SPI_DR register (this clears the TXE flag).
	#ifdef DEBUG_SPI
		debug("%02X ",command);
	#endif
	while (!(SPI2_BASE->SR & SPI_SR_RXNE));
	command = SPI2_BASE->DR;					// ... and read the last received data.
}

uint8_t SPI_Read(void)
{
	SPI_Write(0x00);		
	return SPI2_BASE->DR;
}

uint8_t SPI_SDI_Read()
{	
	uint8_t rx=0;
	cli();	//Fix Hubsan droputs??
	while(!(SPI2_BASE->SR & SPI_SR_TXE));
	while((SPI2_BASE->SR & SPI_SR_BSY));	
	//	
	SPI_DISABLE();
	SPI_SET_BIDIRECTIONAL();
	volatile uint8_t x = SPI2_BASE->DR;
	(void)x;
	SPI_ENABLE();
	//
	SPI_DISABLE();				  
	while(!(SPI2_BASE->SR& SPI_SR_RXNE));
	rx=SPI2_BASE->DR;
	SPI_SET_UNIDIRECTIONAL();
	SPI_ENABLE();
	sei();//fix Hubsan dropouts??
	return rx;
}

void SPI_ENABLE()
{
	SPI2_BASE->CR1 |= SPI_CR1_SPE;
}

void SPI_DISABLE()
{
	SPI2_BASE->CR1 &= ~SPI_CR1_SPE;
}

void SPI_SET_BIDIRECTIONAL()
{
	SPI2_BASE->CR1 |= SPI_CR1_BIDIMODE;
	SPI2_BASE->CR1  &= ~ SPI_CR1_BIDIOE;//receive only
}

void SPI_SET_UNIDIRECTIONAL()
{
	SPI2_BASE->CR1 &= ~SPI_CR1_BIDIMODE;
}

#else

#ifdef ORANGE_TX
	#define XNOP() NOP()
#else
	#define XNOP()
#endif

void SPI_Write(uint8_t command)
{
	uint8_t n=8; 

	SCLK_off;//SCK start low
	XNOP();
	SDI_off;
	XNOP();
	do
	{
		if(command&0x80)
			SDI_on;
		else
			SDI_off;
		XNOP();
		SCLK_on;
		XNOP();
		XNOP();
		command = command << 1;
		SCLK_off;
		XNOP();
	}
	while(--n) ;
	SDI_on;
}

uint8_t SPI_Read(void)
{
	uint8_t result=0,i;
	for(i=0;i<8;i++)
	{
		result=result<<1;
		if(SDO_1)
			result |= 0x01;
		SCLK_on;
		XNOP();
		XNOP();
		NOP();
		SCLK_off;
		XNOP();
		XNOP();
	}
	return result;
}

#ifdef A7105_INSTALLED
uint8_t SPI_SDI_Read(void)
{
	uint8_t result=0;
	SDI_input;
	for(uint8_t i=0;i<8;i++)
	{                    
		result=result<<1;
		if(SDI_1)  ///if SDIO =1 
			result |= 0x01;
		SCLK_on;
		NOP();
		SCLK_off;
	}
	SDI_output;
	return result;
}
#endif

#endif//STM32_BOARD
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/SX1276_SPI.ino"
#ifdef SX1276_INSTALLED
#include "iface_sx1276.h"

bool SX1276_Mode_LoRa=false;

void SX1276_WriteReg(uint8_t address, uint8_t data)
{
	SPI_CSN_off;
	SPI_Write(address | 0x80); // MSB 1 = write
	NOP();
	SPI_Write(data);
	SPI_CSN_on;
}

uint8_t SX1276_ReadReg(uint8_t address)
{ 
	SPI_CSN_off;
	SPI_Write(address & 0x7F);
	uint8_t result = SPI_Read();
	SPI_CSN_on;
	return result;
}

void SX1276_WriteRegisterMulti(uint8_t address, const uint8_t* data, uint8_t length)
{
	SPI_CSN_off;
	SPI_Write(address | 0x80); // MSB 1 = write

	for(uint8_t i = 0; i < length; i++)
		SPI_Write(data[i]);

	SPI_CSN_on;
}

void SX1276_ReadRegisterMulti(uint8_t address, uint8_t* data, uint8_t length)
{ 
	SPI_CSN_off;
	SPI_Write(address & 0x7F);

	for(uint8_t i = 0; i < length; i++)
		data[i]=SPI_Read();

	SPI_CSN_on;
}

uint8_t SX1276_Reset()
{
	//TODO when pin is not wired
	#ifdef SX1276_RST_pin
		SX1276_RST_off;
		delayMicroseconds(200);
		SX1276_RST_on;
	#endif
    return 0;
}

bool SX1276_DetectChip() //to be called after reset, verfies the chip has been detected
{
	#define SX1276_Detect_MaxAttempts 5
	uint8_t i = 0;
	bool chipFound = false;
	while ((i < SX1276_Detect_MaxAttempts) && !chipFound)
	{
		uint8_t ChipVersion = SX1276_ReadReg(SX1276_42_VERSION);
		if (ChipVersion == 0x12)
		{
			debugln("SX1276 reg version=%d", ChipVersion);
			chipFound = true;
		}
		else
		{
			debug("SX1276 not found! attempts: %d", i);
			debug(" of ");
			debugln("%d SX1276 reg version=%d", SX1276_Detect_MaxAttempts, ChipVersion);
			i++;
		}
	}
	if (!chipFound)
	{
		debugln("SX1276 not detected!!!");
		return false;
	}
	else
	{
		debugln("Found SX1276 Device!");
		return true;
	}
}

void SX1276_SetTxRxMode(uint8_t mode)
{
	#ifdef SX1276_TXEN_pin
		if(mode == TX_EN)
			SX1276_TXEN_on;
		else
			SX1276_RXEN_on;
	#endif
}

void SX1276_SetFrequency(uint32_t frequency)
{
	uint32_t f = frequency / 61;
	uint8_t data[3];
	data[0] = f >> 16;
	data[1] = f >> 8;
	data[2] = f;
	
	SX1276_WriteRegisterMulti(SX1276_06_FRFMSB, data, 3);
}

void SX1276_SetMode(bool lora, bool low_freq_mode, uint8_t mode)
{
	uint8_t data = 0x00;

	SX1276_Mode_LoRa=lora;

	if(lora)
	{
		data = data | (1 << 7);
		data = data & ~(1 << 6);
	}
	else
	{
		data = data & ~(1 << 7);
		data = data | (1 << 6);
	}

	if(low_freq_mode)
		data = data | (1 << 3);
	
	data = data | mode;

	SX1276_WriteReg(SX1276_01_OPMODE, data);
}

void SX1276_SetDetectOptimize(bool auto_if, uint8_t detect_optimize)
{
	uint8_t data = SX1276_ReadReg(SX1276_31_DETECTOPTIMIZE);
	data = (data & 0b01111000) | detect_optimize;
	data = data | (auto_if << 7);

	SX1276_WriteReg(SX1276_31_DETECTOPTIMIZE, data);
}

void SX1276_ConfigModem1(uint8_t bandwidth, uint8_t coding_rate, bool implicit_header_mode)
{
	uint8_t data = 0x00;
	data = data | (bandwidth << 4);
	data = data | (coding_rate << 1);
	data = data | implicit_header_mode;

	SX1276_WriteReg(SX1276_1D_MODEMCONFIG1, data);

	if (bandwidth == SX1276_MODEM_CONFIG1_BW_500KHZ) //datasheet errata reconmendation http://caxapa.ru/thumbs/972894/SX1276_77_8_ErrataNote_1.1_STD.pdf
	{
		SX1276_WriteReg(SX1276_36_LORA_REGHIGHBWOPTIMIZE1, 0x02);
		SX1276_WriteReg(SX1276_3A_LORA_REGHIGHBWOPTIMIZE2, 0x64);
	}
	else
		SX1276_WriteReg(SX1276_36_LORA_REGHIGHBWOPTIMIZE1, 0x03);
}

void SX1276_ConfigModem2(uint8_t spreading_factor, bool tx_continuous_mode, bool rx_payload_crc_on)
{
	uint8_t data = SX1276_ReadReg(SX1276_1E_MODEMCONFIG2);
	data = data & 0b11; // preserve the last 2 bits
	data = data | (spreading_factor << 4);
	data = data | (tx_continuous_mode << 3);
	data = data | (rx_payload_crc_on << 2);

	SX1276_WriteReg(SX1276_1E_MODEMCONFIG2, data);
}

void SX1276_ConfigModem3(bool low_data_rate_optimize, bool agc_auto_on)
{
	uint8_t data = SX1276_ReadReg(SX1276_26_MODEMCONFIG3);
	data = data & 0b11; // preserve the last 2 bits
	data = data | (low_data_rate_optimize << 3);
	data = data | (agc_auto_on << 2);
	
	SX1276_WriteReg(SX1276_26_MODEMCONFIG3, data);
}

void SX1276_SetPreambleLength(uint16_t length)
{
	uint8_t data[2];
	data[0] = (length >> 8) & 0xFF; // high byte
	data[1] = length & 0xFF; // low byte
	
	SX1276_WriteRegisterMulti(SX1276_20_PREAMBLEMSB, data, 2);
}

void SX1276_SetDetectionThreshold(uint8_t threshold)
{
	SX1276_WriteReg(SX1276_37_DETECTIONTHRESHOLD, threshold);
}

void SX1276_SetLna(uint8_t gain, bool high_freq_lna_boost)
{
	uint8_t data = SX1276_ReadReg(SX1276_0C_LNA);
	data = data & 0b100; // preserve the third bit
	data = data | (gain << 5);
	
	if(high_freq_lna_boost)
		data = data | 0b11;
	
	SX1276_WriteReg(SX1276_0C_LNA, data);
}

void SX1276_SetHopPeriod(uint8_t freq_hop_period)
{
	SX1276_WriteReg(SX1276_24_HOPPERIOD, freq_hop_period);
}

void SX1276_SetPaDac(bool on)
{
	uint8_t data = SX1276_ReadReg(SX1276_4D_PADAC);
	data = data & 0b11111000; // preserve the upper 5 bits

	if(on)
		data = data | 0x07;
	else
		data = data | 0x04;
	
	SX1276_WriteReg(SX1276_4D_PADAC, data);
}

void SX1276_SetPaConfig(bool pa_boost_pin, uint8_t max_power, uint8_t output_power)
{
	uint8_t data = 0x00;
	data = data | (pa_boost_pin << 7);
	data = data | (max_power << 4);
	data = data | (output_power & 0x0F);

	SX1276_WriteReg(SX1276_09_PACONFIG, data);
}

void SX1276_SetOcp(bool OcpOn, uint8_t OcpTrim)
{
	SX1276_WriteReg(SX1276_0B_OCP, (OcpOn << 5) | OcpTrim);
}

void SX1276_WritePayloadToFifo(uint8_t* payload, uint8_t length)
{
	SX1276_WriteReg(SX1276_22_PAYLOAD_LENGTH, length);
	SX1276_WriteReg(SX1276_0E_FIFOTXBASEADDR, 0x00);
	SX1276_WriteReg(SX1276_0D_FIFOADDRPTR, 0x00);
	SX1276_WriteRegisterMulti(SX1276_00_FIFO, payload, length);
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scanner_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(SCANNER_CC2500_INO)

#include "iface_cc2500.h"

#define SCAN_MAX_RADIOCHANNEL	249 // 2483 MHz
#define SCAN_CHANNEL_LOCK_TIME	90 // with precalibration, channel requires only 90 usec for synthesizer to settle
#define SCAN_AVERAGE_INTVL		20
#define SCAN_MAX_COUNT			10
#define SCAN_CHANS_PER_PACKET	5

enum ScanStates {
	SCAN_CHANNEL_CHANGE = 0,
	SCAN_GET_RSSI = 1,
};

static void __attribute__((unused)) Scanner_cc2500_init()
{
	/* Initialize CC2500 chip */
	CC2500_WriteReg(CC2500_08_PKTCTRL0, 0x12);   // Packet Automation Control
    CC2500_WriteReg(CC2500_0B_FSCTRL1,  0x0A);   // Frequency Synthesizer Control
    CC2500_WriteReg(CC2500_0C_FSCTRL0,  0x00);   // Frequency Synthesizer Control
    CC2500_WriteReg(CC2500_0D_FREQ2,    0x5C);   // Frequency Control Word, High Byte
    CC2500_WriteReg(CC2500_0E_FREQ1,    0x4E);   // Frequency Control Word, Middle Byte
    CC2500_WriteReg(CC2500_0F_FREQ0,    0xC3);   // Frequency Control Word, Low Byte
    CC2500_WriteReg(CC2500_10_MDMCFG4,  0x8D);   // Modem Configuration
    CC2500_WriteReg(CC2500_11_MDMCFG3,  0x3B);   // Modem Configuration
    CC2500_WriteReg(CC2500_12_MDMCFG2,  0x10);   // Modem Configuration
    CC2500_WriteReg(CC2500_13_MDMCFG1,  0x23);   // Modem Configuration
    CC2500_WriteReg(CC2500_14_MDMCFG0,  0xA4);   // Modem Configuration
    CC2500_WriteReg(CC2500_15_DEVIATN,  0x62);   // Modem Deviation Setting
    CC2500_WriteReg(CC2500_18_MCSM0,    0x08);   // Main Radio Control State Machine Configuration
    CC2500_WriteReg(CC2500_19_FOCCFG,   0x1D);   // Frequency Offset Compensation Configuration
    CC2500_WriteReg(CC2500_1A_BSCFG,    0x1C);   // Bit Synchronization Configuration
    CC2500_WriteReg(CC2500_1B_AGCCTRL2, 0xC7);   // AGC Control
    CC2500_WriteReg(CC2500_1C_AGCCTRL1, 0x00);   // AGC Control
    CC2500_WriteReg(CC2500_1D_AGCCTRL0, 0xB0);   // AGC Control
    CC2500_WriteReg(CC2500_21_FREND1,   0xB6);   // Front End RX Configuration

	CC2500_SetTxRxMode(RX_EN);  // Receive mode
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_Strobe(CC2500_SRX);

	delayMicroseconds(1000);  // wait for RX to activate
}

static void __attribute__((unused)) Scanner_calibrate()
{
	for (uint8_t c = 0; c < SCAN_MAX_RADIOCHANNEL; c++)
	{
		CC2500_Strobe(CC2500_SIDLE);
		CC2500_WriteReg(CC2500_0A_CHANNR, c);
		CC2500_Strobe(CC2500_SCAL);
		delayMicroseconds(900);
		calData[c] = CC2500_ReadReg(CC2500_25_FSCAL1);
	}
	CC2500_Strobe(CC2500_SIDLE);
}

static void __attribute__((unused)) Scanner_scan_next()
{
	CC2500_WriteReg(CC2500_0A_CHANNR, rf_ch_num);
	CC2500_WriteReg(CC2500_25_FSCAL1, calData[rf_ch_num]);
	CC2500_Strobe(CC2500_SFRX);
	CC2500_Strobe(CC2500_SRX);
}

static int __attribute__((unused)) Scanner_scan_rssi()
{
	uint8_t rssi;
	rssi = CC2500_ReadReg(0x40 | CC2500_34_RSSI);  // 0.5 db/count, RSSI value read from the RSSI status register is a 2's complement number
	uint8_t rssi_rel;
	if (rssi >= 128) {
		rssi_rel = rssi - 128;  // relative power levels 0-127 (equals -137 to -72 dBm)
	}
	else {
		rssi_rel = rssi + 128;  // relative power levels 128-255 (equals -73 to -10 dBm)
	}
	return rssi_rel;
}

uint16_t SCANNER_callback()
{
	uint8_t rssi,max_rssi;
	
	//!!!Blocking mode protocol!!!
	TX_MAIN_PAUSE_off;
	tx_resume();
	while(1)
	{ //Start
		packet_in[0] = rf_ch_num;						// start channel for telemetry packet
		for(uint8_t i=0;i<SCAN_CHANS_PER_PACKET;i++)
		{
			Scanner_scan_next();						// set channel
			delayMicroseconds(SCAN_CHANNEL_LOCK_TIME);	// wait for freq to adjust
			max_rssi = 0;
			for(uint8_t j=0;j<SCAN_MAX_COUNT;j++)
			{
				rssi = Scanner_scan_rssi();
				if(rssi >= max_rssi) max_rssi = rssi;
				delayMicroseconds(SCAN_AVERAGE_INTVL);	// wait before next read
			}
			packet_in[i+1] = max_rssi;
			//next channel
			rf_ch_num++;
			if (rf_ch_num >= (SCAN_MAX_RADIOCHANNEL + 1))
				rf_ch_num = 0;
		}
		telemetry_link = 1;
		do
		{
			if(Update_All())
				return 1000;							// protocol has changed, give back the control to main
		}
		while(telemetry_link == 1);
	}
	return 0;
}

void SCANNER_init(void)
{
	rf_ch_num = 0;
	telemetry_link = 0;
	Scanner_cc2500_init();
	CC2500_Strobe(CC2500_SRX);
	Scanner_calibrate();
	CC2500_Strobe(CC2500_SIDLE);
	CC2500_SetTxRxMode(RX_EN);
	CC2500_Strobe(CC2500_SRX);  // Receive mode
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Scorpio_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(SCORPIO_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define SCORPIO_FORCE_ID

#define SCORPIO_PACKET_PERIOD		12000
#define SCORPIO_PACKETCH_PERIOD		2580
#define SCORPIO_BINDPAYLOAD_SIZE	8
#define SCORPIO_PAYLOAD_SIZE		10
#define SCORPIO_BIND_COUNT			1000
#define SCORPIO_RF_NUM_CHANNELS		3

static uint16_t __attribute__((unused)) SCORPIO_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x88;					//FIXME: What is this?
		packet[1] = 0x55;					//FIXME: What is this?
		packet[2] = crc;					//CRC_low  for normal packets
		packet[3] = crc >> 8;				//CRC_high for normal packets
		packet[4] = hopping_frequency[0];	//RF freq 0
		packet[5] = hopping_frequency[1];	//RF freq 1
		packet[6] = hopping_frequency[2];	//RF freq 2
		packet[7] = 0x80;					//FIXME: What is this?
		//SendPacket
		CYRF_WriteDataPacketLen(packet, SCORPIO_BINDPAYLOAD_SIZE);
		return SCORPIO_PACKET_PERIOD;
	}
	CYRF_ConfigRFChannel(hopping_frequency[hopping_frequency_no]);
	CYRF_SetPower(0x28);					//Update power
	delayMicroseconds(180);					//Frequency settle time
	packet[0] = hopping_frequency[0];
	packet[1] = hopping_frequency[1];
	packet[2] = hopping_frequency[2];
	packet[3] = convert_channel_8b(THROTTLE);
	packet[4] = 0xFF - convert_channel_8b(RUDDER);
	packet[5] = convert_channel_8b(ELEVATOR);
	packet[6] = convert_channel_8b(AILERON);
	packet[7] = 0x55;						//FIXME: What is this?
	packet[8] = 0x00;						//FIXME: What is this?
	packet[9] = 0x00;						//FIXME: What is this?
	CYRF_WriteDataPacketLen(packet, SCORPIO_PAYLOAD_SIZE);
	hopping_frequency_no++;
	if(hopping_frequency_no >= SCORPIO_RF_NUM_CHANNELS)
	{
		hopping_frequency_no = 0;
		return SCORPIO_PACKET_PERIOD - 2*SCORPIO_PACKETCH_PERIOD;
	}
	return SCORPIO_PACKETCH_PERIOD;
}

static void __attribute__((unused)) SCORPIO_RF_init()
{
	/* Initialise CYRF chip */
	CYRF_WriteRegister(CYRF_32_AUTO_CAL_TIME,	0x3C);
	CYRF_WriteRegister(CYRF_35_AUTOCAL_OFFSET,	0x14);
	CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB,	0x55);
	CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB,	0x05);
	CYRF_WriteRegister(CYRF_10_FRAMING_CFG,		0xE8);
	CYRF_SetPower(0x28);
	CYRF_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) SCORPIO_TX_init()
{
	calc_fh_channels(3);	// select 3 frequencies between 2 and 77. FIXME: Could they be choosen on the spot finding empty frequencies?
	crc = (rx_tx_addr[0] ^ rx_tx_addr[1] ^ RX_num) + ((rx_tx_addr[2] ^ rx_tx_addr[3] ^ RX_num) << 8);

	#ifdef SCORPIO_FORCE_ID
		crc = 0x689C;
		hopping_frequency[0] = 0x26;
		hopping_frequency[1] = 0x49;
		hopping_frequency[2] = 0x2E;
	#endif
	//debugln("C0:%02X, C1:%02X, C2:%02X, CRC:%04X", hopping_frequency[0], hopping_frequency[1], hopping_frequency[2], crc);
	CYRF_ConfigRFChannel(hopping_frequency[0]);	// Use first RF channel for bind
}

uint16_t SCORPIO_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(SCORPIO_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			CYRF_ConfigCRCSeed(crc);
			BIND_DONE;
		}
	return SCORPIO_send_packet();
}

void SCORPIO_init()
{
	SCORPIO_RF_init();
	SCORPIO_TX_init();
	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter = SCORPIO_BIND_COUNT;
		CYRF_ConfigCRCSeed(0x0001);
	}
	else
		bind_counter = 1;
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Skyartec_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(SKYARTEC_CC2500_INO)

#include "iface_cc2500.h"

//#define SKYARTEC_FORCE_ID

#define SKYARTEC_COARSE				0x00
#define SKYARTEC_TX_ADDR			rx_tx_addr[1]
#define SKYARTEC_TX_CHANNEL			rx_tx_addr[0]

enum {
    SKYARTEC_PKT1 = 0,
    SKYARTEC_SLEEP1, 
    SKYARTEC_PKT2,
    SKYARTEC_SLEEP2, 
    SKYARTEC_PKT3,
    SKYARTEC_SLEEP3, 
    SKYARTEC_PKT4,
    SKYARTEC_SLEEP4, 
    SKYARTEC_PKT5,
    SKYARTEC_SLEEP5, 
    SKYARTEC_PKT6,
    SKYARTEC_LAST,
};

const PROGMEM uint8_t SKYARTEC_init_values[] = {
  /* 04 */ 0x13, 0x18, 0xFF, 0x05,
  /* 08 */ 0x05, 0x43, 0xCD, 0x09, 0x00, 0x5D, 0x93, 0xB1 + SKYARTEC_COARSE,
  /* 10 */ 0x2D, 0x20, 0x73, 0x22, 0xF8, 0x50, 0x07, 0x30,
  /* 18 */ 0x18, 0x1D, 0x1C, 0xC7, 0x00, 0xB2, 0x87, 0x6B,
  /* 20 */ 0xF8, 0xB6, 0x10, 0xEA, 0x0A, 0x00, 0x11, 0x41,
  /* 28 */ 0x00, 0x59, 0x7F, 0x3F, 0x88, 0x31, 0x0B
};

static void __attribute__((unused)) SKYARTEC_rf_init()
{
	CC2500_Strobe(CC2500_SIDLE);

	for (uint8_t i = 4; i <= 0x2E; ++i)
		CC2500_WriteReg(i, pgm_read_byte_near(&SKYARTEC_init_values[i-4]));
	
	CC2500_WriteReg(CC2500_0C_FSCTRL0, option);

	CC2500_SetTxRxMode(TX_EN);
	CC2500_SetPower();
	CC2500_Strobe(CC2500_SFTX);
	CC2500_Strobe(CC2500_SFRX);
	CC2500_Strobe(CC2500_SXOFF);
	CC2500_Strobe(CC2500_SIDLE);
}

static void __attribute__((unused)) SKYARTEC_send_data_packet()
{
	//13 c5 01 0259 0168 0000 0259 030c 021a 0489 f3 7e 0a
	//header
	packet[0] = 0x13;				//Length
	packet[1] = SKYARTEC_TX_ADDR;	//Tx Addr?
	packet[2] = 0x01;				//???
	//channels
	for(uint8_t i = 0; i < 7; i++)
	{
		uint16_t value = convert_channel_16b_limit(CH_AETR[i],0x000,0x500);
		packet[3+2*i] = value >> 8;
		packet[4+2*i] = value & 0xff;
	}
	//checks
    uint8_t xor1 = 0;
    for(uint8_t i = 3; i <= 14; i++)
        xor1 ^= packet[i];
    packet[18] = xor1;
    xor1 ^= packet[15];
    xor1 ^= packet[16];
    packet[17] = xor1;
    packet[19] = packet[3] + packet[5] + packet[7] + packet[9] + packet[11] + packet[13];

	CC2500_WriteReg(CC2500_04_SYNC1,	rx_tx_addr[3]);
	CC2500_WriteReg(CC2500_05_SYNC0,	rx_tx_addr[2]);
	CC2500_WriteReg(CC2500_09_ADDR,		SKYARTEC_TX_ADDR);
	CC2500_WriteReg(CC2500_0A_CHANNR,	SKYARTEC_TX_CHANNEL);
	CC2500_WriteData(packet, 20);
}

static void __attribute__((unused)) SKYARTEC_send_bind_packet()
{
	//0b 7d 01 01 b2 c5 4a 2f 00 00 c5 d6
	packet[0] = 0x0b;       //Length
	packet[1] = 0x7d;
	packet[2] = 0x01;
	packet[3] = 0x01;
	packet[4] = rx_tx_addr[0];
	packet[5] = rx_tx_addr[1];
	packet[6] = rx_tx_addr[2];
	packet[7] = rx_tx_addr[3];
	packet[8] = 0x00;
	packet[9] = 0x00;
	packet[10] = SKYARTEC_TX_ADDR;
	uint8_t xor1 = 0;
	for(uint8_t i = 3; i < 11; i++)
		xor1 ^= packet[i];
	packet[11] = xor1;
	CC2500_WriteReg(CC2500_04_SYNC1,	0x7d);
	CC2500_WriteReg(CC2500_05_SYNC0,	0x7d);
	CC2500_WriteReg(CC2500_09_ADDR,		0x7d);
	CC2500_WriteReg(CC2500_0A_CHANNR,	0x7d);
	CC2500_WriteData(packet, 12);
}

uint16_t SKYARTEC_callback()
{
	if (phase & 0x01)
	{
		CC2500_Strobe(CC2500_SIDLE);
		if (phase == SKYARTEC_LAST)
		{
			CC2500_SetPower();
			// Tune frequency if it has been changed
			CC2500_SetFreqOffset();
			phase = SKYARTEC_PKT1;
		}
		else
			phase++;
		return 3000;
	}
	if (phase == SKYARTEC_PKT1 && bind_counter)
	{
		SKYARTEC_send_bind_packet();
		bind_counter--;
		if(bind_counter == 0)
			BIND_DONE;
	}
	else
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(6000);
		#endif
		SKYARTEC_send_data_packet();
	}
	phase++;
	return 3000;
}

void SKYARTEC_init()
{
    SKYARTEC_rf_init();

	#ifdef SKYARTEC_FORCE_ID
		memset(rx_tx_addr,0x00,4);
	#endif
	if(rx_tx_addr[0]==0) rx_tx_addr[0]=0xB2;
	if(rx_tx_addr[1]==0) rx_tx_addr[1]=0xC5;
	if(rx_tx_addr[2]==0) rx_tx_addr[2]=0x4A;
	if(rx_tx_addr[3]==0) rx_tx_addr[3]=0x2F;

	bind_counter = 250;
	phase = SKYARTEC_PKT1;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Symax_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with Syma X5C-1, X11, X11C, X12 and for sub protocol X5C Syma X5C (original), X2

#if defined(SYMAX_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define SYMAX_BIND_COUNT			345		// 1.5 seconds
#define SYMAX_FIRST_PACKET_DELAY	12000
#define SYMAX_PACKET_PERIOD			4000	// Timeout for callback in uSec
#define SYMAX_INITIAL_WAIT			500

#define SYMAX_MAX_RF_CHANNELS    	17

#define SYMAX_FLAG_FLIP				0x01
#define SYMAX_FLAG_VIDEO			0x02
#define SYMAX_FLAG_PICTURE			0x04
#define SYMAX_FLAG_HEADLESS			0x08
#define SYMAX_XTRM_RATES			0x10

#define SYMAX_PAYLOADSIZE			10		// receive data pipes set to this size, but unused
#define SYMAX_MAX_PACKET_LENGTH		16		// X11,X12,X5C-1 10-byte, X5C 16-byte

enum {
	SYMAX_INIT1 = 0,
	SYMAX_BIND2,
	SYMAX_BIND3,
	SYMAX_DATA
};

static uint8_t __attribute__((unused)) SYMAX_checksum(uint8_t *data)
{
	uint8_t sum = data[0];

	for (uint8_t i=1; i < packet_length-1; i++)
	if ( sub_protocol==SYMAX5C )
		sum += data[i];
	else
		sum ^= data[i];

	return sum + ( sub_protocol==SYMAX5C ? 0 : 0x55 );
}

static void __attribute__((unused)) SYMAX_read_controls()
{
	// Protocol is registered AETRF, that is
	// Aileron is channel 1, Elevator - 2, Throttle - 3, Rudder - 4, Flip control - 5
	// Extended (trim-added) Rates - 6, Photo - 7, Video - 8, Headless - 9
	aileron  = convert_channel_s8b(AILERON);
	elevator = convert_channel_s8b(ELEVATOR);
	throttle = convert_channel_8b(THROTTLE);
	rudder   = convert_channel_s8b(RUDDER);

	flags=0;
	// Channel 5
	if (CH5_SW)
		flags = SYMAX_FLAG_FLIP;
	// Channel 6
	if (CH6_SW)
		flags |= SYMAX_XTRM_RATES;
	// Channel 7
	if (CH7_SW)
		flags |= SYMAX_FLAG_PICTURE;
	// Channel 8
	if (CH8_SW)
		flags |= SYMAX_FLAG_VIDEO;
	// Channel 9
	if (CH9_SW)
	{
		flags |= SYMAX_FLAG_HEADLESS;
		flags &= ~SYMAX_XTRM_RATES;	// Extended rates & headless incompatible
	}
}

#define X5C_CHAN2TRIM(X) ((((X) & 0x80 ? 0xff - (X) : 0x80 + (X)) >> 2) + 0x20)

static void __attribute__((unused)) SYMAX_build_packet_x5c(uint8_t bind)
{
	if (bind)
	{
		memset(packet, 0, packet_length);
		packet[7] = 0xae;
		packet[8] = 0xa9;
		packet[14] = 0xc0;
		packet[15] = 0x17;
	}
	else
	{
		SYMAX_read_controls();

		packet[0] = throttle;
		packet[1] = rudder;
		packet[2] = elevator ^ 0x80;  // reversed from default
		packet[3] = aileron;
		if (flags & SYMAX_XTRM_RATES)
		{	// drive trims for extra control range
			packet[4] = X5C_CHAN2TRIM(rudder ^ 0x80);
			packet[5] = X5C_CHAN2TRIM(elevator);
			packet[6] = X5C_CHAN2TRIM(aileron ^ 0x80);
		}
		else
		{
			packet[4] = 0x00;
			packet[5] = 0x00;
			packet[6] = 0x00;
		}
		packet[7] = 0xae;
		packet[8] = 0xa9;
		packet[9] = 0x00;
		packet[10] = 0x00;
		packet[11] = 0x00;
		packet[12] = 0x00;
		packet[13] = 0x00;
		packet[14] =  (flags & SYMAX_FLAG_VIDEO   ? 0x10 : 0x00) 
					| (flags & SYMAX_FLAG_PICTURE ? 0x08 : 0x00)
					| (flags & SYMAX_FLAG_FLIP    ? 0x01 : 0x00)
					| 0x04;// always high rates (bit 3 is rate control)
		packet[15] = SYMAX_checksum(packet);
	}
}

static void __attribute__((unused)) SYMAX_build_packet(uint8_t bind)
{
	if (bind)
	{
		packet[0] = rx_tx_addr[4];
		packet[1] = rx_tx_addr[3];
		packet[2] = rx_tx_addr[2];
		packet[3] = rx_tx_addr[1];
		packet[4] = rx_tx_addr[0];
		packet[5] = 0xaa;
		packet[6] = 0xaa;
		packet[7] = 0xaa;
		packet[8] = 0x00;
	}
	else
	{
		SYMAX_read_controls();
		packet[0] = throttle;
		packet[1] = elevator;
		packet[2] = rudder;
		packet[3] = aileron;
		packet[4] = (flags & SYMAX_FLAG_VIDEO   ? 0x80 : 0x00) | (flags & SYMAX_FLAG_PICTURE ? 0x40 : 0x00);
		packet[5] = 0xc0;	//always high rates (bit 7 is rate control)
		packet[6] = flags & SYMAX_FLAG_FLIP ? 0x40 : 0x00;
		packet[7] = flags & SYMAX_FLAG_HEADLESS ? 0x80 : 0x00;
		if (flags & SYMAX_XTRM_RATES)
		{	// use trims to extend controls
			packet[5] |= elevator >> 2;
			packet[6] |= rudder >> 2;
			packet[7] |= aileron >> 2;
		}
		packet[8] = 0x00;
	}
	packet[9] = SYMAX_checksum(packet);
}

static void __attribute__((unused)) SYMAX_send_packet(uint8_t bind)
{
	if (sub_protocol==SYMAX5C)
		SYMAX_build_packet_x5c(bind);
	else
		SYMAX_build_packet(bind);
		
	// clear packet status bits and TX FIFO
	NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
	NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0x2e);
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[hopping_frequency_no]);
	NRF24L01_FlushTx();

	NRF24L01_WritePayload(packet, packet_length);

	if (packet_count++ % 2)	// use each channel twice
		hopping_frequency_no = (hopping_frequency_no + 1) % rf_ch_num;

	NRF24L01_SetPower();	// Set tx_power
}

static void __attribute__((unused)) symax_rf_init()
{
	NRF24L01_Initialize();
	//
	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x3F);  // Enable all data pipes (even though not used?)
	NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0xff); // 4mS retransmit t/o, 15 tries (retries w/o AA?)
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 0x08);

	if (sub_protocol==SYMAX5C)
	{
		//NRF24L01_SetBitrate(NRF24L01_BR_1M);
		packet_length = 16;
	}
	else
	{
		NRF24L01_SetBitrate(NRF24L01_BR_250K);
		packet_length = 10;
	}
	//
	NRF24L01_WriteReg(NRF24L01_08_OBSERVE_TX, 0x00);
	NRF24L01_WriteReg(NRF24L01_09_CD, 0x00);
	NRF24L01_WriteReg(NRF24L01_0C_RX_ADDR_P2, 0xC3); // LSB byte of pipe 2 receive address
	NRF24L01_WriteReg(NRF24L01_0D_RX_ADDR_P3, 0xC4);
	NRF24L01_WriteReg(NRF24L01_0E_RX_ADDR_P4, 0xC5);
	NRF24L01_WriteReg(NRF24L01_0F_RX_ADDR_P5, 0xC6);
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, SYMAX_PAYLOADSIZE);   // bytes of data payload for pipe 1
	NRF24L01_WriteReg(NRF24L01_12_RX_PW_P1, SYMAX_PAYLOADSIZE);
	NRF24L01_WriteReg(NRF24L01_13_RX_PW_P2, SYMAX_PAYLOADSIZE);
	NRF24L01_WriteReg(NRF24L01_14_RX_PW_P3, SYMAX_PAYLOADSIZE);
	NRF24L01_WriteReg(NRF24L01_15_RX_PW_P4, SYMAX_PAYLOADSIZE);
	NRF24L01_WriteReg(NRF24L01_16_RX_PW_P5, SYMAX_PAYLOADSIZE);
	NRF24L01_WriteReg(NRF24L01_17_FIFO_STATUS, 0x00); // Just in case, no real bits to write here

	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR , sub_protocol==SYMAX5C ? (uint8_t *)"\x6D\x6A\x73\x73\x73" : (uint8_t *)"\xAB\xAC\xAD\xAE\xAF" ,5);
}

static void __attribute__((unused)) symax_init1()
{
	// duplicate stock tx sending strange packet (effect unknown)
	uint8_t first_packet[] = {0xf9, 0x96, 0x82, 0x1b, 0x20, 0x08, 0x08, 0xf2, 0x7d, 0xef, 0xff, 0x00, 0x00, 0x00, 0x00};
	uint8_t chans_bind[] = {0x4b, 0x30, 0x40, 0x20};
	uint8_t chans_bind_x5c[] = {0x27, 0x1b, 0x39, 0x28, 0x24, 0x22, 0x2e, 0x36,
								0x19, 0x21, 0x29, 0x14, 0x1e, 0x12, 0x2d, 0x18};

	NRF24L01_FlushTx();
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, 0x08);
	NRF24L01_WritePayload(first_packet, 15);

	if (sub_protocol==SYMAX5C)
	{
		rf_ch_num = sizeof(chans_bind_x5c);
		memcpy(hopping_frequency, chans_bind_x5c, rf_ch_num);
	}
	else
	{
		rx_tx_addr[4] = 0xa2; // this is constant in ID
		rf_ch_num = sizeof(chans_bind);
		memcpy(hopping_frequency, chans_bind, rf_ch_num);
	}
	hopping_frequency_no = 0;
	packet_count = 0;
}

// channels determined by last byte of tx address
static void __attribute__((unused)) symax_set_channels(uint8_t address)
{
	static const uint8_t start_chans_1[] = {0x0a, 0x1a, 0x2a, 0x3a};
	static const uint8_t start_chans_2[] = {0x2a, 0x0a, 0x42, 0x22};
	static const uint8_t start_chans_3[] = {0x1a, 0x3a, 0x12, 0x32};

	uint8_t laddress = address & 0x1f;
	uint8_t i;
	uint32_t *pchans = (uint32_t *)hopping_frequency;   // avoid compiler warning

	rf_ch_num = 4;

	if (laddress < 0x10)
	{
		if (laddress == 6)
			laddress = 7;
		for(i=0; i < rf_ch_num; i++)
			hopping_frequency[i] = start_chans_1[i] + laddress;
	}
	else
		if (laddress < 0x18)
		{
			for(i=0; i < rf_ch_num; i++)
				hopping_frequency[i] = start_chans_2[i] + (laddress & 0x07);
			if (laddress == 0x16)
			{
				hopping_frequency[0]++;
				hopping_frequency[1]++;
			}
		}
		else
			if (laddress < 0x1e)
			{
				for(i=0; i < rf_ch_num; i++)
					hopping_frequency[i] = start_chans_3[i] + (laddress & 0x07);
			}
			else
				if (laddress == 0x1e)
					*pchans = 0x38184121;
				else
					*pchans = 0x39194121;
}

static void __attribute__((unused)) symax_init2()
{
static	uint8_t chans_data_x5c[] = {0x1d, 0x2f, 0x26, 0x3d, 0x15, 0x2b, 0x25, 0x24,
								0x27, 0x2c, 0x1c, 0x3e, 0x39, 0x2d, 0x22};

	if (sub_protocol==SYMAX5C)
	{
		rf_ch_num = sizeof(chans_data_x5c);
		memcpy(hopping_frequency, chans_data_x5c, rf_ch_num);
	}
	else
	{
		symax_set_channels(rx_tx_addr[0]);
		NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);
	}
	hopping_frequency_no = 0;
	packet_count = 0;
}

uint16_t SYMAX_callback()
{
	switch (phase)
	{
		case SYMAX_INIT1:
			symax_init1();
			phase = SYMAX_BIND2;
			return SYMAX_FIRST_PACKET_DELAY;
			break;
		case SYMAX_BIND2:
			bind_counter = SYMAX_BIND_COUNT;
			phase = SYMAX_BIND3;
			SYMAX_send_packet(1);
			break;
		case SYMAX_BIND3:
			if (bind_counter == 0)
			{
				symax_init2();
				phase = SYMAX_DATA;
				BIND_DONE;
			}
			else
			{
				SYMAX_send_packet(1);
				bind_counter--;
			}
			break;
		case SYMAX_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(SYMAX_PACKET_PERIOD);
			#endif
			SYMAX_send_packet(0);
			break;
	}
	return SYMAX_PACKET_PERIOD;
}

void SYMAX_init()
{	
	packet_count = 0;
	flags = 0;
	BIND_IN_PROGRESS;	// autobind protocol
	symax_rf_init();
	phase = SYMAX_INIT1;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/TEST_cc2500.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(TEST_CC2500_INO)

#include "iface_nrf250k.h"

#define TEST_INITIAL_WAIT    500
#define TEST_PACKET_PERIOD   10000
#define TEST_PAYLOAD_SIZE    10
#define TEST_RF_NUM_CHANNELS 3

uint16_t TEST_callback()
{
	option=1;
	if(phase)
		XN297L_WritePayload(packet, TEST_PAYLOAD_SIZE);
	else
	{
		if(Channel_data[CH5]<CHANNEL_MIN_COMMAND)
			hopping_frequency_no=0;
		else if(Channel_data[CH5]>CHANNEL_MAX_COMMAND)
			hopping_frequency_no=2;
		else
			hopping_frequency_no=1;
		XN297L_Hopping(hopping_frequency_no);
		CC2500_WriteReg(CC2500_3E_PATABLE,convert_channel_8b(CH6));
		debugln("CH:%d, PWR:%d",hopping_frequency_no,convert_channel_8b(CH6));
	}
	phase ^= 1;
	return TEST_PACKET_PERIOD>>1;
}

void TEST_init()
{
	option=1;

	hopping_frequency[0]=0;
	hopping_frequency[1]=40;
	hopping_frequency[2]=80;
	XN297L_Init();
	XN297L_HoppingCalib(TEST_RF_NUM_CHANNELS);	// Calibrate all channels
	XN297L_SetTXAddr((uint8_t*)"RADIO", 5);
	hopping_frequency_no = 0;
	phase=0;
	for(uint8_t i=0; i<TEST_PAYLOAD_SIZE; i++)
		packet[i]= i;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/TRAXXAS_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 
 Works with Traxxas 6519 receivers https://traxxas.com/sites/default/files/24CompGuide-2016.jpg .
 */

#if defined(TRAXXAS_CYRF6936_INO)

#include "iface_cyrf6936.h"

#define TRAXXAS_TQ1_FORCE_ID
//#define TRAXXAS_TQ2_FORCE_ID
#define TRAXXAS_DEBUG

#define TRAXXAS_BIND_CHANNEL		0x2B
#define TRAXXAS_CHECK_CHANNEL		0x22
#define TRAXXAS_PACKET_SIZE			16

#define TRAXXAS_TQ1_BIND_CHANNEL	0x04
#define TRAXXAS_TQ1_CHECK_CHANNEL	0x34

enum {
	TRAXXAS_BIND_PREP_RX=0,
	TRAXXAS_BIND_RX,
	TRAXXAS_BIND_TX1,
	TRAXXAS_PREP_RX,
	TRAXXAS_RX,
	TRAXXAS_PREP_DATA,
	TRAXXAS_DATA,
	TRAXXAS_TQ1_BIND,
	TRAXXAS_TQ1_DATA1,
	TRAXXAS_TQ1_DATA2,
};

const uint8_t PROGMEM TRAXXAS_init_vals[][2] = {
	//Init from dump
	{CYRF_32_AUTO_CAL_TIME, 0x3C},				// Default init value
	{CYRF_35_AUTOCAL_OFFSET, 0x14},				// Default init value
	{CYRF_1B_TX_OFFSET_LSB, 0x55},				// Default init value
	{CYRF_1C_TX_OFFSET_MSB, 0x05},				// Default init value
	{CYRF_28_CLK_EN, 0x02},						// Force Receive Clock Enable
	{CYRF_03_TX_CFG, 0x08 | CYRF_BIND_POWER},	// 8DR Mode, 32 chip codes
	{CYRF_0B_PWR_CTRL, 0x00},					// PMU
	{CYRF_06_RX_CFG, 0x88 | 0x02},				// AGC enabled, Fast Turn Mode enabled, adding overwrite enable to not lockup RX
	{CYRF_1E_RX_OVERRIDE, 0x08},				// Reject packets with 0 seed
};

static void __attribute__((unused)) TRAXXAS_cyrf_bind_config()
{
	CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[0]);
	CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB, 0x5A);
	CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB, 0x5A);
	CYRF_ConfigRFChannel(TRAXXAS_BIND_CHANNEL);
}

static void __attribute__((unused)) TRAXXAS_cyrf_check_config()
{
	CYRF_ConfigRFChannel(TRAXXAS_CHECK_CHANNEL);
	CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[9]);
	CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB, 0xA5);
	CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB, 0xA5);
}

static void __attribute__((unused)) TRAXXAS_cyrf_data_config()
{
	CYRF_ConfigRFChannel(hopping_frequency[0]);
	#ifdef TRAXXAS_FORCE_ID					// data taken from TX dump
		CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB, 0x1B);
		CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB, 0x3F);
		CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[6]);
	#else
		uint16_t addr=TRAXXAS_EEPROM_OFFSET+RX_num*3;
		CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB, cyrfmfg_id[0] - eeprom_read_byte((EE_ADDR)(addr + 0)));
		CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB, cyrfmfg_id[1] - eeprom_read_byte((EE_ADDR)(addr + 1)));
		CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[eeprom_read_byte((EE_ADDR)(addr + 2)) % 20]);
	#endif
	CYRF_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) TRAXXAS_send_data_packet()
{
	packet[0] = 0x01;
	memset(&packet[1],0x00,TRAXXAS_PACKET_SIZE-1);
	//Next RF channel ? 0x00 -> keep current, 0x0E change to F=15
	//packet[1] = hopping_frequency[0] - 1;
	
	//6 channels
	uint16_t ch;
	for(uint8_t i=0; i<6; i++)
	{
		ch = convert_channel_16b_nolimit(i,500,1000,false);
		packet[2+i*2]=ch>>8;
		packet[3+i*2]=ch;
	}

	CYRF_SetPower(0x08);
	CYRF_WriteDataPacket(packet);
}

static void __attribute__((unused)) TRAXXAS_TQ1_send_data_packet()
{
	memcpy(&packet[1], cyrfmfg_id, 4);
	if(IS_BIND_IN_PROGRESS)
	{
		packet_length = 8;
		packet[0] = 0x2A;						// Bind packet
		packet[5] = 0xA0;						// Bind phase 0
		packet[6] = TRAXXAS_TQ1_BIND_CHANNEL-1;	// Not sure...
	}
	else
	{
		packet_length = 16;
		packet[0] = 0x02;						// Normal packet
		packet[5] = 0xA2;						// Bind phase 2 = completed?
		//4 channels
		uint16_t ch;
		for(uint8_t i=0; i<4; i++)
		{
			ch = convert_channel_ppm(i);
			packet[6+i*2]=ch;
			packet[7+i*2]=ch>>8;
		}
		packet[14] = hopping_frequency[0]-1;	// Not sure...
	}
	uint8_t xor_value=0;
	for(uint8_t i=0; i<packet_length-1; i++)
		xor_value ^= packet[i];
	packet[packet_length-1] = xor_value;

	CYRF_SetPower(0x08);
	CYRF_WriteDataPacketLen(packet, packet_length);
	#ifdef TRAXXAS_DEBUG
		debug("P:");
		for(uint8_t i=0; i<packet_length; i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
}

uint16_t TRAXXAS_callback()
{
	uint8_t status;
	
	switch(phase)
	{
		//TQ2
		case TRAXXAS_BIND_PREP_RX:
		case TRAXXAS_PREP_RX:
			//debugln("PREP_RX");
			if(phase == TRAXXAS_BIND_PREP_RX)
				TRAXXAS_cyrf_bind_config();
			else
				TRAXXAS_cyrf_check_config();
			CYRF_SetTxRxMode(RX_EN);								//Receive mode
			CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);				//Prepare to receive
			packet_count=100;										//Timeout for RX
			phase++;	// TRAXXAS_BIND_RX or TRAXXAS_RX
			return 7000;
		case TRAXXAS_BIND_RX:
		case TRAXXAS_RX:
			//debugln("RX");
			//Read data from RX
			status = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((status & 0x03) == 0x02)  							// RXC=1, RXE=0 then 2nd check is required (debouncing)
				status |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			#ifdef TRAXXAS_DEBUG
				//debugln("s=%02X",status);
			#endif
			CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);		// need to set RXOW before data read
			if((status & 0x07) == 0x02)
			{ // Data received with no errors
				len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				#ifdef TRAXXAS_DEBUG
					debugln("L=%02X",len)
				#endif
				if(len==TRAXXAS_PACKET_SIZE)
				{
					CYRF_ReadDataPacketLen(packet, TRAXXAS_PACKET_SIZE);
					#ifdef TRAXXAS_DEBUG
						debug("RX=");
						for(uint8_t i=0;i<TRAXXAS_PACKET_SIZE;i++)
							debug(" %02X",packet[i]);
						debugln("");
					#endif
					uint16_t addr=TRAXXAS_EEPROM_OFFSET+RX_num*3;
					if(phase == TRAXXAS_BIND_RX)
					{
						// Store RX ID
						for(uint8_t i=0;i<2;i++)
							eeprom_write_byte((EE_ADDR)(addr+i),packet[i+1]);
						//Store SOP index
						eeprom_write_byte((EE_ADDR)(addr+2),packet[7]);
					}
					else
					{
						//check RX ID and SOP
						if(eeprom_read_byte((EE_ADDR)(addr + 0)) != packet[1] || eeprom_read_byte((EE_ADDR)(addr + 1)) != packet[2] || eeprom_read_byte((EE_ADDR)(addr + 2)) != packet[7])
						{ // Not our RX
							phase++;	// TRAXXAS_PREP_DATA
							return 10000-7000-500;
						}
					}
					// Replace RX ID by TX ID
					for(uint8_t i=0;i<6;i++)
						packet[i+1]=cyrfmfg_id[i];
					//packet[7 ] = 0xEE;							// Not needed ??
					packet[8 ] = hopping_frequency[0] - 1;
					packet[10] = 0x01;								// Must change otherwise bind doesn't complete
					//packet[13] = 0x05;							// Not needed ??
					packet_count=12;
					CYRF_SetTxRxMode(TX_EN);
					phase=TRAXXAS_BIND_TX1;
					return 10000;
				}
			}
			if(phase == TRAXXAS_BIND_RX)
			{
				if( --packet_count == 0 )
				{ // Retry RX
					CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Enable RX abort
					CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);		// Force end state
					CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Disable RX abort
					if(--bind_counter != 0)
						phase=TRAXXAS_BIND_PREP_RX;					// Retry receiving bind packet
					else
						phase=TRAXXAS_PREP_DATA;					// Abort binding
				}
				return 700;
			}
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);				// Enable RX abort
			CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x24);				// Force end state
			CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);				// Disable RX abort
			phase++;	// TRAXXAS_PREP_DATA
			return 10000-7000-500;
		case TRAXXAS_BIND_TX1:
			//debugln("BIND_TX1");
			CYRF_WriteDataPacketLen(packet, TRAXXAS_PACKET_SIZE);
			#ifdef TRAXXAS_DEBUG
				debug("P=");
				for(uint8_t i=0;i<TRAXXAS_PACKET_SIZE;i++)
					debug(" %02X",packet[i]);
				debugln("");
			#endif
			if(--packet_count==0)	// Switch to normal mode
				phase=TRAXXAS_PREP_DATA;
			break;
		case TRAXXAS_PREP_DATA:
			//debugln("PREP_DATA");
			BIND_DONE;
			TRAXXAS_cyrf_data_config();
			phase++;
			return 500;
		case TRAXXAS_DATA:
			//debugln_time("DATA");
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(10000);
			#endif
			TRAXXAS_send_data_packet();
			phase = TRAXXAS_PREP_RX;
			return 1000;
		//TQ1
		case TRAXXAS_TQ1_BIND:
			if(bind_counter)
			{
				CYRF_ConfigRFChannel(TRAXXAS_TQ1_BIND_CHANNEL);
				TRAXXAS_TQ1_send_data_packet();
				bind_counter--;
				if(bind_counter == 0)
				{
					BIND_DONE;
					phase++;
				}
			}
			return 10000;
		case TRAXXAS_TQ1_DATA1:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(19900);
			#endif
			CYRF_ConfigRFChannel(TRAXXAS_TQ1_CHECK_CHANNEL);
			TRAXXAS_TQ1_send_data_packet();
			phase++;
			return 7100;
		case TRAXXAS_TQ1_DATA2:
			CYRF_ConfigRFChannel(hopping_frequency[0]);
			TRAXXAS_TQ1_send_data_packet();
			phase = TRAXXAS_TQ1_DATA1;
			return 12800;
	}
	return 10000;
}

void TRAXXAS_init()
{ 
	//Config CYRF registers
	uint8_t init;
	if(sub_protocol == TRAXXAS_TQ1)
	{
		//CYRF_WriteRegister(CYRF_06_RX_CFG, 0x48 | 0x02);
		//CYRF_WriteRegister(CYRF_26_XTAL_CFG, 0x08);
		init = 5;
	}
	else //TQ2
	{
		init = sizeof(TRAXXAS_init_vals) / 2;
		for(uint8_t i = 0; i < init; i++)	
			CYRF_WriteRegister(pgm_read_byte_near(&TRAXXAS_init_vals[i][0]), pgm_read_byte_near(&TRAXXAS_init_vals[i][1]));
	}

	//Read CYRF ID
	CYRF_GetMfgData(cyrfmfg_id);
	//Find a free channel
	if(sub_protocol == TRAXXAS_TQ1)
	{
		cyrfmfg_id[3]+=RX_num;				// Not needed for TQ2 since the TX and RX have to match
		//CYRF_FindBestChannels(hopping_frequency,1,1,0x0B,0x30, FIND_CHANNEL_ANY);	// Complete guess
	}
	else //TRAXXAS_TQ2
		CYRF_FindBestChannels(hopping_frequency,1,1,0x02,0x21, FIND_CHANNEL_ANY);

	#ifdef TRAXXAS_TQ1_FORCE_ID				// data taken from TX dump
		if(sub_protocol == TRAXXAS_TQ1)
		{
			cyrfmfg_id[0]=0xD8;				// CYRF MFG ID
			cyrfmfg_id[1]=0xAA;
			cyrfmfg_id[2]=0x59;
			cyrfmfg_id[3]=0xE6;
			//cyrfmfg_id[4]=0x44;			// Unused
			//cyrfmfg_id[5]=0xFB;			// Unused
			hopping_frequency[0] = 0x0B;
		}
	#endif
	#ifdef TRAXXAS_TQ2_FORCE_ID				// data taken from TX dump
		if(sub_protocol == TRAXXAS_TQ2)
		{
			cyrfmfg_id[0]=0x65;				// CYRF MFG ID
			cyrfmfg_id[1]=0xE2;
			cyrfmfg_id[2]=0x5E;
			cyrfmfg_id[3]=0x55;
			cyrfmfg_id[4]=0x4D;
			cyrfmfg_id[5]=0xFE;
			hopping_frequency[0] = 0x05;	// seen 05 and 0F
		}
	#endif
	#ifdef TRAXXAS_DEBUG
		debugln("ID: %02X %02X %02X %02X %02X %02X",cyrfmfg_id[0],cyrfmfg_id[1],cyrfmfg_id[2],cyrfmfg_id[3],cyrfmfg_id[4],cyrfmfg_id[5]);
		debugln("RF CH: %02X",hopping_frequency[0]);
	#endif
	
	bind_counter=100;
	if(sub_protocol == TRAXXAS_TQ1)
	{
		CYRF_WriteRegister(CYRF_28_CLK_EN, 0x02);
		CYRF_WriteRegister(CYRF_32_AUTO_CAL_TIME, 0x3C);
		CYRF_WriteRegister(CYRF_35_AUTOCAL_OFFSET, 0x14);
		CYRF_WriteRegister(CYRF_26_XTAL_CFG, 0x08);
		CYRF_WriteRegister(CYRF_06_RX_CFG, 0x48);
		CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB, 0x55);
		CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB, 0x05);
		CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x21);
		CYRF_WriteRegister(CYRF_03_TX_CFG, 0x0C);
		CYRF_PROGMEM_ConfigSOPCode(DEVO_j6pro_sopcodes[0]);
		CYRF_SetTxRxMode(TX_EN);
		CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x21);
		if(IS_BIND_IN_PROGRESS)
			phase = TRAXXAS_TQ1_BIND;
		else
			phase = TRAXXAS_TQ1_DATA1;
	}
	else
	{//TRAXXAS_TQ2
		if(IS_BIND_IN_PROGRESS)
			phase = TRAXXAS_BIND_PREP_RX;
		else
			phase = TRAXXAS_PREP_DATA;
	}
	//
//	phase = TRAXXAS_BIND_TX1;
//	TRAXXAS_cyrf_bind_config();
//	CYRF_SetTxRxMode(TX_EN);
//	memcpy(packet,(uint8_t *)"\x02\x4A\xA3\x2D\x1A\x49\xFE\x06\x00\x00\x02\x01\x06\x06\x00\x00",TRAXXAS_PACKET_SIZE);
//	memcpy(packet,(uint8_t *)"\x02\x49\xAC\x4F\x55\x4D\xFE\x05\x00\x00\x02\x01\x06\x06\x00\x00",TRAXXAS_PACKET_SIZE);
}

/*
Traxxas TQ 2nd generation
-------------------------
Packets 0x02: Bind learn TX/RX addresses
CHANNEL:	0x2B
SOP_CODE:	0x3C	0x37	0xCC	0x91	0xE2	0xF8	0xCC	0x91
CRC_SEED_LSB:	0x5A
CRC_SEED_MSB:	0x5A
RX:	0x02	0x4A	0xA3	0x2D	0x1A	0x49	0xFE	0x06	0x00	0x00	0x02	0x01	0x06	0x06	0x00	0x00
TX:	0x02	0x65	0xE2	0x5E	0x55	0x4D	0xFE	0xEE	0x00	0x00	0x01	0x01	0x06	0x05	0x00	0x00
Notes:
 - RX cyrfmfg_id is 0x4A,0xA3,0x2D,0x1A,0x49,0xFE and TX cyrfmfg_id is 0x65,0xE2,0x5E,0x55,0x4D,0xFE
 - P[7] changes from 0x06 to 0xEE but not needed to complete the bind -> doesn't care??
 - P[8] RF channel - 1 (on packets type 0x03)
 - P[9] 0x00 unchanged??
 - P[10] needs to be set to 0x01 to complete the bind -> normal packet P[0]??
 - P[11] unchanged ?? -> no bind if set to 0x00 or 0x81
 - P[12] unchanged ?? -> no bind if set to 0x05 or 0x86
 - P[13] changes from 0x06 to 0x05 but not needed to complete the bind -> doesn't care??
 - P[14..15]=0x00 unchanged??

Packets 0x03: Which RF channel
CHANNEL:	0x22
SOP_CODE:	0x97	0xE5	0x14	0x72	0x7F	0x1A	0x14	0x72
CRC_SEED_LSB:	0xA5
CRC_SEED_MSB:	0xA5
RX:	0x03	0x4A	0xA3	0x2D	0x1A	0x49	0xFE	0x06	0x00	0x00	0x02	0x01	0x06	0x06	0x00	0x00
TX:	0x03	0x65	0xE2	0x5E	0x55	0x4D	0xFE	0xEE	0x0E	0x00	0x01	0x01	0x06	0x05	0x00	0x00
 - P[8] RF channel - 1

Packets 0x04: unknown
RX: 0x04	0x4A	0xA3	0x2D	0x1A	0x49	0xFE	0x06	0x00	0x00	0x02	0x01	0x06	0x06	0x00	0x00

Packets 0x01: Normal mode
CHANNEL: 	0x05
SOP_CODE:	0xA1	0x78	0xDC	0x3C	0x9E	0x82	0xDC	0x3C
CRC_SEED_LSB:	0x1B
CRC_SEED_MSB:	0x3F
TX3:	0x01	0x00	0x02	0xA8	0x03	0xE7	0x02	0x08	0x00	0x00	0x01	0x01	0x02	0xEE	0x00	0x00

CRC_SEED:
TX ID: \x65\xE2\x5E\x55\x4D\xFE
RX ID: \x4A\xA3\x2D\x1A\x49\xFE CRC 0x1B 0x3F => CRC: 65-4A=1B E2-A3=3F
RX ID: \x4B\xA3\x2D\x1A\x49\xFE CRC 0x1A 0x3F => CRC: 65-4B=1A E2-A3=3F
RX ID: \x00\x00\x2D\x1A\x49\xFE CRC 0x65 0xE2 => CRC: 65-00=65 E2-00=E2
RX ID: \x00\xFF\x2D\x1A\x49\xFE CRC 0x65 0xE3 => CRC: 65-00=65 E2-FF=E3
RX ID: \xFF\x00\x2D\x1A\x49\xFE CRC 0x66 0xE2 => CRC: 65-FF=66 E2-00=E2

SOP Codes:
RX1: 02 4A A3 2D 1A 49 FE 06 00 00 02 01 06 06 00 00
SOP: A1 78 DC 3C 9E 82 DC 3C
RX2: 02 49 AC 4F 55 4D FE 05 00 00 02 01 06 06 00 00
SOP: 5A CC AE 46 B6 31 AE 46
RX3: 02 CA F3 62 55 4D FE 03 00 00 02 01 06 06 00 00
SOP: 66 CD 7C 50 DD 26 7C 50

Dump of SOP Codes:
00: 3C 37 CC 91 E2 F8 CC 91 => bind
01: 9B C5 A1 0F AD 39 A2 0F
02: EF 64 B0 2A D2 8F B1 2A
03: 66 CD 7C 50 DD 26 7C 50
04: 5C E1 F6 44 AD 16 F6 44
05: 5A CC AE 46 B6 31 AE 46
06: A1 78 DC 3C 9E 82 DC 3C
07: B9 8E 19 74 6F 65 18 74
08: DF B1 C0 49 62 DF C1 49
09: 97 E5 14 72 7F 1A 14 72 => check
10: 82 C7 90 36 21 03 FF 17
11: E2 F8 CC 91 3C 37 CC 91 => bind 4 bytes group swapped
12: AD 39 A2 0F 9B C5 A1 0F => 01 4 bytes group swapped
13: D2 8F B1 2A EF 64 B0 2A => 02 4 bytes group swapped
14: DD 26 7C 50 66 CD 7C 50 => 03 4 bytes group swapped
...
19: 62 DF C1 49 DF B1 C0 49 => 08 4 bytes group swapped
20: 00 00 00 33 DE AD BA BE ??over??
*/

/*
Traxxas TQ 1st generation
-------------------------
https://github.com/pascallanger/DIY-Multiprotocol-TX-Module/issues/967#issuecomment-2079038576
*/
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Telemetry.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
//**************************
// Telemetry serial code   *
//**************************
#if defined TELEMETRY

uint8_t RetrySequence ;

#ifdef MULTI_TELEMETRY
	uint32_t lastMulti = 0;
	#define MULTI_TIME				500	//in ms
	#ifdef MULTI_SYNC
		#define INPUT_SYNC_TIME			100	//in ms
		#define INPUT_ADDITIONAL_DELAY	100	// in 10s, 100 => 1000 s
		uint32_t lastInputSync = 0;
		uint16_t inputDelay = 0;
	#endif // MULTI_SYNC
#endif // MULTI_TELEMETRY

#if defined SPORT_TELEMETRY	
	#define FRSKY_SPORT_PACKET_SIZE   8
	#define FX_BUFFERS	4
	uint8_t Sport_Data = 0;
	uint8_t pktx1[FRSKY_SPORT_PACKET_SIZE*FX_BUFFERS];

	// Store for out of sequence packet
	uint8_t FrSkyX_RX_ValidSeq ;
	struct t_FrSkyX_RX_Frame
	{
		boolean valid;
		uint8_t count;
		uint8_t payload[6];
	} ;

	// Store for FrskyX telemetry
	struct t_FrSkyX_RX_Frame FrSkyX_RX_Frames[4] ;
	uint8_t FrSkyX_RX_NextFrame=0;
#endif // SPORT_TELEMETRY

#if defined HUB_TELEMETRY
	#define USER_MAX_BYTES 6
	uint8_t prev_index;

	struct t_FrSkyD_User_Frame
	{
		uint8_t ID;
		uint8_t low;
		uint8_t high;
	} FrSkyD_User_Frame[8];
	uint8_t FrSkyD_User_Frame_Start=0, FrSkyD_User_Frame_End=0;
#endif // HUB_TELEMETRY

#define START_STOP	0x7e
#define BYTESTUFF	0x7d
#define STUFF_MASK	0x20
#define MAX_PKTX	10
uint8_t pktx[MAX_PKTX];
uint8_t frame[18];

#ifdef MULTI_TELEMETRY
static void multi_send_header(uint8_t type, uint8_t len)
{
	Serial_write('M');
	Serial_write('P');
	Serial_write(type);
	Serial_write(len);
}

#ifdef MULTI_SYNC
static void telemetry_set_input_sync(uint16_t refreshRate)
{
	#if defined(STM32_BOARD) && defined(DEBUG_PIN)
		static uint8_t c=0;
		if (c++%2==0)
		{	DEBUG_PIN_on;	}
		else
		{	DEBUG_PIN_off;	}
	#endif
	// Only record input Delay after a frame has really been received
	// Otherwise protocols with faster refresh rates then the TX sends (e.g. 3ms vs 6ms) will screw up the calcualtion
	inputRefreshRate = refreshRate;
	if (last_serial_input != 0)
	{
		cli();										// Disable global int due to RW of 16 bits registers
		inputDelay = TCNT1;
		sei();										// Enable global int
		//inputDelay = (inputDelay - last_serial_input)>>1;
		inputDelay -= last_serial_input;
		//if(inputDelay & 0x8000)
		//	inputDelay = inputDelay - 0x8000;
		last_serial_input=0;
	}
}
#endif

#ifdef MULTI_SYNC
	static void mult_send_inputsync()
	{
		multi_send_header(MULTI_TELEMETRY_SYNC, 6);
		Serial_write(inputRefreshRate >> 8);
		Serial_write(inputRefreshRate & 0xff);
//		Serial_write(inputDelay >> 8);
//		Serial_write(inputDelay & 0xff);
		Serial_write(inputDelay >> 9);
		Serial_write(inputDelay >> 1);
		Serial_write(INPUT_SYNC_TIME);
		Serial_write(INPUT_ADDITIONAL_DELAY);
	}
#endif //MULTI_SYNC

static void multi_send_status()
{
	if(protocol == 0) return;
	
	multi_send_header(MULTI_TELEMETRY_STATUS, 24);

	// Build flags
	uint8_t flags=0;
	if(IS_INPUT_SIGNAL_on)
		flags |= 0x01;
	if(mode_select==MODE_SERIAL)
		flags |= 0x02;
	if(remote_callback != 0)
	{
		if(multi_protocols_index != 0xFF && IS_SUB_PROTO_VALID)
			flags |= 0x04;				//Invalid protocol / sub protocol, can't make the distinction since there is no more flags...
		if(IS_WAIT_BIND_on)
			flags |= 0x10;
		else
			if(IS_BIND_IN_PROGRESS)
				flags |= 0x08;
		if(multi_protocols_index != 0xFF)
		{
			if(multi_protocols[multi_protocols_index].chMap)
				flags |= 0x40;			//Disable_ch_mapping supported
			#ifdef FAILSAFE_ENABLE
				if(multi_protocols[multi_protocols_index].failSafe)
					flags |= 0x20;		//Failsafe supported
			#endif
		}
		if(IS_DATA_BUFFER_LOW_on)
			flags |= 0x80;
	}
	Serial_write(flags);
	
	// Version number example: 1.1.6.1
	Serial_write(VERSION_MAJOR);
	Serial_write(VERSION_MINOR);
	Serial_write(VERSION_REVISION);
	Serial_write(VERSION_PATCH_LEVEL);

	// Channel order
	Serial_write(RUDDER<<6|THROTTLE<<4|ELEVATOR<<2|AILERON);
	
	if(multi_protocols_index == 0xFF)													// selection out of list... send first available protocol
	{
		Serial_write(multi_protocols[0].protocol);										// begining of list
		Serial_write(multi_protocols[0].protocol);										// begining of list
		for(uint8_t i=0;i<16;i++)
			Serial_write(0x00);															// everything else is invalid
	}
	else
	{
		// Protocol next/prev
		if(multi_protocols[multi_protocols_index+1].protocol != 0xFF)
		{
			if(multi_protocols[multi_protocols_index+1].protocol == PROTO_SCANNER )//|| multi_protocols[multi_protocols_index+1].protocol == PROTO_CONFIG )
			{// if next is scanner
				if(multi_protocols[multi_protocols_index+2].protocol != 0xFF)
					Serial_write(multi_protocols[multi_protocols_index+2].protocol);	// skip to next protocol number
				else
					Serial_write(multi_protocols[multi_protocols_index].protocol);		// or end of list
			}
			else
				Serial_write(multi_protocols[multi_protocols_index+1].protocol);		// next protocol number
		}
		else
			Serial_write(multi_protocols[multi_protocols_index].protocol);				// end of list
		if(multi_protocols_index>0 && multi_protocols[multi_protocols_index-1].protocol != 0)
		{
			if(multi_protocols[multi_protocols_index-1].protocol == PROTO_SCANNER )//|| multi_protocols[multi_protocols_index-1].protocol == PROTO_CONFIG )
			{// if prev is scanner
				if(multi_protocols_index > 1)
					Serial_write(multi_protocols[multi_protocols_index-2].protocol);	// skip to prev protocol number
				else
					Serial_write(multi_protocols[multi_protocols_index].protocol);		// begining of list
			}
			else
				Serial_write(multi_protocols[multi_protocols_index-1].protocol);		// prev protocol number
		}
		else
			Serial_write(multi_protocols[multi_protocols_index].protocol);				// begining of list
		// Protocol
		for(uint8_t i=0;i<7;i++)
			Serial_write(multi_protocols[multi_protocols_index].ProtoString[i]);		// protocol name
		// Sub-protocol
		uint8_t nbr=multi_protocols[multi_protocols_index].nbrSubProto;
		if(option_override>0x0F)
			Serial_write(nbr | (multi_protocols[multi_protocols_index].optionType<<4));	// number of sub protocols && option type
		else
			Serial_write(nbr | (option_override<<4));									// number of sub protocols && option_override type
		uint8_t j=0;
		if(IS_SUB_PROTO_VALID)
		{
			uint8_t len=multi_protocols[multi_protocols_index].SubProtoString[0];
			uint8_t offset=len*(sub_protocol&0x07)+1;
			for(;j<len;j++)
				Serial_write(multi_protocols[multi_protocols_index].SubProtoString[j+offset]);	// current sub protocol name
		}
		for(;j<8;j++)
			Serial_write(0x00);
	}
}

#ifdef MULTI_CONFIG_INO
	void CONFIG_frame()
	{
		multi_send_header(MULTI_TELEMETRY_CONFIG, 21);
		for (uint8_t i = 0; i < 21; i++)		// Config data
			Serial_write(packet_in[i]);
	}
#endif

#ifdef MLINK_FW_TELEMETRY
	void MLINK_frame()
	{
		multi_send_header(MULTI_TELEMETRY_MLINK, 10);
		Serial_write(TX_RSSI);					// RSSI
		Serial_write(TX_LQI);					// LQI
		for (uint8_t i = 0; i < 8; i++)			// followed by 8 bytes of telemetry data
			Serial_write(packet_in[i]);
	}
#endif

#ifdef DSM_TELEMETRY
	void DSM_frame()
	{
		if (packet_in[0] == 0x80)
		{
			multi_send_header(MULTI_TELEMETRY_DSMBIND, 10);
			for (uint8_t i = 1; i < 11; i++) 	// 10 bytes of DSM bind response
				Serial_write(packet_in[i]);

		}
		else
		{
			multi_send_header(MULTI_TELEMETRY_DSM, 17);
			for (uint8_t i = 0; i < 17; i++)	// RSSI value followed by 16 bytes of telemetry data
				Serial_write(packet_in[i]);
		}
	}
#endif

#ifdef SCANNER_TELEMETRY
	void spectrum_scanner_frame()
	{
		multi_send_header(MULTI_TELEMETRY_SCANNER, SCAN_CHANS_PER_PACKET + 1);
		Serial_write(packet_in[0]);					// start channel
		for(uint8_t ch = 0; ch < SCAN_CHANS_PER_PACKET; ch++)
			Serial_write(packet_in[ch+1]);			// RSSI power levels
	}
#endif

#if defined (FRSKY_RX_TELEMETRY) || defined (AFHDS2A_RX_TELEMETRY) || defined (BAYANG_RX_TELEMETRY) || defined (DSM_RX_CYRF6936_INO)
	void receiver_channels_frame()
	{
		uint16_t len = packet_in[3] * 11;			// 11 bit per channel
		if (len % 8 == 0)
			len = 4 + (len / 8);
		else
			len = 5 + (len / 8);
		multi_send_header(MULTI_TELEMETRY_RX_CHANNELS, len);
		for (uint8_t i = 0; i < len; i++)
			Serial_write(packet_in[i]);				// pps, rssi, ch start, ch count, 16x ch data
	}
#endif

#ifdef AFHDS2A_FW_TELEMETRY
	void AFHDSA_short_frame()
	{
		multi_send_header(packet_in[29]==0xAA?MULTI_TELEMETRY_AFHDS2A:MULTI_TELEMETRY_AFHDS2A_AC, 29);
		for (uint8_t i = 0; i < 29; i++)			// RSSI value followed by 4*7 bytes of telemetry data
			Serial_write(packet_in[i]);
	}
#endif

#ifdef HITEC_FW_TELEMETRY
	void HITEC_short_frame()
	{
		multi_send_header(MULTI_TELEMETRY_HITEC, 8);
		for (uint8_t i = 0; i < 8; i++)				// TX RSSI and TX LQI values followed by frame number and 5 bytes of telemetry data
			Serial_write(packet_in[i]);
	}
#endif

#ifdef HOTT_FW_TELEMETRY
	void HOTT_short_frame()
	{
		multi_send_header(MULTI_TELEMETRY_HOTT, 15);
		for (uint8_t i = 0; i < 15; i++)			// TX RSSI and TX LQI values followed by frame number and telemetry data
			Serial_write(packet_in[i]);
	}
#endif

static void multi_send_frskyhub()
{
	multi_send_header(MULTI_TELEMETRY_HUB, 9);
	for (uint8_t i = 0; i < 9; i++)
		Serial_write(frame[i]);
}

#endif //MULTI_TELEMETRY

void frskySendStuffed()
{
	Serial_write(START_STOP);
	for (uint8_t i = 0; i < 9; i++)
	{
		if ((frame[i] == START_STOP) || (frame[i] == BYTESTUFF))
		{
			Serial_write(BYTESTUFF);
			frame[i] ^= STUFF_MASK;
		}
		Serial_write(frame[i]);
	}
	Serial_write(START_STOP);
}

bool frsky_process_telemetry(uint8_t *buffer,uint8_t len)
{
	if(protocol!=PROTO_FRSKY_R9)
	{
		if(buffer[1] != rx_tx_addr[3] || buffer[2] != rx_tx_addr[2] || len != buffer[0] + 3 )
			return false;										// Bad address or length...
		// RSSI and LQI are the 2 last bytes
		TX_RSSI = buffer[len-2];
		if(TX_RSSI >=128)
			TX_RSSI -= 128;
		else
			TX_RSSI += 128;
	}
	telemetry_link|=1;								// Telemetry data is available

#if defined FRSKYD_CC2500_INO
	if (protocol==PROTO_FRSKYD)
	{
		TX_LQI = buffer[len-1]&0x7F;
		//Save current buffer
		for (uint8_t i=3;i<len-2;i++)
			telemetry_in_buffer[i]=buffer[i];	// Buffer telemetry values to be sent
	
		//Check incoming telemetry sequence
		if(telemetry_in_buffer[6]>0 && telemetry_in_buffer[6]<=10)
		{ //Telemetry length ok
			if ( ( telemetry_in_buffer[7] & 0x1F ) == (telemetry_counter & 0x1F) )
			{//Sequence is ok
				uint8_t topBit = 0 ;
				if ( telemetry_counter & 0x80 )
					if ( ( telemetry_counter & 0x1F ) != RetrySequence )
						topBit = 0x80 ;
				telemetry_counter = ( (telemetry_counter+1)%32 ) | topBit ;	// Request next telemetry frame
			}
			else
			{//Incorrect sequence
				RetrySequence = telemetry_in_buffer[7] & 0x1F ;
				telemetry_counter |= 0x80 ;
				telemetry_in_buffer[6]=0 ;			// Discard current packet and wait for retransmit
			}
		}
		else
			telemetry_in_buffer[6]=0; 				// Discard packet
	}
#endif

#if defined SPORT_TELEMETRY && (defined FRSKYX_CC2500_INO || defined FRSKYR9_SX1276_INO)
	if (protocol==PROTO_FRSKYX||protocol==PROTO_FRSKYX2)
	{
		/*Telemetry frames(RF) SPORT info 
		15 bytes payload
		SPORT frame valid 6+3 bytes
		[00] PKLEN  0E 0E 0E 0E 
		[01] TXID1  DD DD DD DD 
		[02] TXID2  6D 6D 6D 6D 
		[03] CONST  02 02 02 02 
		[04] RS/RB  2C D0 2C CE	//D0;CE=2*RSSI;....2C = RX battery voltage(5V from Bec)
		[05] HD-SK  03 10 21 32	//TX/RX telemetry hand-shake bytes
		[06] NO.BT  00 00 06 03	//No.of valid SPORT frame bytes in the frame		
		[07] STRM1  00 00 7E 00 
		[08] STRM2  00 00 1A 00 
		[09] STRM3  00 00 10 00 
		[10] STRM4  03 03 03 03  
		[11] STRM5  F1 F1 F1 F1 
		[12] STRM6  D1 D1 D0 D0
		[13] CHKSUM1 --|2 CRC bytes sent by RX (calculated on RX side crc16/table)
		[14] CHKSUM2 --|*/
		//len=17 -> len-7=10 -> 3..12
		uint16_t lcrc = FrSkyX_crc(&buffer[3], len-7 ) ;
		if ( ( (lcrc >> 8) != buffer[len-4]) || ( (lcrc & 0x00FF ) != buffer[len-3]) )
			return false;									// Bad CRC
		
		if(buffer[4] & 0x80)
			RX_RSSI=buffer[4] & 0x7F ;
		else
			v_lipo1 = (buffer[4]<<1) + 1 ;
		#if defined(TELEMETRY_FRSKYX_TO_FRSKYD) && defined(ENABLE_PPM)
			if(mode_select != MODE_SERIAL)
				return true;
		#endif
	}
	if (protocol==PROTO_FRSKYX||protocol==PROTO_FRSKYX2||protocol==PROTO_FRSKY_R9)
	{
		telemetry_lost=0;

		//Save outgoing telemetry sequence
		FrSkyX_TX_IN_Seq=buffer[5] >> 4;

		//Check incoming telemetry sequence
		uint8_t packet_seq=buffer[5] & 0x03;
		if ( buffer[5] & 0x08 )
		{//Request init
			FrSkyX_RX_Seq = 0x08 ;
			FrSkyX_RX_NextFrame = 0x00 ;
			FrSkyX_RX_Frames[0].valid = false ;
			FrSkyX_RX_Frames[1].valid = false ;
			FrSkyX_RX_Frames[2].valid = false ;
			FrSkyX_RX_Frames[3].valid = false ;
		}
		else if ( packet_seq == (FrSkyX_RX_Seq & 0x03 ) )
		{//In sequence
			struct t_FrSkyX_RX_Frame *p ;
			uint8_t count ;
			// buffer[4] RSSI
			// buffer[5] sequence control
			// buffer[6] payload count
			// buffer[7-12] payload			
			p = &FrSkyX_RX_Frames[packet_seq] ;
			count = buffer[6];					// Payload length
			if ( count <= 6 )
			{//Store payload
				p->count = count ;
				for ( uint8_t i = 0 ; i < count ; i++ )
					p->payload[i] = buffer[i+7] ;
			}
			else
				p->count = 0 ;					// Discard
			p->valid = true ;

			FrSkyX_RX_Seq = ( FrSkyX_RX_Seq + 1 ) & 0x03 ;	// Move to next sequence

			if ( FrSkyX_RX_ValidSeq & 0x80 )
			{
				FrSkyX_RX_Seq = ( FrSkyX_RX_ValidSeq + 1 ) & 3 ;
				FrSkyX_RX_ValidSeq &= 0x7F ;
			}

		}
		else
		{//Not in sequence
			struct t_FrSkyX_RX_Frame *q ;
			uint8_t count ;
			// buffer[4] RSSI
			// buffer[5] sequence control
			// buffer[6] payload count
			// buffer[7-12] payload			
			if ( packet_seq == ( ( FrSkyX_RX_Seq +1 ) & 3 ) )
			{//Received next sequence -> save it
				q = &FrSkyX_RX_Frames[packet_seq] ;
				count = buffer[6];				// Payload length
				if ( count <= 6 )
				{//Store payload
					q->count = count ;
					for ( uint8_t i = 0 ; i < count ; i++ )
						q->payload[i] = buffer[i+7] ;
				}
				else
					q->count = 0 ;
				q->valid = true ;
			
				FrSkyX_RX_ValidSeq = 0x80 | packet_seq ;
			}
			FrSkyX_RX_Seq = ( FrSkyX_RX_Seq & 0x03 ) | 0x04 ;	// Request re-transmission of original sequence
		}
	}
#endif
	return true;
}

void init_frskyd_link_telemetry()
{
	telemetry_link=0;
	telemetry_counter=0;
	telemetry_lost=1;
	v_lipo1=0;
	v_lipo2=0;
	RX_RSSI=0;
	TX_RSSI=0;
	RX_LQI=0;
	TX_LQI=0;
	#if defined HUB_TELEMETRY
		FrSkyD_User_Frame_Start=FrSkyD_User_Frame_End=0;
	#endif
}

void frsky_link_frame()
{
	frame[0] = 0xFE;			// Link frame
	if (protocol==PROTO_FRSKYD)
	{		
		frame[1] = telemetry_in_buffer[3];		// A1
		frame[2] = telemetry_in_buffer[4];		// A2
		frame[3] = telemetry_in_buffer[5];		// RX_RSSI
		telemetry_link &= ~1 ;		// Sent
		telemetry_link |= 2 ;		// Send hub if available
	}
	else
	{//PROTO_HUBSAN, PROTO_AFHDS2A, PROTO_BAYANG, PROTO_NCC1701, PROTO_CABELL, PROTO_HITEC, PROTO_BUGS, PROTO_BUGSMINI, PROTO_FRSKYX, PROTO_FRSKYX2, PROTO_PROPEL, PROTO_DEVO, PROTO_RLINK, PROTO_OMP, PROTO_WFLY2, PROTO_LOLI, PROTO_MLINK, PROTO_MT99XX
		frame[1] = v_lipo1;
		frame[2] = v_lipo2;
		frame[3] = RX_RSSI;
		telemetry_link &= ~1 ;		// Sent
	}
	frame[4] = TX_RSSI;
	frame[5] = RX_LQI;
	frame[6] = TX_LQI;
	frame[7] = frame[8] = 0;
	#if defined MULTI_TELEMETRY
		multi_send_frskyhub();
	#else
		frskySendStuffed();
	#endif
}

#if defined HUB_TELEMETRY
void frsky_user_frame()
{
	if(telemetry_in_buffer[6])
	{//only send valid hub frames
		frame[0] = 0xFD;				// user frame
		if(telemetry_in_buffer[6]>USER_MAX_BYTES)
		{
			frame[1]=USER_MAX_BYTES;	// packet size
			telemetry_in_buffer[6]-=USER_MAX_BYTES;
			telemetry_link |= 2 ;			// 2 packets need to be sent
		}
		else
		{
			frame[1]=telemetry_in_buffer[6];			// packet size
			telemetry_link &= ~2;			// only 1 packet or processing second packet
		}
		frame[2] = telemetry_in_buffer[7];
		for(uint8_t i=0;i<USER_MAX_BYTES;i++)
			frame[i+3]=telemetry_in_buffer[i+8];
		if(telemetry_link & 2)				// prepare the content of second packet
			for(uint8_t i=8;i<USER_MAX_BYTES+8;i++)
				telemetry_in_buffer[i]=telemetry_in_buffer[i+USER_MAX_BYTES];
		#if defined MULTI_TELEMETRY
			multi_send_frskyhub();
		#else
			frskySendStuffed();
		#endif
	}
	else
		telemetry_link &= ~2;
}
/*
HuB RX packets.
packet_in[6]|(counter++)|00 01 02 03 04 05 06 07 08 09 
        %32        
01     08          5E 28 12 00 5E 5E 3A 06 00 5E
0A     09          28 12 00 5E 5E 3A 06 00 5E 5E  
09     0A          3B 09 00 5E 5E 06 36 7D 5E 5E 
03     0B          5E 28 11 00 5E 5E 06 06 6C 5E
0A     0C          00 5E 5E 3A 06 00 5E 5E 3B 09
07     0D          00 5E 5E 06 06 6C 5E 16 72 5E
05     0E          5E 28 11 00 5E 5E 3A 06 00 5E
0A     0F          5E 3A 06 00 5E 5E 3B 09 00 5E
05     10          5E 06 16 72 5E 5E 3A 06 00 5E
*/
static void __attribute__((unused)) frsky_write_user_frame(uint8_t ID, uint8_t low, uint8_t high)
{
	telemetry_in_buffer[6]  = 0x04;		// number of bytes in the payload
	telemetry_in_buffer[7]  = 0x00;		// unknown?
	telemetry_in_buffer[8]  = 0x5E;		// start of payload
	telemetry_in_buffer[9]  = ID;		// ID must be less than 0x40
	uint8_t pos=10;
	uint8_t value = low;
	for(uint8_t i=0;i<2;i++)
	{// Byte stuffing
		if(value == 0x5D || value == 0x5E)
		{// Byte stuffing
			telemetry_in_buffer[pos+1] = value ^ 0x60;
			telemetry_in_buffer[pos] = 0x5D;
			telemetry_in_buffer[6]++;	// 1 more byte in the payload
			pos += 2;
		}
		else
			telemetry_in_buffer[pos++] = value;
		value = high;
	}
	telemetry_link |= 2;				// request to send frame
}

static void __attribute__((unused)) frsky_send_user_frame(uint8_t ID, uint8_t low, uint8_t high)
{
	if(telemetry_link&2)
	{ // add to buffer
		uint8_t test = (FrSkyD_User_Frame_End + 1) & 0x07;
		if(test == FrSkyD_User_Frame_Start)
			return;	// buffer full...
		FrSkyD_User_Frame_End = test;
		FrSkyD_User_Frame[FrSkyD_User_Frame_End].ID   = ID;
		FrSkyD_User_Frame[FrSkyD_User_Frame_End].low  = low;
		FrSkyD_User_Frame[FrSkyD_User_Frame_End].high = high;
	}
	else // send to TX direct
		frsky_write_user_frame(ID, low, high);
}

static void __attribute__((unused)) frsky_check_user_frame()
{
	if((telemetry_link&2) || FrSkyD_User_Frame_Start == FrSkyD_User_Frame_End)
		return;		// need to wait that the last frame is sent or buffer is empty
	frsky_write_user_frame(FrSkyD_User_Frame[FrSkyD_User_Frame_Start].ID, FrSkyD_User_Frame[FrSkyD_User_Frame_Start].low, FrSkyD_User_Frame[FrSkyD_User_Frame_Start].high);
	FrSkyD_User_Frame_Start++;
	FrSkyD_User_Frame_Start &= 0x07;
}
#endif


#if defined SPORT_TELEMETRY
/* SPORT details serial
	100K 8E2 normal-multiprotocol
	-every 12ms-or multiple of 12; %36
	1  2  3  4  5  6  7  8  9  CRC DESCR
	7E 98 10 05 F1 20 23 0F 00 A6 SWR_ID 
	7E 98 10 01 F1 33 00 00 00 C9 RSSI_ID 
	7E 98 10 04 F1 58 00 00 00 A1 BATT_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 
	7E BA 10 03 F1 E2 00 00 00 18 ADC2_ID 	
	
	
	Telemetry frames(RF) SPORT info 
	15 bytes payload
	SPORT frame valid 6+3 bytes
	[00] PKLEN  0E 0E 0E 0E 
	[01] TXID1  DD DD DD DD 
	[02] TXID2  6D 6D 6D 6D 
	[03] CONST  02 02 02 02 
	[04] RS/RB  2C D0 2C CE	//D0;CE=2*RSSI;....2C = RX battery voltage(5V from Bec)
	[05] HD-SK  03 10 21 32	//TX/RX telemetry hand-shake bytes
	[06] NO.BT  00 00 06 03	//No.of valid SPORT frame bytes in the frame		
	[07] STRM1  00 00 7E 00 
	[08] STRM2  00 00 1A 00 
	[09] STRM3  00 00 10 00 
	[10] STRM4  03 03 03 03  
	[11] STRM5  F1 F1 F1 F1 
	[12] STRM6  D1 D1 D0 D0
	[13] CHKSUM1 --|2 CRC bytes sent by RX (calculated on RX side crc16/table)
	[14] CHKSUM2 --|
	+2	appended bytes automatically  RSSI and LQI/CRC bytes(len=0x0E+3);
	
0x06	0x06	0x06	0x06	0x06

0x7E	0x00	0x03	0x7E	0x00
0x1A	0x00	0xF1	0x1A	0x00
0x10	0x00	0xD7	0x10	0x00
0x03	0x7E	0x00	0x03	0x7E
0xF1	0x1A	0x00	0xF1	0x1A
0xD7	0x10	0x00	0xD7	0x10

0xE1	0x1C	0xD0	0xEE	0x33
0x34	0x0A	0xC3	0x56	0xF3
*/

#if defined MULTI_TELEMETRY
const uint8_t PROGMEM Indices[] = {	0x00, 0xA1, 0x22, 0x83, 0xE4, 0x45,
									0xC6, 0x67, 0x48, 0xE9, 0x6A, 0xCB,
									0xAC, 0x0D, 0x8E, 0x2F, 0xD0, 0x71,
									0xF2, 0x53, 0x34, 0x95, 0x16, 0xB7,
									0x98, 0x39, 0xBA, 0x1B } ;
#endif

#ifdef MULTI_TELEMETRY
	void sportSend(uint8_t *p)
	{
		multi_send_header(MULTI_TELEMETRY_SPORT, 9);
		uint16_t crc_s = 0;
		uint8_t x = p[0] ;
		if ( x <= 0x1B )
			x = pgm_read_byte_near( &Indices[x] ) ;
		Serial_write(x) ;
		for (uint8_t i = 1; i < 8; i++)
		{
			Serial_write(p[i]);
			crc_s += p[i];			//0-1FF
			crc_s += crc_s >> 8;	//0-100
			crc_s &= 0x00ff;
		}
		Serial_write(0xff - crc_s);
	}
#else
	void sportSend(uint8_t *p)
	{
		uint16_t crc_s = 0;
		Serial_write(START_STOP);//+9
		Serial_write(p[0]) ;
		for (uint8_t i = 1; i < 9; i++)
		{
			if (i == 8)
				p[i] = 0xff - crc_s;
			
			if ((p[i] == START_STOP) || (p[i] == BYTESTUFF))
			{
				Serial_write(BYTESTUFF);//stuff again
				Serial_write(STUFF_MASK ^ p[i]);
			} 
			else			
				Serial_write(p[i]);					
			
			crc_s += p[i]; //0-1FF
			crc_s += crc_s >> 8; //0-100
			crc_s &= 0x00ff;
		}
	}	
#endif

void sportIdle()
{
	#if !defined MULTI_TELEMETRY
		Serial_write(START_STOP);
	#endif
}	

void sportSendFrame()
{
	static uint8_t sport_counter=0;
	uint8_t i;

	sport_counter = (sport_counter + 1) %36;
	if(telemetry_lost)
	{
		sportIdle();
		return;
	}
	if(sport_counter<6)
	{
		frame[0] = 0x98;
		frame[1] = 0x10;
		for (i=5;i<8;i++)
			frame[i]=0;
	}
	switch (sport_counter)
	{
		case 0:
			frame[2] = 0x05;
			frame[3] = 0xf1;
			frame[4] = 0x02; //dummy values if swr 20230f00
			frame[5] = 0x23;
			frame[6] = 0x0F;
			break;
		case 2: // RSSI
			frame[2] = 0x01;
			frame[3] = 0xf1;
			frame[4] = RX_RSSI;
			frame[5] = TX_RSSI;
			frame[6] = RX_LQI;
			frame[7] = TX_LQI;
			break;
		case 4: //BATT
			frame[2] = 0x04;
			frame[3] = 0xf1;
			frame[4] = v_lipo1; //a1;
			break;								
		default:
			if(Sport_Data)
			{	
				for (i=0;i<FRSKY_SPORT_PACKET_SIZE;i++)
					frame[i]=pktx1[i];
				Sport_Data -- ;
				if ( Sport_Data )
				{
					uint8_t j = Sport_Data * FRSKY_SPORT_PACKET_SIZE ;
					for (i=0;i<j;i++)
						pktx1[i] = pktx1[i+FRSKY_SPORT_PACKET_SIZE] ;
				}
				break;
			}
			else
			{
				sportIdle();
				return;
			}		
	}
	sportSend(frame);
}	

void proces_sport_data(uint8_t data)
{
	static uint8_t pass = 0, indx = 0;
	switch (pass)
	{
		case 0:
			if (data == START_STOP)
			{//waiting for 0x7e
				indx = 0;
				pass = 1;
			}
			break;		
		case 1:
			if (data == START_STOP)	// Happens if missed packet
			{//waiting for 0x7e
				indx = 0;
				pass = 1;
				break;		
			}
			if(data == BYTESTUFF)	//if they are stuffed
				pass=2;
			else
				if (indx < MAX_PKTX)		
					pktx[indx++] = data;		
			break;
		case 2:	
			if (indx < MAX_PKTX)	
				pktx[indx++] = data ^ STUFF_MASK;	//unstuff bytes	
			pass=1;
			break;	
	} // end switch
	if (indx >= FRSKY_SPORT_PACKET_SIZE)
	{//8 bytes no crc 
		if ( Sport_Data < FX_BUFFERS )
		{
			uint8_t dest = Sport_Data * FRSKY_SPORT_PACKET_SIZE ;
			uint8_t i ;
			for ( i = 0 ; i < FRSKY_SPORT_PACKET_SIZE ; i++ )
				pktx1[dest++] = pktx[i] ;	// Triple buffer
			Sport_Data += 1 ;//ok to send
		}
//		else
//		{
//			// Overrun
//		}
		pass = 0;//reset
	}
}

#endif

void TelemetryUpdate()
{
	// check for space in tx buffer
	#ifdef BASH_SERIAL
		uint8_t h ;
		uint8_t t ;
		h = SerialControl.head ;
		t = SerialControl.tail ;
		if ( h >= t )
			t += TXBUFFER_SIZE - h ;
		else
			t -= h ;
		if ( t < 64 )
		{
			return ;
		}
	#else
		uint8_t h ;
		uint8_t t ;
		h = tx_head ;
		t = tx_tail ;
		if ( h >= t )
			t += TXBUFFER_SIZE - h ;
		else
			t -= h ;
		if ( t < 32 )
		{
			debugln("TEL_BUF_FULL %d",t);
			return ;
		}
/*		else
			if(t!=96)
				debugln("TEL_BUF %d",t);
*/
	#endif
	#ifdef MULTI_TELEMETRY
		uint32_t now = millis();
		if ((IS_SEND_MULTI_STATUS_on || ((now - lastMulti) > MULTI_TIME))&& protocol != PROTO_SCANNER)
		{
			multi_send_status();
			SEND_MULTI_STATUS_off;
			lastMulti = now;
			return;
		}
		#ifdef MULTI_SYNC
			if ( inputRefreshRate && (now - lastInputSync) > INPUT_SYNC_TIME )
			{
				mult_send_inputsync();
				lastInputSync = now;
				return;
			}
		#endif
	#endif
	#if defined SPORT_TELEMETRY
		if ((protocol==PROTO_FRSKYX || protocol==PROTO_FRSKYX2||protocol==PROTO_FRSKY_R9) && telemetry_link 
		#ifdef TELEMETRY_FRSKYX_TO_FRSKYD
			&& mode_select==MODE_SERIAL
		#endif
		)
		{	// FrSkyX
			for(;;)
			{ //Empty buffer
				struct t_FrSkyX_RX_Frame *p ;
				uint8_t count ;
				p = &FrSkyX_RX_Frames[FrSkyX_RX_NextFrame] ;
				if ( p->valid )
				{
					count = p->count ;
					for (uint8_t i=0; i < count ; i++)
						proces_sport_data(p->payload[i]) ;
					p->valid = false ;	// Sent
					FrSkyX_RX_NextFrame = ( FrSkyX_RX_NextFrame + 1 ) & 3 ;
				}
				else
					break ;
			}
			telemetry_link=0; 
			sportSendFrame();
		}
	#endif // SPORT_TELEMETRY

	#ifdef MULTI_TELEMETRY
		#if defined MULTI_CONFIG_INO
			if(telemetry_link && protocol == PROTO_CONFIG)
			{
				CONFIG_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined MLINK_FW_TELEMETRY
			if(telemetry_link && protocol == PROTO_MLINK)
			{
				MLINK_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined DSM_TELEMETRY
			if(telemetry_link && protocol == PROTO_DSM)
			{	// DSM
				DSM_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined AFHDS2A_FW_TELEMETRY
			if(telemetry_link == 2 && protocol == PROTO_AFHDS2A)
			{
				AFHDSA_short_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined HITEC_FW_TELEMETRY
			if(telemetry_link == 2 && protocol == PROTO_HITEC)
			{
				HITEC_short_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined HOTT_FW_TELEMETRY
			if(telemetry_link == 2 && protocol == PROTO_HOTT)
			{
				HOTT_short_frame();
				telemetry_link=0;
				return;
			}
		#endif
		#if defined SCANNER_TELEMETRY
			if (telemetry_link && protocol == PROTO_SCANNER)
			{
				spectrum_scanner_frame();
				telemetry_link = 0;
				return;
			}
		#endif
		#if defined (FRSKY_RX_TELEMETRY) || defined(AFHDS2A_RX_TELEMETRY) || defined (BAYANG_RX_TELEMETRY) || defined (DSM_RX_CYRF6936_INO)
			if ((telemetry_link & 1) && (protocol == PROTO_FRSKY_RX || protocol == PROTO_AFHDS2A_RX || protocol == PROTO_BAYANG_RX || protocol == PROTO_DSM_RX) )
			{
				receiver_channels_frame();
				telemetry_link &= ~1;
				return;
			}
		#endif
	#endif //MULTI_TELEMETRY
	
	if( telemetry_link & 1 )
	{	// FrSkyD + Hubsan + AFHDS2A + Bayang + Cabell + Hitec + Bugs + BugsMini + NCC1701 + PROPEL + RLINK + OMP + MLINK + DEVO
		// FrSkyX telemetry if in PPM
		frsky_link_frame();
		return;
	}
	#if defined HUB_TELEMETRY
		if((telemetry_link & 2) && ( protocol == PROTO_FRSKYD || protocol == PROTO_BAYANG || protocol == PROTO_MLINK  || protocol == PROTO_DEVO ) )
		{	// FrSkyD + Bayang + MLINK + DEVO
			frsky_user_frame();
			frsky_check_user_frame();
			return;
		}
	#endif
}


/**************************/
/**************************/
/**  Serial TX routines  **/
/**************************/
/**************************/

#ifndef BASH_SERIAL
	// Routines for normal serial output
	void Serial_write(uint8_t data)
	{
		uint8_t nextHead ;
		nextHead = tx_head + 1 ;
		if ( nextHead >= TXBUFFER_SIZE )
			nextHead = 0 ;
		tx_buff[nextHead]=data;
		tx_head = nextHead ;
		tx_resume();
	}

	void initTXSerial( uint8_t speed)
	{
		#ifdef ENABLE_PPM
			if(speed==SPEED_9600)
			{ // 9600
				#ifdef ORANGE_TX
					USARTC0.BAUDCTRLA = 207 ;
					USARTC0.BAUDCTRLB = 0 ;
					USARTC0.CTRLB = 0x18 ;
					USARTC0.CTRLA = (USARTC0.CTRLA & 0xCF) | 0x10 ;
					USARTC0.CTRLC = 0x03 ;
				#else
					#ifdef STM32_BOARD
						usart3_begin(9600,SERIAL_8N1);		//USART3 
					#else
						UBRR0H = 0x00;
						UBRR0L = 0x67;
						UCSR0A = 0 ;						// Clear X2 bit
						//Set frame format to 8 data bits, none, 1 stop bit
						UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
					#endif
				#endif
			}
			else if(speed==SPEED_57600)
			{ // 57600
				#ifdef ORANGE_TX
					/*USARTC0.BAUDCTRLA = 207 ;
					USARTC0.BAUDCTRLB = 0 ;
					USARTC0.CTRLB = 0x18 ;
					USARTC0.CTRLA = (USARTC0.CTRLA & 0xCF) | 0x10 ;
					USARTC0.CTRLC = 0x03 ;*/
				#else
					#ifdef STM32_BOARD
						usart3_begin(57600,SERIAL_8N1);		//USART3 
					#else
						UBRR0H = 0x00;
						UBRR0L = 0x22;
						UCSR0A = 0x02 ;	// Set X2 bit
						//Set frame format to 8 data bits, none, 1 stop bit
						UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
					#endif
				#endif
			}
			else if(speed==SPEED_125K)
			{ // 125000
				#ifdef ORANGE_TX
					/*USARTC0.BAUDCTRLA = 207 ;
					USARTC0.BAUDCTRLB = 0 ;
					USARTC0.CTRLB = 0x18 ;
					USARTC0.CTRLA = (USARTC0.CTRLA & 0xCF) | 0x10 ;
					USARTC0.CTRLC = 0x03 ;*/
				#else
					#ifdef STM32_BOARD
						usart3_begin(125000,SERIAL_8N1);	//USART3 
					#else
						UBRR0H = 0x00;
						UBRR0L = 0x07;
						UCSR0A = 0x00 ;	// Clear X2 bit
						//Set frame format to 8 data bits, none, 1 stop bit
						UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
					#endif
				#endif
			}
		#else
			(void)speed;
		#endif
		#ifndef ORANGE_TX
			#ifndef STM32_BOARD
				UCSR0B |= (1<<TXEN0);//tx enable
			#endif
		#endif
	}

	//Serial TX
	#ifdef ORANGE_TX
		ISR(USARTC0_DRE_vect)
	#else
		#ifdef STM32_BOARD
			void __irq_usart3()			
		#else
			ISR(USART_UDRE_vect)
		#endif
	#endif
	{	// Transmit interrupt
		#ifdef STM32_BOARD
			if(USART3_BASE->SR & USART_SR_TXE)
			{
		#endif
				if(tx_head!=tx_tail)
				{
					if(++tx_tail>=TXBUFFER_SIZE)//head 
						tx_tail=0;
					#ifdef STM32_BOARD	
						USART3_BASE->DR=tx_buff[tx_tail];//clears TXE bit				
					#else
						UDR0=tx_buff[tx_tail];
					#endif
				}
				if (tx_tail == tx_head)
				{
					tx_pause(); // Check if all data is transmitted. If yes disable transmitter UDRE interrupt.
				}
		#ifdef STM32_BOARD	
			}
		#endif		
	}
#else	//BASH_SERIAL
// Routines for bit-bashed serial output

// Speed is 0 for 100K and 1 for 9600
void initTXSerial( uint8_t speed)
{
	TIMSK0 = 0 ;	// Stop all timer 0 interrupts
	#ifdef INVERT_SERIAL
		SERIAL_TX_off;
	#else
		SERIAL_TX_on;
	#endif
	UCSR0B &= ~(1<<TXEN0) ;

	SerialControl.speed = speed ;
	if ( speed == SPEED_9600 )
	{
		OCR0A = 207 ;	// 104uS period
		TCCR0A = 3 ;
		TCCR0B = 0x0A ; // Fast PMM, 2MHz
	}
	else	// 100K
	{
		TCCR0A = 0 ;
		TCCR0B = 2 ;	// Clock/8 (0.5uS)
	}
}

void Serial_write( uint8_t byte )
{
	uint8_t temp ;
	uint8_t temp1 ;
	uint8_t byteLo ;

	#ifdef INVERT_SERIAL
		byte = ~byte ;
	#endif

	byteLo = byte ;
	byteLo >>= 7 ;		// Top bit
	if ( SerialControl.speed == SPEED_100K )
	{
		#ifdef INVERT_SERIAL
				byteLo |= 0x02 ;	// Parity bit
		#else
				byteLo |= 0xFC ;	// Stop bits
		#endif
		// calc parity
		temp = byte ;
		temp >>= 4 ;
		temp = byte ^ temp ;
		temp1 = temp ;
		temp1 >>= 2 ;
		temp = temp ^ temp1 ;
		temp1 = temp ;
		temp1 <<= 1 ;
		temp ^= temp1 ;
		temp &= 0x02 ;
		#ifdef INVERT_SERIAL
				byteLo ^= temp ;
		#else	
				byteLo |= temp ;
		#endif
	}
	else
	{
		byteLo |= 0xFE ;	// Stop bit
	}
	byte <<= 1 ;
	#ifdef INVERT_SERIAL
		byte |= 1 ;		// Start bit
	#endif
	uint8_t next = SerialControl.head + 2;
	if(next>=TXBUFFER_SIZE)
		next=0;
	if ( next != SerialControl.tail )
	{
		SerialControl.data[SerialControl.head] = byte ;
		SerialControl.data[SerialControl.head+1] = byteLo ;
		SerialControl.head = next ;
	}
	if(!IS_TX_PAUSE_on)
		tx_resume();
}

void resumeBashSerial()
{
	cli() ;
	if ( SerialControl.busy == 0 )
	{
		sei() ;
		// Start the transmission here
		#ifdef INVERT_SERIAL
			GPIOR2 = 0 ;
		#else
			GPIOR2 = 0x01 ;
		#endif
		if ( SerialControl.speed == SPEED_100K )
		{
			GPIOR1 = 1 ;
			OCR0B = TCNT0 + 40 ;
			OCR0A = OCR0B + 210 ;
			TIFR0 = (1<<OCF0A) | (1<<OCF0B) ;
			TIMSK0 |= (1<<OCIE0B) ;
			SerialControl.busy = 1 ;
		}
		else
		{
			GPIOR1 = 1 ;
			TIFR0 = (1<<TOV0) ;
			TIMSK0 |= (1<<TOIE0) ;
			SerialControl.busy = 1 ;
		}
	}
	else
	{
		sei() ;
	}
}

// Assume timer0 at 0.5uS clock

ISR(TIMER0_COMPA_vect)
{
	uint8_t byte ;
	byte = GPIOR0 ;
	if ( byte & 0x01 )
		SERIAL_TX_on;
	else
		SERIAL_TX_off;
	byte /= 2 ;		// Generates shorter code than byte >>= 1
	GPIOR0 = byte ;
	if ( --GPIOR1 == 0 )
	{
		TIMSK0 &= ~(1<<OCIE0A) ;
		GPIOR1 = 3 ;
	}
	else
		OCR0A += 20 ;
}

ISR(TIMER0_COMPB_vect)
{
	uint8_t byte ;
	byte = GPIOR2 ;
	if ( byte & 0x01 )
		SERIAL_TX_on;
	else
		SERIAL_TX_off;
	byte /= 2 ;		// Generates shorter code than byte >>= 1
	GPIOR2 = byte ;
	if ( --GPIOR1 == 0 )
	{
		if ( IS_TX_PAUSE_on )
		{
			SerialControl.busy = 0 ;
			TIMSK0 &= ~(1<<OCIE0B) ;
		}
		else
		{
			// prepare next byte and allow for 2 stop bits
			volatile struct t_serial_bash *ptr = &SerialControl ;
			if ( ptr->head != ptr->tail )
			{
				GPIOR0 = ptr->data[ptr->tail] ;
				GPIOR2 = ptr->data[ptr->tail+1] ;
				uint8_t nextTail = ptr->tail + 2 ;
				if ( nextTail >= TXBUFFER_SIZE )
					nextTail = 0 ;
				ptr->tail = nextTail ;
				GPIOR1 = 8 ;
				OCR0A = OCR0B + 40 ;
				OCR0B = OCR0A + 8 * 20 ;
				TIMSK0 |= (1<<OCIE0A) ;
			}
			else
			{
				SerialControl.busy = 0 ;
				TIMSK0 &= ~(1<<OCIE0B) ;
			}
		}
	}
	else
		OCR0B += 20 ;
}

ISR(TIMER0_OVF_vect)
{
	uint8_t byte ;
	if ( GPIOR1 > 2 )
		byte = GPIOR0 ;
	else
		byte = GPIOR2 ;
	if ( byte & 0x01 )
		SERIAL_TX_on;
	else
		SERIAL_TX_off;
	byte /= 2 ;		// Generates shorter code than byte >>= 1
	if ( GPIOR1 > 2 )
		GPIOR0 = byte ;
	else
		GPIOR2 = byte ;
	if ( --GPIOR1 == 0 )
	{	// prepare next byte
		volatile struct t_serial_bash *ptr = &SerialControl ;
		if ( ptr->head != ptr->tail )
		{
			GPIOR0 = ptr->data[ptr->tail] ;
			GPIOR2 = ptr->data[ptr->tail+1] ;
			uint8_t nextTail = ptr->tail + 2 ;
			if ( nextTail >= TXBUFFER_SIZE )
				nextTail = 0 ;
			ptr->tail = nextTail ;
			GPIOR1 = 10 ;
		}
		else
		{
			SerialControl.busy = 0 ;
			TIMSK0 &= ~(1<<TOIE0) ;
		}
	}
}


#endif // BASH_SERIAL

#endif // TELEMETRY

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/UDIRC_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
//Models: UDIRC UD160x(PRO), Pinecone Models SG-160x, Eachine EAT15

#if defined(UDIRC_CCNRF_INO)

#include "iface_xn297.h"

#define FORCE_UDIRC_ORIGINAL_ID

#define UDIRC_PAYLOAD_SIZE			15
#define UDIRC_RF_NUM_CHANNELS		4
#define UDIRC_PACKET_PERIOD			21000
#define UDIRC_BIND_COUNT			2000
#define UDIRC_P1_P2_TIME			5000
#define UDIRC_WRITE_TIME			1500

enum {
	UDIRC_DATA1=0,
	UDIRC_DATA2,
	UDIRC_DATA3,
	UDIRC_RX,
};

static void __attribute__((unused)) UDIRC_send_packet()
{
	if(rf_ch_num==0)
	{
		XN297_Hopping(hopping_frequency_no);
		debug("H %d ",hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no &= 3;
	}

	memset(&packet[3], 0x00, 12);
	if(bind_counter)
	{//Bind in progress
		bind_counter--;
		if(bind_counter)
		{//Bind
			packet[0] = 0x01;
			memcpy(&packet[1],rx_tx_addr,5);
		}
		else
		{//Switch to normal
			rf_ch_num = 1;
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);
			XN297_SetRXAddr(rx_tx_addr, UDIRC_PAYLOAD_SIZE);
		}
	}
	if(!bind_counter)
	{//Normal
		packet[0] = 0x08;
		//Channels SG-16xx: ST/TH/CH4 /CH3  /UNK/UNK/UNK/UNK/GYRO/ST_TRIM/ST_DR
		//Channels EAT15  : ST/TH/RATE/LIGHT/UNK/UNK/UNK/UNK/GYRO/ST_TRIM/ST_DR
		for(uint8_t i=0; i<12; i++)
			packet[i+1] = convert_channel_16b_limit(i,0,200);
		//Just for now let's set the additional channels to 0
		packet[5] = packet[6] = packet[7] = packet[8] = 0;
	}
	packet[12] = GET_FLAG(CH12_SW,  0x40)						//TH.REV
				|GET_FLAG(CH13_SW,  0x80);						//ST.REV
	//packet[13] = 00; //Unknown, future flags?
	for(uint8_t i=0;i<UDIRC_PAYLOAD_SIZE-1;i++)
		packet[14] += packet[i];
	// Send
	XN297_SetFreqOffset();
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, UDIRC_PAYLOAD_SIZE,false);
	#ifdef DEBUG_SERIAL
		for(uint8_t i=0; i < UDIRC_PAYLOAD_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) UDIRC_initialize_txid()
{
	#ifdef FORCE_UDIRC_ORIGINAL_ID
		if(RX_num)
		{
			rx_tx_addr[0] = 0xD0;
			rx_tx_addr[1] = 0x06;
			rx_tx_addr[2] = 0x00;
			rx_tx_addr[3] = 0x00;
			rx_tx_addr[4] = 0x81;
		}
		else
		{
			rx_tx_addr[0] = 0xF6;
			rx_tx_addr[1] = 0x96;
			rx_tx_addr[2] = 0x01;
			rx_tx_addr[3] = 0x00;
			rx_tx_addr[4] = 0x81;
		}
		hopping_frequency[0] = 45;
		hopping_frequency[1] = 59;
		hopping_frequency[2] = 52;
		hopping_frequency[3] = 67;
	#endif
}

static void __attribute__((unused)) UDIRC_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	//Bind address
	XN297_SetTXAddr((uint8_t*)"\x01\x03\x05\x07\x09", 5);
	XN297_SetRXAddr((uint8_t*)"\x01\x03\x05\x07\x09", UDIRC_PAYLOAD_SIZE);
	XN297_HoppingCalib(UDIRC_RF_NUM_CHANNELS);
}

uint16_t UDIRC_callback()
{
	bool rx;
	switch(phase)
	{
		case UDIRC_DATA1:
			rx = XN297_IsRX();
			XN297_SetTxRxMode(TXRX_OFF);
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(UDIRC_PACKET_PERIOD);
			#endif
			UDIRC_send_packet();
			if(rx)
			{
				uint8_t val=XN297_ReadEnhancedPayload(packet_in, UDIRC_PAYLOAD_SIZE);
				debug("RX(%d):",val);
				if(val != 255)
				{
					rf_ch_num = 1;
					if(bind_counter)
						bind_counter=1;
					#ifdef DEBUG_SERIAL
						for(uint8_t i=0; i < UDIRC_PAYLOAD_SIZE; i++)
							debug(" %02X", packet_in[i]);
					#endif
				}
				debugln("");
			}
			phase++;
			return UDIRC_P1_P2_TIME;
		case UDIRC_DATA2:
			//Resend packet
			XN297_ReSendPayload();
			phase++;
			return UDIRC_WRITE_TIME;
		default: //UDIRC_RX
			//Wait for the packet transmission to finish
			while(XN297_IsPacketSent()==false);
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = UDIRC_DATA1;
			return UDIRC_PACKET_PERIOD - UDIRC_P1_P2_TIME - UDIRC_WRITE_TIME;
	}
	return 0;
}

void UDIRC_init()
{
	UDIRC_initialize_txid();
	UDIRC_RF_init();

	bind_counter = IS_BIND_IN_PROGRESS ? UDIRC_BIND_COUNT : 1;
	phase = UDIRC_DATA1;
	hopping_frequency_no = 0;
	rf_ch_num = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V2X2_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with WLToys V2x2, JXD JD38x, JD39x, JJRC H6C, Yizhan Tarantula X6 ...
// Last sync with hexfet new_protocols/v202_nrf24l01.c dated 2015-03-15

#if defined(V2X2_NRF24L01_INO)


#include "iface_nrf24l01.h"
#define V2X2_MR101_FORCE_ID

#define V2X2_BIND_COUNT 1000
// Timeout for callback in uSec, 4ms=4000us for V202
#define V2X2_PACKET_PERIOD 4000
//
// Time to wait for packet to be sent (no ACK, so very short)
#define V2X2_PACKET_CHKTIME  100
#define V2X2_PAYLOADSIZE 16

// 
enum {
	V2X2_FLAG_CAMERA = 0x01, // also automatic Missile Launcher and Hoist in one direction
	V2X2_FLAG_VIDEO  = 0x02, // also Sprayer, Bubbler, Missile Launcher(1), and Hoist in the other dir.
	V2X2_FLAG_FLIP   = 0x04,
	V2X2_FLAG_UNK9   = 0x08,
	V2X2_FLAG_LIGHT  = 0x10,
	V2X2_FLAG_UNK10  = 0x20,
	V2X2_FLAG_BIND   = 0xC0,
	// flags going to byte 10
	V2X2_FLAG_HEADLESS  = 0x02,
	V2X2_FLAG_MAG_CAL_X = 0x08,
	V2X2_FLAG_MAG_CAL_Y = 0x20,
    V2X2_FLAG_EMERGENCY = 0x80,	// JXD-506
    // flags going to byte 11 (JXD-506)
    V2X2_FLAG_START_STOP = 0x40,
    V2X2_FLAG_CAMERA_UP  = 0x01,   
    V2X2_FLAG_CAMERA_DN  = 0x02,
};

//

// This is frequency hopping table for V202 protocol
// The table is the first 4 rows of 32 frequency hopping
// patterns, all other rows are derived from the first 4.
// For some reason the protocol avoids channels, dividing
// by 16 and replaces them by subtracting 3 from the channel
// number in this case.
// The pattern is defined by 5 least significant bits of
// sum of 3 bytes comprising TX id
const uint8_t PROGMEM freq_hopping[][16] = {
	{ 0x27, 0x1B, 0x39, 0x28, 0x24, 0x22, 0x2E, 0x36,
		0x19, 0x21, 0x29, 0x14, 0x1E, 0x12, 0x2D, 0x18 }, //  00
	{ 0x2E, 0x33, 0x25, 0x38, 0x19, 0x12, 0x18, 0x16,
		0x2A, 0x1C, 0x1F, 0x37, 0x2F, 0x23, 0x34, 0x10 }, //  01
	{ 0x11, 0x1A, 0x35, 0x24, 0x28, 0x18, 0x25, 0x2A,
		0x32, 0x2C, 0x14, 0x27, 0x36, 0x34, 0x1C, 0x17 }, //  02
	{ 0x22, 0x27, 0x17, 0x39, 0x34, 0x28, 0x2B, 0x1D,
		0x18, 0x2A, 0x21, 0x38, 0x10, 0x26, 0x20, 0x1F }  //  03
};

static void __attribute__((unused)) V2X2_RF_init()
{
	NRF24L01_Initialize();

	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x3F);  // Enable all data pipes
	if(sub_protocol==V2X2_MR101)
		NRF24L01_SetBitrate(NRF24L01_BR_250K);
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t *)"\x66\x88\x68\x68\x68", 5);
	NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR,    (uint8_t *)"\x66\x88\x68\x68\x68", 5);
}

static void __attribute__((unused)) V2X2_set_tx_id(void)
{
	uint8_t sum;
	sum = rx_tx_addr[1] + rx_tx_addr[2] + rx_tx_addr[3];
	// Higher 3 bits define increment to corresponding row
	uint8_t increment = (sum & 0x1e) >> 2;
	// Base row is defined by lowest 2 bits
	sum &=0x03;
	for (uint8_t i = 0; i < 16; ++i) {
		uint8_t val = pgm_read_byte_near(&freq_hopping[sum][i]) + increment;
		// Strange avoidance of channels divisible by 16
		hopping_frequency[i] = (val & 0x0f) ? val : val - 3;
	}
	#ifdef V2X2_MR101_FORCE_ID
	if(sub_protocol==V2X2_MR101)
	{
		rx_tx_addr[1]=0x83;
		rx_tx_addr[2]=0x03;
		rx_tx_addr[3]=0xAE;
		memcpy(hopping_frequency,"\x05\x12\x08\x0C\x04\x0E\x10",7);
	}
	#endif
}

static void __attribute__((unused)) V2X2_send_packet()
{
	uint8_t rf_ch = hopping_frequency[hopping_frequency_no >> 1];
	hopping_frequency_no = (hopping_frequency_no + 1) & 0x1F;
	if(sub_protocol==V2X2_MR101 && hopping_frequency_no>13)
			hopping_frequency_no=0;
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, rf_ch);

	uint8_t flags2=0;
	if (IS_BIND_IN_PROGRESS)
	{
		flags     = V2X2_FLAG_BIND;
		packet[0] = 0;
		packet[1] = 0;
		packet[2] = 0;
		packet[3] = 0;
		packet[4] = 0;
		packet[5] = 0;
		packet[6] = 0;
	}
	else
	{
		packet[0] = convert_channel_8b(THROTTLE);
		packet[1] = convert_channel_s8b(RUDDER);
		packet[2] = convert_channel_s8b(ELEVATOR);
		packet[3] = convert_channel_s8b(AILERON);
		// Trims, middle is 0x40
		packet[4] = 0x40; // yaw
		packet[5] = 0x40; // pitch
		packet[6] = 0x40; // roll

		//Flags
		flags=0;
		// Channel 5
		if (CH5_SW)	flags = V2X2_FLAG_FLIP;

		if(sub_protocol!=V2X2_MR101)
		{//V2X2 & JXD506
			// Channel 6
			if (CH6_SW)	flags |= V2X2_FLAG_LIGHT;
			// Channel 7
			if (CH7_SW)	flags |= V2X2_FLAG_CAMERA;
			// Channel 8
			if (CH8_SW)	flags |= V2X2_FLAG_VIDEO;

			//Flags2
			// Channel 9
			if (CH9_SW)
				flags2 = V2X2_FLAG_HEADLESS;
			if(sub_protocol==JXD506)
			{
				// Channel 11
				if (CH11_SW)
					flags2 |= V2X2_FLAG_EMERGENCY;
			}
			else
			{//V2X2
				// Channel 10
				if (CH10_SW)
					flags2 |= V2X2_FLAG_MAG_CAL_X;
				// Channel 11
				if (CH11_SW)
					flags2 |= V2X2_FLAG_MAG_CAL_Y;
			}
		}
	}
	// TX id
	packet[7] = rx_tx_addr[1];
	packet[8] = rx_tx_addr[2];
	packet[9] = rx_tx_addr[3];
	// flags
	packet[10] = flags2;
	packet[11] = 0x00;
	packet[12] = 0x00;
	packet[13] = 0x00;
	if(sub_protocol==JXD506)
	{
		// Channel 10
		if (CH10_SW)
			packet[11] = V2X2_FLAG_START_STOP;
		// Channel 12
		if(CH12_SW)
			packet[11] |= V2X2_FLAG_CAMERA_UP;
		else if(Channel_data[CH12] < CHANNEL_MIN_COMMAND)
			packet[11] |= V2X2_FLAG_CAMERA_DN;
		packet[12] = 0x40;
		packet[13] = 0x40;
	}
	else if(sub_protocol==V2X2_MR101)
	{
		
		if (CH10_SW) packet[11]  = 0x04;	// Motors start/stop
		if (CH11_SW) packet[11] |= 0x40;	// Auto Land=-100% Takeoff=+100%
		if (CH7_SW)	 flags |= 0x02;			// Picture
		if (CH8_SW)	 flags |= 0x01;			// Video
		if(IS_BIND_IN_PROGRESS)
			flags = 0x80;
		flags |= (hopping_frequency_no & 0x01)<<6;
	}
	packet[14] = flags;
	uint8_t sum = packet[0];
	for (uint8_t i = 1; i < 15;  ++i)
		sum += packet[i];
	packet[15] = sum;

	NRF24L01_FlushTx();
	NRF24L01_WritePayload(packet, V2X2_PAYLOADSIZE);
	//packet_sent = 1;

	if (! hopping_frequency_no)
		NRF24L01_SetPower();
}

uint16_t V2X2_callback()
{
	//if (packet_sent && NRF24L01_packet_ack() != PKT_ACKED)
	//	return V2X2_PACKET_CHKTIME;
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(V2X2_PACKET_PERIOD);
	#endif
	if(bind_counter)
	{
		if (--bind_counter == 0)
		{
			BIND_DONE;
			if(sub_protocol==V2X2_MR101)
			{
				#ifdef V2X2_MR101_FORCE_ID
					NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, (uint8_t *)"\xC9\x59\xD2\x65\x34", 5);
					memcpy(hopping_frequency,"\x03\x05\x15\x0D\x06\x14\x0B",7);
				#endif
			}
			hopping_frequency_no = 0;
		}
	}
	V2X2_send_packet();
	// Packet every 4ms
	return V2X2_PACKET_PERIOD;
}

void V2X2_init()
{	
	if(sub_protocol==V2X2_MR101)
		BIND_IN_PROGRESS;
	//packet_sent = 0;
	hopping_frequency_no = 0;
	bind_counter = V2X2_BIND_COUNT;

	V2X2_RF_init();
	V2X2_set_tx_id();
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V761_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 
 Thanks to  Goebish ,Ported  from his deviation firmware
 */

#if defined(V761_NRF24L01_INO)

#include "iface_xn297.h"

//#define V761_FORCE_ID

#define V761_PACKET_PERIOD		7060 // Timeout for callback in uSec
#define V761_INITIAL_WAIT		500
#define V761_PACKET_SIZE		8
#define V761_RXPAYLOAD_SIZE		3
#define V761_BIND_COUNT			200
#define V761_BIND_FREQ			0x28
#define V761_RF_NUM_CHANNELS	3
#define TOPRC_BIND_FREQ			0x2A
#define TOPRC_PACKET_PERIOD		14120 // Timeout for callback in uSec

#define V761_WRITE_TIME			450
#define V761_TELEM_PACKET_PERIOD	14088 // Timeout for callback in uSec
//#define V761_TELEM_DEBUG

enum 
{
	V761_BIND1 = 0,
	V761_BIND2,
	V761_RX_CHECK,
	V761_DATA,
	V761_RX
};

static void __attribute__((unused)) V761_set_checksum()
{
	uint8_t checksum = packet[0];
	for(uint8_t i=1; i<V761_PACKET_SIZE-2; i++)
		checksum += packet[i];
	if(phase == V761_BIND1)
	{
		packet[6] = checksum ^ 0xff;
		packet[7] = packet[6];
	}
	else 
	{
		checksum += packet[6];
		packet[7] = checksum ^ 0xff;
	}
}

static void __attribute__((unused)) V761_send_packet()
{
	static bool calib=false, prev_ch6=false;

	if(phase != V761_DATA)
	{
		memcpy(packet, rx_tx_addr, 4);
		packet[4] = hopping_frequency[1];
		packet[5] = hopping_frequency[2];
		if(phase == V761_BIND2)
			packet[6] = 0xF0;							// ?
	}
	else
	{ 
		#ifdef V761_TELEM_DEBUG
			debug_time("");
			debugln(" Ph:%d",hopping_frequency_no);
		#endif
		XN297_Hopping(hopping_frequency_no++);
		if(hopping_frequency_no >= V761_RF_NUM_CHANNELS)
		{
			hopping_frequency_no = 0;
			packet_sent++;
			packet_sent &= 0x03;
		}

		packet[0] = convert_channel_8b(THROTTLE);		// Throttle
		packet[2] = convert_channel_8b(ELEVATOR)>>1;	// Elevator

		if(sub_protocol == V761_4CH || sub_protocol == V761_TOPRC)
		{
			packet[1] = convert_channel_8b(AILERON)>>1;	// Aileron
			packet[3] = convert_channel_8b(RUDDER)>>1;	// Rudder
		}
		else
		{
			packet[1] = convert_channel_8b(RUDDER)>>1;	// Rudder
			packet[3] = convert_channel_8b(AILERON)>>1;	// Aileron
		}

		packet[5] = packet_sent<<6;						// 0X, 4X, 8X, CX
		packet[4] = 0x20;								// Trims 00..20..40, 0X->20 4X->TrAil 8X->TrEle CX->TrRud

		if(CH5_SW)										// Mode Expert Gyro off
			flags = 0x0c;
		else
			if(Channel_data[CH5] < CHANNEL_MIN_COMMAND)
				flags = 0x08;							// Beginer mode (Gyro on, yaw and pitch rate limited)
			else
				flags = 0x0a;							// Mid Mode ( Gyro on no rate limits)        

		if(!prev_ch6 && CH6_SW)							// -100% -> 100% launch gyro calib
			calib=!calib;
		prev_ch6 = CH6_SW;
		if(calib)
			flags |= 0x01;								// Gyro calibration

		packet[5] |= flags;

		packet[6] =  GET_FLAG(CH7_SW,  0x20) 			// Flip
					|GET_FLAG(CH8_SW,  0x08)			// RTH activation
					|GET_FLAG(CH9_SW,  0x10)			// RTH on/off
					|GET_FLAG(CH10_SW, 0x40);			// Beeper on/off
		if(sub_protocol == V761_3CH)
			packet[6] |= 0x80;							// Unknown, set on original V761-1 dump but not on eachine dumps, keeping for compatibility
	}
	V761_set_checksum();

	#if 0
		debug("H:%02X P:",hopping_frequency_no);
		for(uint8_t i=0;i<V761_PACKET_SIZE;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, V761_PACKET_SIZE);
}

static void __attribute__((unused)) V761_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
}

static void __attribute__((unused)) V761_initialize_txid()
{
	#ifdef V761_FORCE_ID
		if(sub_protocol == V761_TOPRC)
		{ //Dump from air on TopRCHobby TX
			memcpy(rx_tx_addr,(uint8_t *)"\xD5\x01\x00\x00",4);
			memcpy(hopping_frequency,(uint8_t *)"\x2E\x41",2);
		}
		else
		{
			switch(RX_num%5)
			{
				case 1:	//Dump from air on Protonus TX
					memcpy(rx_tx_addr,(uint8_t *)"\xE8\xE4\x45\x09",4);
					memcpy(hopping_frequency,(uint8_t *)"\x0D\x21",2);
					break;
				case 2:	//Dump from air on mshagg2 TX
					memcpy(rx_tx_addr,(uint8_t *)"\xAE\xD1\x45\x09",4);
					memcpy(hopping_frequency,(uint8_t *)"\x13\x1D",2);
					break;
				case 3:	//Dump from air on MikeHRC Eachine TX
					memcpy(rx_tx_addr,(uint8_t *)"\x08\x03\x00\xA0",4);
					memcpy(hopping_frequency,(uint8_t *)"\x0D\x21",2);
					break;
				case 4:	//Dump from air on Crashanium Eachine TX
					memcpy(rx_tx_addr,(uint8_t *)"\x58\x08\x00\xA0",4);
					memcpy(hopping_frequency,(uint8_t *)"\x0D\x31",2);
					break;
				default: //Dump from SPI
					memcpy(rx_tx_addr,(uint8_t *)"\x6f\x2c\xb1\x93",4);
					memcpy(hopping_frequency,(uint8_t *)"\x14\x1e",2);
					break;
			}
		}
	#else
		//Tested with Eachine RX
		rx_tx_addr[0]+=RX_num;
		hopping_frequency[0]=(rx_tx_addr[0]&0x0F)+0x05;
		hopping_frequency[1]=hopping_frequency[0]+0x05+(RX_num%0x2D);
	#endif

	hopping_frequency[2]=hopping_frequency[0]+0x37;

	debugln("ID: %02X %02X %02X %02X , HOP: %02X %02X %02X",rx_tx_addr[0],rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3],hopping_frequency[0],hopping_frequency[1],hopping_frequency[2]);
}

uint16_t V761_callback()
{
	static bool rx = false;
	static uint8_t packet_telem = 0;

	switch(phase)
	{
		case V761_BIND1:
			if(bind_counter) 
				bind_counter--;
			packet_sent ++;
			XN297_RFChannel(sub_protocol == V761_TOPRC ? TOPRC_BIND_FREQ : V761_BIND_FREQ);
			XN297_SetTXAddr(rx_id, 4);
			V761_send_packet();
			if(packet_sent >= 20) 
			{
				packet_sent = 0;
				phase = V761_BIND2;
			}
			return 15730;
		case V761_BIND2:
			if(bind_counter) 
				bind_counter--;
			packet_sent ++;
			XN297_Hopping(0);
			XN297_SetTXAddr(rx_tx_addr, 4);
			V761_send_packet();
			if(bind_counter == 0) 
			{
				packet_sent = 0;
				BIND_DONE;
				phase = V761_DATA;
				#ifdef V761_HUB_TELEMETRY
					XN297_SetRXAddr(rx_tx_addr, V761_RXPAYLOAD_SIZE);
				#endif
			}
			else if(packet_sent >= 20) 
			{
				packet_sent = 0;
				phase = V761_BIND1;
			}
			return 15730;
	#ifdef V761_HUB_TELEMETRY
		case V761_RX_CHECK:
			rx = XN297_IsRX();					// Needed for the NRF24L01 since otherwise the bit gets cleared
			XN297_SetTxRxMode(TXRX_OFF);
			if(packet_count > 4*63)				// Around 3.5sec with no telemetry
			{
				telemetry_lost = 1;
				packet_period = V761_PACKET_PERIOD;
			}
			else
			{
				packet_count++;
				if(!telemetry_lost && !rx && (packet_count & 0x3F) == 0)
				{// Should have received a telem packet but... Send telem to the radio to keep it alive
					telemetry_link = 1;
					#ifdef V761_TELEM_DEBUG
						debugln("Miss");
					#endif
				}
			}
			phase++;
	#endif
		case V761_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(packet_period);
			#endif
			V761_send_packet();
	#ifdef V761_HUB_TELEMETRY
			if(sub_protocol == V761_TOPRC)
				break;
			if(rx)
			{ // Check if a packet has been received
				#ifdef V761_TELEM_DEBUG
					debug("RX ");
				#endif
				if(XN297_ReadPayload(packet_in, V761_RXPAYLOAD_SIZE))
				{ // packet with good CRC and length
					#ifdef V761_TELEM_DEBUG
						debug("OK:");
						for(uint8_t i=0;i<V761_RXPAYLOAD_SIZE;i++)
							debug(" %02X",packet_in[i]);
						debug(" pps:%d", packet_count);
					#endif
					// packet_in[] = AA 00 55 -> battery ok
					// packet_in[] = 55 00 AA -> low battery
					crc8 = 0;
					for(uint8_t i=0;i<V761_RXPAYLOAD_SIZE;i++)
						crc8 ^= packet_in[i];
					if(crc8 == 0xFF)
					{
						v_lipo1 = packet_in[0] >> 1;
						telemetry_link = 1;
						telemetry_lost = 0;
						packet_count = 0;
						packet_period = V761_TELEM_PACKET_PERIOD;
					}
					#ifdef V761_TELEM_DEBUG
					else // Bad packet
						debug(" NOK");
					#endif
				}
				#ifdef V761_TELEM_DEBUG
				else // Bad packet
					debug("NOK");
				debugln("");
				#endif
				rx = false;
			}
			phase++;
			return V761_WRITE_TIME;
		case V761_RX:
			{ // Wait for packet to be sent before switching to receive mode
				uint16_t start=(uint16_t)micros();
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
					if(XN297_IsPacketSent())
						break;
			}
			XN297_SetTxRxMode(RX_EN);
			phase = V761_RX_CHECK;
			return packet_period - V761_WRITE_TIME;
	#else
			break;
	#endif
	}
	return packet_period;
}

void V761_init(void)
{
	V761_initialize_txid();
	V761_RF_init();
	if(sub_protocol == V761_TOPRC)
	{
		memcpy(rx_id,(uint8_t*)"\x20\x21\x05\x0A",4);
		packet_period = TOPRC_PACKET_PERIOD;
	}
	else
	{
		memcpy(rx_id,(uint8_t*)"\x34\x43\x10\x10",4);
		packet_period = V761_PACKET_PERIOD;
	}

	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter = V761_BIND_COUNT;
		phase = V761_BIND1;
	}
	else
	{
		XN297_SetTXAddr(rx_tx_addr, 4);
		#ifdef V761_HUB_TELEMETRY
			XN297_SetRXAddr(rx_tx_addr, V761_RXPAYLOAD_SIZE);
		#endif
		phase = V761_DATA;
	}

	hopping_frequency_no = 0;
	packet_sent = 0;
	#ifdef V761_HUB_TELEMETRY
		packet_count = 0;
		telemetry_lost = 1;
		RX_RSSI = 100;		// Dummy value
	#endif
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/V911S_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with V911S

#if defined(V911S_CCNRF_INO)

#include "iface_xn297.h"

//#define V911S_ORIGINAL_ID

#define V911S_PACKET_PERIOD			5000
#define V911S_BIND_PACKET_PERIOD	3300
#define V911S_INITIAL_WAIT			500
#define V911S_PACKET_SIZE			16
#define V911S_RF_BIND_CHANNEL		35
#define V911S_NUM_RF_CHANNELS		8
#define V911S_BIND_COUNT			800

// flags going to packet[1]
#define	V911S_FLAG_EXPERT	0x04
#define	E119_FLAG_EXPERT	0x08	//0x00 low, 0x08 high
#define	E119_FLAG_CALIB		0x40
// flags going to packet[2]
#define	V911S_FLAG_CALIB	0x01
#define A220_FLAG_6G3D		0x04
#define A280_FLAG_6GSENIOR	0x08
#define A280_FLAG_LIGHT		0x20

static void __attribute__((unused)) V911S_send_packet()
{
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x42;
		packet[1] = 0x4E;
		packet[2] = 0x44;
		for(uint8_t i=0;i<5;i++)
			packet[i+3] = rx_tx_addr[i];
		for(uint8_t i=0;i<8;i++)
			packet[i+8] = hopping_frequency[i];
	}
	else
	{
		uint8_t channel=hopping_frequency_no;
		if(rf_ch_num&1)
		{
			if((hopping_frequency_no&1)==0)
				channel+=8;
			channel>>=1;
		}
		if(rf_ch_num&2)
			channel=7-channel;
		XN297_Hopping(channel);
		hopping_frequency_no++;
		hopping_frequency_no&=7;							// 8 RF channels

		packet[ 0]=(rf_ch_num<<3)|channel;
		memset(packet+1, 0x00, V911S_PACKET_SIZE - 1);
		if(sub_protocol==V911S_STD)
		{
			packet[ 1]=GET_FLAG(!CH6_SW,V911S_FLAG_EXPERT);	// short press on left button
			packet[ 2]=GET_FLAG(CH5_SW,V911S_FLAG_CALIB);	// long  press on right button
		}
		else//E119
		{
			packet[ 1]=GET_FLAG(!CH6_SW,E119_FLAG_EXPERT)	// short  press on left button
					  |GET_FLAG( CH5_SW,E119_FLAG_CALIB);	// short  press on right button
			packet[ 2]=GET_FLAG( CH7_SW,A220_FLAG_6G3D)	// short  press on right button
					  |GET_FLAG( CH8_SW,A280_FLAG_6GSENIOR)    // -100% - 6G, +100% - Senior mode (turn off gyro)
					  |GET_FLAG( CH9_SW,A280_FLAG_LIGHT);	// cycle the light through on-flash-off when the CH9 value is changed from -100% to 100% 
		}
			
		//packet[3..6]=trims TAER signed
		uint16_t ch=convert_channel_16b_limit(THROTTLE ,0,0x7FF);
		packet[ 7] = ch;
		packet[ 8] = ch>>8;
		ch=convert_channel_16b_limit(AILERON ,0x7FF,0);
		packet[ 8]|= ch<<3;
		packet[ 9] = ch>>5;
		ch=convert_channel_16b_limit(ELEVATOR,0,0x7FF);
		if(sub_protocol==V911S_STD)
		{
			packet[10] = ch;
			packet[11] = ch>>8;
			ch=convert_channel_16b_limit(RUDDER  ,0x7FF,0);
			packet[11]|= ch<<3;
			packet[12] = ch>>5;
		}
		else
		{//E119
			ch=0x7FF-ch;
			packet[ 9]|= ch<<6;
			packet[10] = ch>>2;
			packet[11] = ch>>10;
			ch=convert_channel_16b_limit(RUDDER  ,0x7FF,0);
			packet[11]|= ch<<1;
			packet[12] = ch>>7;
		}
	}
	
	if(sub_protocol==V911S_STD)
		XN297_WritePayload(packet, V911S_PACKET_SIZE);
	else//E119
		XN297_WriteEnhancedPayload(packet, V911S_PACKET_SIZE, IS_BIND_IN_PROGRESS?0:1);
	
	XN297_SetPower();				// Set tx_power
	XN297_SetFreqOffset();			// Set frequency offset
}

static void __attribute__((unused)) V911S_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	if(sub_protocol==V911S_STD)
		XN297_SetTXAddr((uint8_t *)"KNBND",5);		// V911S Bind address
	else//E119
		XN297_SetTXAddr((uint8_t *)"XPBND",5);		// E119 Bind address
	XN297_HoppingCalib(V911S_NUM_RF_CHANNELS);		// Calibrate all channels
	XN297_RFChannel(V911S_RF_BIND_CHANNEL);		// Set bind channel
}

static void __attribute__((unused)) V911S_initialize_txid()
{
	//channels
	uint8_t offset=rx_tx_addr[3]%5;				// 0-4
	for(uint8_t i=0;i<V911S_NUM_RF_CHANNELS;i++)
		hopping_frequency[i]=0x10+i*5+offset;
	if(!offset) hopping_frequency[0]++;
	
	// channels order
	rf_ch_num=random(0xfefefefe)&0x03;			// 0-3
}

uint16_t V911S_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(V911S_PACKET_PERIOD);
	#endif
	if(bind_counter)
	{
		bind_counter--;
		if (bind_counter == 0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);
			packet_period=V911S_PACKET_PERIOD;
		}
		else if(bind_counter==100)		// same as original TX...
			packet_period=V911S_BIND_PACKET_PERIOD*3;
	}
	V911S_send_packet();
	return	packet_period;
}

void V911S_init(void)
{
	V911S_initialize_txid();
	#ifdef V911S_ORIGINAL_ID
		if(sub_protocol==V911S_STD)
		{//V911S
			rx_tx_addr[0]=0xA5;
			rx_tx_addr[1]=0xFF;
			rx_tx_addr[2]=0x70;
			rx_tx_addr[3]=0x8D;
			rx_tx_addr[4]=0x76;
			for(uint8_t i=0;i<V911S_NUM_RF_CHANNELS;i++)
				hopping_frequency[i]=0x10+i*5;
			hopping_frequency[0]++;
			rf_ch_num=0;
		}
		else
		{//E119
			rx_tx_addr[0]=0x30;
			rx_tx_addr[1]=0xFF;
			rx_tx_addr[2]=0xD1;
			rx_tx_addr[3]=0x2C;
			rx_tx_addr[4]=0x2A;
			for(uint8_t i=0;i<V911S_NUM_RF_CHANNELS;i++)
				hopping_frequency[i]=0x0E + i*5;
			rf_ch_num=0;
		}
	#endif

	V911S_RF_init();

	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter = V911S_BIND_COUNT;
		packet_period= V911S_BIND_PACKET_PERIOD;
	}
	else
	{
		XN297_SetTXAddr(rx_tx_addr, 5);
		packet_period= V911S_PACKET_PERIOD;
	}
	hopping_frequency_no=0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY2_a7105.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(WFLY2_A7105_INO)

#include "iface_a7105.h"

//#define WFLY2_FORCE_ID

//WFLY2 constants & variables
#define WFLY2_BIND_COUNT		2777	// abort bind after 10sec
#define WFLY2_PACKET_SIZE		32

enum{
	WFLY2_DATA,
	WFLY2_PLL_TX,
	WFLY2_RX,
};

static void __attribute__((unused)) WFLY2_build_packet()
{
	static uint16_t pseudo=0;

	//End bind
	if(IS_BIND_IN_PROGRESS && bind_counter)
	{
		bind_counter--;
		if (bind_counter==0)
		{
			BIND_DONE;
			A7105_WriteID(MProtocol_id);
			rf_ch_num = 0;
		}
	}

	memset(packet,0x00,WFLY2_PACKET_SIZE);

	if(IS_BIND_IN_PROGRESS)
	{
		//Header
		packet[0] = 0x0F;			// Bind packet

		//ID
		packet[1] = rx_tx_addr[3];
		packet[2] = rx_tx_addr[2];
		packet[3] = rx_tx_addr[1];
		//packet[4] = 0x00;			// Should be rx_tx_addr[0]&0x0F but bind is already using 0x00 so ....

		//Unknown
		packet[5] = 0x01;

		//Freq
		rf_ch_num = (hopping_frequency_no<<1)+0x08;
		packet[6] = rf_ch_num;
		hopping_frequency_no++;
		if(hopping_frequency_no > 0x17) hopping_frequency_no=0x00;

		//Unknown bytes 7..31
	}
	else
	{
		//Pseudo
		uint16_t high_bit=(pseudo & 0x8000) ^ 0x8000; 							// toggle 0x8000 every other line
		pseudo <<= 1;															// *2
		if( (pseudo & 0x8000) || pseudo == 0 ) pseudo ^= 0x8A87;				// Randomisation, pseudo==0 is a guess but would give the start value seen on the dump when P[2]P[1]=0 at init and will prevent a lock up
		pseudo |= high_bit;														// include toggle
		packet[1] = pseudo;
		packet[2] = pseudo>>8;
		
		//RF channel
		int8_t prev = rf_ch_num & 0x1F;
		rf_ch_num = (pseudo ^ (pseudo >> 7));
		rf_ch_num = ((rf_ch_num>>1)&0x08) | (rf_ch_num & 0x47);
		rf_ch_num = ((rf_ch_num>>2)&0x10) | (rf_ch_num & 0x1F);
		rf_ch_num ^= rx_tx_addr[3] & 0x1F;
		if(abs((int8_t)rf_ch_num-prev) <= 9)
		{
			if(high_bit)
				rf_ch_num |= 0x20;
		}
		else
			if(!high_bit)
				rf_ch_num |= 0x20;

		//Partial ID
		packet[3] = rx_tx_addr[3];
		packet[4] = rx_tx_addr[2] & 0x03;

		//Header
		if(prev_option!=option)
		{//Set the RX PPM/WBUS on change
			packet[0] = 0x05;	//PPM/WBUS packet
			packet[5] = 0x01;
			if(option)
				packet[6] = 0x01;	// PPM
			else
				packet[6] = 0x00;	// WBUS
			prev_option = option;
		}
		else
		{//Normal or Failsafe packets
			uint8_t offset=0;
			
			//packet[0] = 0x00;	// Normal packet

			#ifdef FAILSAFE_ENABLE
				#define WFLY2_NUM_FS_PKTS 2	//the original TX sends 4 but that's not needed...
				if(IS_FAILSAFE_VALUES_on && packet_sent >= WFLY2_NUM_FS_PKTS)	//Failsafe packet arrived from radio
					packet_sent = 0;		// send FS config packets
					
				if(packet_sent < WFLY2_NUM_FS_PKTS)
				{// Send failsafe packets
					packet[0] = 0x01;		//Failsafe packet
					packet[5] = 0x08 | packet_sent;
					/*if(packet_sent > 1)	// needed when more than 2 FS packets are sent
					{
						packet[5] |= 0x50;	// all channels in failsafe
						packet[6]  = 0x55;	// all channels in failsafe
					}
					else*/
					{
						uint8_t val=0;
						for(uint8_t i = 0; i < 6; i++)
						{
							val >>= 2;
							if(Failsafe_data[i+packet_sent*6] == FAILSAFE_CHANNEL_NOPULSES)		//no pulse value = 2
								val |= 0x80;
							else if(Failsafe_data[i+packet_sent*6] != FAILSAFE_CHANNEL_HOLD)	//hold value = 0
								val |= 0x40;													//fs value = 1
							//debug("ch%d=%04X, val=%02X | ",i+1+packet_sent*6, Failsafe_data[i+packet_sent*6],val);
							if(i==1)
								packet[5] |= val;
						}
						packet[6] = val;
					}
					offset=2;
					packet_sent++;
					//debugln("5=%02X, 6=%02X", packet[5], packet[6]);
				}
			#endif

			//10 channels -100%=0x2C1...0%=0x800...+100%=0xD3F
			for(uint8_t i = 0; i < 5; i++)
			{
				uint16_t temp=convert_channel_16b_nolimit(i*2 , 0x2C1, 0xD3F, IS_FAILSAFE_VALUES_on);
				packet[5 + offset + i*3]  = temp&0xFF;		// low byte
				packet[7 + offset + i*3]  = (temp>>8)&0x0F;	// high byte
				temp=convert_channel_16b_nolimit(i*2+1, 0x2C1, 0xD3F, IS_FAILSAFE_VALUES_on);
				packet[6 + offset + i*3]  = temp&0xFF;		// low byte
				packet[7 + offset + i*3] |= (temp>>4)&0xF0;	// high byte
			}
			
			#ifdef FAILSAFE_ENABLE
				if(packet_sent >= WFLY2_NUM_FS_PKTS)
					FAILSAFE_VALUES_off;
			#endif

			//Unknown bytes 20+offset..31
		}
	}

	//Debug
	#if 0
		debug("ch=%02X,%02X P=",rf_ch_num,(rf_ch_num<<1)+0x10);
		for(uint8_t i=0; i<WFLY2_PACKET_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln("");
	#endif
}

#ifdef WFLY2_HUB_TELEMETRY
	static void __attribute__((unused)) WFLY2_Send_Telemetry()
	{
		//Incoming packet values
		v_lipo1=packet[3]<<1;		// RX_batt *10 in V
		v_lipo2=packet[5]<<1;		// Ext_batt*10 in V
		RX_RSSI=(255-packet[7])>>1;	// Looks to be the RX RSSI value direct from A7105

		// Read TX RSSI
		TX_RSSI=255-A7105_ReadReg(A7105_1D_RSSI_THOLD);

		telemetry_counter++;			// LQI counter
		telemetry_link=1;
		if(telemetry_lost)
		{
			telemetry_lost = 0;
			packet_count = 100;
			telemetry_counter = 100;
		}
	}
#endif

#define WFLY2_PACKET_PERIOD		3600	//3600
#define WFLY2_BUFFER_TIME		1500	//1500
#define WFLY2_WRITE_TIME		800		//942

uint16_t WFLY2_callback()
{
	uint16_t start;
	uint8_t status;
	
	#ifndef FORCE_WFLY2_TUNING
		A7105_AdjustLOBaseFreq(1);
	#endif
	switch(phase)
	{
		case WFLY2_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(WFLY2_PACKET_PERIOD);
			#endif
			//Build data packet
			WFLY2_build_packet();

			//Fill the TX buffer without sending
			A7105_WriteData(WFLY2_PACKET_SIZE,0);
			
			#ifdef WFLY2_HUB_TELEMETRY
				//LQI calculation
				packet_count++;
				if(packet_count>=100)
				{
					packet_count=0;
					TX_LQI=telemetry_counter;
					if(telemetry_counter==0)
						telemetry_lost = 1;
					telemetry_counter = 0;
				}
			#endif
			
			phase++;	// WFLY2_PLL_TX
			return WFLY2_BUFFER_TIME;
			
		case WFLY2_PLL_TX:
			//Check RX status
			status=A7105_ReadReg(A7105_00_MODE);
			//debugln("S:%02X", status);
			
			//PLL
			A7105_Strobe(A7105_PLL);
			
			//Read incoming packet even if bad/not present to not change too much the TX timing, might want to reorg the code...
			A7105_ReadData(WFLY2_PACKET_SIZE);

			//Read telemetry
			if((status & 0x21)==0)
			{ // Packet received and CRC OK
				//Debug
				#if 0
					debug("T:");
					for(uint8_t i=0; i<WFLY2_PACKET_SIZE-20; i++)		// Can't send the full telemetry at full speed
						debug(" %02X", packet[i]);
					debugln("");
				#endif
				
				if(IS_BIND_IN_PROGRESS)
				{
					if(packet[0]==0x0F && packet[1]==rx_tx_addr[3] && packet[2]==rx_tx_addr[2] && packet[3]==rx_tx_addr[1] && packet[4]==0x00)
					{
						bind_counter=1;									// End bind
						debugln("Bind done");
						//packet[5..7] contains the RXID
					}
				}
				#ifdef WFLY2_HUB_TELEMETRY
					else
						if(packet[0]==0 && packet[1]==rx_tx_addr[3] && packet[2]==(rx_tx_addr[2] & 0x03))
						{//Packet match the ID
								WFLY2_Send_Telemetry();							// Packet looks good do send telem to the radio
						}
				#endif
			}
			
			//Change RF channel
			A7105_WriteReg(A7105_0F_PLL_I, (rf_ch_num<<1)+0x10);
			
			//Switch to TX
			A7105_SetPower();
			A7105_SetTxRxMode(TX_EN);
			A7105_Strobe(A7105_TX);

			phase++;	// WFLY2_RX
			return WFLY2_WRITE_TIME;
			
		case WFLY2_RX:
			//Wait for TX completion
			start=micros();
			while ((uint16_t)((uint16_t)micros()-start) < 700)				// Wait max 700s
				if(!(A7105_ReadReg(A7105_00_MODE) & 0x01))
					break;
			
			//Switch to RX
			A7105_SetTxRxMode(RX_EN);
			A7105_Strobe(A7105_RX);
			
			phase = WFLY2_DATA;
			return WFLY2_PACKET_PERIOD-WFLY2_WRITE_TIME-WFLY2_BUFFER_TIME;
	}
	return WFLY2_PACKET_PERIOD; // never reached, please the compiler
}

void WFLY2_init()
{
	A7105_Init();

	#ifdef WFLY2_FORCE_ID
		MProtocol_id = 0x50002313;	//Richard
		//MProtocol_id = 0x50000223;	//Pascal
	#endif
	MProtocol_id &= 0x00FFFFFF;		// Since the bind ID starts with 50, let's keep only the last 3 bytes of the ID
	MProtocol_id |= 0x50000000;		// As recommended on the A7105 datasheet
	set_rx_tx_addr(MProtocol_id);	// Update the ID
	
	if(IS_BIND_IN_PROGRESS)
		A7105_WriteID(0x50FFFFFE);	// Bind ID
	else
		A7105_WriteID(MProtocol_id);

	hopping_frequency_no=0;
	rf_ch_num = 0;
	bind_counter = WFLY2_BIND_COUNT;
	packet_sent = 255;
	phase = WFLY2_DATA;
	#ifdef WFLY2_HUB_TELEMETRY
		packet_count = 0;
		telemetry_lost = 1;
	#endif
}
#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WFLY_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(WFLY_CYRF6936_INO)

#include "iface_cyrf6936.h"

//#define WFLY_FORCE_ID
#define WFLY_BIND_COUNT 1500	// around 15s
#define WFLY_NUM_FREQUENCE 4
#define WFLY_BIND_CHANNEL 0x09

enum {
	WFLY_BIND_TX=0,
	WFLY_BIND_PREP_RX,
	WFLY_BIND_RX,
	WFLY_PREP_DATA,
	WFLY_DATA,
};

const uint8_t PROGMEM WFLY_sop_bind[]={ 0x5A, 0xCC, 0xAE, 0x46, 0xB6, 0x31, 0xAE, 0x46 };
const uint8_t PROGMEM WFLY_sop_data[]={ 0xEF, 0x64, 0xB0, 0x2A, 0xD2, 0x8F, 0xB1, 0x2A };

//Most of the bytes are unknown... 1C A7 looks to be the bind ID, BF 13 is the TX ID, 15 is the channel used to send the hopping frequencies.
const uint8_t PROGMEM WFLY_bind_packet[]={ 0x1C, 0xA7, 0x60, 0x04, 0x04, 0xBF, 0x13, 0x15, 0xC5, 0x40, 0x8A, 0x37, 0xE0, 0xE8, 0x03, 0xA3 };


const uint8_t PROGMEM WFLY_init_vals[][2] = {
	//Init from dump
	{CYRF_1D_MODE_OVERRIDE, 0x19},			// Reset
	{CYRF_32_AUTO_CAL_TIME, 0x3C},			// Default init value
	{CYRF_35_AUTOCAL_OFFSET, 0x14},			// Default init value
	{CYRF_1B_TX_OFFSET_LSB, 0x55},			// Default init value
	{CYRF_1C_TX_OFFSET_MSB, 0x05},			// Default init value
	{CYRF_06_RX_CFG, 0x48 | 0x02},			// LNA enabled, Fast Turn Mode enabled, adding overwrite enable to not lockup RX
	{CYRF_10_FRAMING_CFG, 0xE8},			// SOP enable
	{CYRF_03_TX_CFG, 0x08 | CYRF_BIND_POWER},	// Original=0x0F, 8DR Mode, 32 chip codes
	{CYRF_0C_XTAL_CTRL, 0xC4},				// Enable XOUT as GPIO
	{CYRF_0D_IO_CFG, 0x04},					// Enable PACTL as GPIO
	{CYRF_0F_XACT_CFG, 0x21},				// Abort current operation
	{CYRF_1E_RX_OVERRIDE, 0x00},			// Accept packets with 0 seed for bind
	{CYRF_15_CRC_SEED_LSB, 0x00},			// CRC seed for bind
	{CYRF_16_CRC_SEED_MSB, 0x00},			// CRC seed for bind
};

static void __attribute__((unused)) WFLY_cyrf_bind_config()
{
	for(uint8_t i = 0; i < sizeof(WFLY_init_vals) / 2; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&WFLY_init_vals[i][0]), pgm_read_byte_near(&WFLY_init_vals[i][1]));

    CYRF_PROGMEM_ConfigSOPCode(WFLY_sop_bind);
	CYRF_ConfigRFChannel(WFLY_BIND_CHANNEL);
	CYRF_SetTxRxMode(TX_EN);
}

static void __attribute__((unused)) WFLY_cyrf_data_config()
{
	for(uint8_t i = 0; i < (sizeof(WFLY_init_vals) / 2)-3; i++)	
		CYRF_WriteRegister(pgm_read_byte_near(&WFLY_init_vals[i][0]), pgm_read_byte_near(&WFLY_init_vals[i][1]));

	//CYRF_WriteRegister(CYRF_1E_RX_OVERRIDE, 0x08);	// Do not accept CRC with 0 seed but not needed since the RX is not sending any data...
	CYRF_WriteRegister(CYRF_15_CRC_SEED_LSB, rx_tx_addr[2]);
	CYRF_WriteRegister(CYRF_16_CRC_SEED_MSB, rx_tx_addr[3]);
	
    CYRF_PROGMEM_ConfigSOPCode(WFLY_sop_data);
	CYRF_SetTxRxMode(TX_EN);
}

static uint16_t __attribute__((unused)) WFLY_send_data_packet()
{
	packet_count++;
	packet[0] = rx_tx_addr[2];
	packet[1] = rx_tx_addr[3];
	if(packet_count%4==3)
	{	// Send the hopping frequencies
		packet[2]=0x70;		// packet type
		packet[3]=0x04;		// unknown
		packet[4]=0x00;		// unknown
		packet[5]=0x04;		// unknown
		packet[6]=hopping_frequency[0];
		packet[7]=hopping_frequency[0];
		packet[8]=hopping_frequency[1];
		packet[9]=hopping_frequency[2];
		len=10;				// packet[10] contains the checksum
	}
	else
	{	// Send sticks packet
		uint8_t nbr_ch=option;
		if(nbr_ch<4) nbr_ch=9;			// 4 channels min can be sent, default to 9
		if(nbr_ch>9) nbr_ch=9;			// 9 channels max can be sent
		packet[2]=nbr_ch-3;				// nbr of channels to follow
		packet[3]=packet_count>>2;		// packet counter 0x00..0x3F
		len=4;
		for(uint8_t i=0;i<3;i++)
		{ // Channels
			uint16_t ch = convert_channel_16b_nolimit(i*4+0,151,847,IS_FAILSAFE_VALUES_on);
			uint8_t offset=i*5;
			packet[3+offset] |= ch<<6;
			packet[4+offset]  = ch>>2;
			len++;
			if(--nbr_ch==0) break;
			ch = convert_channel_16b_nolimit(i*4+1,151,847,IS_FAILSAFE_VALUES_on);
			packet[5+offset]  = ch;
			packet[6+offset]  = ch>>8;
			len+=2;
			if(--nbr_ch==0) break;
			ch = convert_channel_16b_nolimit(i*4+2,151,847,IS_FAILSAFE_VALUES_on);
			packet[6+offset] |= ch<<2;
			packet[7+offset]  = ch>>6;
			len++;
			if(--nbr_ch==0) break;
			ch = convert_channel_16b_nolimit(i*4+3,151,847,IS_FAILSAFE_VALUES_on);
			packet[7+offset] |= ch<<4;
			packet[8+offset]  = ch>>4;
			len++;
			if(--nbr_ch==0) break;
		}
		#ifdef FAILSAFE_ENABLE
			if(IS_FAILSAFE_VALUES_on)
			{
				packet[2] |= 0x10;			// 19 times 3 times 0x10 followed by 3 times 0x18 and so on but 1 time 0x10 seems to be enough for the RX to learn
				FAILSAFE_VALUES_off;
			}
		#endif
	}

	uint8_t sum=0;
	for(uint8_t i = 0; i < len; i++)
		sum += packet[i];
	packet[len] = sum;

	CYRF_ConfigRFChannel(hopping_frequency[(packet_count)%4]);
	CYRF_SetPower(0x08);
	CYRF_WriteDataPacketLen(packet, len+1);

	switch(packet_count%4)
	{
		case 0:
			return 1393;
		case 1:
			return 1330;
		case 2:
			return 1555;
	}
	return 1093;	// case 3
}

uint16_t WFLY_callback()
{
	uint8_t status,len,sum=0,check=0;
	uint8_t start;
	static uint8_t retry;

	switch(phase)
	{
		case WFLY_BIND_TX:
			CYRF_SetTxRxMode(TX_EN);
			CYRF_WriteDataPacketLen(packet, sizeof(WFLY_bind_packet));
			debug("P=");
			for(uint8_t i=0;i<sizeof(WFLY_bind_packet);i++)
				debug(" %02X",packet[i]);
			debugln(" , L=%02X", sizeof(WFLY_bind_packet));
			phase++;
			if(--bind_counter==0)
			{ // Switch to normal mode
				BIND_DONE;
				phase=WFLY_PREP_DATA;
			}
			return 2500;
		case WFLY_BIND_PREP_RX:
			start=micros();
			while ((uint8_t)((uint8_t)micros()-(uint8_t)start) < 200)				// Wait max 200s for TX to finish
				if((CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80) == 0x00)
					break;										// Packet transmission complete
			CYRF_SetTxRxMode(RX_EN);							//Receive mode
			CYRF_WriteRegister(CYRF_05_RX_CTRL, 0x83);			//Prepare to receive
			retry=10;									//Timeout for RX
			phase=WFLY_BIND_RX;
			return 700;
		case WFLY_BIND_RX:
			//Read data from RX
			status = CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			if((status & 0x03) == 0x02)  						// RXC=1, RXE=0 then 2nd check is required (debouncing)
				status |= CYRF_ReadRegister(CYRF_07_RX_IRQ_STATUS);
			CYRF_WriteRegister(CYRF_07_RX_IRQ_STATUS, 0x80);	// need to set RXOW before data read
			if((status & 0x07) == 0x02)
			{ // Data received with no errors
				len=CYRF_ReadRegister(CYRF_09_RX_COUNT);
				debugln("L=%02X",len)
				if(len==0x10)
				{
					CYRF_ReadDataPacketLen(packet_in, len);
					debug("RX=");
					for(uint8_t i=0;i<0x0F;i++)
					{
						debug(" %02X",packet_in[i]);
						if(packet_in[i]==packet[i])
							check++;							// Verify quickly the content
						sum+=packet_in[i];
					}
					debugln(" %02X",packet_in[15]);
					if(sum==packet_in[15] && check>=10)
					{ // Good packet received
						if(packet_in[2]==0x64)
						{ // Switch to normal mode
							BIND_DONE;
							phase=WFLY_PREP_DATA;
							return 10000;
						}
						memcpy((void *)packet,(void *)packet_in,0x10);	// Send back to the RX what we've just received with no modifications
					}
					phase=WFLY_BIND_TX;							
					return 200;
				}
			}
			if(status & 0x85 || --retry == 0)
			{ // RX error or no answer
				debugln("Abort");
				CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x20);		// Enable RX abort
				CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x21);		// Force end state
				CYRF_WriteRegister(CYRF_29_RX_ABORT, 0x00);		// Disable RX abort
				phase=WFLY_BIND_TX;								// Retry sending bind packet
			}
			return 700;
		case WFLY_PREP_DATA:
			WFLY_cyrf_data_config();
			packet_count=0;
			phase++;
		case WFLY_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(5371);
			#endif
			start=micros();
			while ((uint8_t)((uint8_t)micros()-(uint8_t)start) < 200)
				if((CYRF_ReadRegister(CYRF_02_TX_CTRL) & 0x80) == 0x00)
					break;										// Packet transmission complete
			return WFLY_send_data_packet();
	}
	return 1000;
}

void WFLY_init()
{ 
	//Random start channel
	uint8_t ch=0x0A+random(0xfefefefe)%0x0E;
	if(ch%3==0)
		ch++;								// remove these channels as they seem to not be working...
	rf_ch_num=0x0C+(rx_tx_addr[1]&0x03)*3;	// use the start channels which do not seem to work to send the hopping table instead
	
	#ifdef WFLY_FORCE_ID					// data taken from TX dump
		rx_tx_addr[2]=0xBF;					// ID
		rx_tx_addr[3]=0x13;					// ID
		ch=0x16;							// value seen between 0x0A and 0x17
		rf_ch_num=0x15						// RF channel to send the current hopping table
	#endif

	debug("ID:")
	for(uint8_t i=0;i<2;i++)
		debug(" %02X", rx_tx_addr[2+i]);
	debugln("");

	hopping_frequency[0]=ch;
	hopping_frequency[1]=ch+0x1E;
	hopping_frequency[2]=ch+0x2D;
	hopping_frequency[3]=rf_ch_num;			// RF channel used to send the current hopping table
	
	debug("RF Channels:")
	for(uint8_t i=0;i<WFLY_NUM_FREQUENCE;i++)
		debug(" %02X", hopping_frequency[i]);
	debugln("");

	if(IS_BIND_IN_PROGRESS)
	{
		bind_counter=WFLY_BIND_COUNT;
		WFLY_cyrf_bind_config();
		for(uint8_t i=0;i<sizeof(WFLY_bind_packet);i++)
			packet[i]=pgm_read_byte_near(&WFLY_bind_packet[i]);
		packet[5]=rx_tx_addr[2];
		packet[6]=rx_tx_addr[3];
		packet[7]=rf_ch_num;
		uint8_t sum=0;
		for(uint8_t i = 0; i < 15; i++)
			sum += packet[i];
		packet[15] = sum;
		phase=WFLY_BIND_TX;
	}
	else
		phase = WFLY_PREP_DATA;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WK2x01_cyrf6936.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(WK2x01_CYRF6936_INO)

#include "iface_cyrf6936.h"

#define WK_BIND_COUNT 2980
#define WK_NUM_WAIT_LOOPS (100 / 5) //each loop is ~5us.  Do not wait more than 100us

enum {
	WK_BIND=0,
	WK_BOUND_1,
	WK_BOUND_2,
	WK_BOUND_3,
	WK_BOUND_4,
	WK_BOUND_5,
	WK_BOUND_6,
	WK_BOUND_7,
	WK_BOUND_8,
};

static const uint8_t WK_sopcodes[8] = {
    /* Note these are in order transmitted (LSB 1st) */
    0xDF,0xB1,0xC0,0x49,0x62,0xDF,0xC1,0x49 //0x49C1DF6249C0B1DF
};
static const uint8_t init_2801[] = {0xc5, 0x34, 0x60, 0x00, 0x25};
static const uint8_t init_2601[] = {0xb9, 0x45, 0xb0, 0xf1, 0x3a};
static const uint8_t init_2401[] = {0xa5, 0x23, 0xd0, 0xf0, 0x00};

uint8_t WK_last_beacon;

static void __attribute__((unused)) WK_add_pkt_crc(uint8_t init)
{
	uint8_t add = init;
	uint8_t xou = init;
	for (uint8_t i = 0; i < 14; i++)
	{
		add += packet[i];
		xou ^= packet[i];
	}
	packet[14] = xou;
	packet[15] = add;
}

static void __attribute__((unused)) WK_build_bind_pkt(const uint8_t *init)
{
	packet[0] = init[0];
	packet[1] = init[1];
	packet[2] = hopping_frequency[0];
	packet[3] = hopping_frequency[1];
	packet[4] = init[2];
	packet[5] = hopping_frequency[2];
	packet[6] = 0xff;
	packet[7] = 0x00;
	packet[8] = 0x00;
	packet[9] = 0x32;
	if (sub_protocol == WK2401)
		packet[10]  = 0x10 | (rx_tx_addr[0]  & 0x0e);
	else
		packet[10]  = rx_tx_addr[0];
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2] | packet_count;
	packet[13] = init[3];
	WK_add_pkt_crc(init[4]);
}

static int16_t __attribute__((unused)) WK_get_channel(uint8_t ch, int32_t scale, int16_t center, int16_t range)
{
	int16_t value = convert_channel_16b_nolimit(CH_AETR[ch],-scale,scale,false)+center;
	if (value < center - range) value = center - range;
	if (value > center + range) value = center + range;
	return value;
}

static void __attribute__((unused)) WK_build_data_pkt_2401()
{
	uint16_t msb = 0;
	uint8_t offset = 0;
	for (uint8_t i = 0; i < 4; i++)
	{
		if (i == 2)
			offset = 1;
		int16_t value = WK_get_channel(i, 0x800, 0, 0xA00);	//12 bits, allow value to go to 125%
		uint16_t base = abs(value) >> 2;					//10 bits is the base value
		uint16_t trim = abs(value) & 0x03;					//lowest 2 bits represent trim
		if (base >= 0x200)
		{  //if value is > 100%, remainder goes to trim
			trim = 4 *(base - 0x200);
			base = 0x1ff;
		}
		base = (value >= 0) ? 0x200 + base : 0x200 - base;
		trim = (value >= 0) ? 0x200 + trim : 0x200 - trim;

		packet[2*i+offset]   = base & 0xff;
		packet[2*i+offset+1] = trim & 0xff;
		msb = (msb << 4) | ((base >> 6) & 0x0c) | ((trim >> 8) & 0x03);
	}
	packet[4] = msb >> 8; //Ele/Ail MSB
	packet[9] = msb & 0xff; //Thr/Rud MSB
	packet[10]  = 0xe0 | (rx_tx_addr[0]  & 0x0e);
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2] | packet_count;
	packet[13] = 0xf0; //FIXME - What is this?
	WK_add_pkt_crc(0x00);
}

#define PCT(pct, max) (((int32_t)(max) * (int32_t)(pct) + 1L) / 1000L)
#define MAXTHR 426 //Measured to provide equal value at +/-0
static void __attribute__((unused)) WK_channels_6plus1_2601(uint8_t frame, int16_t *_v1, int16_t *_v2)
{
	int16_t thr = WK_get_channel(2, 1000, 0, 1000);
	int16_t v1;
	uint8_t thr_rev = 0, pitch_rev = 0;
	if(thr > 0)
	{
		if(thr >= 780)
		{ //78%
			v1 = 0; //thr = 60% * (x - 78%) / 22% + 40%
			thr = PCT(1000-MAXTHR,512) * (thr-PCT(780,1000)) / PCT(220,1000) + PCT(MAXTHR,512);
		}
		else
		{
			v1 = 1023 - 1023 * thr / 780;
			thr = PCT(MAXTHR, 512); //40%
		}
	}
	else
	{
		thr = -thr;
		thr_rev = 1;
		if(thr >= 780)
		{ //78%
			v1 = 1023; //thr = 60% * (x - 78%) / 22% + 40%
			thr = PCT(1000-MAXTHR,512) * (thr-PCT(780,1000)) / PCT(220,1000) + PCT(MAXTHR,512);
		}
		else
		{
			v1 = 1023 * thr / 780;
			thr = PCT(MAXTHR, 512); //40%
		}
	}
	if (thr >= 512)
		thr = 511;
	packet[2] = thr & 0xff;
	packet[4] = (packet[4] & 0xF3) | ((thr >> 6) & 0x04);

	int16_t pitch= WK_get_channel(5, 0x400, 0, 0x400);
	if (pitch < 0)
	{
		pitch_rev = 1;
		pitch = -pitch;
	}
	if (frame == 1)
	{
		//Pitch curve and range
		if (thr > PCT(MAXTHR, 512))
			*_v2 = pitch - pitch * 16 * (thr - PCT(MAXTHR, 512)) / PCT(1000 - MAXTHR, 512) / 100;
		else
			*_v2 = pitch;
		*_v1 = 0;
	}
	else
		if (frame == 2)
		{
			//Throttle curve & Expo
			*_v1 = v1;
			*_v2 = 512;
		}
	packet[7] = (thr_rev << 5) | (pitch_rev << 2); //reverse bits
	packet[8] = 0;
}

static void __attribute__((unused)) WK_channels_5plus1_2601(uint8_t frame, int16_t *v1, int16_t *v2)
{
	(void)v1;
	//Zero out pitch, provide ail, ele, thr, rud, gyr + gear
	if (frame == 1)
		*v2 = 0;					//Pitch curve and range
	packet[7] = 0;
	packet[8] = 0;
}
static void __attribute__((unused)) WK_channels_heli_2601(uint8_t frame, int16_t *v1, int16_t *v2)
{
	//pitch is controlled by rx
	//we can only control fmode, pit-reverse and pit/thr rate
	uint8_t pit_rev = 0;
	if (sub_protocol==W6_HEL_I)
		pit_rev = 1;
	int16_t pit_rate = WK_get_channel(5, 0x400, 0, 0x400);
	uint8_t fmode = 1;
	if (pit_rate < 0)
	{
		pit_rate = -pit_rate;
		fmode = 0;
	}
	if (frame == 1)
	{
		//Pitch curve and range
		*v1 = pit_rate;
		*v2 = (int16_t)(option) * 0x400 / 100 + 0x400;
	}
	packet[7] = (pit_rev << 2);		//reverse bits
	packet[8] = fmode ? 0x02 : 0x00;
}

static void __attribute__((unused)) WK_build_data_pkt_2601()
{
	uint8_t msb = 0;
	uint8_t frame = (packet_count % 3);
	for (uint8_t i = 0; i < 4; i++)
	{
		int16_t value = WK_get_channel(i, 0x190, 0, 0x1FF);
		uint16_t mag = value < 0 ? -value : value;
		packet[i] = mag & 0xff;
		msb = (msb << 2) | ((mag >> 8) & 0x01) | (value < 0 ? 0x02 : 0x00);
	}
	packet[4] = msb;
	int16_t v1 = 0x200, v2 = 0x200;
	if (frame == 0)
	{
		//Gyro & Rudder mix
		v1 = WK_get_channel(6, 0x200, 0x200, 0x200);
		v2 = 0;
	}
	if (sub_protocol == W6_5_1)
		WK_channels_5plus1_2601(frame, &v1, &v2);
	else if (sub_protocol == W6_6_1)
		WK_channels_6plus1_2601(frame, &v1, &v2);
	else
		WK_channels_heli_2601(frame, &v1, &v2);
	if (v1 > 1023)
		v1 = 1023;
	if (v2 > 1023)
		v2 = 1023;
	packet[5] = v2 & 0xff;
	packet[6] = v1 & 0xff;
	//packet[7] handled by channel code
	packet[8] |= (WK_get_channel(4, 0x190, 0, 0x1FF) > 0 ? 1 : 0);
	packet[9] =  ((v1 >> 4) & 0x30) | ((v2 >> 2) & 0xc0) | 0x04 | frame;
	packet[10]  = rx_tx_addr[0];
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2] | packet_count;
	packet[13] = 0xff;

	WK_add_pkt_crc(0x3A);
}

static void __attribute__((unused)) WK_build_data_pkt_2801()
{
	uint16_t msb = 0;
	uint8_t offset = 0;
	uint8_t sign = 0;
	for (uint8_t i = 0; i < 8; i++)
	{
		if (i == 4) { offset = 1; }
		int16_t value = WK_get_channel(i, 0x1C2, 0, 0x3FF);
		uint16_t mag = value < 0 ? -value : value;
		packet[i+offset] = mag & 0xff;
		msb = (msb << 2) | ((mag >> 8) & 0x03);
		if (value < 0) { sign |= 1 << i; }
	}
	packet[4] = msb >> 8;
	packet[9] = msb  & 0xff;
	packet[10] = rx_tx_addr[0];
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2] | packet_count;
	packet[13] = sign;
	WK_add_pkt_crc(0x25);
}

static void __attribute__((unused)) WK_build_beacon_pkt_2801()
{
	WK_last_beacon ^= 1;
	uint8_t en = 0;
	uint8_t bind_state;

	#ifdef ENABLE_PPM
	if(mode_select && option==0 && IS_BIND_DONE) 			//PPM mode and option not already set and bind is finished
	{
		BIND_SET_INPUT;
		BIND_SET_PULLUP;										// set pullup
		if(IS_BIND_BUTTON_on)
		{
			eeprom_write_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num),0x01);	// Set fixed id mode for the current model
			option=1;
		}
		BIND_SET_OUTPUT;
	}
	#endif //ENABLE_PPM
    if(prev_option!=option && IS_BIND_DONE)
	{
		set_rx_tx_addr(MProtocol_id);
		rx_tx_addr[2]=rx_tx_addr[3]<<4;		// Make use of RX_num
		bind_counter = WK_BIND_COUNT / 8 + 1;
	}
	if (option)
	{
        if (bind_counter)
            bind_state = 0xe4;
        else
            bind_state = 0x1b;
    }
	else
        bind_state = 0x99;
	
	for (uint8_t i = 0; i < 4; i++)
	{
		#ifdef FAILSAFE_ENABLE
			uint16_t failsafe=Failsafe_data[CH_AETR[i + WK_last_beacon * 4]];
			if(failsafe!=FAILSAFE_CHANNEL_HOLD && IS_FAILSAFE_VALUES_on)
			{
				packet[i+1] = failsafe>>3;	//0..255
				en |= 1 << i;
			}
			else
		#endif
				packet[i+1] = 0;
	}
	packet[0] = en;
	packet[5] = packet[4];
	packet[4] = WK_last_beacon << 6;
	packet[6] = hopping_frequency[0];
	packet[7] = hopping_frequency[1];
	packet[8] = hopping_frequency[2];
	packet[9] = bind_state;
	packet[10] = rx_tx_addr[0];
	packet[11] = rx_tx_addr[1];
	packet[12] = rx_tx_addr[2] | packet_count;
	packet[13] = 0x00; //Does this matter?  in the docs it is the same as the data packet
	WK_add_pkt_crc(0x1C);
}

static void __attribute__((unused)) wk2x01_cyrf_init() {
	/* Initialize CYRF chip */
	CYRF_SetPower(0x28);
	CYRF_WriteRegister(CYRF_06_RX_CFG, 0x4A);
	CYRF_WriteRegister(CYRF_0B_PWR_CTRL, 0x00);
	CYRF_WriteRegister(CYRF_0C_XTAL_CTRL, 0xC0);
	CYRF_WriteRegister(CYRF_0D_IO_CFG, 0x04);
	CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x2C);
	CYRF_WriteRegister(CYRF_10_FRAMING_CFG, 0xEE);
	CYRF_WriteRegister(CYRF_1B_TX_OFFSET_LSB, 0x55);
	CYRF_WriteRegister(CYRF_1C_TX_OFFSET_MSB, 0x05);
	CYRF_WriteRegister(CYRF_1D_MODE_OVERRIDE, 0x18);
	CYRF_WriteRegister(CYRF_32_AUTO_CAL_TIME, 0x3C);
	CYRF_WriteRegister(CYRF_35_AUTOCAL_OFFSET, 0x14);
	CYRF_WriteRegister(CYRF_1E_RX_OVERRIDE, 0x90);
	CYRF_WriteRegister(CYRF_1F_TX_OVERRIDE, 0x00);
	CYRF_WriteRegister(CYRF_01_TX_LENGTH, 0x10);
	CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x2C);
	CYRF_WriteRegister(CYRF_28_CLK_EN, 0x02);
	CYRF_WriteRegister(CYRF_27_CLK_OVERRIDE, 0x02);
	CYRF_ConfigSOPCode(WK_sopcodes);
	CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x28);
	CYRF_WriteRegister(CYRF_1E_RX_OVERRIDE, 0x10);
	CYRF_WriteRegister(CYRF_0E_GPIO_CTRL, 0x20);
	CYRF_WriteRegister(CYRF_0F_XACT_CFG, 0x2C);
}

static void __attribute__((unused)) WK_BuildPacket_2801()
{
	switch(phase) {
		case WK_BIND:
			bind_counter--;
			WK_build_bind_pkt(init_2801);
			if (bind_counter == 0)
			{
				BIND_DONE;
				phase++;
			}
			break;
		case WK_BOUND_1:
		case WK_BOUND_2:
		case WK_BOUND_3:
		case WK_BOUND_4:
		case WK_BOUND_5:
		case WK_BOUND_6:
		case WK_BOUND_7:
			WK_build_data_pkt_2801();
			phase++;
			break;
		case WK_BOUND_8:
			WK_build_beacon_pkt_2801();
			phase = WK_BOUND_1;
			if (bind_counter)
			{
				bind_counter--;
				if (bind_counter == 0)
					BIND_DONE;
			}
			break;
	}
}

static void __attribute__((unused)) WK_BuildPacket_2601()
{
	if (bind_counter)
	{
		bind_counter--;
		WK_build_bind_pkt(init_2601);
		if (bind_counter == 0)
			BIND_DONE;
	}
	else
		WK_build_data_pkt_2601();
}

static void __attribute__((unused)) WK_BuildPacket_2401()
{
	if (bind_counter)
	{
		bind_counter--;
		WK_build_bind_pkt(init_2401);
		if(bind_counter == 0)
			BIND_DONE;
	}
	else
		WK_build_data_pkt_2401();
}

uint16_t WK_callback()
{
	if (packet_sent == 0)
	{
		#ifdef MULTI_SYNC
			telemetry_set_input_sync(2800);
		#endif
		packet_sent = 1;
		if(sub_protocol == WK2801)
			WK_BuildPacket_2801();
		else if(sub_protocol == WK2401)
			WK_BuildPacket_2401();
		else
			WK_BuildPacket_2601();
		packet_count = (packet_count + 1) % 12;
		CYRF_WriteDataPacket(packet);
		return 1600;
	}
	packet_sent = 0;
	uint8_t start=micros();
	while ((uint8_t)((uint8_t)micros()-start) < 100)			// Wait max 100s
		if(CYRF_ReadRegister(CYRF_04_TX_IRQ_STATUS) & 0x02)
			break;
	if((packet_count & 0x03) == 0)
	{
		hopping_frequency_no++;
		hopping_frequency_no%=3;
		CYRF_ConfigRFChannel(hopping_frequency[hopping_frequency_no]);
		//Keep transmit power updated
		CYRF_SetPower(0x28);
	}
	return 1200;
}

void WK_init()
{
	#ifdef ENABLE_PPM
		if(mode_select) //PPM mode
		{
			if(IS_BIND_BUTTON_FLAG_on)
			{
				eeprom_write_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num),0x00);	// reset to autobind mode for the current model
				option=0;
			}
			else
			{	
				option=eeprom_read_byte((EE_ADDR)(MODELMODE_EEPROM_OFFSET+RX_num));	// load previous mode: autobind or fixed id
				if(option!=1) option=0;								// if not fixed id mode then it should be autobind
			}
		}
	#endif //ENABLE_PPM

	wk2x01_cyrf_init();
	CYRF_SetTxRxMode(TX_EN);

	hopping_frequency_no=0;
	CYRF_FindBestChannels(hopping_frequency, 3, 4, 4, 80, FIND_CHANNEL_ANY);
	CYRF_ConfigRFChannel(hopping_frequency[0]);

	packet_count = 0;
	packet_sent = 0;
	WK_last_beacon = 0;
	if(sub_protocol!=WK2801 || option==0)
	{
		CYRF_GetMfgData(cyrfmfg_id);
		rx_tx_addr[2]=(hopping_frequency[0] ^ cyrfmfg_id[0] ^ cyrfmfg_id[3])<<4;
		rx_tx_addr[1]=hopping_frequency[1] ^ cyrfmfg_id[1] ^ cyrfmfg_id[4];
		rx_tx_addr[0]=hopping_frequency[2] ^ cyrfmfg_id[2] ^ cyrfmfg_id[5];
		if(sub_protocol == WK2401)
			rx_tx_addr[0] |= 0x01;			//ID must be odd for 2401

		bind_counter = WK_BIND_COUNT;
		phase = WK_BIND;
		BIND_IN_PROGRESS;
	}
	else
	{
		rx_tx_addr[2]=rx_tx_addr[3]<<4;		// Make use of RX_num
		bind_counter = 0;
		phase = WK_BOUND_1;
		BIND_DONE;
	}
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WL91X_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

#if defined(WL91X_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_WL91X_ORIGINAL_ID

#define WL91X_PAYLOAD_SIZE		9
#define WL91X_RF_NUM_CHANNELS	3
#define WL91X_PACKET_PERIOD		2594

static void __attribute__((unused)) WL91X_send_packet()
{
	uint8_t val;

	//RF freq
	XN297_Hopping(hopping_frequency_no++);
	hopping_frequency_no %= WL91X_RF_NUM_CHANNELS;

	//Sticks
	val = convert_channel_16b_limit(CH2,0x21,0xE0);			//THR forward 00..5F, backward 80..DF
	if(val < 128) val = 127 - val;
	packet[0] = val - 0x80;
	val = convert_channel_s8b(CH1);							//ST right 00..7F, left 80..FF
	packet[1] = val - 0x80;
	//Trims
	val = convert_channel_s8b(CH3);							//ST_Trim centered=80, increment/decrement=4, right 04..7C, left 84..FC
	packet[2] = val - 0x80;
	packet[3] = convert_channel_16b_limit(CH4,0x00,0x70);	//TH_Trim increment/decrement=3, 00..39..6F
	//TX_ID
	memcpy(&packet[4], rx_tx_addr, 4);
	//Checksum
	val = 0;
	for(uint8_t i=0; i<WL91X_PAYLOAD_SIZE-1; i++)
		val += packet[i];
	packet[8] = val;

	//Send
	XN297_SetPower();
	XN297_SetFreqOffset();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, WL91X_PAYLOAD_SIZE);
	#ifdef DEBUG_SERIAL
		for(uint8_t i=0; i < WL91X_PAYLOAD_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) WL91X_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_UNSCRAMBLED, XN297_250K);
	XN297_HoppingCalib(WL91X_RF_NUM_CHANNELS);
	XN297_SetTXAddr((uint8_t*)"\x46\x14\x7B\x08", 4);
}

static void __attribute__((unused)) WL91X_initialize_txid()
{
	#ifdef FORCE_WL91X_ORIGINAL_ID
		memcpy(rx_tx_addr, (uint8_t*)"\x00\x1E\x33\x02",4);
	#endif
	memcpy(hopping_frequency, (uint8_t*)"\x1A\x3B\x3B",3);	//26,59,59
}

uint16_t WL91X_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(WL91X_PACKET_PERIOD);
	#endif
	WL91X_send_packet();
	return WL91X_PACKET_PERIOD;
}

void WL91X_init()
{
	BIND_DONE;	//No bind for this protocol
	WL91X_initialize_txid();
	WL91X_RF_init();
	hopping_frequency_no = 0;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/WPL_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with WPL "Basic" TX models D12, D12KM, D22, D32, D42, D14

#if defined(WPL_NRF24L01_INO)

#include "iface_xn297.h"

#define FORCE_WPL_ORIGINAL_ID

#define WPL_PACKET_PERIOD   9875
#define WPL_RF_NUM_CHANNELS 4
#define WPL_PAYLOAD_SIZE    16
#define WPL_BIND_COUNT		303	//3sec

static void __attribute__((unused)) WPL_send_packet()
{
	#if 0
		debug("no:%d, rf:%d, ",hopping_frequency_no + (IS_BIND_IN_PROGRESS?0:4),hopping_frequency[hopping_frequency_no + (IS_BIND_IN_PROGRESS?0:4)]);
	#endif
	XN297_Hopping(hopping_frequency_no + (IS_BIND_IN_PROGRESS?0:4) );
	hopping_frequency_no++;
	hopping_frequency_no &= WPL_RF_NUM_CHANNELS-1;	// 4 RF channels

	memset(&packet[8],0,7);
	packet[0] = 0x94;											//??
	packet[1] = 0x16;											//??
	packet[2] = 0xCC;											//??
	
	if(IS_BIND_IN_PROGRESS)
	{
		memcpy(&packet[3],rx_tx_addr,5);
		packet[9] = 0x08;										// ?? Not bound + Headlights on
	}
	else
	{
		packet[3 ] = convert_channel_s8b(CH1);					// Throttle
		packet[4 ] = convert_channel_s8b(CH2);					// Steering
		packet[5 ] = convert_channel_16b_limit(CH3,0x22,0x5E);	// Steering trim
		packet[6 ] = rx_tx_addr[3];								// 0x32??
		packet[7 ] = convert_channel_s8b(CH4);					// Aux
		packet[9 ] = 0x80										// ?? Bound
				   | GET_FLAG(CH5_SW, 0x08)						// Headlights 100%=on
				   | GET_FLAG(CH6_SW, 0x04)						// Throttle rate 100%=high
				   | GET_FLAG(CH7_SW, 0x02);					// Steering rate 100%=high
	}
	uint8_t sum = 0x66;
	for(uint8_t i=0;i<WPL_PAYLOAD_SIZE-1;i++)
		sum += packet[i];
	packet[WPL_PAYLOAD_SIZE-1] = sum;
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, WPL_PAYLOAD_SIZE);
	#if 0
		for(uint8_t i=0; i<WPL_PAYLOAD_SIZE; i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
}

static void __attribute__((unused)) WPL_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"\x69\xA5\x37\x4D\x8B", 5);
	XN297_HoppingCalib(WPL_RF_NUM_CHANNELS*2);	// Calibrate bind and normal channels
}

static void __attribute__((unused)) WPL_initialize_txid()
{
	//Bind frequencies
	memcpy(hopping_frequency  ,"\x17\x25\x46\x36", WPL_RF_NUM_CHANNELS);	//23=17, 37=25, 70=46, 54=36
	#ifdef FORCE_WPL_ORIGINAL_ID
		//Original ID
		memcpy(rx_tx_addr,"\x96\x2A\xA9\x32\xB4",5);
		//Normal frequencies
		memcpy(hopping_frequency+4,"\x0C\x2A\x3D\x1D", WPL_RF_NUM_CHANNELS);	//12=0C, 42=2A, 61=3D, 29=1D
	#endif
}

uint16_t WPL_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(WPL_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);
		}
	WPL_send_packet();
	return WPL_PACKET_PERIOD;
}

void WPL_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	WPL_initialize_txid();
	WPL_RF_init();
	hopping_frequency_no = 0;
	bind_counter=WPL_BIND_COUNT;
}

#endif
/* https://github.com/pascallanger/DIY-Multiprotocol-TX-Module/issues/1120
Bind packet
-----------
XN297 1Mb Scrambled
Bind address: 69 A5 37 4D 8B
RF channels: 23, 37, 70, 54
Timing: 9875s
Payload 16 bytes: 94 16 CC 96 2A A9 32 B4 00 08 00 00 00 00 00 33

P[0] = 94 ??
P[1] = 16 ??
P[2] = CC ??
P[3..7] = Normal address
P[8] = 00 ??
P[9] = 08 ?? not bound?, Throttle and Steering rate low, Headlights on
P[10..14] = 00 ??
P[15] = sum(P[0..14])+66 why 66...

Normal packet
-----------
XN297 1Mb Scrambled
Normal address: 96 2A A9 32 B4
RF channels: 12=0C, 42=2A, 61=3D, 29=1D -> no idea where they come from...
Timing: 9875s
Payload 16 bytes: 94 16 CC 80 80 38 32 80 00 88 00 00 00 00 00 4E
P[0] = 94 ??
P[1] = 16 ??
P[2] = CC ??
P[3] = Throttle, not enough data on dumps... Same coding as Steering?
P[4] = Steering, not enough data on dumps, looks like one side goes from 7F to 00 and the other 80 to FF which would be s8b
P[5] = Steering trim 22..5E, mid gives 40 not 38... Was the trim centered on the other dumps with value 38?
P[6] = 32 ?? Left over from the bind packet TX_ADDR[3]?
P[7] = 80 ?? Additional channel? It moves at the same time as the trim but my guess is that it is an unconnected channel.
P[8] = 00 ??
P[9] = 80 ?? bound?, Throttle and Steering rate low, Headlights off
      |02 -> Steering rate high
      |04 -> Throttle rate high
      |08 -> Headlights on
P[10..14] = 00 ??
P[15] = sum(P[0..14])+66 why 66...
*/

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XERALL_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// compatible with XERALL

#if defined(XERALL_NRF24L01_INO)

#include "iface_xn297.h"

//#define XERALL_ORIGINAL_ID

#define XERALL_PACKET_PERIOD		2500	//2046
#define XERALL_PACKET_SIZE			10
#define XERALL_NUM_RF_CHANNELS		4
#define XERALL_BIND_COUNT			15000	//about 30sec

// flags going to packet[6]
#define	XERALL_FLAG_VIDEO			0x80
#define	XERALL_FLAG_PHOTO			0x40
// flags going to packet[7]
#define	XERALL_FLAG_RATE			0x80
#define	XERALL_FLAG_FLIGHT_GROUND	0x20
#define	XERALL_FLAG_HEADING_HOLD	0x04
#define	XERALL_FLAG_ONE_BUTTON		0x02

enum {
	XERALL_DATA,
	XERALL_RX,
	XERALL_CHECK,
};

static void __attribute__((unused)) XERALL_send_packet()
{
	if(bind_phase)
		bind_phase--;
	else
	{	// Hopping frequency
		if(packet_sent==0)
		{
			XN297_Hopping(hopping_frequency_no);
			hopping_frequency_no++;
			hopping_frequency_no &= (XERALL_NUM_RF_CHANNELS-1);
		}
		packet_sent++;
		if(IS_BIND_IN_PROGRESS)
		{
			if(packet_sent > 24)
			packet_sent=0;													// Hopp after 25 packets
		}
		else
		{
			if(packet_sent > 18)
				packet_sent = 0;											// Hopp after 19 packets
		}

		// Packet
		if(IS_BIND_IN_PROGRESS && (bind_counter&0x10))						// Alternate bind and normal packets
		{ // Bind packet: 01 56 06 23 00 13 20 40 02 00 and 01 F9 58 31 00 13 20 40 05 00
			if(packet[0] != 0x01)
			{
				XN297_SetTXAddr((uint8_t *)"\x01\x01\x01\x01\x09", 5);		// Bind address
				XN297_SetRXAddr((uint8_t *)"\x01\x01\x01\x01\x09", XERALL_PACKET_SIZE);
			}
			packet[0] = 0x01;
			for(uint8_t i=0;i<5;i++)
				packet[i+1] = rx_tx_addr[i];
			packet[9] = 0;
		}
		else
		{
			if(packet[0] != 0x08)
			{
				XN297_SetTXAddr(rx_tx_addr, 5);
				XN297_SetRXAddr(rx_tx_addr, XERALL_PACKET_SIZE);
			}
			// Normal packet: 08 32 7C 1C 20 20 20 40 0A 00
			packet[0] = 0x08;
			//Throttle
			packet[1] = convert_channel_16b_limit(THROTTLE ,0,0x32)<<1; 	//00..64 but only even values
			//Rudder
			packet[2] = (0xFF-convert_channel_8b(RUDDER))&0xF8;				//F8..00 -> 5 bits
			//Elevator
			uint8_t ch = convert_channel_8b(ELEVATOR)>>3;
			packet[2] |= ch>>2;												//00..07 -> 3 bits high
			packet[3]  = ch<<6;												//00,40,80,C0 -> 2 bits low
			//Aileron
			packet[3] |= ((0xFF-convert_channel_8b(AILERON))>>3)<<1;		//5 bits

			//Trim Rudder 0x00..0x20..0x3F
			packet[4] = convert_channel_8b(CH11)>>2;
			//Trim Elevator 0x00..0x20..0x3F
			packet[5] = convert_channel_8b(CH12)>>2;
		}
	}
	
	// Flags + Trim Aileron
	//packet[6]
	// 0x20 -> 0x60 short press photo/video => |0x40 -> momentary
	// 0x20 -> 0xA0 long press photo/video  => |0x80 -> toggle
	// 0xA0 -> 0xE0 short press photo/video => |0x40 -> momentary
	// 0x20 -> 0x00..0x20..0x3F Trim Aileron
	packet[6] = (convert_channel_8b(CH13)>>2)
			  | GET_FLAG(CH9_SW,XERALL_FLAG_PHOTO)
			  | GET_FLAG(CH10_SW,XERALL_FLAG_VIDEO);

	// Flags
	// 0x40 -> 0x44 Heading hold mode => |0x04 -> toggle
	// 0x40 -> 0xC0 High/low speed => |0x80 -> toggle
	// 0x40 -> 0x42 One button takeoff/landing/emergency => |0x02 -> toggle
	// 0x40 -> 0x60 Flight/Ground => |0x20 -> toggle
	packet[7] = 0x40
			  | GET_FLAG(CH5_SW,XERALL_FLAG_FLIGHT_GROUND)
			  | GET_FLAG(CH6_SW,XERALL_FLAG_ONE_BUTTON)
			  | GET_FLAG(CH7_SW,XERALL_FLAG_RATE)
			  | GET_FLAG(CH8_SW,XERALL_FLAG_HEADING_HOLD);

	// CRC
	uint8_t sum = 0;
	for(uint8_t i=1;i<8;i++)
		sum += packet[i];
	packet[8] = sum & 0x0F;

	//0x00 -> 0x1A on first telemetry packet received
	//packet[9] = 0x00;
	
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TXRX_OFF);
	XN297_SetTxRxMode(TX_EN);
	XN297_WriteEnhancedPayload(packet, XERALL_PACKET_SIZE, 0);
	#if 0
		debug("H:%d,P:",hopping_frequency_no);
		for(uint8_t i=0; i<XERALL_PACKET_SIZE; i++)
			debug("%02X ", packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) XERALL_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
}

static void __attribute__((unused)) XERALL_initialize_txid()
{
	rx_tx_addr[0] = rx_tx_addr[3];
	#ifdef XERALL_ORIGINAL_ID
		// Pascal
		if(RX_num)
		{
			rx_tx_addr[0]=0x56;
			rx_tx_addr[1]=0x06;
			rx_tx_addr[2]=0x23;
			rx_tx_addr[3]=0x00;
			rx_tx_addr[4]=0x13;
		}
		else
		{
			// Alfons
			rx_tx_addr[0]=0xF9;
			rx_tx_addr[1]=0x58;
			rx_tx_addr[2]=0x31;
			rx_tx_addr[3]=0x00;
			rx_tx_addr[4]=0x13;
		}
	#endif
	rx_tx_addr[3] = 0x00;
	rx_tx_addr[4] = 0x13;
	hopping_frequency[0] = 56;	// 0x38
	hopping_frequency[1] = 46;	// 0x2E
	hopping_frequency[2] = 61;	// 0x3D
	hopping_frequency[3] = 51;	// 0x33
}

#define XERALL_WRITE_WAIT 600
#define XERALL_CHECK_WAIT 300
uint16_t XERALL_callback()
{
	static uint8_t wait = 0;
	switch(phase)
	{
		case XERALL_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(XERALL_PACKET_PERIOD);
			#endif
			if (bind_counter == 0)
				BIND_DONE;
			else
				bind_counter--;
			XERALL_send_packet();
			phase++;
			return XERALL_WRITE_WAIT;
		case XERALL_RX:
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase++;
			return XERALL_PACKET_PERIOD-XERALL_WRITE_WAIT-XERALL_CHECK_WAIT;
		case XERALL_CHECK:
			if( XN297_IsRX() )
			{ // RX fifo data ready
				uint8_t len = XN297_ReadEnhancedPayload(packet_in, XERALL_PACKET_SIZE);
				if(len != 255) // CRC OK
				{
					#if 0
						debug("RX(%d):",len);
						for(uint8_t i=0; i<len; i++)
							debug("%02X ", packet_in[i]);
						debugln();
					#endif
					if(len == XERALL_PACKET_SIZE && packet_in[0] == 0x11)
					{ // Request for ack packet
						// Ack the telem packet
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(TX_EN);
						XN297_WriteEnhancedPayload(packet, 0, 0);

						packet[9] = packet_in[9];
						if(packet[0] == 0x01)				// Last packet sent was a bind packet
						{// Build bind response
							packet[0] = 0x02;
							for(uint8_t i=1; i<5; i++)
								packet[i] = packet_in[i];	// Tank ID???
							bind_phase = 14;
							XN297_SetTXAddr(rx_tx_addr, 5);
						}
						wait = 0;
						phase = XERALL_DATA;
						break;
					}
					else if(len == XERALL_PACKET_SIZE && packet_in[0] == 0x12)
					{
						BIND_DONE;
						bind_phase = 0;
						wait = 0;
					}
					else if(len == 0)
						wait = 5;							// The quad wants to talk let's pause sending data...
				}
				if(wait)
				{ // switch to RX mode
					XN297_SetTxRxMode(TXRX_OFF);
					XN297_SetTxRxMode(RX_EN);
				}
			}
			if(wait)
			{
				wait--;
				break;
			}
			phase = XERALL_DATA;
			return XERALL_CHECK_WAIT;
	}
	return XERALL_PACKET_PERIOD;
}

void XERALL_init(void)
{
	XERALL_initialize_txid();

	XERALL_RF_init();

	if(IS_BIND_IN_PROGRESS)
		bind_counter = XERALL_BIND_COUNT;
	hopping_frequency_no=0;
	packet_sent = 0;
	bind_phase = 0;
	memset(packet, 0, XERALL_PACKET_SIZE);
	phase = XERALL_DATA;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK2_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with XK TX X4 and model A160S.

#if defined(XK2_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_XK2_ID
//#define FORCE_XK2_P10_ID

#define XK2_RF_BIND_CHANNEL		71
#define XK2_P10_RF_BIND_CHANNEL	69
#define XK2_PAYLOAD_SIZE		9
#define XK2_PACKET_PERIOD		4911
#define XK2_RF_NUM_CHANNELS		4
#define XK2_WRITE_TIME			1000

enum {
	XK2_BIND1,
	XK2_BIND2,
	XK2_DATA_PREP,
	XK2_DATA,
	XK2_RX,
};

static uint8_t __attribute__((unused)) XK2_checksum(uint8_t init)
{
	for(uint8_t i=0; i<XK2_PAYLOAD_SIZE-1; i++)
		init += packet[i];
	if(sub_protocol == XK2_P10)
		init += 0x10;
	return init;
}

static void __attribute__((unused)) XK2_send_packet()
{
	static uint8_t trim_ch=0;
	
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0x9D;
		//TXID
		memcpy(&packet[1], rx_tx_addr, 3);
		//RXID
		//memcpy(&packet[4], rx_id     , 3);
		//Unknown
		packet[7] = 0x00;
	}
	else
	{
		XN297_Hopping(hopping_frequency_no);
		hopping_frequency_no++;
		hopping_frequency_no &= 0x03;
		//Channels
		packet[0] = convert_channel_16b_limit(AILERON ,0x00,0x64);		//Aileron
		packet[1] = convert_channel_16b_limit(ELEVATOR,0x00,0x64);		//Elevator
		packet[2] = convert_channel_16b_limit(THROTTLE,0x00,0x64);		//Throttle
		packet[3] = convert_channel_16b_limit(RUDDER  ,0x00,0x64);		//Rudder
		//Center the trims
		trim_ch++;
		if(trim_ch > 2) trim_ch = 0;
		packet[4] = 0x20 + 0x40 * trim_ch;								//Trims are A=01..20..3F/E=41..60..7F/R=81..A0..BF, E0 appears when telemetry is received, C1 when p[6] changes from 00->08, C0 when p[6] changes from 08->00
		if(trim_ch == 2)												//Drive rudder trim since otherwise there is no control...
		{
			packet[4] = 0x80 + (convert_channel_8b(RUDDER)>>2);
			if(packet[4] <= 0x81) packet[4] = 0x81;
		}
		//Flags
		packet[5] = GET_FLAG(CH5_SW, 0x01)								//Rate
				  | GET_FLAG(CH7_SW, 0x20)								//Hover
				  | GET_FLAG(CH8_SW, 0x40);								//Light
		if(CH6_SW)
			packet[5] |= 0x10;											//Gyro off (senior mode)
		else if(Channel_data[CH6] > CHANNEL_MIN_COMMAND)
			packet[5] |= 0x08;											//3D
		//Requiest telemetry flag
		packet[6] = 0x01;
		//RXID checksum
		packet[7] = crc8;												//Sum RX_ID[0..2]
	}
	//Checksum
	packet[8] = XK2_checksum(IS_BIND_IN_PROGRESS ? 0xC0 : num_ch);

	// Send
	XN297_SetFreqOffset();
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, XK2_PAYLOAD_SIZE);
	#if 0
		debug("P");
		for(uint8_t i=0; i<XK2_PAYLOAD_SIZE; i++)
			debug(" %02X",packet[i]);
		debugln();
	#endif
}

static void __attribute__((unused)) XK2_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_250K);
	
	XN297_SetTXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", 5);
	XN297_SetRXAddr((uint8_t*)"\xcc\xcc\xcc\xcc\xcc", XK2_PAYLOAD_SIZE);

	XN297_HoppingCalib(XK2_RF_NUM_CHANNELS);
	XN297_RFChannel(sub_protocol==XK2_X4?XK2_RF_BIND_CHANNEL:XK2_P10_RF_BIND_CHANNEL);
}

static void __attribute__((unused)) XK2_initialize_txid()
{
	rx_tx_addr[0] = rx_tx_addr[3];				// Use RX_num

	num_ch = 0x21 + rx_tx_addr[0] - rx_tx_addr[1] + rx_tx_addr[2];

	//RF frequencies for X4: 65=0x41, 69=0x45, 73=0x49, 77=0x4D
	//RF frequencies for P10: 67, unknown
	uint8_t start = 65;
	if(sub_protocol == XK2_P10) start += 2;
	for(uint8_t i=0;i<XK2_RF_NUM_CHANNELS;i++)
		hopping_frequency[i] = start + i*4;

	#ifdef FORCE_XK2_ID
		if(rx_tx_addr[3]&1)
		{//Pascal
			rx_tx_addr[0] = 0x66;
			rx_tx_addr[1] = 0x4F;
			rx_tx_addr[2] = 0x47;
			num_ch = 0x7F;
			//hopping frequencies 65=0x41, 69=0x45, 73=0x49, 77=0x4D
		}
		else
		{//Marc
			rx_tx_addr[0] = 0x36;
			rx_tx_addr[1] = 0x49;
			rx_tx_addr[2] = 0x6B;
			num_ch = 0x79;
			//hopping frequencies 65=0x41, 69=0x45, 73=0x49, 77=0x4D
		}
	#endif
	#ifdef FORCE_XK2_P10_ID
		rx_tx_addr[0] = 0xE8;
		rx_tx_addr[1] = 0x25;
		rx_tx_addr[2] = 0x3B;
		num_ch = 0x1F;
		//hopping frequencies 67=0x43, =0x, =0x, =0x
	#endif

	rx_tx_addr[3] = rx_tx_addr[4] = 0xCC;
	debugln("ID: %02X %02X %02X %02X %02X, OFFSET: %02X, HOP: %02X %02X %02X %02X",rx_tx_addr[0],rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3],rx_tx_addr[4],num_ch,hopping_frequency[0],hopping_frequency[1],hopping_frequency[2],hopping_frequency[3]);
}

uint16_t XK2_callback()
{
	static bool rx = false;

	switch(phase)
	{
		case XK2_BIND1:
			// switch to RX mode
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase++;
			return 5000;
		case XK2_BIND2:
			if(XN297_IsRX())
			{
				XN297_ReadPayload(packet, XK2_PAYLOAD_SIZE);
				#if 0
					debug("RX");
					for(uint8_t i=0; i<XK2_PAYLOAD_SIZE; i++)
						debug(" %02X",packet[i]);
					debugln("");
				#endif
				if(XK2_checksum(0xBF) != packet[8])
				{//Wrong checksum
					phase = XK2_BIND1;
					return 1000;
				}
				if(packet[0] == 0x9B)
					phase++;
				else
				{
					//checksum of RX_ID
					crc8 = packet[4] + packet[5] + packet[6];
					debugln("W:RX_ID=%02X",crc8);
					eeprom_write_byte((EE_ADDR)(XK2_EEPROM_OFFSET+RX_num),crc8);
					XN297_SetTxRxMode(TXRX_OFF);
					XN297_SetTxRxMode(TX_EN);
					bind_counter = 10;					//send 10 bind end packets
					phase = XK2_DATA;
				}
			}
			return 1000;
		case XK2_DATA_PREP:
			crc8 = eeprom_read_byte((EE_ADDR)(XK2_EEPROM_OFFSET+RX_num));
			debugln("R:RX_ID=%02X",crc8);
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(TX_EN);
			XN297_SetTXAddr(rx_tx_addr, 5);
	#ifdef XK2_HUB_TELEMETRY
			XN297_SetRXAddr(rx_tx_addr, XK2_PAYLOAD_SIZE);
	#endif
			BIND_DONE;
			phase++;
		case XK2_DATA:
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(XK2_PACKET_PERIOD);
			#endif
	#ifdef XK2_HUB_TELEMETRY
			rx = XN297_IsRX();
			XN297_SetTxRxMode(TXRX_OFF);
	#endif
			XK2_send_packet();
	#ifdef XK2_HUB_TELEMETRY
			if(rx)
			{
				XN297_ReadPayload(packet, XK2_PAYLOAD_SIZE);
				#if 0
					debug("RX");
					for(uint8_t i=0; i<XK2_PAYLOAD_SIZE; i++)
						debug(" %02X",packet[i]);
					debugln("");
				#endif
				if(XK2_checksum(0xCC) == packet[8] && memcmp(packet, rx_tx_addr, 3) == 0)
				{//Good checksum and TXID
					//packets: E5 20 F2 00 00 00 00 00 C3 -> E5 20 F2 80 00 00 00 00 43
					telemetry_link = 1;
					v_lipo1 = packet[3] ? 137:162;		// low voltage 7.1V
				}
			}
	#endif
			if(bind_counter)
			{
				bind_counter--;
				if(bind_counter == 0)
					phase = XK2_DATA_PREP;
				break;
			}
	#ifndef XK2_HUB_TELEMETRY
			break;
	#else
			phase++;
			return XK2_WRITE_TIME;
		default: //XK2_RX
			/*{ // Wait for packet to be sent before switching to receive mode
				uint16_t start=(uint16_t)micros(), count=0;
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
				{
					if(XN297_IsPacketSent())
						break;
					count++;
				}
				debugln("%d",count);
			}*/
			//Switch to RX
			XN297_SetTxRxMode(TXRX_OFF);
			XN297_SetTxRxMode(RX_EN);
			phase = XK2_DATA;
			return XK2_PACKET_PERIOD-XK2_WRITE_TIME;
	#endif
	}
	return XK2_PACKET_PERIOD;
}

void XK2_init()
{
	//BIND_IN_PROGRESS;	// autobind protocol
	XK2_initialize_txid();
	XK2_RF_init();
	
	if(IS_BIND_IN_PROGRESS)
		phase = XK2_BIND1;
	else
		phase = XK2_DATA_PREP;
	bind_counter = 0;
	hopping_frequency_no = 0;
	#ifdef XK2_HUB_TELEMETRY
		RX_RSSI = 100;		// Dummy value
	#endif
}

#endif

/*
XK A160 Piper CUB

Bind
----
Plane sends these packets:
RX:     0us C=71 S=Y A= CC CC CC CC CC P(9)= 9C BB CC DD 38 12 10 00 19
P[0] = 9C bind phase 1
P[1] = Dummy TX_ID
P[2] = Dummy TX_ID
P[3] = Dummy TX_ID
P[4] = RX_ID[0]
P[5] = RX_ID[1]
P[6] = RX_ID[2]
P[7] = 00
P[8] = sum P[0..7] + BF

TX responds to plane:
RX 9D 66 4F 47 38 12 10 00 B3
P[0] = 9D bind phase 2
P[1] = TX_ID[0]
P[2] = TX_ID[1]
P[3] = TX_ID[2]
P[4] = RX_ID[0]
P[5] = RX_ID[1]
P[6] = RX_ID[2]
P[7] = 00
P[8] = sum P[0..7] + C0

Planes ack:
RX:  4299us C=71 S=Y A= CC CC CC CC CC P(9)= 9B 66 4F 47 38 12 10 00 B0
RX: 26222us C=71 S=Y A= CC CC CC CC CC P(9)= 9B 66 4F 47 38 12 10 00 B0
RX:  8743us C=71 S=Y A= CC CC CC CC CC P(9)= 9B 66 4F 47 38 12 10 00 B0
P[0] = 9B bind phase 3
P[1] = TX_ID[0]
P[2] = TX_ID[1]
P[3] = TX_ID[2]
P[4] = RX_ID[0]
P[5] = RX_ID[1]
P[6] = RX_ID[2]
P[7] = 00
P[8] = sum P[0..7] + BF

Normal
------
TX sends
C=65,69,73,77 -> only one channel when telemetry is working
250K C=69 S=Y A= 66 4F 47 CC CC P(9)= 32 32 00 32 E0 00 01 5A 50
P[0] = A 00..32..64
P[1] = E 00..32..64
P[2] = T 00..64
P[3] = R 00..32..64
P[4] = alternates 20,60,A0,E0
       trims
		A 01..20..3F
		E 41..60..7F
		R 81..A0..BF
	   telemetry
	    E0 present when the telemetry works
	   6g/3d
		C1 few times if P[6] flag 00->08
		C0 few times if P[6] = flag 08->00
P[5] = flags
        01=high rate
		20=hover=long_press_left
		40=light -> temporary
		08=6g/3d=short_press_right sequece also switches for a few packets to C1 if 8 C0 if 0
P[6] = 00 telemetry nok
       01 telemetry ok but sometimes switch to 1 also when telemetry is nok...
P[7] = 5A -> sum RX_ID[0..2] 
P[8] = sum P[0..7] + TX_ID[0] - TX_ID[1] + TX_ID[2] + 21

Telemetry
RX on channel: 69, Time:  3408us P: 66 4F 47 00 00 00 00 00 C8
P[0] = TX_ID[0]
P[1] = TX_ID[1]
P[2] = TX_ID[2]
P[8] = sum P[0..7] + CC

Timing when plane is not detected:
RF
2469 110713 0
2473 114560 3847
2477 120291 5731
2465 135684 15393
2469 142138 6454
2473 145984 3846
2477 151753 5769
2465 155330 3577

*/
/* P10 Piper CUB
Bind
----
Phase 1
Plane sends these packets:
250K C=69 S=Y A= CC CC CC CC CC P(9)= 9C BB CC DD 84 24 20 00 97
P[0] = 9C bind phase 1
P[1] = Dummy TX_ID
P[2] = Dummy TX_ID
P[3] = Dummy TX_ID
P[4] = RX_ID[0]
P[5] = RX_ID[1]
P[6] = RX_ID[2]
P[7] = 00
P[8] = sum P[0..7] + BF + 10

Normal
------
TX sends
C=67 -> only one channel when telemetry is working
A= E8 25 3B CC CC P(9)= 32 32 00 32 A0 40 01 C8 6E
P[0] = A 00..32..64
P[1] = E 00..32..64
P[2] = T 00..64
P[3] = R 00..32..64
P[4] = alternates 20,60,A0,E0
       trims
		A 01..20..3F
		E 41..60..7F
		R 81..A0..BF
	   telemetry
	    E0 present when the telemetry works
	   6g/3d
		C1 few times if P[6] flag 00->08
		C0 few times if P[6] = flag 08->00
P[5] = flags
        01=high rate
		20=hover=long_press_left
		40=light -> temporary
		08=6g/3d=short_press_right sequece also switches for a few packets to C1 if 8 C0 if 0
P[6] = 00 telemetry nok
       01 telemetry ok but sometimes switch to 1 also when telemetry is nok...
P[7] = C8 -> sum RX_ID[0..2] 
P[8] = sum P[0..7] + TX_ID[0] - TX_ID[1] + TX_ID[2] + 21 +10
*/
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XK_ccnrf.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with X450 and X420/X520 plane.

#if defined(XK_CCNRF_INO)

#include "iface_xn297.h"

//#define FORCE_XK_ORIGINAL_ID

#define XK_INITIAL_WAIT		500
#define XK_PACKET_PERIOD	4000
#define XK_RF_BIND_NUM_CHANNELS 8
#define XK_RF_NUM_CHANNELS	4
#define XK_PAYLOAD_SIZE		16
#define XK_BIND_COUNT		750					//3sec

static uint16_t __attribute__((unused)) XK_convert_channel(uint8_t num)
{
	uint16_t val;
	
	if(sub_protocol != XK_CARS)
	{
		// Introduce deadband on all channels to prevent twitching
		//debug("val:%d",val);
		val=convert_channel_8b_limit_deadband(num,0x00,0x80, 0xFF, 40)<<2;
		//debugln(",%d",val);
	}
	else
		val=convert_channel_16b_limit(num,0x00,0x3FF);
	
	// 1FF..01=left, 00=center, 200..3FF=right
	if(val==0x200)
		val=0;									// 0
	else
		if(val>0x200)
			val--;								// 200..3FE
		else
		{
			val=0x200-val;						// 200..01
			if(val==0x200)
				val--;							// 1FF..01
		}
	return val;
}

static void __attribute__((unused)) XK_send_packet()
{
	// RF channel
	XN297_Hopping((IS_BIND_IN_PROGRESS?0:XK_RF_BIND_NUM_CHANNELS)+(hopping_frequency_no>>1));
	hopping_frequency_no++;
	if(hopping_frequency_no >= (IS_BIND_IN_PROGRESS?XK_RF_BIND_NUM_CHANNELS*2:XK_RF_NUM_CHANNELS*2))
		hopping_frequency_no=0;
	
	// Build packet
	memset(packet,0x00,7);
	memset(&packet[10],0x00,5);

	packet[12]=0x40;
	packet[13]=0x40;
	if(IS_BIND_IN_PROGRESS)
		packet[14] = 0xC0;
	else
	{
		uint16_t val=convert_channel_10b(THROTTLE, false);
		packet[0] = val>>2;						// 0..255
		packet[12] |= val & 2;
		val=XK_convert_channel(RUDDER);
		packet[1] = val>>2;
		packet[12] |= (val & 2)<<2;
		val=XK_convert_channel(ELEVATOR);
		packet[2] = val>>2;
		packet[13] |= val & 2;
		val=XK_convert_channel(AILERON);
		packet[3] = val>>2;
		packet[13] |= (val & 2)<<2;
		
		memset(&packet[4],0x40,3);				// Trims
		
		if(Channel_data[CH5] > CHANNEL_MAX_COMMAND)
			packet[10] = 0x10; 					// V-Mode
		else
			if(Channel_data[CH5] > CHANNEL_MIN_COMMAND)
				packet[10] = 0x04; 				// 6G-Mode
		//0x00 default M-Mode
		
		packet[10] |= GET_FLAG(CH7_SW ,0x80);	// Emergency stop momentary switch

		packet[11]  = GET_FLAG(CH8_SW ,0x03)	// 3D/6G momentary switch
					 |GET_FLAG(CH6_SW ,0x40);	// Take off momentary switch
		packet[14]  = GET_FLAG(CH9_SW ,0x01)	// Photo momentary switch
					 |GET_FLAG(CH10_SW,0x02)	// Video momentary switch
					 |GET_FLAG(CH11_SW,0x04)	// Flip
					 |GET_FLAG(CH12_SW,0x10);	// Light
		//debugln("P1:%02X,P12:%02X",packet[1],packet[12]);
	}

	crc=packet[0];
	for(uint8_t i=1; i<XK_PAYLOAD_SIZE-1;i++)
		crc+=packet[i];
	packet[15]=crc;

//	debug("C: %02X, P:",hopping_frequency[rf_ch_num]);
//	for(uint8_t i=0; i<XK_PAYLOAD_SIZE; i++)
//		debug(" %02X",packet[i]);
//	debugln("");
	
	// Send
	XN297_SetPower();			// Set tx_power
	XN297_SetTxRxMode(TX_EN);
	XN297_SetFreqOffset();		// Set frequency offset
	XN297_WritePayload(packet, XK_PAYLOAD_SIZE);
}

const uint8_t PROGMEM XK_bind_hop[XK_RF_BIND_NUM_CHANNELS]= { 0x07, 0x24, 0x3E, 0x2B, 0x47, 0x0E, 0x39, 0x1C };	// Bind

const uint8_t PROGMEM XK_tx_addr[]= { 0xB3, 0x67, 0xE9, 0x98, 0x3A, 0xEC, 0xA6, 0x59, 0xB2, 0x94, 0x2B, 0xA5, 0x37, 0xC5, 0x4A, 0xD3,
									  0x49, 0xA6, 0x83, 0xEB, 0x4B, 0xC9, 0x59, 0xD2, 0x65, 0x34, 0x6A, 0xD3, 0x2C, 0x96, 0x2A, 0xA9,
									  0x32, 0xB2, 0xB4, 0x49, 0xD3, 0x37, 0xE9 };

const uint8_t PROGMEM XK_hop[]= { 0x47, 0x3A, 0x4C, 0x39, 0x4D, 0x34, 0x4A, 0x3F, 0x45, 0x3E, 0x4B, 0x3D, 0x3B, 0x48, 0x40, 0x49,
								  0x46, 0x3C, 0x43, 0x38, 0x35, 0x42, 0x33, 0x44, 0x4E, 0x37, 0x44, 0x35, 0x37, 0x4E, 0x36, 0x41 };

static void __attribute__((unused)) XK_initialize_txid()
{
	//bind hop
	for(uint8_t i=0; i<XK_RF_BIND_NUM_CHANNELS; i++)
		hopping_frequency[i]=pgm_read_byte_near( &XK_bind_hop[i] );

	//GID
	packet[7]=rx_tx_addr[1];
	packet[8]=rx_tx_addr[2];
	packet[9]=rx_tx_addr[3];
	uint8_t sum=packet[7]+packet[8]+packet[9];
//	debugln("GID=%02X %02X %02X, sum=%d", packet[7],packet[8],packet[9],sum);
	
	//Normal hop
	uint8_t start=(sum&0x07)<<2;
//	debug("start=%d, hop=",start);
	for(uint8_t i=0; i<XK_RF_NUM_CHANNELS; i++)
	{
		hopping_frequency[ i + XK_RF_BIND_NUM_CHANNELS ]=pgm_read_byte_near( &XK_hop[ start + i ] );
//		debug("%02X ", hopping_frequency[ i + XK_RF_BIND_NUM_CHANNELS ]);
	}
//	debugln("");
	//Normal packet address
	start=(sum&0x1F)+((sum>>5)&0x03);
//	debug("start=%d, addr=",start);
	for(uint8_t i=0; i<5; i++)
	{
		rx_tx_addr[i]=pgm_read_byte_near( &XK_tx_addr[ start + i ] );
//		debug("%02X ", rx_tx_addr[ i ]);
	}
//	debugln("");

	#ifdef FORCE_XK_ORIGINAL_ID
		switch(RX_num%2)
		{
			default:
				//TX1 X8 X450
				//GID
				packet[7]=0x04;
				packet[8]=0x15;
				packet[9]=0x22;
				//Normal hop
				memcpy(&hopping_frequency[XK_RF_BIND_NUM_CHANNELS],(uint8_t*)"\x3B\x48\x40\x49", XK_RF_NUM_CHANNELS);	// freq and order verified
				//Normal packet address
				memcpy(rx_tx_addr,(uint8_t*)"\x2C\x96\x2A\xA9\x32",5);
				break;
			case 1:
				//TX2 X4 X420
				//GID
				packet[7]=0x13;
				packet[8]=0x24;
				packet[9]=0x18;
				//Normal hop
				memcpy(&hopping_frequency[XK_RF_BIND_NUM_CHANNELS],(uint8_t*)"\x36\x41\x37\x4E", XK_RF_NUM_CHANNELS);	// freq ok and order from xn297dump auto
				//Normal packet address
				memcpy(rx_tx_addr,(uint8_t*)"\xA6\x83\xEB\x4B\xC9",5);
				break;
		}
	#endif
}

static void __attribute__((unused)) XK_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, sub_protocol==X450 ? XN297_250K : XN297_1M );
	XN297_SetTXAddr((uint8_t*)"\x68\x94\xA6\xD5\xC3", 5);						// Bind address
	XN297_HoppingCalib(XK_RF_BIND_NUM_CHANNELS+XK_RF_NUM_CHANNELS);				// Calibrate all channels
}

uint16_t XK_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(XK_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 5);										// Normal packets address
		}
	XK_send_packet();
	return XK_PACKET_PERIOD;
}

void XK_init()
{
	if(sub_protocol != XK_CARS)
		BIND_IN_PROGRESS;															// Autobind protocol
	XK_initialize_txid();
	XK_RF_init();
	hopping_frequency_no = 0;
	bind_counter=XK_BIND_COUNT;
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XN297Dump_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */

// sub_protocol: 0=250Kbps, 1=1Mbps, 2=2Mbps. Other values default to 1Mbps.
// RX_num = address length 3 or 4 or 5. Other values default to 5.
// option = RF channel number 0..84 and -1 = scan all channels. Other values default to RF channel 0.

#ifdef XN297DUMP_NRF24L01_INO

#include "iface_xn297.h"

// Parameters which can be modified
#define XN297DUMP_PERIOD_SCAN		50000 	// 25000
#define XN297DUMP_MAX_RF_CHANNEL	84		// Default 84

// Do not touch from there
#define XN297DUMP_INITIAL_WAIT		500
#define XN297DUMP_MAX_PACKET_LEN	32
#define XN297DUMP_CRC_LENGTH		2

uint8_t address_length;
uint16_t timeH=0;
boolean scramble;
boolean enhanced;
boolean ack;
uint8_t pid;
uint8_t bitrate;
uint8_t old_option;

static void __attribute__((unused)) XN297Dump_RF_init()
{
	NRF24L01_Initialize();
	NRF24L01_SetTxRxMode(RX_EN);

	NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, 0x01);			// 3 bytes RX/TX address
	NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, (uint8_t*)"\x55\x0F\x71", 3);	// set up RX address to xn297 preamble
	NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, XN297DUMP_MAX_PACKET_LEN);	// Enable rx pipe 0

	debug("XN297 dump, address length=%d, bitrate=",address_length);
	switch(bitrate)
	{
		case XN297DUMP_250K:
			NRF24L01_SetBitrate(NRF24L01_BR_250K);
			debugln("250K");
			break;
		case XN297DUMP_2M:
			NRF24L01_SetBitrate(NRF24L01_BR_2M);
			debugln("2M");
			break;
		default:
			NRF24L01_SetBitrate(NRF24L01_BR_1M);
			debugln("1M");
			break;

	}
}

extern const uint8_t xn297_scramble[];
extern const uint16_t PROGMEM xn297_crc_xorout_scrambled[];
extern const uint16_t PROGMEM xn297_crc_xorout[];
extern const uint16_t PROGMEM xn297_crc_xorout_scrambled_enhanced[];
extern const uint16_t xn297_crc_xorout_enhanced[];

static boolean __attribute__((unused)) XN297Dump_process_packet(void)
{
	uint16_t crcxored;
	uint8_t packet_sc[XN297DUMP_MAX_PACKET_LEN], packet_un[XN297DUMP_MAX_PACKET_LEN];
	enhanced=false;
	// init crc
	crc = 0xb5d2;
	
	/*debug("P: 71 0F 55 ");
	for(uint8_t i=0; i<XN297DUMP_MAX_PACKET_LEN; i++)
		debug("%02X ",packet[i]);
	debugln("");*/
	//Try normal payload
	// address
	for (uint8_t i = 0; i < address_length; i++)
	{
		crc16_update( packet[i], 8);
		packet_un[address_length-1-i]=packet[i];
		packet_sc[address_length-1-i]=packet[i] ^ xn297_scramble[i];
	}
	
	// payload
	for (uint8_t i = address_length; i < XN297DUMP_MAX_PACKET_LEN-XN297DUMP_CRC_LENGTH; i++)
	{
		crc16_update( packet[i], 8);
		packet_sc[i] = bit_reverse(packet[i]^xn297_scramble[i]);
		packet_un[i] = bit_reverse(packet[i]);
		// check crc
		crcxored = crc ^ pgm_read_word(&xn297_crc_xorout[i+1 - 3]);
		if( (crcxored >> 8) == packet[i + 1] && (crcxored & 0xff) == packet[i + 2])
		{
			packet_length=i+1;
			memcpy(packet,packet_un,packet_length);
			scramble=false;
			return true;
		}
		crcxored = crc ^ pgm_read_word(&xn297_crc_xorout_scrambled[i+1 - 3]);
		if( (crcxored >> 8) == packet[i + 1] && (crcxored & 0xff) == packet[i + 2])
		{
			packet_length=i+1;
			memcpy(packet,packet_sc,packet_length);
			scramble=true;
			return true;
		}
	}

	//Try enhanced payload
	uint16_t crc_save = 0xb5d2;
	packet_length=0;
	for (uint8_t i = 0; i < XN297DUMP_MAX_PACKET_LEN-XN297DUMP_CRC_LENGTH; i++) 
	{
		packet_sc[i]=packet[i]^xn297_scramble[i];
		crc = crc_save;
		crc16_update( packet[i], 8);
		crc_save = crc;
		crc16_update( packet[i+1] & 0xC0, 2);
		crcxored=(packet[i+1]<<10)|(packet[i+2]<<2)|(packet[i+3]>>6) ;
		if(i>=3)
		{
			if((crc ^ pgm_read_word(&xn297_crc_xorout_scrambled_enhanced[i - 3])) == crcxored)
			{ // Found a valid CRC for the enhanced payload mode
				packet_length=i;
				scramble=true;
				i++;
				packet_sc[i]=packet[i]^xn297_scramble[i];
				memcpy(packet_un,packet_sc,packet_length+2); // unscramble packet
				break;
			}
			if((crc ^ pgm_read_word(&xn297_crc_xorout_enhanced[i - 3])) == crcxored)
			{ // Found a valid CRC for the enhanced payload mode
				packet_length=i;
				scramble=false;
				memcpy(packet_un,packet,packet_length+2); 	// packet is unscrambled
				break;
			}
		}
	}
	if(packet_length!=0)
	{ // Found a valid CRC for the enhanced payload mode
		enhanced=true;
		//check selected address length
		if((packet_un[address_length]>>1)!=packet_length-address_length)
		{
			for(uint8_t i=3;i<=5;i++)
				if((packet_un[i]>>1)==packet_length-i)
					address_length=i;
			debugln("Detected wrong address length, using %d intead", address_length );
		}
		pid=((packet_un[address_length]&0x01)<<1)|(packet_un[address_length+1]>>7);
		ack=(packet_un[address_length+1]>>6)&0x01;
		// address
		for (uint8_t i = 0; i < address_length; i++)
			packet[address_length-1-i]=packet_un[i];
		// payload
		for (uint8_t i = address_length; i < packet_length; i++)
			packet[i] = bit_reverse((packet_un[i+1]<<2)|(packet_un[i+2]>>6));
		return true;
	}

	return false;
}

static void __attribute__((unused)) XN297Dump_overflow()
{
	if(TIMER2_BASE->SR & TIMER_SR_UIF)
	{ // timer overflow
		timeH++;
		TIMER2_BASE->SR = 0x1E5F & ~TIMER_SR_UIF;	// Clear Timer2 overflow flag
	}
}
static uint16_t XN297Dump_callback()
{
	static uint32_t time=0,*time_rf;
	static uint8_t *nbr_rf,compare_channel;

	//!!!Blocking mode protocol!!!
	TX_MAIN_PAUSE_off;
	tx_resume();
	while(1)
	{
		if(sub_protocol<XN297DUMP_AUTO)
		{
			if(option==0xFF && bind_counter>XN297DUMP_PERIOD_SCAN)
			{	// Scan frequencies
				hopping_frequency_no++;
				bind_counter=0;
			}
			if(hopping_frequency_no!=rf_ch_num)
			{	// Channel has changed
				if(hopping_frequency_no>XN297DUMP_MAX_RF_CHANNEL)
					hopping_frequency_no=0;	// Invalid channel 0 by default
				rf_ch_num=hopping_frequency_no;
				debugln("Channel=%d,0x%02X",hopping_frequency_no,hopping_frequency_no);
				NRF24L01_WriteReg(NRF24L01_05_RF_CH,hopping_frequency_no);
				// switch to RX mode
				NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_SetTxRxMode(RX_EN);
				NRF24L01_FlushRx();
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)   // switch to RX mode and disable CRC
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
				phase=0;				// init timer
			}
			XN297Dump_overflow();
			
			if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
			{ // RX fifo data ready
				if(NRF24L01_ReadReg(NRF24L01_09_CD) || option != 0xFF)
				{
					NRF24L01_ReadPayload(packet,XN297DUMP_MAX_PACKET_LEN);
					XN297Dump_overflow();
					uint16_t timeL=TCNT1;
					if(TIMER2_BASE->SR & TIMER_SR_UIF)
					{//timer just rolled over...
						XN297Dump_overflow();
						timeL=0;
					}
					if((phase&0x01)==0)
					{
						phase=1;
						time=0;
					}
					else
						time=(timeH<<16)+timeL-time;
					if(XN297Dump_process_packet())
					{ // valid crc found
						debug("RX: %5luus C=%d ", time>>1 , hopping_frequency_no);
						time=(timeH<<16)+timeL;
						if(enhanced)
						{
							debug("Enhanced ");
							debug("pid=%d ",pid);
							if(ack) debug("ack ");
						}
						debug("S=%c A=",scramble?'Y':'N');
						for(uint8_t i=0; i<address_length; i++)
						{
							debug(" %02X",packet[i]);
						}
						debug(" P(%d)=",packet_length-address_length);
						for(uint8_t i=address_length; i<packet_length; i++)
						{
							debug(" %02X",packet[i]);
						}
						debugln("");
					}
					else
					{
						debugln("RX: %5luus C=%d Bad CRC", time>>1 , hopping_frequency_no);
					}
				}
				
				XN297Dump_overflow();
				// restart RX mode
				NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_SetTxRxMode(RX_EN);
				NRF24L01_FlushRx();
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)   // switch to RX mode and disable CRC
												| (1 << NRF24L01_00_CRCO)
												| (1 << NRF24L01_00_PWR_UP)
												| (1 << NRF24L01_00_PRIM_RX));
				XN297Dump_overflow();
			}
		}
		else if(sub_protocol==XN297DUMP_AUTO)
		{
			switch(phase)
			{
				case 0:
					debugln("------------------------");
					debugln("Detecting XN297 packets.");
					XN297Dump_RF_init();
					debug("Trying RF channel: 0");
					hopping_frequency_no=0;
					bitrate=0;
					phase++;
					break;
				case 1:
					if(bind_counter>XN297DUMP_PERIOD_SCAN)
					{	// Scan frequencies
						hopping_frequency_no++;
						bind_counter=0;
						if(hopping_frequency_no>XN297DUMP_MAX_RF_CHANNEL)
						{
							hopping_frequency_no=0;
							bitrate++;
							bitrate%=3;
							debugln("");
							XN297Dump_RF_init();
							debug("Trying RF channel: 0");
						}
						if(hopping_frequency_no)
							debug(",%d",hopping_frequency_no);
						NRF24L01_WriteReg(NRF24L01_05_RF_CH,hopping_frequency_no);
						// switch to RX mode
						NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
						NRF24L01_SetTxRxMode(TXRX_OFF);
						NRF24L01_SetTxRxMode(RX_EN);
						NRF24L01_FlushRx();
						NRF24L01_WriteReg(NRF24L01_00_CONFIG, (0 << NRF24L01_00_EN_CRC)   // switch to RX mode and disable CRC
														| (1 << NRF24L01_00_CRCO)
														| (1 << NRF24L01_00_PWR_UP)
														| (1 << NRF24L01_00_PRIM_RX));
					}
					if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
					{ // RX fifo data ready
						if(NRF24L01_ReadReg(NRF24L01_09_CD))
						{
							NRF24L01_ReadPayload(packet,XN297DUMP_MAX_PACKET_LEN);
							if(XN297Dump_process_packet())
							{ // valid crc found
								debug("\r\n\r\nPacket detected: bitrate=");
								switch(bitrate)
								{
									case XN297DUMP_250K:
										XN297_Configure(XN297_CRCEN, scramble?XN297_SCRAMBLED:XN297_UNSCRAMBLED, XN297_250K, true);
										debug("250K");
										break;
									case XN297DUMP_2M:
										XN297_Configure(XN297_CRCEN, scramble?XN297_SCRAMBLED:XN297_UNSCRAMBLED, XN297_1M);
										NRF24L01_SetBitrate(NRF24L01_BR_2M);
										debug("2M");
										break;
									default:
										XN297_Configure(XN297_CRCEN, scramble?XN297_SCRAMBLED:XN297_UNSCRAMBLED, XN297_1M);
										debug("1M");
										break;

								}
								debug(" C=%d ", hopping_frequency_no);
								if(enhanced)
								{
									debug("Enhanced ");
									debug("pid=%d ",pid);
									if(ack) debug("ack ");
								}
								debug("S=%c A=",scramble?'Y':'N');
								for(uint8_t i=0; i<address_length; i++)
								{
									debug(" %02X",packet[i]);
									rx_tx_addr[i]=packet[i];
								}
								debug(" P(%d)=",packet_length-address_length);
								for(uint8_t i=address_length; i<packet_length; i++)
								{
									debug(" %02X",packet[i]);
								}
								packet_length=packet_length-address_length;
								debugln("\r\n--------------------------------");
								phase=2;
								debugln("Identifying all RF channels in use.");
								bind_counter=0;
								hopping_frequency_no=0;
								rf_ch_num=0;
								packet_count=0;
								nbr_rf=(uint8_t*)malloc(XN297DUMP_MAX_RF_CHANNEL*sizeof(uint8_t));
								if(nbr_rf==NULL)
								{
									debugln("\r\nCan't allocate memory for next phase!!!");
									phase=0;
									break;
								}
								debug("Trying RF channel: 0");
								XN297_SetTXAddr(rx_tx_addr,address_length);
								XN297_SetRXAddr(rx_tx_addr,packet_length);
								XN297_RFChannel(0);
								XN297_SetTxRxMode(TXRX_OFF);
								XN297_SetTxRxMode(RX_EN);
							}
						}
					}
					break;
				case 2:
					if(bind_counter>XN297DUMP_PERIOD_SCAN)
					{	// Scan frequencies
						hopping_frequency_no++;
						bind_counter=0;
						if(packet_count && packet_count<=20)
							debug("\r\nTrying RF channel: ");
						packet_count=0;
						if(hopping_frequency_no>XN297DUMP_MAX_RF_CHANNEL)
						{
							uint8_t nbr_max=0,j=0;
							debug("\r\n\r\n%d RF channels identified:",rf_ch_num);
							compare_channel=0;
							for(uint8_t i=0;i<rf_ch_num;i++)
							{
								debug(" %d[%d]",hopping_frequency[i],nbr_rf[i]);
								if(nbr_rf[i]>nbr_max)
								{
									nbr_max=nbr_rf[i];
									compare_channel=i;
								}
							}
							nbr_max = (nbr_max*2)/3;
							debug("\r\nKeeping only RF channels with more than %d packets:", nbr_max);
							for(uint8_t i=0;i<rf_ch_num;i++)
								if(nbr_rf[i]>=nbr_max)
								{
									hopping_frequency[j]=hopping_frequency[i];
									debug(" %d",hopping_frequency[j]);
									if(compare_channel==i)
									{
										compare_channel=j;
										debug("*");
									}
									j++;
								}
							rf_ch_num = j;
							free(nbr_rf);
							time_rf=(uint32_t*)malloc(rf_ch_num*sizeof(time));
							if(time_rf==NULL)
							{
								debugln("\r\nCan't allocate memory for next phase!!!");
								phase=0;
								break;
							}
							debugln("\r\n--------------------------------");
							debugln("Identifying RF channels order.");
							hopping_frequency_no=0;
							phase=3;
							packet_count=0;
							bind_counter=0;
							debugln("Time between CH:%d and CH:%d",hopping_frequency[compare_channel],hopping_frequency[hopping_frequency_no]);
							time_rf[hopping_frequency_no]=0xFFFFFFFF;
							XN297_RFChannel(hopping_frequency[compare_channel]);
							uint16_t timeL=TCNT1;
							if(TIMER2_BASE->SR & TIMER_SR_UIF)
							{//timer just rolled over...
								XN297Dump_overflow();
								timeL=0;
							}
							time=(timeH<<16)+timeL;
							XN297_SetTxRxMode(TXRX_OFF);
							XN297_SetTxRxMode(RX_EN);
							XN297Dump_overflow();
							break;
						}
						debug(",%d",hopping_frequency_no);
						XN297_RFChannel(hopping_frequency_no);
						// switch to RX mode
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(RX_EN);
					}
					if( XN297_IsRX() )
					{ // RX fifo data ready
						if(NRF24L01_ReadReg(NRF24L01_09_CD))
						{
							uint8_t res;
							if(enhanced)
							{
								res=XN297_ReadEnhancedPayload(packet, packet_length);
								res++;
							}
							else
								res=XN297_ReadPayload(packet, packet_length);
							if(res)
							{ // valid crc found
								XN297Dump_overflow();
								uint16_t timeL=TCNT1;
								if(TIMER2_BASE->SR & TIMER_SR_UIF)
								{//timer just rolled over...
									XN297Dump_overflow();
									timeL=0;
								}
								if(packet_count==0)
								{//save channel
									hopping_frequency[rf_ch_num]=hopping_frequency_no;
									rf_ch_num++;
									time=0;
								}
								else
									time=(timeH<<16)+timeL-time;
								debug("\r\nRX on channel: %d, Time: %5luus P:",hopping_frequency_no, time>>1);
								time=(timeH<<16)+timeL;
								for(uint8_t i=0;i<packet_length;i++)
									debug(" %02X",packet[i]);
								packet_count++;
								nbr_rf[rf_ch_num-1]=packet_count;
								if(packet_count>20)
								{//change channel
									bind_counter=XN297DUMP_PERIOD_SCAN+1;
									debug("\r\nTrying RF channel: ");
								}
							}
						}
						// restart RX mode
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(RX_EN);
					}
					XN297Dump_overflow();
					break;
				case 3:
					if(bind_counter>XN297DUMP_PERIOD_SCAN)
					{	// Scan frequencies
						hopping_frequency_no++;
						bind_counter=0;
						if(hopping_frequency_no>=rf_ch_num)
						{
							uint8_t next=0;
							debugln("\r\n\r\nChannel order:");
							debugln("%d:     0us",hopping_frequency[compare_channel]);
							uint8_t i=0;
							do
							{
								time=time_rf[i];
								if(time!=0xFFFFFFFF)
								{
									next=i;
									for(uint8_t j=1;j<rf_ch_num;j++)
										if(time>time_rf[j])
										{
											next=j;
											time=time_rf[j];
										}
									time_rf[next]=-1;
									debugln("%d: %5luus",hopping_frequency[next],time);
									i=0;
								}
								i++;
							}
							while(i<rf_ch_num);
							free(time_rf);
							debugln("\r\n--------------------------------");
							debugln("Identifying Sticks and features.");
							phase=4;
							hopping_frequency_no=0;
							break;
						}
						debugln("Time between CH:%d and CH:%d",hopping_frequency[compare_channel],hopping_frequency[hopping_frequency_no]);
						time_rf[hopping_frequency_no]=-1;
						XN297_RFChannel(hopping_frequency[compare_channel]);
						uint16_t timeL=TCNT1;
						if(TIMER2_BASE->SR & TIMER_SR_UIF)
						{//timer just rolled over...
							XN297Dump_overflow();
							timeL=0;
						}
						time=(timeH<<16)+timeL;
						// switch to RX mode
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(RX_EN);
					}
					if( XN297_IsRX() )
					{ // RX fifo data ready
						if(NRF24L01_ReadReg(NRF24L01_09_CD))
						{
							uint8_t res;
							if(enhanced)
							{
								res=XN297_ReadEnhancedPayload(packet, packet_length);
								res++;
							}
							else
								res=XN297_ReadPayload(packet, packet_length);
							if(res)
							{ // valid crc found
								XN297Dump_overflow();
								uint16_t timeL=TCNT1;
								if(TIMER2_BASE->SR & TIMER_SR_UIF)
								{//timer just rolled over...
									XN297Dump_overflow();
									timeL=0;
								}
								if(packet_count&1)
								{
									time=(timeH<<16)+timeL-time;
									if(time_rf[hopping_frequency_no] > (time>>1))
										time_rf[hopping_frequency_no]=time>>1;
									debugln("Time: %5luus", time>>1);
									XN297_RFChannel(hopping_frequency[compare_channel]);
								}
								else
								{
									time=(timeH<<16)+timeL;
									XN297_RFChannel(hopping_frequency[hopping_frequency_no]);
								}
								packet_count++;
								if(packet_count>24)
								{
									bind_counter=XN297DUMP_PERIOD_SCAN+1;
									packet_count=0;
								}
							}
						}
						// restart RX mode
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(RX_EN);
					}
					XN297Dump_overflow();
					break;
				case 4:
					if( XN297_IsRX() )
					{ // RX fifo data ready
						//if(NRF24L01_ReadReg(NRF24L01_09_CD))
						{
							uint8_t res;
							if(enhanced)
							{
								res=XN297_ReadEnhancedPayload(packet, packet_length);
								res++;
							}
							else
								res=XN297_ReadPayload(packet, packet_length);
							if(res)
							{ // valid crc found
								if(memcmp(packet_in,packet,packet_length))
								{
									debug("P:");
									for(uint8_t i=0;i<packet_length;i++)
										debug(" %02X",packet[i]);
									debugln("");
									memcpy(packet_in,packet,packet_length);
								}
							}
						}
						// restart RX mode
						XN297_SetTxRxMode(TXRX_OFF);
						XN297_SetTxRxMode(RX_EN);
					}
					break;
			}
		}
		else if(sub_protocol == XN297DUMP_NRF)
		{
			if(phase==0)
			{
				address_length=5;
				memcpy(rx_tx_addr, (uint8_t *)"\xCC\xCC\xCC\xCC\xCC", address_length);	// bind \x7E\xB8\x63\xA9
				bitrate=XN297DUMP_250K;
				packet_length=9;
				hopping_frequency_no=71; //bind 71, normal ??
				
				NRF24L01_Initialize();
				NRF24L01_SetTxRxMode(TXRX_OFF);
				NRF24L01_SetTxRxMode(RX_EN);
				NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, address_length-2);			// RX/TX address length
				NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, address_length);	// set up RX address
				NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, packet_length);				// Enable rx pipe 0
				NRF24L01_WriteReg(NRF24L01_05_RF_CH, option);	//hopping_frequency_no);
				old_option = option;
				
				debug("NRF dump, len=%d, rf=%d, address length=%d, bitrate=",packet_length,option,address_length);	//hopping_frequency_no,address_length);
				switch(bitrate)
				{
					case XN297DUMP_250K:
						NRF24L01_SetBitrate(NRF24L01_BR_250K);
						debugln("250K");
						break;
					case XN297DUMP_2M:
						NRF24L01_SetBitrate(NRF24L01_BR_2M);
						debugln("2M");
						break;
					default:
						NRF24L01_SetBitrate(NRF24L01_BR_1M);
						debugln("1M");
						break;

				}
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, _BV(NRF24L01_00_PWR_UP) | _BV(NRF24L01_00_PRIM_RX)); //_BV(NRF24L01_00_EN_CRC) | _BV(NRF24L01_00_CRCO) | 
				phase++;
				time=0;
			}
			else
			{
				if( NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR))
				{ // RX fifo data ready
					if(NRF24L01_ReadReg(NRF24L01_09_CD))
					{
						XN297Dump_overflow();
						uint16_t timeL=TCNT1;
						if(TIMER2_BASE->SR & TIMER_SR_UIF)
						{//timer just rolled over...
							XN297Dump_overflow();
							timeL=0;
						}
						time=(timeH<<16)+timeL-time;
						debug("RX: %5luus ", time>>1);
						time=(timeH<<16)+timeL;
						NRF24L01_ReadPayload(packet, packet_length);
						//bool ok=true;
						uint8_t buffer[40];
						memcpy(buffer,packet,packet_length);
						//if(memcmp(&packet_in[0],&packet[0],packet_length))
						{
							debug("C: %02X P:", option);
							for(uint8_t i=0;i<packet_length;i++)
								debug(" %02X",packet[i]);
							debugln("");
							memcpy(packet_in,packet,packet_length);
						}
						/*//realign bits
							for(uint8_t i=0; i<packet_length; i++)
								buffer[i]=buffer[i+2];
							//for(uint8_t i=0; i<packet_length; i++)
							//	buffer[i]=(buffer[i]<<4)+(buffer[i+1]>>4);
							
							//check for validity and decode
							memset(packet_in,0,packet_length);
							for(uint8_t i=0; i<packet_length-2; i++)
							{
								for(uint8_t j=0;j<2;j++)
								{
									packet_in[i>>2] >>= 1;
									if( (buffer[i]&0xC0) == 0xC0 && (buffer[i]&0x30) == 0x00 )
										packet_in[i>>2] |= 0x80;
									else if( (buffer[i]&0xC0) == 0x00 && (buffer[i]&0x30) == 0x30 )
										packet_in[i>>2] |= 0x00;
									else
										ok=false;	// error
									buffer[i] <<= 4;
								}
							}
							if(ok)
							{
								debug("P:(%02X,%02X):",packet[0],packet[1]);
								for(uint8_t i=0;i<packet_length/4;i++)
									debug(" %02X",packet_in[i]);
								debugln("");
								memcpy(packet_in,packet,packet_length);
							}
						}*/
						/*crc=0;
						for (uint8_t i = 1; i < 12; ++i)
							crc16_update( packet[i], 8);
						if(packet[12]==((crc>>8)&0xFF) && packet[13]==(crc&0xFF))
							if(memcmp(&packet_in[1],&packet[1],packet_length-1))
							{
								debug("P:");
								for(uint8_t i=0;i<packet_length;i++)
									debug(" %02X",packet[i]);
								debug(" CRC: %04X",crc);
								debugln("");
								debug("P(%02X):",packet[0]);
								for(uint8_t i=1;i<packet_length-2;i++)
									debug(" %02X",((bit_reverse(packet[i])<<1)|(bit_reverse(packet[i-1])>>7))&0xFF);
								debugln("");
								memcpy(packet_in,packet,packet_length);
							}*/
					}
					// restart RX mode
					NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);			// Clear data ready, data sent, and retransmit
					NRF24L01_SetTxRxMode(TXRX_OFF);
					NRF24L01_SetTxRxMode(RX_EN);
					NRF24L01_FlushRx();
					NRF24L01_WriteReg(NRF24L01_00_CONFIG, _BV(NRF24L01_00_PWR_UP) | _BV(NRF24L01_00_PRIM_RX)); //  _BV(NRF24L01_00_EN_CRC) | _BV(NRF24L01_00_CRCO) |
				}
				XN297Dump_overflow();
				if(old_option != option)
				{
					NRF24L01_WriteReg(NRF24L01_05_RF_CH, option);	//hopping_frequency_no);
					old_option = option;
				}
			}
		}
		else if(sub_protocol == XN297DUMP_CC2500)
		{
		#if defined (CC2500_INSTALLED)
			if(phase==0)
			{
				address_length=5;
				switch(RX_num)
				{
					case 0:
						memcpy(rx_tx_addr, (uint8_t *)"\xAE\xD2\x71\x79\x46", address_length);
						break;
					case 1:
						memcpy(rx_tx_addr, (uint8_t *)"\x5D\xA4\xE2\xF2\x8C", address_length);
						break;
					case 2:
						memcpy(rx_tx_addr, (uint8_t *)"\xBB\x49\xC5\xE5\x18", address_length);
						break;
					case 3:
						memcpy(rx_tx_addr, (uint8_t *)"\x76\x93\x8B\xCA\x30", address_length);
						break;
					case 4:
						memcpy(rx_tx_addr, (uint8_t *)"\xED\x27\x17\x94\x61", address_length);
						break;
					case 5:
						memcpy(rx_tx_addr, (uint8_t *)"\xDA\x4E\x2F\x28\xC2", address_length);
						break;
					case 6:
						memcpy(rx_tx_addr, (uint8_t *)"\xAB\xB4\x9C\x5E\x51", address_length);
						break;
					case 7:
						memcpy(rx_tx_addr, (uint8_t *)"\x57\x69\x38\xBC\xA3", address_length);
						break;
				}
				packet_length=38;
				hopping_frequency_no=54; //bind 30, normal 54
				debugln("CC2500 dump, len=%d, rf=%d, address length=%d, bitrate=250K",packet_length,hopping_frequency_no,address_length);
				
				//Config CC2500
				CC2500_250K_Init();
				CC2500_SetFreqOffset();
				CC2500_WriteReg(CC2500_04_SYNC1, rx_tx_addr[0]);	// Sync word, high byte
				CC2500_WriteReg(CC2500_05_SYNC0, rx_tx_addr[1]);	// Sync word, low byte
				CC2500_WriteReg(CC2500_09_ADDR,  rx_tx_addr[2]);	// Set addr
				CC2500_WriteReg(CC2500_12_MDMCFG2,  0x12);			// Modem Configuration, GFSK, 16/16 Sync Word TX&RX
				CC2500_WriteReg(CC2500_06_PKTLEN, packet_length);	// Packet len

				//2.4001GHz: offfset of 100KHz
				CC2500_WriteReg(CC2500_0D_FREQ2,    0x5C);   // Frequency Control Word, High Byte
				CC2500_WriteReg(CC2500_0E_FREQ1,    0x4F);   // Frequency Control Word, Middle Byte
				CC2500_WriteReg(CC2500_0F_FREQ0,    0xC1);   // Frequency Control Word, Low Byte

				CC2500_250K_RFChannel(hopping_frequency_no);

				CC2500_SetTxRxMode(RX_EN);
				CC2500_Strobe(CC2500_SFRX);
				CC2500_Strobe(CC2500_SRX);
				phase++;
			}
			else
			{
				CC2500_SetFreqOffset();
				if((CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F) == packet_length + 2) // 2 = RSSI + LQI
				{ // RX fifo data ready
					//debugln("f_off=%02X", CC2500_ReadReg(0x32 | CC2500_READ_BURST));
					CC2500_ReadData(packet, packet_length+2);
					bool ok=true;
					//filter address
					if(rx_tx_addr[2]!=packet[0] || rx_tx_addr[3]!=packet[1] || rx_tx_addr[4]!=packet[2] )
						ok=false;
					//filter constants
					if(RX_num == 0 && ok)
					{
						if (packet[3] != 0x10 || (packet[4] & 0xFC) != 0x54 || packet[5] != 0x64)
							ok=false;
						else if(packet[6] != 0x10 && packet[6] != 0x25)
								ok=false;
						else if(memcmp(&packet[9],"\xC6\xE7\x50\x02\xAA\x49",6)!=0)
								ok=false;
					}
					else if(RX_num == 4 && ok)
					{
						if (packet[3] != 0x05 || (packet[4] & 0xCF) != 0x46)
							ok=false;
						else if(packet[5] != 0x41 && packet[5] != 0x42)
								ok=false;
						else if((packet[6]&0xF0) != 0x50 && (packet[6]&0xF0) != 0x00)
								ok=false;
						else if((packet[8]&0x0F) != 0x0C)
								ok=false;
						else if(memcmp(&packet[9],"\x6E\x75\x00\x2A\xA4\x94\xA4\x6F",8)!=0)
								ok=false;
					}
					if(ok)
					{
						//uint8_t buffer[100];
						//memcpy(buffer,packet,packet_length);
						//if(memcmp(&packet_in[0],&packet[0],packet_length))
						{
							debug("P:");
							for(uint8_t i=0;i<packet_length;i++)
								debug(" %02X",packet[i]);
							debugln("");
							memcpy(packet_in,packet,packet_length);
						}
					}
					CC2500_SetTxRxMode(TXRX_OFF);
					CC2500_SetTxRxMode(RX_EN);
					CC2500_Strobe(CC2500_SFRX);
					CC2500_Strobe(CC2500_SRX);
				}
			}
		#endif
		}
		else if(sub_protocol == XN297DUMP_XN297)
		{
			if(phase==0)
			{
				address_length=5;
				memcpy(rx_tx_addr, (uint8_t *)"\x00\x00\x00\x00\x00", address_length);	// bind \x7E\xB8\x63\xA9
				packet_length=9;
				hopping_frequency_no=0x30;
				
				XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
				XN297_SetTxRxMode(TXRX_OFF);
				XN297_SetTXAddr(rx_tx_addr, address_length);
				XN297_SetRXAddr(rx_tx_addr, packet_length);
				XN297_Hopping(option);
				old_option = option;
				XN297_SetTxRxMode(RX_EN);
				
				debugln("XN297 dump, len=%d, rf=%d, address length=%d",packet_length,option,address_length);	//hopping_frequency_no,address_length);
				phase = 1;
			}
			else
			{
				bool rx = XN297_IsRX();					// Needed for the NRF24L01 since otherwise the bit gets cleared
				if(rx)
				{ // RX fifo data ready
					XN297_SetTxRxMode(TXRX_OFF);
					XN297Dump_overflow();
					uint16_t timeL=TCNT1;
					if(TIMER2_BASE->SR & TIMER_SR_UIF)
					{//timer just rolled over...
						XN297Dump_overflow();
						timeL=0;
					}
					time=(timeH<<16)+timeL-time;
					debug("RX: %5luus ", time>>1);
					time=(timeH<<16)+timeL;
					if(XN297_ReadPayload(packet_in, packet_length))
					{
						debug("OK:");
						for(uint8_t i=0;i<packet_length;i++)
							debug(" %02X",packet_in[i]);
					}
					else // Bad packet
						debug(" NOK");
					debugln("");
					// restart RX mode
					XN297_SetTxRxMode(RX_EN);
				}
				XN297Dump_overflow();
				if(old_option != option)
				{
					debugln("C=%d(%02X)",option,option);
					XN297_Hopping(option);
					old_option = option;
				}
			}
		}
		bind_counter++;
		if(IS_RX_FLAG_on)					// Let the radio update the protocol
		{
			if(Update_All()) return 10000;	// New protocol selected
			if(prev_option!=option && sub_protocol<XN297DUMP_AUTO)
			{	// option has changed
				hopping_frequency_no=option;
				prev_option=option;
			}
		}
		XN297Dump_overflow();
	}
	return 100;
}

void XN297Dump_init(void)
{
	BIND_DONE;
	if(sub_protocol<XN297DUMP_AUTO)
		bitrate=sub_protocol;
	else
		bitrate=0;
	address_length=RX_num;
	if(address_length<3||address_length>5)
		address_length=5;	//default
	XN297Dump_RF_init();
	bind_counter=0;
	rf_ch_num=0xFF;
	prev_option=option^0x55;
	phase=0;				// init
}

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/XN297_EMU.ino"
#if defined(CC2500_INSTALLED) || defined(NRF24L01_INSTALLED)

#include "iface_xn297.h"

bool xn297_scramble_enabled, xn297_crc, xn297_bitrate, xn297_rf;
uint8_t xn297_addr_len, xn297_rx_packet_len;
uint8_t xn297_tx_addr[5], xn297_rx_addr[5];

// xn297 address / pcf / payload scramble table
const uint8_t xn297_scramble[] = {
    0xE3, 0xB1, 0x4B, 0xEA, 0x85, 0xBC, 0xE5, 0x66,
    0x0D, 0xAE, 0x8C, 0x88, 0x12, 0x69, 0xEE, 0x1F,
    0xC7, 0x62, 0x97, 0xD5, 0x0B, 0x79, 0xCA, 0xCC,
    0x1B, 0x5D, 0x19, 0x10, 0x24, 0xD3, 0xDC, 0x3F,
    0x8E, 0xC5, 0x2F, 0xAA, 0x16, 0xF3, 0x95 };

// scrambled, standard mode crc xorout table
const uint16_t PROGMEM xn297_crc_xorout_scrambled[] = {
    0x0000, 0x3448, 0x9BA7, 0x8BBB, 0x85E1, 0x3E8C,
    0x451E, 0x18E6, 0x6B24, 0xE7AB, 0x3828, 0x814B,
    0xD461, 0xF494, 0x2503, 0x691D, 0xFE8B, 0x9BA7,
    0x8B17, 0x2920, 0x8B5F, 0x61B1, 0xD391, 0x7401,
    0x2138, 0x129F, 0xB3A0, 0x2988, 0x23CA, 0xC0CB,
    0x0C6C, 0xB329, 0xA0A1, 0x0A16, 0xA9D0 };

// unscrambled, standard mode crc xorout table
const uint16_t PROGMEM xn297_crc_xorout[] = {
    0x0000, 0x3D5F, 0xA6F1, 0x3A23, 0xAA16, 0x1CAF,
    0x62B2, 0xE0EB, 0x0821, 0xBE07, 0x5F1A, 0xAF15,
    0x4F0A, 0xAD24, 0x5E48, 0xED34, 0x068C, 0xF2C9,
    0x1852, 0xDF36, 0x129D, 0xB17C, 0xD5F5, 0x70D7,
    0xB798, 0x5133, 0x67DB, 0xD94E, 0x0A5B, 0xE445,
    0xE6A5, 0x26E7, 0xBDAB, 0xC379, 0x8E20 };

// scrambled enhanced mode crc xorout table
const uint16_t PROGMEM xn297_crc_xorout_scrambled_enhanced[] = {
    0x0000, 0x7EBF, 0x3ECE, 0x07A4, 0xCA52, 0x343B,
    0x53F8, 0x8CD0, 0x9EAC, 0xD0C0, 0x150D, 0x5186,
    0xD251, 0xA46F, 0x8435, 0xFA2E, 0x7EBD, 0x3C7D,
    0x94E0, 0x3D5F, 0xA685, 0x4E47, 0xF045, 0xB483,
    0x7A1F, 0xDEA2, 0x9642, 0xBF4B, 0x032F, 0x01D2,
    0xDC86, 0x92A5, 0x183A, 0xB760, 0xA953 };

// unscrambled enhanced mode crc xorout table
// unused so far
#ifdef XN297DUMP_NRF24L01_INO
const uint16_t xn297_crc_xorout_enhanced[] = {
    0x0000, 0x8BE6, 0xD8EC, 0xB87A, 0x42DC, 0xAA89,
    0x83AF, 0x10E4, 0xE83E, 0x5C29, 0xAC76, 0x1C69,
    0xA4B2, 0x5961, 0xB4D3, 0x2A50, 0xCB27, 0x5128,
    0x7CDB, 0x7A14, 0xD5D2, 0x57D7, 0xE31D, 0xCE42,
    0x648D, 0xBF2D, 0x653B, 0x190C, 0x9117, 0x9A97,
    0xABFC, 0xE68E, 0x0DE7, 0x28A2, 0x1965 };
#endif

static bool __attribute__((unused)) XN297_Configure(bool crc_en, bool scramble_en, bool bitrate, bool force_nrf)
{
	xn297_crc = crc_en;
	xn297_scramble_enabled = scramble_en;
	xn297_bitrate = bitrate;
	xn297_rf = XN297_NRF;
	
	#if defined(NRF24L01_INSTALLED) and defined(CC2500_INSTALLED)
		if(bitrate == XN297_1M || force_nrf)
			xn297_rf = XN297_NRF;		// Use NRF24L01
		else
			xn297_rf = XN297_CC2500;	// Use CC2500
	#elif defined(NRF24L01_INSTALLED) and not defined(CC2500_INSTALLED)
		xn297_rf = XN297_NRF;			// Use NRF24L01
	#else //CC2500 only
		xn297_rf = XN297_CC2500;		// Use CC2500
		if(bitrate == XN297_1M)
		{
			xn297_rf = XN297_NRF;		// Use NRF24L01 which does not exist, nothing will happen...
			SUB_PROTO_INVALID;
			return false;				// Can't do...
		}
	#endif

	#if defined(NRF24L01_INSTALLED)
		if(xn297_rf == XN297_NRF)
		{
			debugln("Using NRF");
			rf_switch(SW_NRF);
			NRF24L01_Initialize();
			if(bitrate == XN297_250K)
				NRF24L01_SetBitrate(NRF24L01_BR_250K);			// 250Kbps
		}
	#endif
	#if defined(CC2500_INSTALLED)
		if(xn297_rf == XN297_CC2500)
		{
			debugln("Using CC2500");
			rf_switch(SW_CC2500);
			CC2500_250K_Init();
			option_override = 2;	// OPTION_RFTUNE
		}
	#endif
	return true;
}

static void __attribute__((unused)) XN297_SetTXAddr(const uint8_t* addr, uint8_t len)
{
	if (len > 5) len = 5;
	if (len < 3) len = 3;
	xn297_addr_len = len;
	memcpy(xn297_tx_addr, addr, len);
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
		{
			uint8_t buf[] = { 0x55, 0x0F, 0x71, 0x0C, 0x00 };			// bytes for XN297 preamble 0xC710F55 (28 bit)
			NRF24L01_WriteReg(NRF24L01_03_SETUP_AW, len-2);
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, xn297_addr_len == 3 ? buf+1 : buf, 5);
		}
	#endif
};

static void __attribute__((unused)) XN297_SetRXAddr(const uint8_t* addr, uint8_t rx_packet_len)
{
	//Scramble address
	for (uint8_t i = 0; i < xn297_addr_len; ++i)
	{
		xn297_rx_addr[i] = addr[i];
		if(xn297_scramble_enabled)
			xn297_rx_addr[i] ^= xn297_scramble[xn297_addr_len-i-1];
	}

	if(xn297_crc)
		rx_packet_len += 2;															// Include CRC
	rx_packet_len += 2;																// Include pcf, will this be a problem timing wise even if not enhanced?

	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
		{
			NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, xn297_rx_addr, xn297_addr_len);
			if(rx_packet_len > 32)
				rx_packet_len = 32;
			NRF24L01_WriteReg(NRF24L01_11_RX_PW_P0, rx_packet_len);
		}
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
		{// TX: Sync1, Sync0, Address
			CC2500_WriteReg(CC2500_04_SYNC1, xn297_rx_addr[xn297_addr_len-1]);		// Sync word, high byte
			CC2500_WriteReg(CC2500_05_SYNC0, xn297_rx_addr[xn297_addr_len-2]);		// Sync word, low byte
			CC2500_WriteReg(CC2500_09_ADDR,  xn297_rx_addr[xn297_addr_len-3]);		// Address
			rx_packet_len += 1 + xn297_addr_len - 3;								// The Address field above will be in the payload then the end of the XN297 address
		}
	#endif
	xn297_rx_packet_len = rx_packet_len;
}

static void __attribute__((unused)) XN297_SetTxRxMode(enum TXRX_State mode)
{
	static enum TXRX_State cur_mode=TXRX_OFF;
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
		{
			
			NRF24L01_WriteReg(NRF24L01_07_STATUS, (1 << NRF24L01_07_RX_DR)			//reset the flag(s)
												| (1 << NRF24L01_07_TX_DS)
												| (1 << NRF24L01_07_MAX_RT));
			if(mode==TXRX_OFF)
			{
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, 0);							//PowerDown
				NRF_CE_off;
				return;
			}
			NRF_CE_off;
			if(mode == TX_EN)
			{
				NRF24L01_FlushTx();
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, 1 << NRF24L01_00_PWR_UP);
			}
			else
			{
				NRF24L01_FlushRx();
				NRF24L01_WriteReg(NRF24L01_00_CONFIG, (1 << NRF24L01_00_PWR_UP)
													| (1 << NRF24L01_00_PRIM_RX));	// RX
			}
			if(mode != cur_mode)
			{
				//delayMicroseconds(130);
				cur_mode=mode;
			}			
			NRF_CE_on;
		}
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
		{
			if(mode != cur_mode)
			{
				CC2500_SetTxRxMode(mode);
				if(mode == RX_EN)
				{
					CC2500_WriteReg(CC2500_12_MDMCFG2,  0x12);   						// Modem Configuration, GFSK, 16/16 Sync Word TX&RX
					CC2500_WriteReg(CC2500_06_PKTLEN, xn297_rx_packet_len);				// Packet len
					CC2500_Strobe(CC2500_SFRX);
					CC2500_Strobe(CC2500_SRX);
				}
				else
					CC2500_WriteReg(CC2500_12_MDMCFG2,	0x10);   						// Modem Configuration, GFSK, no preambule and no sync word
				cur_mode=mode;
			}
		}
	#endif
}

#ifdef CC2500_INSTALLED
uint8_t XN297_Buffer[32];
uint8_t XN297_Buffer_Len = 0;

static void __attribute__((unused)) XN297_SendCC2500Payload()
{
	// stop TX/RX
	CC2500_Strobe(CC2500_SIDLE);
	// flush tx FIFO
	CC2500_Strobe(CC2500_SFTX);
	// packet length
	CC2500_WriteReg(CC2500_06_PKTLEN, XN297_Buffer_Len + 4);  // Packet len, fix packet len
	// xn297L preamble
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, (uint8_t*)"\x0C\x71\x0F\x55", 4);
	// xn297 packet
	CC2500_WriteRegisterMulti(CC2500_3F_TXFIFO, XN297_Buffer, XN297_Buffer_Len);
	// transmit
	CC2500_Strobe(CC2500_STX);
}
#endif

static void __attribute__((unused)) XN297_SendPayload(uint8_t* msg, uint8_t len)
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
		{
			NRF24L01_WriteReg(NRF24L01_07_STATUS, 0x70);
			NRF24L01_FlushTx();
			NRF24L01_WritePayload(msg, len);
		}
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
		{
			memcpy(XN297_Buffer, msg, len);
			XN297_Buffer_Len = len;
			XN297_SendCC2500Payload();
		}
	#endif
}

static void __attribute__((unused)) XN297_ReSendPayload()
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			NRF24L01_Strobe(NRF24L01_E3_REUSE_TX_PL);
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			XN297_SendCC2500Payload();
	#endif
}

static void __attribute__((unused)) XN297_WritePayload(uint8_t* msg, uint8_t len)
{
	uint8_t buf[32];
	uint8_t last = 0;

	if (xn297_rf == XN297_NRF && xn297_addr_len < 4 && xn297_rf == XN297_NRF)
	{ // If address length (which is defined by receiver address length) is less than 4 the TX address can't fit the preamble, so the last byte goes here
		buf[last++] = 0x55;
	}

	// address
	for (uint8_t i = 0; i < xn297_addr_len; ++i)
	{
		buf[last] = xn297_tx_addr[xn297_addr_len-i-1];
		if(xn297_scramble_enabled)
			buf[last] ^=  xn297_scramble[i];
		last++;
	}

	// payload
	for (uint8_t i = 0; i < len; ++i)
	{
		// bit-reverse bytes in packet
		buf[last] = bit_reverse(msg[i]);
		if(xn297_scramble_enabled)
			buf[last] ^= xn297_scramble[xn297_addr_len+i];
		last++;
	}

	// crc
	if (xn297_crc)
	{
		uint8_t offset = (xn297_addr_len < 4  && xn297_rf == XN297_NRF) ? 1 : 0;
		crc = 0xb5d2;
		for (uint8_t i = offset; i < last; ++i)
			crc16_update( buf[i], 8);
		if(xn297_scramble_enabled)
			crc ^= pgm_read_word(&xn297_crc_xorout_scrambled[xn297_addr_len - 3 + len]);
		else
			crc ^= pgm_read_word(&xn297_crc_xorout[xn297_addr_len - 3 + len]);
		buf[last++] = crc >> 8;
		buf[last++] = crc & 0xff;
	}

	// send packet
	XN297_SendPayload(buf, last);
}

static void __attribute__((unused)) XN297_WriteEnhancedPayload(uint8_t* msg, uint8_t len, uint8_t noack)
{
	uint8_t buf[32];
	uint8_t scramble_index=0;
	uint8_t last = 0;
	static uint8_t pid=0;

	if (xn297_rf == XN297_NRF && xn297_addr_len < 4)
	{ // If address length (which is defined by receiver address length) is less than 4 the TX address can't fit the preamble, so the last byte goes here
		buf[last++] = 0x55;
	}

	// address
	for (uint8_t i = 0; i < xn297_addr_len; ++i)
	{
		buf[last] = xn297_tx_addr[xn297_addr_len-i-1];
		if(xn297_scramble_enabled)
			buf[last] ^= xn297_scramble[scramble_index++];
		last++;
	}

	// pcf
	buf[last] = (len << 1) | (pid>>1);
	if(xn297_scramble_enabled)
		buf[last] ^= xn297_scramble[scramble_index++];
	last++;
	buf[last] = (pid << 7) | (noack << 6);

	// payload
	if(len)
	{
		buf[last]|= bit_reverse(msg[0]) >> 2; // first 6 bit of payload
		if(xn297_scramble_enabled)
			buf[last] ^= xn297_scramble[scramble_index++];

		for (uint8_t i = 0; i < len-1; ++i)
		{
			last++;
			buf[last] = (bit_reverse(msg[i]) << 6) | (bit_reverse(msg[i+1]) >> 2);
			if(xn297_scramble_enabled)
				buf[last] ^= xn297_scramble[scramble_index++];
		}

		last++;
		buf[last] = bit_reverse(msg[len-1]) << 6; // last 2 bit of payload
	}
	if(xn297_scramble_enabled)
		buf[last] ^= xn297_scramble[scramble_index++] & 0xc0;

	// crc
	if (xn297_crc)
	{
		uint8_t offset = (xn297_addr_len < 4 && xn297_rf == XN297_NRF) ? 1 : 0;
		crc = 0xb5d2;
		for (uint8_t i = offset; i < last; ++i)
			crc16_update( buf[i], 8);
		crc16_update( buf[last] & 0xc0, 2);
		if (xn297_scramble_enabled)
			crc ^= pgm_read_word(&xn297_crc_xorout_scrambled_enhanced[xn297_addr_len-3+len]);
		//else
		//	crc ^= pgm_read_word(&xn297_crc_xorout_enhanced[xn297_addr_len - 3 + len]);

		buf[last++] |= (crc >> 8) >> 2;
		buf[last++] = ((crc >> 8) << 6) | ((crc & 0xff) >> 2);
		buf[last++] = (crc & 0xff) << 6;
	}
	pid++;
	pid &= 0x03;

	// send packet
	XN297_SendPayload(buf, last);
}

static bool __attribute__((unused)) XN297_IsRX()
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			return (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_RX_DR));
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
		{
			if((CC2500_ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST) & 0x7F) != xn297_rx_packet_len + 2) // 2 = RSSI + LQI
				return false; 										// Buffer does not contain the expected number of bytes
			// Check the address
			uint8_t buf[3];
			CC2500_ReadData(buf, xn297_addr_len-3 + 1);
			for(uint8_t i=0; i < xn297_addr_len-3 + 1; i++)
				if(buf[i] != xn297_rx_addr[xn297_addr_len-3 - i])
					return false;									// Bad address
			return true;											// Address is correct
		}
	#endif
	return false;
}

static void __attribute__((unused)) XN297_ReceivePayload(uint8_t* msg, uint8_t len)
{
	if (xn297_crc)
		len += 2;									// Include CRC 
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			NRF24L01_ReadPayload(msg, len);			// Read payload and CRC 
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_ReadData(msg, len);
	#endif
}

static bool __attribute__((unused)) XN297_ReadPayload(uint8_t* msg, uint8_t len)
{ //!!! Don't forget if using CRC to do a +2 on the received packet length (NRF24L01_11_RX_PW_Px !!! or CC2500_06_PKTLEN)
	uint8_t buf[32];

	// Read payload
	XN297_ReceivePayload(buf, len);

	// Decode payload
	for(uint8_t i=0; i<len; i++)
	{
		uint8_t b_in=buf[i];
		if(xn297_scramble_enabled)
			b_in ^= xn297_scramble[i+xn297_addr_len];
		msg[i] = bit_reverse(b_in);
	}

	if (!xn297_crc)
		return true;	// No CRC so OK by default...

	// Calculate CRC
	crc = 0xb5d2;
	//process address
	for (uint8_t i = 0; i < xn297_addr_len; ++i)
		crc16_update( xn297_rx_addr[xn297_addr_len-i-1], 8);
	//process payload
	for (uint8_t i = 0; i < len; ++i)
		crc16_update( buf[i], 8);
	//xorout
	if(xn297_scramble_enabled)
		crc ^= pgm_read_word(&xn297_crc_xorout_scrambled[xn297_addr_len - 3 + len]);
	else
		crc ^= pgm_read_word(&xn297_crc_xorout[xn297_addr_len - 3 + len]);
	//test
	if( (crc >> 8) == buf[len] && (crc & 0xff) == buf[len+1])
		return true;	// CRC  OK
	return false;		// CRC NOK
}

static uint8_t __attribute__((unused)) XN297_ReadEnhancedPayload(uint8_t* msg, uint8_t len)
{ //!!! Don't forget do a +2 and if using CRC add +4 on any of the used NRF24L01_11_RX_PW_Px !!!
	uint8_t buffer[32];
	uint8_t pcf_size;							// pcf payload size

	// Read payload
	XN297_ReceivePayload(buffer, len+2);		// Read pcf + payload + CRC
	// Decode payload
	pcf_size = buffer[0];
	if(xn297_scramble_enabled)
		pcf_size ^= xn297_scramble[xn297_addr_len];
	pcf_size = pcf_size >> 1;
	if(pcf_size>32)
		return 255;								// Error
	for(uint8_t i=0; i< pcf_size; i++)
	{
		msg[i] = bit_reverse((buffer[i+1] << 2) | (buffer[i+2] >> 6));
		if(xn297_scramble_enabled)
			msg[i] ^= bit_reverse((xn297_scramble[xn297_addr_len+i+1] << 2) | 
									(xn297_scramble[xn297_addr_len+i+2] >> 6));
	}

	if (!xn297_crc)
		return pcf_size;						// No CRC so OK by default...

	// Calculate CRC
	crc = 0xb5d2;
	//process address
	for (uint8_t i = 0; i < xn297_addr_len; ++i)
		crc16_update( xn297_rx_addr[xn297_addr_len-i-1], 8);
	//process payload
	for (uint8_t i = 0; i < pcf_size+1; ++i)
		crc16_update( buffer[i], 8);
	crc16_update( buffer[pcf_size+1] & 0xc0, 2);
	//xorout
	if (xn297_scramble_enabled)
		crc ^= pgm_read_word(&xn297_crc_xorout_scrambled_enhanced[xn297_addr_len-3+pcf_size]);
#ifdef XN297DUMP_NRF24L01_INO
	else
		crc ^= pgm_read_word(&xn297_crc_xorout_enhanced[xn297_addr_len - 3 + pcf_size]);
#endif
	uint16_t crcxored=(buffer[pcf_size+1]<<10)|(buffer[pcf_size+2]<<2)|(buffer[pcf_size+3]>>6) ;
	if( crc == crcxored)
		return pcf_size;					// CRC  OK
	return 255;								// CRC NOK
}
 
static bool __attribute__((unused)) XN297_IsPacketSent()
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			return (NRF24L01_ReadReg(NRF24L01_07_STATUS) & _BV(NRF24L01_07_TX_DS));
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			return (CC2500_ReadReg(CC2500_35_MARCSTATE | CC2500_READ_BURST) != 0x13);
	#endif
	return true;	// packet sent to not block
}

static void __attribute__((unused)) XN297_HoppingCalib(uint8_t num_freq)
{	//calibrate hopping frequencies
	#ifdef NRF24L01_INSTALLED
		(void)num_freq;
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_250K_HoppingCalib(num_freq);
	#endif
}

static void __attribute__((unused)) XN297_Hopping(uint8_t index)
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, hopping_frequency[index]);
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_250K_Hopping(index);
	#endif
}

static void __attribute__((unused)) XN297_RFChannel(uint8_t number)
{	//change channel
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			NRF24L01_WriteReg(NRF24L01_05_RF_CH, number);
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_250K_RFChannel(number);
	#endif
}

static void __attribute__((unused)) XN297_SetPower()
{
	#ifdef NRF24L01_INSTALLED
		if(xn297_rf == XN297_NRF)
			NRF24L01_SetPower();
	#endif
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_SetPower();
	#endif
}

static void __attribute__((unused)) XN297_SetFreqOffset()
{	// Frequency offset
	#ifdef CC2500_INSTALLED
		if(xn297_rf == XN297_CC2500)
			CC2500_SetFreqOffset();
	#endif
}

 // End of XN297 emulation

#endif

#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/YD717_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Last sync with hexfet new_protocols/YD717_nrf24l01.c dated 2015-09-28

#if defined(YD717_NRF24L01_INO)

#include "iface_nrf24l01.h"

#define YD717_BIND_COUNT		120
#define YD717_PACKET_PERIOD		8000	// Timeout for callback in uSec, 8ms=8000us for YD717
#define YD717_INITIAL_WAIT		50000	// Initial wait before starting callbacks

// Stock tx fixed frequency is 0x3C. Receiver only binds on this freq.
#define YD717_RF_CHANNEL 0x3C

#define YD717_FLAG_FLIP     0x0F
#define YD717_FLAG_LIGHT    0x80
#define YD717_FLAG_PICTURE  0x40
#define YD717_FLAG_VIDEO    0x20
#define YD717_FLAG_HEADLESS 0x10

#define YD717_PAYLOADSIZE 8				// receive data pipes set to this size, but unused

static void __attribute__((unused)) YD717_send_packet()
{
	uint8_t rudder_trim, elevator_trim, aileron_trim;
	if (IS_BIND_IN_PROGRESS)
	{
		packet[0]= rx_tx_addr[0]; // send data phase address in first 4 bytes
		packet[1]= rx_tx_addr[1];
		packet[2]= rx_tx_addr[2];
		packet[3]= rx_tx_addr[3];
		packet[4] = 0x56;
		packet[5] = 0xAA;
		packet[6] = (sub_protocol == NIHUI) ? 0x00 : 0x32;
		packet[7] = 0x00;
	}
	else
	{
		// Throttle
		packet[0] = convert_channel_8b(THROTTLE);
		// Rudder
		if( sub_protocol==XINXUN )
		{
			rudder = convert_channel_8b(RUDDER);
			rudder_trim = (0xff - rudder) >> 1;
		}
		else
		{
			rudder = 0xff - convert_channel_8b(RUDDER);
			rudder_trim = rudder >> 1;
		}
		packet[1] = rudder;
		// Elevator
		elevator = convert_channel_8b(ELEVATOR);
		elevator_trim = elevator >> 1;
		packet[3] = elevator;
		// Aileron
		aileron = 0xff - convert_channel_8b(AILERON);
		aileron_trim = aileron >> 1;
		packet[4] = aileron;
		// Trims
		if( sub_protocol == YD717 )
		{
			packet[2] = elevator_trim;
			packet[5] = aileron_trim;
			packet[6] = rudder_trim;
		}
		else
		{
			packet[2] = rudder_trim;
			packet[5] = elevator_trim;
			packet[6] = aileron_trim;
		}
		// Flags
		flags=0;
		// Channel 5
		if (CH5_SW)	flags = YD717_FLAG_FLIP;
		// Channel 6
		if (CH6_SW)	flags |= YD717_FLAG_LIGHT;
		// Channel 7
		if (CH7_SW)	flags |= YD717_FLAG_PICTURE;
		// Channel 8
		if (CH8_SW)	flags |= YD717_FLAG_VIDEO;
		// Channel 9
		if (CH9_SW)	flags |= YD717_FLAG_HEADLESS;
		packet[7] = flags;
	}

    // clear packet status bits and TX FIFO
    NRF24L01_WriteReg(NRF24L01_07_STATUS, (_BV(NRF24L01_07_TX_DS) | _BV(NRF24L01_07_MAX_RT)));
    NRF24L01_FlushTx();

	if( sub_protocol == YD717 )
		NRF24L01_WritePayload(packet, 8);
	else
	{
		packet[8] = packet[0];  // checksum
		for(uint8_t i=1; i < 8; i++)
			packet[8] += packet[i];
		packet[8] = ~packet[8];
		NRF24L01_WritePayload(packet, 9);
	}

	NRF24L01_SetPower();	// Set tx_power
}

static void __attribute__((unused)) YD717_RF_init()
{
	NRF24L01_Initialize();

	// CRC, radio on
	NRF24L01_WriteReg(NRF24L01_01_EN_AA, 0x3F);				// Enable Acknowledgement on all data pipes
	NRF24L01_WriteReg(NRF24L01_02_EN_RXADDR, 0x3F);			// Enable all data pipes
	NRF24L01_WriteReg(NRF24L01_04_SETUP_RETR, 0x1A);		// 500uS retransmit t/o, 10 tries
	NRF24L01_WriteReg(NRF24L01_05_RF_CH, YD717_RF_CHANNEL);	// Channel 3C

	NRF24L01_WriteReg(NRF24L01_1C_DYNPD, 0x3F);				// Enable dynamic payload length on all pipes
	NRF24L01_WriteReg(NRF24L01_1D_FEATURE, 0x07);			// Set feature bits on

	// for bind packets set address to prearranged value known to receiver
	uint8_t bind_rx_tx_addr[5];
	uint8_t offset=5;
	if( sub_protocol==SYMAX4 )
		offset=0;
	else
		if( sub_protocol==NIHUI )
			offset=4;
	for(uint8_t i=0; i < 5; i++)
		bind_rx_tx_addr[i]  = 0x60 + offset;
    NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, bind_rx_tx_addr, 5);
    NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, bind_rx_tx_addr, 5);

	NRF24L01_WriteReg(NRF24L01_00_CONFIG, _BV(NRF24L01_00_EN_CRC) | _BV(NRF24L01_00_PWR_UP));
}

uint16_t YD717_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(YD717_PACKET_PERIOD);
	#endif
	if (bind_counter)
		if(--bind_counter==0)
		{
			NRF24L01_WriteRegisterMulti(NRF24L01_10_TX_ADDR, rx_tx_addr, 5);	// set address
			NRF24L01_WriteRegisterMulti(NRF24L01_0A_RX_ADDR_P0, rx_tx_addr, 5);
			BIND_DONE;							// bind complete
		}
	YD717_send_packet();
	return YD717_PACKET_PERIOD;					// Packet every 8ms
}

void YD717_init()
{
	BIND_IN_PROGRESS;			// autobind protocol
	rx_tx_addr[4] = 0xC1;		// always uses first data port
	YD717_RF_init();
	bind_counter = YD717_BIND_COUNT;
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/Yuxiang_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 
 Thanks to  Goebish ,Ported  from his deviation firmware
 */

#if defined(YUXIANG_NRF24L01_INO)

#include "iface_xn297.h"

//#define YUXIANG_FORCE_ID

#define YUXIANG_PACKET_PERIOD		12422
#define YUXIANG_PACKET_SIZE			9
#define YUXIANG_BIND_COUNT			150
#define YUXIANG_BIND_FREQ			0x30	//48
#define YUXIANG_RF_NUM_CHANNELS		4

#define YUXIANG_WRITE_TIME			1000
//#define YUXIANG_TELEM_DEBUG

enum 
{
	YUXIANG_DATA = 0,
	YUXIANG_RX
};

static void __attribute__((unused)) YUXIANG_send_packet()
{
	if(bind_counter && packet_sent < 5 && (hopping_frequency_no & 0x07) == 0)
	{
		bind_counter--;
		if(!bind_counter)
			BIND_DONE;
	#if 0
		debug("B C:%d, ",YUXIANG_BIND_FREQ);
	#endif
		XN297_RFChannel(YUXIANG_BIND_FREQ);
		XN297_SetTXAddr((uint8_t*)"\x00\x00\x00\x00\x00", 5);
		bind_phase = 1;
		packet_sent++;
	}
	else
	{//Normal operation
		XN297_Hopping(hopping_frequency_no & 0x03);
	#if 0
		debug("C:%d, ",hopping_frequency[hopping_frequency_no & 0x03]);
	#endif
		hopping_frequency_no++;
		if(bind_phase)
		{
			XN297_SetTXAddr(rx_tx_addr, 5);
			XN297_SetRXAddr(rx_tx_addr, YUXIANG_PACKET_SIZE);
			bind_phase = 0;
			packet_sent = 0;
		}
	}

	packet[0] = GET_FLAG(!bind_phase, 0x80)		// Bind packet
			| GET_FLAG(telemetry_lost, 0x20)	// No telem
			| GET_FLAG(!CH5_SW, 0x10)			// Lock
			| GET_FLAG(CH6_SW, 0x08)			// High
			| GET_FLAG(CH11_SW, 0x01);			// Screw pitch -> temporary
	
	packet[1] = GET_FLAG(CH7_SW, 0x08)			// Land only when unlock
			| GET_FLAG(CH10_SW, 0x20);			// Mode

	packet[2] = GET_FLAG(CH5_SW, 0x02)			// Altitude hold set when unlock
			| GET_FLAG(CH8_SW, 0x01)			// Manual
			| GET_FLAG(CH9_SW, 0x40);			// Flip

	uint16_t value = convert_channel_16b_limit(AILERON,0,1000);
	packet[3] = value;
	packet[7] = value >> 8;
	value = convert_channel_16b_limit(ELEVATOR,0,1000);
	packet[4] = value;
	packet[7] |= (value >> 6) & 0x0C;
	value = convert_channel_16b_limit(THROTTLE,0,1000);
	packet[5] = value;
	packet[7] |= (value >> 4) & 0x30;
	value = convert_channel_16b_limit(RUDDER,0,1000);
	packet[6] = value;
	packet[7] |= (value >> 2) & 0xC0;

	if(bind_phase)
		memcpy(&packet[3], rx_tx_addr, 4);

	uint8_t checksum = 0;
	for(uint8_t i=0; i<YUXIANG_PACKET_SIZE-1; i++)
		checksum += packet[i];
	packet[8] = checksum;
	
	#if 0
		debug("P:");
		for(uint8_t i=0;i<YUXIANG_PACKET_SIZE;i++)
			debug(" %02X",packet[i]);
		debugln("");
	#endif
	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, YUXIANG_PACKET_SIZE);
}

static void __attribute__((unused)) YUXIANG_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
}

static void __attribute__((unused)) YUXIANG_initialize_txid()
{
	//Modify address to influence hop 
	rx_tx_addr[0] += RX_num;
	//Calc hop
	uint8_t val;
	for(uint8_t i=0; i<4; i++)
	{
		val = i*0x06;
		if(i) val |= 0x01;
		val += rx_tx_addr[0];
		val &= 0x1F;
		val += 47;
		if(val < 50)
			val = 50;
		if(val > 62 && val < 66)
			val = 62;
		hopping_frequency[i] = val;
	}

	#ifdef YUXIANG_FORCE_ID
		switch(RX_num)
		{
			case 0://TX1
				memcpy(rx_tx_addr,(uint8_t *)"\xB3\x13\x36\xDD",4); 		//rx_tx_addr[4]=0xD9
				memcpy(hopping_frequency,(uint8_t *)"\x42\x49\x32\x35",4);	//66,73,50,53
				break;
			case 1://TX2
				memcpy(rx_tx_addr,(uint8_t *)"\xEB\x13\x36\xAC",4);			//rx_tx_addr[4]=0xE0
				memcpy(hopping_frequency,(uint8_t *)"\x47\x4D\x3A\x3E",4);	//58,62,71,77
				break;
		}
	#endif

	uint8_t sum=0;
	for(uint8_t i=0; i<4; i++)
		sum += rx_tx_addr[i];
	rx_tx_addr[4] = sum;
	debugln("ID: %02X %02X %02X %02X %02X , HOP: %2d %2d %2d %2d",rx_tx_addr[0],rx_tx_addr[1],rx_tx_addr[2],rx_tx_addr[3],rx_tx_addr[4],hopping_frequency[0],hopping_frequency[1],hopping_frequency[2],hopping_frequency[3]);
}

uint16_t YUXIANG_callback()
{
	bool rx = false;
	
	switch(phase)
	{
		case YUXIANG_DATA:
			rx = XN297_IsRX();					// Needed for the NRF24L01 since otherwise the bit gets cleared
			XN297_SetTxRxMode(TXRX_OFF);
	#ifdef YUXIANG_HUB_TELEMETRY
			if(packet_count > 240)				// Around 3sec with no telemetry
				telemetry_lost = 1;
			else
				packet_count++;
	#endif
			#ifdef MULTI_SYNC
				telemetry_set_input_sync(YUXIANG_PACKET_PERIOD);
			#endif
			YUXIANG_send_packet();
			if(rx)
			{ // Check if a packet has been received
				#ifdef YUXIANG_TELEM_DEBUG
					debug("RX ");
				#endif
				if(XN297_ReadPayload(packet_in, YUXIANG_PACKET_SIZE))
				{ // packet with good CRC and length
					uint8_t checksum = 0;
					for(uint8_t i=0; i<YUXIANG_PACKET_SIZE-1; i++)
						checksum += packet_in[i];
					if(packet_in[8] == checksum)
					{
	#ifdef YUXIANG_HUB_TELEMETRY
						if(packet_in[0]==0x78)
						{
							#ifdef YUXIANG_TELEM_DEBUG
								debug("OK:");
								for(uint8_t i=0;i<YUXIANG_PACKET_SIZE;i++)
									debug(" %02X",packet_in[i]);
							#endif
							v_lipo1 = packet_in[4];
							v_lipo2 = packet_in[6];
						}
						telemetry_link = 1;
	#endif
						telemetry_lost = 0;
						packet_count = 0;
						bind_counter = 0;	// Stop bind
						BIND_DONE;
					}
					#ifdef YUXIANG_TELEM_DEBUG
					else // Bad packet
						debug(" NOK");
					#endif
				}
				#ifdef YUXIANG_TELEM_DEBUG
				else // Bad packet
					debug("NOK");
				debugln("");
				#endif
				rx = false;
			}
			phase++;
			return YUXIANG_WRITE_TIME;
		default:
			// RX
			{ // Wait for packet to be sent before switching to receive mode
				uint16_t start=(uint16_t)micros();
				while ((uint16_t)((uint16_t)micros()-(uint16_t)start) < 500)
					if(XN297_IsPacketSent())
						break;
			}
			//if(bind_phase)
			//	XN297_Hopping(3);
			XN297_SetTxRxMode(RX_EN);
			phase = YUXIANG_DATA;
			return YUXIANG_PACKET_PERIOD - YUXIANG_WRITE_TIME;
	}
	return 0;
}

void YUXIANG_init(void)
{
	YUXIANG_initialize_txid();
	YUXIANG_RF_init();

	if(IS_BIND_IN_PROGRESS)
		bind_counter = YUXIANG_BIND_COUNT;
	else
		bind_counter = 0;
		
	phase = YUXIANG_DATA;
	hopping_frequency_no = 0;
	bind_phase = 1;
	packet_sent = 8;
	#ifdef YUXIANG_HUB_TELEMETRY
		packet_count = 0;
		telemetry_lost = 1;
		RX_RSSI = 100;		// Dummy value
	#endif
}

#endif
#line 1 "/home/runner/work/DIY-Multiprotocol-TX-Module/DIY-Multiprotocol-TX-Module/Multiprotocol/ZSX_nrf24l01.ino"
/*
 This project is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

Multiprotocol is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with Multiprotocol.  If not, see <http://www.gnu.org/licenses/>.
 */
// Compatible with JJRC ZSX-280 plane.

#if defined(ZSX_NRF24L01_INO)

#include "iface_xn297.h"

//#define FORCE_ZSX_ORIGINAL_ID

#define ZSX_INITIAL_WAIT	500
#define ZSX_PACKET_PERIOD	10093
#define ZSX_RF_BIND_CHANNEL	7
#define ZSX_PAYLOAD_SIZE	6
#define ZSX_BIND_COUNT		50
#define ZSX_RF_NUM_CHANNELS	1

static void __attribute__((unused)) ZSX_send_packet()
{
	memcpy(&packet[1],rx_tx_addr,3);
	if(IS_BIND_IN_PROGRESS)
	{
		packet[0] = 0xAA;
		packet[4] = 0x00;
		packet[5] = 0x00;
	}
	else
	{
		packet[0]= 0x55;
		packet[4]= 0xFF-convert_channel_8b(RUDDER);		// FF..80..01
		packet[5]= convert_channel_8b(THROTTLE)>>1		// 0..7F
				| GET_FLAG(CH5_SW, 0x80);				// Light
	}

	// Send
	XN297_SetPower();
	XN297_SetTxRxMode(TX_EN);
	XN297_WritePayload(packet, ZSX_PAYLOAD_SIZE);
}

static void __attribute__((unused)) ZSX_initialize_txid()
{
	rx_tx_addr[0]=rx_tx_addr[3];	// Use RX_num;
	#ifdef FORCE_ZSX_ORIGINAL_ID
		//TX1
		rx_tx_addr[0]=0x03;
		rx_tx_addr[1]=0x01;
		rx_tx_addr[2]=0xC3;
	#endif
}

static void __attribute__((unused)) ZSX_RF_init()
{
	XN297_Configure(XN297_CRCEN, XN297_SCRAMBLED, XN297_1M);
	XN297_SetTXAddr((uint8_t*)"\xc1\xc2\xc3", 3);
	XN297_RFChannel(ZSX_RF_BIND_CHANNEL);	// Set bind channel
}

uint16_t ZSX_callback()
{
	#ifdef MULTI_SYNC
		telemetry_set_input_sync(ZSX_PACKET_PERIOD);
	#endif
	if(bind_counter)
		if(--bind_counter==0)
		{
			BIND_DONE;
			XN297_SetTXAddr(rx_tx_addr, 3);
			XN297_RFChannel(0x00);
		}
	ZSX_send_packet();
	return ZSX_PACKET_PERIOD;
}

void ZSX_init()
{
	BIND_IN_PROGRESS;	// autobind protocol
	ZSX_initialize_txid();
	ZSX_RF_init();
	bind_counter=ZSX_BIND_COUNT;
}

#endif

// XN297 speed 1Mb, scrambled
// Bind
//   channel 7
//   address: C1 C2 C3
//   P(6)= AA 03 01 C3 00 00
//   03 01 C3 <- normal address
// Normal
//   channel 0 and seems to be fixed
//   address: 03 01 C3
//   P(6)= 55 03 01 C3 80 00
//   03 01 C3 <- normal address
//   80 <- rudder FF..80..01
//   00 <- throttle 00..7F, light flag 0x80
